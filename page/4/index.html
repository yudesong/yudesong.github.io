<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">啃碎并发（四）：Java线程Dump分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 10:26:46 / 修改时间：15:33:08" itemprop="dateCreated datePublished" datetime="2020-06-01T10:26:46+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-Thread-Dump介绍"><a href="#1-Thread-Dump介绍" class="headerlink" title="1 Thread Dump介绍"></a>1 Thread Dump介绍</h4><h5 id="1-1-什么是Thread-Dump"><a href="#1-1-什么是Thread-Dump" class="headerlink" title="1.1 什么是Thread Dump"></a>1.1 什么是Thread Dump</h5><p>Thread Dump是非常有用的诊断Java应用问题的工具。<strong>每一个Java虚拟机都有及时生成所有线程在某一点状态的thread-dump的能力，</strong>虽然各个 Java虚拟机打印的thread dump略有不同，但是<strong>大多都提供了当前活动线程的快照，及JVM中所有Java线程的堆栈跟踪信息，堆栈信息一般包含完整的类名及所执行的方法，</strong>如果可能的话还有源代码的行数。</p>
<h5 id="1-2-Thread-Dump特点"><a href="#1-2-Thread-Dump特点" class="headerlink" title="1.2 Thread Dump特点"></a>1.2 Thread Dump特点</h5><blockquote>
<p>1.能在各种操作系统下使用；<br>2.能在各种Java应用服务器下使用；<br>3.能在生产环境下使用而不影响系统的性能；<br>4.能将问题直接定位到应用程序的代码行上；</p>
</blockquote>
<h5 id="1-3-Thread-Dump抓取"><a href="#1-3-Thread-Dump抓取" class="headerlink" title="1.3 Thread Dump抓取"></a>1.3 Thread Dump抓取</h5><p><strong>一般当服务器挂起，崩溃或者性能低下时，</strong>就需要抓取服务器的线程堆栈（Thread Dump）用于后续的分析。在实际运行中，往往一次 dump的信息，还不足以确认问题。为了反映线程状态的动态变化，<strong>需要接连多次做thread dump，每次间隔10-20s，建议至少产生三次 dump信息，</strong>如果每次 dump都指向同一个问题，我们才确定问题的典型性。</p>
<p><strong>1. 操作系统命令获取ThreadDump</strong></p>
<blockquote>
<p>1.ps –ef | grep java<br>2.kill -3 <pid></p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>一定要谨慎, 一步不慎就可能让服务器进程被杀死。kill -9 命令会杀死进程。</p>
</blockquote>
<p><strong>2. JVM 自带的工具获取线程堆栈</strong></p>
<blockquote>
<ol>
<li>jps 或 ps –ef | grep java （获取PID）</li>
<li>jstack [-l ] <pid> | tee -a jstack.log（获取ThreadDump）</li>
</ol>
</blockquote>
<h4 id="2-Thread-Dump分析"><a href="#2-Thread-Dump分析" class="headerlink" title="2 Thread Dump分析"></a>2 Thread Dump分析</h4><h5 id="2-1-Thread-Dump信息"><a href="#2-1-Thread-Dump信息" class="headerlink" title="2.1 Thread Dump信息"></a>2.1 Thread Dump信息</h5><p><strong>1. 头部信息：时间，JVM信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-11-02 19:05:06  </span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (16.3-b01 mixed mode):</span><br></pre></td></tr></table></figure>

<p><strong>2. 线程INFO信息块：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;Timer-0&quot; daemon prio&#x3D;10 tid&#x3D;0xac190c00 nid&#x3D;0xaef in Object.wait() [0xae77d000] </span><br><span class="line"># 线程名称：Timer-0；线程类型：daemon；优先级: 10，默认是5；</span><br><span class="line"># JVM线程id：tid&#x3D;0xac190c00，JVM内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现）。</span><br><span class="line"># 对应系统线程id（NativeThread ID）：nid&#x3D;0xaef，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）</span><br><span class="line"># 线程状态：in Object.wait()；</span><br><span class="line"># 起始栈地址：[0xae77d000]，对象的内存地址，通过JVM内存查看工具，能够看出线程是在哪儿个对象上等待；</span><br><span class="line">2.  java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">3.  at java.lang.Object.wait(Native Method)</span><br><span class="line">4.  -waiting on &lt;0xb3885f60&gt; (a java.util.TaskQueue)     # 继续wait </span><br><span class="line">5.  at java.util.TimerThread.mainLoop(Timer.java:509)</span><br><span class="line">6.  -locked &lt;0xb3885f60&gt; (a java.util.TaskQueue)         # 已经locked</span><br><span class="line">7.  at java.util.TimerThread.run(Timer.java:462)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java thread statck trace：是上面2-7行的信息。到目前为止这是最重要的数据，Java stack trace提供了大部分信息来精确定位问题根源。</p>
</blockquote>
<p><strong>3. Java thread statck trace详解：</strong></p>
<p><strong>堆栈信息应该逆向解读：</strong>程序先执行的是第7行，然后是第6行，依次类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- locked &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br><span class="line">- waiting on &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br></pre></td></tr></table></figure>

<p><strong>也就是说对象先上锁，锁住对象0xb3885f60，然后释放该对象锁，进入waiting状态。</strong>为啥会出现这样的情况呢？看看下面的java代码示例，就会明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;  </span><br><span class="line">   .........  </span><br><span class="line">   obj.wait();  </span><br><span class="line">   .........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，线程的执行过程，先用 synchronized 获得了这个对象的 Monitor（对应于 locked &lt;0xb3885f60&gt; ）。当执行到 obj.wait()，线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on &lt;0xb3885f60&gt; ）。</p>
</blockquote>
<p><strong>在堆栈的第一行信息中，进一步标明了线程在代码级的状态，例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br></pre></td></tr></table></figure>

<p><strong>解释如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|blocked|</span><br><span class="line"></span><br><span class="line">&gt; This thread tried to enter asynchronized block, but the lock was taken by another thread. This thread isblocked until the lock gets released.</span><br><span class="line"></span><br><span class="line">|blocked (on thin lock)|</span><br><span class="line"></span><br><span class="line">&gt; This is the same state asblocked, but the lock in question is a thin lock.</span><br><span class="line"></span><br><span class="line">|waiting|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledObject.wait() on an object. The thread will remain there until some otherthread sends a notification to that object.</span><br><span class="line"></span><br><span class="line">|sleeping|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.lang.Thread.sleep().</span><br><span class="line"></span><br><span class="line">|parked|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.util.concurrent.locks.LockSupport.park().</span><br><span class="line"></span><br><span class="line">|suspended|</span><br><span class="line"></span><br><span class="line">&gt; The thread&#39;s execution wassuspended by java.lang.Thread.suspend() or a JVMTI agent call.</span><br></pre></td></tr></table></figure>

<h5 id="2-2-Thread状态分析"><a href="#2-2-Thread状态分析" class="headerlink" title="2.2 Thread状态分析"></a>2.2 Thread状态分析</h5><p>线程的状态是一个很重要的东西，因此thread dump中会显示这些状态，通过对这些状态的分析，能够得出线程的运行状况，进而发现可能存在的问题。<strong>线程的状态在Thread.State这个枚举类型中定义</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public enum State   </span><br><span class="line">&#123;  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread which has not yet started. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       NEW,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a runnable thread.  A thread in the runnable </span><br><span class="line">        * state is executing in the Java virtual machine but it may </span><br><span class="line">        * be waiting for other resources from the operating system </span><br><span class="line">        * such as processor. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       RUNNABLE,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread blocked waiting for a monitor lock. </span><br><span class="line">        * A thread in the blocked state is waiting for a monitor lock </span><br><span class="line">        * to enter a synchronized block&#x2F;method or  </span><br><span class="line">        * reenter a synchronized block&#x2F;method after calling </span><br><span class="line">        * &#123;@link Object#wait() Object.wait&#125;. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       BLOCKED,  </span><br><span class="line">     </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread. </span><br><span class="line">        * A thread is in the waiting state due to calling one of the  </span><br><span class="line">        * following methods: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *  </span><br><span class="line">        * &lt;p&gt;A thread in the waiting state is waiting for another thread to </span><br><span class="line">        * perform a particular action.   </span><br><span class="line">        * </span><br><span class="line">        * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt; </span><br><span class="line">        * on an object is waiting for another thread to call  </span><br><span class="line">        * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on  </span><br><span class="line">        * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;  </span><br><span class="line">        * is waiting for a specified thread to terminate. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       WAITING,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread with a specified waiting time. </span><br><span class="line">        * A thread is in the timed waiting state due to calling one of  </span><br><span class="line">        * the following methods with a specified positive waiting time: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;  </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TIMED_WAITING,  </span><br><span class="line">  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a terminated thread. </span><br><span class="line">        * The thread has completed execution. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TERMINATED;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. NEW：</strong></p>
<p><strong>每一个线程，在堆内存中都有一个对应的Thread对象。</strong>Thread t = new Thread();当刚刚在堆内存中创建Thread对象，还没有调用t.start()方法之前，线程就处在NEW状态。<strong>在这个状态上，线程与普通的java对象没有什么区别，就仅仅是一个堆内存中的对象。</strong></p>
<p><strong>2. RUNNABLE：</strong></p>
<p><strong>该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。</strong>这个状态的线程比较正常，但如果线程长时间停留在在这个状态就不正常了，这说明线程运行的时间很长（存在性能问题），或者是线程一直得不得执行的机会（存在线程饥饿的问题）。</p>
<p><strong>3. BLOCKED：</strong></p>
<p><strong>线程正在等待获取java对象的监视器(也叫内置锁)，即线程正在等待进入由synchronized保护的方法或者代码块。</strong>synchronized用来保证原子性，任意时刻最多只能由一个线程进入该临界区域，其他线程只能排队等待。</p>
<p><strong>4. WAITING：</strong></p>
<p><strong>处在该线程的状态，正在等待某个事件的发生，只有特定的条件满足，才能获得执行机会。</strong>而产生这个特定的事件，通常都是另一个线程。也就是说，<strong>如果不发生特定的事件，那么处在该状态的线程一直等待，不能获取执行的机会。</strong> 比如：</p>
<blockquote>
<p>1.A线程调用了obj对象的obj.wait()方法，如果没有线程调用obj.notify或obj.notifyAll，那么A线程就没有办法恢复运行；<br>2.如果A线程调用了LockSupport.park()，没有别的线程调用LockSupport.unpark(A)，那么A没有办法恢复运行。</p>
</blockquote>
<p><strong>5. TIMED_WAITING：</strong></p>
<p>J.U.C中很多与线程相关类，都提供了限时版本和不限时版本的API。 <strong>TIMED_WAITING意味着线程调用了限时版本的API，正在等待时间流逝。 **当等待时间过去后，线程一样可以恢复运行。</strong>如果线程进入了WAITING状态，一定要特定的事件发生才能恢复运行；而处在TIMED_WAITING的线程，如果特定的事件发生或者是时间流逝完毕，都会恢复运行。**</p>
<p><strong>6. TERMINATED：</strong></p>
<p><strong>线程执行完毕，执行完run方法正常返回，或者抛出了运行时异常而结束，线程都会停留在这个状态。</strong>这个时候线程只剩下Thread对象了，没有什么用了。</p>
<h5 id="2-3-关键状态分析"><a href="#2-3-关键状态分析" class="headerlink" title="2.3 关键状态分析"></a>2.3 关键状态分析</h5><ol>
<li>Wait on condition：The thread is either sleeping or waiting to be notified by another thread.<br>该状态说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(n)。</li>
</ol>
<p><strong>此时线程状态大致为以下几种：</strong></p>
<blockquote>
<p>1.java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；<br>2.java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p>
</blockquote>
<ol start="2">
<li>Waiting for Monitor Entry 和 in Object.wait()：The thread is waiting to get the lock for an object (some other thread may be holding the lock). This happens if two or more threads try to execute synchronized code. Note that the lock is always for an object and not for individual methods.</li>
</ol>
<p>在多线程的JAVA程序中，实现线程之间的同步，就要说说 Monitor。 *<em>Monitor是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者Class的锁。 *</em>每一个对象都有，也仅有一个 Monitor。下面这个图，描述了线程和 Monitor之间关系，以及线程的状态转换图：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2770d7fd4e31c5fa.png" alt="A Java Monitor And Thread"></p>
<p>如上图，每个Monitor在某个时刻，只能被一个线程拥有，*<em>该线程就是 “ActiveThread”，而其它线程都是 “Waiting Thread”，分别在两个队列“Entry Set”和“Wait Set”里等候。 *</em>在“Entry Set”中等待的线程状态是“Waiting for monitor entry”，而在“Wait Set”中等待的线程状态是“in Object.wait()”。</p>
<p><strong>先看“Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了“Entry Set”队列。</strong>对应的 code就像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;</span><br><span class="line">   .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这时有两种可能性：</strong></p>
<blockquote>
<p>1.该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码。<br>2.该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。</p>
</blockquote>
<p><strong>在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-0&quot; prio&#x3D;10 tid&#x3D;0x08222eb0 nid&#x3D;0x9 waiting for monitor entry [0xf927b000..0xf927bdb8] </span><br><span class="line">at testthread.WaitThread.run(WaitThread.java:39) </span><br><span class="line">- waiting to lock &lt;0xef63bf08&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line">at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p><strong>临界区的设置，是为了保证其内部的代码执行的原子性和完整性。</strong>但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。</p>
<p><strong>再看“Wait Set”里面的线程。</strong>当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll()，“Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;10 tid&#x3D;0x08223250 nid&#x3D;0xa in Object.wait() [0xef47a000..0xef47aa38] </span><br><span class="line"> at java.lang.Object.wait(Native Method) </span><br><span class="line"> - waiting on &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Object.wait(Object.java:474) </span><br><span class="line"> at testthread.MyWaitThread.run(MyWaitThread.java:40) </span><br><span class="line"> - locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p>综上，一般CPU很忙时，则关注runnable的线程，CPU很闲时，则关注waiting for monitor entry的线程。</p>
<ol start="3">
<li>JDK 5.0 的 Lock</li>
</ol>
<p>上面提到如果 synchronized和 monitor机制运用不当，可能会造成多线程程序的性能问题。在 JDK 5.0中，引入了 Lock机制，从而使开发者能更灵活的开发高性能的并发多线程程序，可以替代以往 JDK中的 synchronized和 Monitor的 机制。** 但是，要注意的是，因为 Lock类只是一个普通类，JVM无从得知 Lock对象的占用情况，所以在线程 DUMP中，也不会包含关于 Lock的信息，**关于死锁等问题，就不如用 synchronized的编程方式容易识别。</p>
<h5 id="2-4-关键状态示例"><a href="#2-4-关键状态示例" class="headerlink" title="2.4 关键状态示例"></a>2.4 关键状态示例</h5><p><strong>显示BLOCKED状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class BlockedState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis(); </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取object的线程会执行5分钟，这5分钟内会一直持有object的监视器，另一个线程无法执行处在B</p>
<p><strong>LOCKED状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1314 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7a800 nid&#x3D;0x1350 waiting for monitor entry [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:17)  </span><br><span class="line">     - waiting to lock &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d79400 nid&#x3D;0x1338 runnable [0x282ef000]  </span><br><span class="line"> java.lang.Thread.State: RUNNABLE  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:22)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>通过thread dump可以看到：t2线程确实处在BLOCKED (on object monitor)。waiting for monitor entry 等待进入synchronized保护的区域。</p>
<p><strong>显示WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class WaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        try  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            &#x2F;&#x2F; 进入等待的同时,会进入释放监视器  </span><br><span class="line">                            object.wait();  </span><br><span class="line">                        &#125; catch (InterruptedException e)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1734 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7e000 nid&#x3D;0x17f4 in Object.wait() [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d7d400 nid&#x3D;0x17f0 in Object.wait() [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以发现t1和t2都处在WAITING (on object monitor)，进入等待状态的原因是调用了in Object.wait()。通过J.U.C包下的锁和条件队列，也是这个效果，大家可以自己实践下。</p>
<p><strong>显示TIMED_WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">import java.util.concurrent.TimeUnit;  </span><br><span class="line">import java.util.concurrent.locks.Condition;  </span><br><span class="line">import java.util.concurrent.locks.Lock;  </span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line">public class TimedWaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    &#x2F;&#x2F; java的显示锁,类似java对象内置的监视器  </span><br><span class="line">    private static Lock lock &#x3D; new ReentrantLock();  </span><br><span class="line">    &#x2F;&#x2F; 锁关联的条件队列(类似于object.wait)  </span><br><span class="line">    private static Condition condition &#x3D; lock.newCondition();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                &#x2F;&#x2F; 加锁,进入临界区  </span><br><span class="line">                lock.lock();  </span><br><span class="line">                try  </span><br><span class="line">                &#123;  </span><br><span class="line">                    condition.await(5, TimeUnit.MINUTES);  </span><br><span class="line">                &#125; catch (InterruptedException e)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                &#x2F;&#x2F; 解锁,退出临界区  </span><br><span class="line">                lock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x169c waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7d800 nid&#x3D;0xc30 waiting on condition [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x280d0c00 nid&#x3D;0x16e0 waiting on condition [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以看到t1和t2线程都处在java.lang.Thread.State: TIMED_WAITING (parking)，这个parking代表是调用的JUC下的工具类，而不是java默认的监视器。</p>
<h4 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3 案例分析"></a>3 案例分析</h4><h5 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a>3.1 问题场景</h5><p><strong>1. CPU飙高，load高，响应很慢</strong></p>
<blockquote>
<p>1.一个请求过程中多次dump；<br>2.对比多次dump文件的runnable线程，如果执行的方法有比较大变化，说明比较正常。如果在执行同一个方法，就有一些问题了；</p>
</blockquote>
<p><strong>2. 查找占用CPU最多的线程</strong></p>
<blockquote>
<p>1.使用命令：top -H -p pid（pid为被测系统的进程号），找到导致CPU高的线程ID，对应thread dump信息中线程的nid，只不过一个是十进制，一个是十六进制；<br>2.在thread dump中，根据top命令查找的线程id，查找对应的线程堆栈信息；</p>
</blockquote>
<p><strong>3. CPU使用率不高但是响应很慢</strong></p>
<blockquote>
<p>进行dump，查看是否有很多thread struck在了i/o、数据库等地方，定位瓶颈原因；</p>
</blockquote>
<p><strong>4. 请求无法响应</strong></p>
<blockquote>
<p>多次dump，对比是否所有的runnable线程都一直在执行相同的方法，如果是的，恭喜你，锁住了！</p>
</blockquote>
<h5 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h5><p><strong>死锁经常表现为程序的停顿，或者不再响应用户的请求。</strong>从操作系统上观察，对应进程的CPU占用率为零，很快会从top或prstat的输出中消失。</p>
<p>比如在下面这个示例中，是个较为典型的死锁情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;5 tid&#x3D;0x00acc490 nid&#x3D;0xe50 waiting for monitor entry [0x02d3f000 </span><br><span class="line">..0x02d3fd68] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f18&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot; prio&#x3D;5 tid&#x3D;0x00accdb0 nid&#x3D;0xdec waiting for monitor entry [0x02cff000 </span><br><span class="line">..0x02cff9e8] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f18&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure>

<p>在 JAVA 5中加强了对死锁的检测。线程 Dump中可以直接报告出 Java级别的死锁，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock: </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">&quot;Thread-1&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f334 (object 0x22c19f18, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-0&quot; </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f314 (object 0x22c19f20, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-热锁"><a href="#3-3-热锁" class="headerlink" title="3.3 热锁"></a>3.3 热锁</h5><p>热锁，也往往是导致系统性能瓶颈的主要因素。其表现特征为：由于多个线程对临界区，或者锁的竞争，可能出现：</p>
<blockquote>
<p>1.频繁的线程的上下文切换：从操作系统对线程的调度来看，当线程在等待资源而阻塞的时候，操作系统会将之切换出来，放到等待的队列，当线程获得资源之后，调度算法会将这个线程切换进去，放到执行队列中。<br>2.大量的系统调用：因为线程的上下文切换，以及热锁的竞争，或者临界区的频繁的进出，都可能导致大量的系统调用。<br>3.大部分CPU开销用在“系统态”：线程上下文切换，和系统调用，都会导致 CPU在 “系统态 ”运行，换而言之，虽然系统很忙碌，但是CPU用在 “用户态 ”的比例较小，应用程序得不到充分的 CPU资源。<br>4.随着CPU数目的增多，系统的性能反而下降。因为CPU数目多，同时运行的线程就越多，可能就会造成更频繁的线程上下文切换和系统态的CPU开销，从而导致更糟糕的性能。</p>
</blockquote>
<p>上面的描述，都是一个 scalability（可扩展性）很差的系统的表现。从整体的性能指标看，由于线程热锁的存在，程序的响应时间会变长，吞吐量会降低。</p>
<p>那么，怎么去了解 “热锁 ”出现在什么地方呢？</p>
<blockquote>
<p>一个重要的方法是 结合操作系统的各种工具观察系统资源使用状况，以及收集Java线程的DUMP信息，看线程都阻塞在什么方法上，了解原因，才能找到对应的解决方法。</p>
</blockquote>
<h5 id="4-JVM重要线程"><a href="#4-JVM重要线程" class="headerlink" title="4 JVM重要线程"></a>4 JVM重要线程</h5><p>JVM运行过程中产生的一些比较重要的线程罗列如下：</p>
<table>
<thead>
<tr>
<th>线程名称</th>
<th align="right">所属</th>
<th align="right">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>Attach Listener</td>
<td align="right">JVM</td>
<td align="right">Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并把结果返回给发送者。通常我们会用一些命令去要求JVM给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在JVM启动的时候没有初始化，那么，则会在用户第一次执行JVM命令时，得到启动。</td>
</tr>
<tr>
<td>Signal Dispatcher</td>
<td align="right">JVM</td>
<td align="right">前面提到Attach Listener线程的职责是接收外部JVM命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部JVM命令时，进行初始化工作。</td>
</tr>
<tr>
<td>CompilerThread0</td>
<td align="right">JVM</td>
<td align="right">用来调用JITing，实时编译装卸class 。 通常，JVM会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：CompilerThread1。</td>
</tr>
<tr>
<td>Concurrent Mark-Sweep GC Thread</td>
<td align="right">JVM</td>
<td align="right">并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。ps：启用该垃圾回收器，需要在JVM启动参数中加上：-XX:+UseConcMarkSweepGC。</td>
</tr>
<tr>
<td>DestroyJavaVM</td>
<td align="right">JVM</td>
<td align="right">执行main()的线程，在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程，处于等待状态，等待其它线程（Java线程和Native线程）退出时通知它卸载JVM。每个线程退出时，都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，则通知DestroyJavaVM 线程卸载JVM。</td>
</tr>
<tr>
<td>Finalizer Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：1) 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；2) 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</td>
</tr>
<tr>
<td>Low Memory Detector</td>
<td align="right">JVM</td>
<td align="right">这个线程是负责对可使用内存进行检测，如果发现可用内存低，分配新的内存空间。</td>
</tr>
<tr>
<td>Reference Handler</td>
<td align="right">JVM</td>
<td align="right">JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</td>
</tr>
<tr>
<td>VM Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程就比较牛b了，是JVM里面的线程母体，根据hotspot源码（vmThread.hpp）里面的注释，它是一个单个的对象（最原始的线程）会产生或触发所有其他的线程，这个单个的VM线程是会被其他线程所使用来做一些VM操作（如：清扫垃圾等）。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">啃碎并发（三）：Java线程上下文切换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:37:55" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是<strong>多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</strong></p>
<p>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。<strong>一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。</strong></p>
<p>多线程比多任务更加有挑战。<strong>多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。</strong>这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着<strong>不同的线程能被不同的CPU核得到真正意义的并行执行。</strong></p>
<p>所以，<strong>在多线程、多任务情况下，线程上下文切换是必须的，</strong>然而对于CPU架构设计中的概念，应先熟悉了解，这样会有助于理解线程上下文切换原理。</p>
<h4 id="1-多核、多CPU、超线程、多线程"><a href="#1-多核、多CPU、超线程、多线程" class="headerlink" title="1 多核、多CPU、超线程、多线程"></a>1 多核、多CPU、超线程、多线程</h4><h5 id="1-1-为什么要多核"><a href="#1-1-为什么要多核" class="headerlink" title="1.1 为什么要多核"></a>1.1 为什么要多核</h5><p>先要说的是多核、多CPU、超线程，这三个其实都是CPU架构设计的概念，<strong>一个现代CPU除了处理器核心之外还包括寄存器、L1L2缓存这些存储设备、浮点运算单元、整数运算单元等一些辅助运算设备以及内部总线等。</strong>一个多核的CPU也就是一个CPU上有多个处理器核心，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，<strong>就意味着这个程序的不同线程需要经常在CPU之间的外部总线上通信，同时还要处理不同CPU之间不同缓存导致数据不一致的问题，所以在这种场景下多核单CPU的架构就能发挥很大的优势，通信都在内部总线，共用同一个缓存。</strong></p>
<h5 id="1-2-为什么要多CPU"><a href="#1-2-为什么要多CPU" class="headerlink" title="1.2 为什么要多CPU"></a>1.2 为什么要多CPU</h5><p>前面提了多核的好处，那为什么要多CPU呢？这个其实很容易想到，如果要运行多个程序（进程）的话，假如只有一个CPU的话，就意味着要经常进行进程上下文切换，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，所以 <strong>多个进程就必然要经常进行进程上下文切换，这个代价是很高的。</strong></p>
<h5 id="1-3-为什么要超线程"><a href="#1-3-为什么要超线程" class="headerlink" title="1.3 为什么要超线程"></a>1.3 为什么要超线程</h5><p>超线程这个概念是Intel提出的，<strong>简单来说是在一个CPU上真正的并发两个线程</strong>，听起来似乎不太可能，因为CPU都是分时的啊，其实这里也是分时，<strong>因为前面也提到一个CPU除了处理器核心还有其他设备，一段代码执行过程也不光是只有处理器核心工作，如果两个线程A和B，A正在使用处理器核心，B正在使用缓存或者其他设备，那AB两个线程就可以并发执行，但是如果AB都在访问同一个设备，那就只能等前一个线程执行完后一个线程才能执行。</strong>实现这种并发的原理是<strong>在CPU里加了一个协调辅助核心，</strong>根据Intel提供的数据，这样一个设备会使得设备面积增大5%，但是性能提高15%~30%。</p>
<h5 id="1-4-为什么要多线程"><a href="#1-4-为什么要多线程" class="headerlink" title="1.4 为什么要多线程"></a>1.4 为什么要多线程</h5><p>这个问题也许是面试中问的最多的一个经典问题了，<strong>一个进程里多线程之间可以共享变量，线程间通信开销也较小，可以更好的利用多核CPU的性能，多核CPU上跑多线程程序往往会比单线程更快，</strong>有的时候甚至在单核CPU上多线程程序也会有更好的性能，<strong>因为虽然多线程会有上下文切换和线程创建销毁开销，但是单线程程序会被IO阻塞无法充分利用CPU资源，加上线程的上下文开销较低以及线程池的大量应用，多线程在很多场景下都会有更高的效率。</strong></p>
<h5 id="1-5-线程与进程"><a href="#1-5-线程与进程" class="headerlink" title="1.5 线程与进程"></a>1.5 线程与进程</h5><p><strong>进程是操作系统的管理单位，而线程则是进程的管理单位；</strong>一个进程至少包含一个执行线程。不管是在单线程还是多线程中，每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）。虽然线程寄生在进程中，但与他的进程是不同的概念，并且可以分别处理：<strong>进程是系统分配资源的基本单位，线程是调度CPU的基本单位。</strong></p>
<p>一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，<strong>每条线程并行执行不同的任务。每个线程共享堆空间，拥有自己独立的栈空间。</strong></p>
<blockquote>
<p>1.线程划分尺度小于进程，线程隶属于某个进程；<br>2.进程是CPU、内存等资源占用的基本单位，线程是不能独立占有这些资源的；<br>3.进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信方便；<br>4.进程在执行过程中，包含：固定的入口、执行顺序和出口，而进程的这些过程会被应用程序控制；<br>进程&amp;线程表项</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-926d1b70a1b4cac0.png" alt=""></p>
<h4 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2 上下文切换"></a>2 上下文切换</h4><p>支持多任务处理是CPU设计史上最大的跨越之一。<strong>在计算机中，多任务处理是指同时运行两个或多个程序。</strong>从使用者的角度来看，这看起来并不复杂或者难以实现，但是它确实是计算机设计史上一次大的飞跃。<strong>在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里。</strong>上下文切换就是这样一个过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。</p>
<p>多任务系统往往需要同时执行多道作业。作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者<strong>巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载, 这段过程就叫做上下文切换。</strong>时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-4c5c5e8b4fd1e2c0.png" alt="任务的状态保存及再加载, 这段过程就叫做上下文切换"></p>
<h5 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p>上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程或线程切换到另一个进程或线程。</p>
<blockquote>
<p>1.进程（有时候也称做任务）是指一个程序运行的实例。<br>2.在Linux系统中，<strong>线程</strong>就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的 轻量级的进程。<br>3.<strong>上下文</strong>是指某一时间点 CPU 寄存器和程序计数器的内容。<br>4.<strong>寄存器</strong>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。<strong>寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</strong><br>5.<strong>程序计数器是一个专用的寄存器，</strong>用于表明指令序列中 CPU 正在执行的位置，<strong>存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</strong></p>
</blockquote>
<p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：</p>
<blockquote>
<p>1.挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处；<br>2.恢复一个进程，在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复；<br>3.跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</p>
</blockquote>
<h5 id="2-2-切换种类"><a href="#2-2-切换种类" class="headerlink" title="2.2 切换种类"></a>2.2 切换种类</h5><p>上下文切换在不同的场合有不同的含义，在下表中列出：</p>
<table>
<thead>
<tr>
<th>上下文切换种类</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>线程切换</td>
<td align="right">同一进程中的两个线程之间的切换</td>
</tr>
<tr>
<td>进程切换</td>
<td align="right">两个进程之间的切换</td>
</tr>
<tr>
<td>模式切换</td>
<td align="right">在给定线程中，用户模式和内核模式的切换</td>
</tr>
<tr>
<td>地址空间切换</td>
<td align="right">将虚拟内存切换到物理内存</td>
</tr>
</tbody></table>
<h5 id="2-3-切换步骤"><a href="#2-3-切换步骤" class="headerlink" title="2.3 切换步骤"></a>2.3 切换步骤</h5><p>在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。<strong>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB, process control block）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</strong></p>
<p><strong>PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，</strong>它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。</p>
<blockquote>
<p>1.保存进程A的状态（寄存器和操作系统数据）；<br>2.更新PCB中的信息，对进程A的“运行态”做出相应更改；<br>3.将进程A的PCB放入相关状态的队列；<br>4.将进程B的PCB信息改为“运行态”，并执行进程B；<br>5.B执行完后，从队列中取出进程A的PCB，恢复进程A被切换时的上下文，继续执行A；</p>
</blockquote>
<p>线程切换和进程切换的步骤也不同。进程的上下文切换分为两步：</p>
<blockquote>
<p>1.切换页目录以使用新的地址空间；<br>2.切换内核栈和硬件上下文；</p>
</blockquote>
<p>对于Linux来说，线程和进程的最大区别就在于地址空间。<strong>对于线程切换，第1步是不需要做的，</strong>第2是进程和线程切换都要做的。所以明显是进程切换代价大。线程上下文切换和进程上下文切换一个最主要的区别是<strong>线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。</strong>这两种上下文切换的处理都是<strong>通过操作系统内核来完成的。</strong>内核的这种切换过程伴随的 最显著的性能损耗是将寄存器中的内容切换出。</p>
<p>对于一个正在执行的进程包括<strong>程序计数器、寄存器、变量的当前值等 ，</strong>而这些数据都是 <strong>保存在CPU的寄存器中的，</strong>且这些寄存器只能是正在使用CPU的进程才能享用，在进程切换时，首先得保存上一个进程的这些数据（便于下次获得CPU的使用权时从上次的中断处开始继续顺序执行，而不是返回到进程开始，否则每次进程重新获得CPU时所处理的任务都是上一次的重复，可能永远也到不了进程的结束出，因为一个进程几乎不可能执行完所有任务后才释放CPU），然后将本次获得CPU的进程的这些数据装入CPU的寄存器从上次断点处继续执行剩下的任务。</p>
<p><strong>操作系统为了便于管理系统内部进程，为每个进程创建了一张进程表项：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-e2afee842676828d.png" alt="进程表项"></p>
<h5 id="2-4-切换查看"><a href="#2-4-切换查看" class="headerlink" title="2.4 切换查看"></a>2.4 切换查看</h5><p>在Linux系统下可以使用vmstat命令来查看上下文切换的次数，下面是利用vmstat查看上下文切换次数的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-73c88cc6c86895f3.png" alt="上线文切换查看"></p>
<blockquote>
<p>vmstat 1指每秒统计一次, 其中cs列就是指上下文切换的数目. 一般情况下, 空闲系统的上下文切换每秒大概在1500以下.</p>
</blockquote>
<h5 id="3-切换原因"><a href="#3-切换原因" class="headerlink" title="3 切换原因"></a>3 切换原因</h5><p>引起线程上下文切换的原因，主要存在三种情况如下：</p>
<blockquote>
<p>1.中断处理：在中断处理中，其他程序”打断”了当前正在运行的程序。当CPU接收到中断请求时，会在正在运行的程序和发起中断请求的程序之间进行一次上下文切换。中断分为硬件中断和软件中断，软件中断包括因为IO阻塞、未抢到资源或者用户代码等原因，线程被挂起。<br>2.多任务处理：在多任务处理中，CPU会在不同程序之间来回切换，每个程序都有相应的处理时间片，CPU在两个时间片的间隔中进行上下文切换。<br>3.用户态切换：对于一些操作系统，当进行用户态切换时也会进行一次上下文切换，虽然这不是必须的。</p>
</blockquote>
<p>对于我们经常 使用的抢占式操作系统 而言，引起线程上下文切换的原因大概有以下几种：</p>
<blockquote>
<p>1.当前执行任务的时间片用完之后，系统CPU正常调度下一个任务；<br>2.当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务；<br>3.多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；<br>4.用户代码挂起当前任务，让出CPU时间；<br>5.硬件中断；</p>
</blockquote>
<h5 id="4-切换损耗"><a href="#4-切换损耗" class="headerlink" title="4 切换损耗"></a>4 切换损耗</h5><p>上下文切换会带来 直接和间接 两种因素影响程序性能的消耗。</p>
<blockquote>
<p>1.直接消耗：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉；<br>2.间接消耗：指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小；</p>
</blockquote>
<h5 id="5-减少切换"><a href="#5-减少切换" class="headerlink" title="5 减少切换"></a>5 减少切换</h5><p>既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。但上下文切换又分为2种：</p>
<blockquote>
<p>1.让步式上下文切换：指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；<br>2.抢占式上下文切换：指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。</p>
</blockquote>
<p>所以，减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p>
<blockquote>
<p>1.无锁并发：多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据；<br>2.CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；<br>3.最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；<br>4.使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；</p>
</blockquote>
<h5 id="6-线程数目"><a href="#6-线程数目" class="headerlink" title="6 线程数目"></a>6 线程数目</h5><p>合理设置线程数目，<strong>关键点是：1. 尽量减少线程切换和管理的开支；2. 最大化利用CPU；</strong></p>
<blockquote>
<p>1.对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支；</p>
<p>对于2，要求尽量多的线程，以保证CPU资源最大化的利用；</p>
</blockquote>
<p>所以<strong>对于任务耗时短的情况，要求线程尽量少，</strong>如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；</p>
<p><strong>对于耗时长的任务，要分是CPU任务，还是IO等类型的任务。</strong>如果是CPU类型的任务，线程数不宜太多；但是如果是IO类型的任务，线程多一些更好，可以更充分利用CPU。</p>
<p><strong>高并发，低耗时的情况：</strong>建议少线程，只要满足并发即可，因为上下文切换本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片，反而会增加线程切换的开销；例如并发100，线程池可能设置为10就可以；</p>
<p><strong>低并发，高耗时的情况：</strong>建议多线程，保证有空闲线程，接受新的任务；例如并发10，线程池可能就要设置为20；</p>
<p><strong>高并发高耗时</strong>：1. 要分析任务类型；2. 增加排队；3. 加大线程数；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">啃碎并发（二）：Java线程的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:37:55" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是 线程状态也会多次在运行、阻塞之间切换。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-bf153c2ed5c95f66.png" alt=""></p>
<h6 id="1-新建（New）状态"><a href="#1-新建（New）状态" class="headerlink" title="1 新建（New）状态"></a>1 新建（New）状态</h6><p>当程序使用new关键字创建了一个线程之后，该线程就处于<strong>新建状态</strong>，此时的线程情况如下：</p>
<blockquote>
<p><strong>1.此时JVM为其分配内存，并初始化其成员变量的值；<br>2.此时线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体；</strong></p>
</blockquote>
<h6 id="2-就绪（Runnable）状态"><a href="#2-就绪（Runnable）状态" class="headerlink" title="2 就绪（Runnable）状态"></a>2 就绪（Runnable）状态</h6><p>当线程对象调用了start()方法之后，该线程处于<strong>就绪状态</strong>。此时的线程情况如下：</p>
<blockquote>
<p>1.此时JVM会为其<strong>创建方法调用栈和程序计数器；</strong><br>2.该状态的线程一直处于<strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；<br>3.此时线程<strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</p>
</blockquote>
<p>调用start()方法与run()方法，对比如下：</p>
<blockquote>
<p>1.调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体；<br>2.需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常；</p>
</blockquote>
<p>如何让子线程调用start()方法之后立即执行而非”等待执行”：</p>
<blockquote>
<p>程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行；</p>
</blockquote>
<h6 id="3-运行（Running）状态"><a href="#3-运行（Running）状态" class="headerlink" title="3 运行（Running）状态"></a>3 运行（Running）状态</h6><p>当CPU开始调度处于<strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 运行状态。</p>
<blockquote>
<p><strong>1.如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；<br>2.如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；<br>3.当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</strong></p>
</blockquote>
<p>处于运行状态的线程最为复杂，它 不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。线程状态可能会变为 阻塞状态、就绪状态和死亡状态。比如：</p>
<blockquote>
<p><strong>1.对于采用 抢占式策略 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 从运行状态变为就绪状态，重新等待系统分配资源；<br>2.对于采用 协作式策略的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—也就是必须由该线程主动放弃所占用的资源，线程就会又 从运行状态变为就绪状态。</strong></p>
</blockquote>
<h5 id="4-阻塞（Blocked）状态"><a href="#4-阻塞（Blocked）状态" class="headerlink" title="4 阻塞（Blocked）状态"></a>4 阻塞（Blocked）状态</h5><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入<strong>阻塞状态</strong>。</p>
<p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p>
<blockquote>
<p><strong>1.线程调用sleep()方法，主动放弃所占用的处理器资源，暂时进入中断状态（不会释放持有的对象锁），时间到后等待系统分配CPU继续执行；<br>2.线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；<br>3.线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有;<br>4.程序调用了线程的suspend方法将线程挂起；<br>5.线程调用wait，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</strong></p>
</blockquote>
<p>阻塞状态分类：</p>
<blockquote>
<p><strong>1.等待阻塞：运行状态中的 线程执行wait()方法，使本线程进入到等待阻塞状态；<br>同步阻塞：线程在 获取synchronized同步锁失败（因为锁被其它线程占用），它会进入到同步阻塞状态；<br>其他阻塞：通过调用线程的 sleep()或join()或发出I/O请求 时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕 时，线程重新转入就绪状态；<br>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。</strong></p>
</blockquote>
<blockquote>
<p>但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。</p>
</blockquote>
<h5 id="4-1-等待（WAITING）状态"><a href="#4-1-等待（WAITING）状态" class="headerlink" title="4.1 等待（WAITING）状态"></a>4.1 等待（WAITING）状态</h5><p>线程处于 无限制等待状态，等待一个特殊的事件来重新唤醒，如：</p>
<blockquote>
<p><strong>1.通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；<br>2.通过join()方法进行等待的线程等待目标线程运行结束而唤醒；<br>以上两种一旦通过相关事件唤醒线程，线程就进入了 就绪（RUNNABLE）状态 继续运行。</strong></p>
</blockquote>
<h5 id="4-2-时限等待（TIMED-WAITING）状态"><a href="#4-2-时限等待（TIMED-WAITING）状态" class="headerlink" title="4.2 时限等待（TIMED_WAITING）状态"></a>4.2 时限等待（TIMED_WAITING）状态</h5><p>线程进入了一个 时限等待状态，如：</p>
<blockquote>
<p>sleep(3000)，等待3秒后线程重新进行 就绪（RUNNABLE）状态 继续运行。</p>
</blockquote>
<h5 id="5-死亡（Dead）状态"><a href="#5-死亡（Dead）状态" class="headerlink" title="5 死亡（Dead）状态"></a>5 死亡（Dead）状态</h5><p>线程会以如下3种方式结束，结束后就处于 死亡状态：</p>
<blockquote>
<p><strong>1.run()或call()方法执行完成，线程正常结束；<br>2.线程抛出一个未捕获的Exception或Error；<br>3.直接调用该线程stop()方法来结束该线程—该方法容易导致死锁，通常不推荐使用；</strong></p>
</blockquote>
<p>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。**</p>
<p>所以，需要注意的是：</p>
<blockquote>
<p>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态。</p>
</blockquote>
<h5 id="5-1-终止（TERMINATED）状态"><a href="#5-1-终止（TERMINATED）状态" class="headerlink" title="5.1 终止（TERMINATED）状态"></a>5.1 终止（TERMINATED）状态</h5><p>线程执行完毕后，进入终止（TERMINATED）状态。</p>
<h5 id="6-线程相关方法"><a href="#6-线程相关方法" class="headerlink" title="6 线程相关方法"></a>6 线程相关方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Thread&#123;</span><br><span class="line">    &#x2F;&#x2F; 线程的启动</span><br><span class="line">    public void start(); </span><br><span class="line">    &#x2F;&#x2F; 线程体</span><br><span class="line">    public void run(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void stop(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void resume(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void suspend(); </span><br><span class="line">    &#x2F;&#x2F; 在指定的毫秒数内让当前正在执行的线程休眠</span><br><span class="line">    public static void sleep(long millis); </span><br><span class="line">    &#x2F;&#x2F; 同上，增加了纳秒参数</span><br><span class="line">    public static void sleep(long millis, int nanos); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否处于活动状态</span><br><span class="line">    public boolean isAlive(); </span><br><span class="line">    &#x2F;&#x2F; 中断线程</span><br><span class="line">    public void interrupt(); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否已经中断</span><br><span class="line">    public boolean isInterrupted(); </span><br><span class="line">    &#x2F;&#x2F; 测试当前线程是否已经中断</span><br><span class="line">    public static boolean interrupted(); </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止</span><br><span class="line">    public void join() throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒</span><br><span class="line">    public void join(long millis) throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</span><br><span class="line">    public void join(long millis, int nanos) throws InterruptedException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/2062729-3220c4bc58f5448b.png" alt=""></p>
<h5 id="6-1-线程就绪、运行和死亡状态转换"><a href="#6-1-线程就绪、运行和死亡状态转换" class="headerlink" title="6.1 线程就绪、运行和死亡状态转换"></a>6.1 线程就绪、运行和死亡状态转换</h5><p>1.就绪状态转换为运行状态：此线程得到CPU资源；<br>2.运行状态转换为就绪状态：此线程主动调用yield()方法或在运行过程中失去CPU资源。<br>3.运行状态转换为死亡状态：此线程执行执行完毕或者发生了异常；</p>
<p><strong>注意：</strong></p>
<blockquote>
<p><strong>当调用线程中的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的那个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</strong></p>
</blockquote>
<h5 id="6-2-run-amp-start"><a href="#6-2-run-amp-start" class="headerlink" title="6.2 run &amp; start"></a>6.2 run &amp; start</h5><p>通过调用start启动线程，线程执行时会执行run方法中的代码。</p>
<blockquote>
<p><strong>1.start()：线程的启动；<br>2.run()：线程的执行体；</strong></p>
</blockquote>
<h6 id="6-3-sleep-amp-yield"><a href="#6-3-sleep-amp-yield" class="headerlink" title="6.3 sleep &amp; yield"></a>6.3 sleep &amp; yield</h6><p>sleep()：通过sleep(millis)使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<p><strong>比如，我们想要使主线程每休眠100毫秒，然后再打印出数字：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意如下几点问题：</strong></p>
<p><strong>sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。</strong>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread&#x3D;new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        &#x2F;&#x2F; 这里sleep的就是main线程，而非myThread线程 </span><br><span class="line">        myThread.sleep(1000); </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName()+&quot;线程&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(50);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看某一次的运行结果：可以发现，线程0首先执行，然后线程1执行一次，又了执行一次。发现并不是按照sleep的顺序执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0线程0次执行！  </span><br><span class="line">Thread-1线程0次执行！  </span><br><span class="line">Thread-1线程1次执行！  </span><br><span class="line">Thread-0线程1次执行！  </span><br><span class="line">Thread-0线程2次执行！  </span><br><span class="line">Thread-1线程2次执行！</span><br></pre></td></tr></table></figure>

<p><strong>yield()</strong>：与sleep类似，也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。</p>
<blockquote>
<p><strong>实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于sleep()方法和yield()方的区别如下：</strong></p>
<blockquote>
<p><strong>sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态；<br>sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常；<br>sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行；</strong></p>
</blockquote>
<h5 id="6-4-join"><a href="#6-4-join" class="headerlink" title="6.4 join"></a>6.4 join</h5><p>线程的合并的含义就是 将几个并行线程的线程合并为一个单线程执行，应用场景是 当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。</p>
<p>join有3个重载的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void join()</span><br><span class="line">当前线程等该加入该线程后面，等待该线程终止。    </span><br><span class="line">void join(long millis)    </span><br><span class="line">当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   </span><br><span class="line">void join(long millis,int nanos)    </span><br><span class="line">等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span><br></pre></td></tr></table></figure>

<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在主线程中调用thread.join(); 就是将主线程加入到thread子线程后面等待执行。不过有时间限制，为1毫秒。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread t&#x3D;new MyThread();  </span><br><span class="line">        t.start();  </span><br><span class="line">        t.join(1);&#x2F;&#x2F;将主线程加入到子线程后面，不过如果子线程在1毫秒时间内没执行完，则主线程便不再等待它执行完，进入就绪状态，等待cpu调度  </span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++)&#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在JDK中join方法的源码，如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)    throws InterruptedException &#123;  </span><br><span class="line">    long base &#x3D; System.currentTimeMillis();  </span><br><span class="line">    long now &#x3D; 0;  </span><br><span class="line">  </span><br><span class="line">    if (millis &lt; 0) &#123;  </span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">          </span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">           wait(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">            long delay &#x3D; millis - now;  </span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            wait(delay);  </span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>join方法实现是通过调用wait方法实现。当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁)，调用该对象的wait(等待时间)，直到该对象唤醒main线程，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。</strong></p>
</blockquote>
<h5 id="6-5-suspend-amp-resume-已过时"><a href="#6-5-suspend-amp-resume-已过时" class="headerlink" title="6.5 suspend &amp; resume (已过时)"></a>6.5 suspend &amp; resume (已过时)</h5><p>suspend-线程进入阻塞状态，但不会释放锁。此方法已不推荐使用，因为同步时不会释放锁，会造成死锁的问题。</p>
<p>resume-使线程重新进入可执行状态。</p>
<p>为什么<strong>Thread.suspend **和</strong>Thread.resume**被废弃了？</p>
<blockquote>
<p><strong>Thread.suspend 天生容易引起死锁。如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了。这种死锁一般自身表现为“冻结（ frozen ）”进程。</strong></p>
</blockquote>
<h5 id="6-6-stop（已过时）"><a href="#6-6-stop（已过时）" class="headerlink" title="6.6 stop（已过时）"></a>6.6 stop（已过时）</h5><p>不推荐使用，且以后可能去除，因为它不安全。为什么 Thread.stop 被废弃了？</p>
<p>因为其天生是不安全的。停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。这种对象被称为受损的 （damaged）。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。</p>
<p>不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。</p>
<h5 id="6-7-wait-amp-notify-notifyAll"><a href="#6-7-wait-amp-notify-notifyAll" class="headerlink" title="6.7 wait &amp; notify/notifyAll"></a>6.7 wait &amp; notify/notifyAll</h5><p>*<em>wait &amp; notify/notifyAll *</em>这三个都是Object类的方法。使用 wait ，notify 和 notifyAll 前提是先获得调用对象的锁。</p>
<blockquote>
<p><strong>1.调用 wait 方法后，释放持有的对象锁，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列；<br>2.调用notify 或者 notifyAll 方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回；<br>3.notify 方法：将等待队列的一个等待线程从等待队列种移到同步队列中 ，而 notifyAll 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked。</strong></p>
</blockquote>
<p>前面一直提到两个概念，等待队列（等待池），同步队列（锁池），这两者是不一样的。具体如下：</p>
<blockquote>
<p><strong>1. 同步队列（锁池）：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked。<br>2.等待队列（等待池）：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么 仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）。</strong></p>
</blockquote>
<p><strong>被notify或notifyAll唤起的线程是有规律的，具体如下：</strong></p>
<blockquote>
<p><strong>1.如果是通过notify来唤起的线程，那 先进入wait的线程会先被唤起来；<br>2. 如果是通过nootifyAll唤起的线程，默认情况是 最后进入的会先被唤起来，即LIFO的策略；</strong></p>
</blockquote>
<h5 id="6-8-线程优先级"><a href="#6-8-线程优先级" class="headerlink" title="6.8 线程优先级"></a>6.8 线程优先级</h5><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p>
<blockquote>
<p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级；</p>
</blockquote>
<p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   &#x3D;10</span><br><span class="line">MIN_PRIORITY   &#x3D;1</span><br><span class="line">NORM_PRIORITY   &#x3D;5</span><br></pre></td></tr></table></figure>
<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name,int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F;设置线程的名称  </span><br><span class="line">        setPriority(pro);&#x2F;&#x2F;设置线程的优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从执行结果可以看到 ，一般情况下，高级线程更显执行完毕。</p>
<p><strong>注意一点：</strong></p>
<blockquote>
<p>虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>
<h5 id="6-9-守护线程"><a href="#6-9-守护线程" class="headerlink" title="6.9 守护线程"></a>6.9 守护线程</h5><p>守护线程与普通线程写法上基本没啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</p>
<p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</p>
<p>setDaemon方法详细说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line"></span><br><span class="line">该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">on - 如果为 true，则将该线程标记为守护线程。</span><br><span class="line">抛出：</span><br><span class="line">IllegalThreadStateException - 如果该线程处于活动状态。</span><br><span class="line">SecurityException - 如果当前线程无法修改该线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">* Java线程：线程的调度-守护线程 </span><br><span class="line">*&#x2F;  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">        public static void main(String[] args) &#123;  </span><br><span class="line">                Thread t1 &#x3D; new MyCommon();  </span><br><span class="line">                Thread t2 &#x3D; new Thread(new MyDaemon());  </span><br><span class="line">                t2.setDaemon(true);        &#x2F;&#x2F;设置为守护线程  </span><br><span class="line">  </span><br><span class="line">                t2.start();  </span><br><span class="line">                t1.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyCommon extends Thread &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;线程1第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyDaemon implements Runnable &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (long i &#x3D; 0; i &lt; 9999999L; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;后台线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">后台线程第0次执行！  </span><br><span class="line">线程1第0次执行！  </span><br><span class="line">线程1第1次执行！  </span><br><span class="line">后台线程第1次执行！  </span><br><span class="line">后台线程第2次执行！  </span><br><span class="line">线程1第2次执行！  </span><br><span class="line">线程1第3次执行！  </span><br><span class="line">后台线程第3次执行！  </span><br><span class="line">线程1第4次执行！  </span><br><span class="line">后台线程第4次执行！  </span><br><span class="line">后台线程第5次执行！  </span><br><span class="line">后台线程第6次执行！  </span><br><span class="line">后台线程第7次执行！</span><br></pre></td></tr></table></figure>
<p>从上面的执行结果可以看出：前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。</p>
<blockquote>
<p>实际上：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。</p>
</blockquote>
<h5 id="6-10-如何结束一个线程"><a href="#6-10-如何结束一个线程" class="headerlink" title="6.10 如何结束一个线程"></a>6.10 如何结束一个线程</h5><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。</p>
<blockquote>
<p>1.正常执行完run方法，然后结束掉；<br>2.控制循环条件和判断条件的标识符来结束掉线程；</p>
</blockquote>
<p>比如run方法这样写：只要保证在一定的情况下，run方法能够执行完毕即可。而不是while(true)的无限循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                break;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    boolean next&#x3D;true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                next&#x3D;false;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                return;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>诚然，使用上面方法的标识符来结束一个线程，是一个不错的方法，但其也有弊端，如果 该线程是处于sleep、wait、join的状态时候，while循环就不会执行，那么我们的标识符就无用武之地了，当然也不能再通过它来结束处于这3种状态的线程了。</p>
<p>所以，此时可以使用interrupt这个巧妙的方式结束掉这个线程。我们先来看看sleep、wait、join方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException </span><br><span class="line">public static native void sleep(long millis) throws InterruptedException</span><br><span class="line">public final void join() throws InterruptedException</span><br></pre></td></tr></table></figure>
<p>可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。在什么时候会产生这样一个异常呢？</p>
<blockquote>
<p>每个Thread都有一个中断状状态，默认为false。可以通过Thread对象的isInterrupted()方法来判断该线程的中断状态。可以通过Thread对象的interrupt()方法将中断状态设置为true。</p>
<p>当一个线程处于sleep、wait、join这三种状态之一的时候，如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常，并将中断状态重新设置为false。</p>
</blockquote>
<p>看下面的简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;1;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            System.out.println(this.isInterrupted());  </span><br><span class="line">            try &#123;  </span><br><span class="line">                System.out.println(&quot;我马上去sleep了&quot;);  </span><br><span class="line">                Thread.sleep(2000);  </span><br><span class="line">                this.interrupt();  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;异常捕获了&quot;+this.isInterrupted());  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">false  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">2  </span><br><span class="line">true  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">异常捕获了false</span><br></pre></td></tr></table></figure>

<p>可以看到，首先执行第一次while循环，在第一次循环中，睡眠2秒，然后将中断状态设置为true。当进入到第二次循环的时候，中断状态就是第一次设置的true，当它再次进入sleep的时候，马上就抛出了InterruptedException异常，然后被我们捕获了。然后中断状态又被重新自动设置为false了（从最后一条输出可以看出来）。</p>
<p>所以，我们可以使用interrupt方法结束一个线程。具体使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">        Thread.sleep(3000);  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(1000);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;中断异常被捕获了&quot;);  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多测试几次，会发现一般有两种执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">3  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>这两种结果恰恰说明了，只要一个线程的中断状态一旦为true，只要它进入sleep等状态，或者处于sleep状态，立马回抛出InterruptedException异常。</p>
<blockquote>
<p><strong>第一种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程正处于sleep状态，立马抛出InterruptedException异常。</p>
<p><strong>第二种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程还没有处于sleep状态。然后再第3次while循环的时候，在此进入sleep状态，立马抛出InterruptedException异常。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">啃碎并发（一）：Java线程总述与概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 21:14:46" itemprop="dateCreated datePublished" datetime="2020-05-31T21:14:46+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h4><p>在JDK5之前，Java多线程以及其性能一直是个软肋，只有synchronized、Thread.sleep()、Object.wait/notify这样有限的方法，而synchronized的效率还特别地低，开销比较大。</p>
<p>在JDK5之后，相对于前面版本有了重大改进，不仅在Java语法上有了很多改进，包括：泛型、装箱、for循环、变参等，在多线程上也有了彻底提高，其引进了并发编程大师Doug Lea的java.util.concurrent包(后面简称J.U.C)，支持了现代CPU的CAS原语，不仅在性能上有了很大提升，在自由度上也有了更多的选择，此时 J.U.C的效率在高并发环境下的效率远优于synchronized。</p>
<p>在JDK6（Mustang 野马）中，对synchronized的内在机制做了大量显著的优化，加入了CAS的概念以及偏向锁、轻量级锁，使得synchronized的效率与J.U.C不相上下，并且官方说后面该关键字还有继续优化的空间，所以在现 在JDK7时代，synchronized已经成为一般情况下的首选，在某些特殊场景：可中断的锁、条件锁、等待获得锁一段时间如果失败则停止，J.U.C是适用的，所以对于 多线程研究来说，了解其原理以及各自的适用场景是必要的。</p>
<h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2 基本概念"></a>2 基本概念</h4><h5 id="2-1-线程"><a href="#2-1-线程" class="headerlink" title="2.1 线程"></a>2.1 线程</h5><p>线程是依附于进程的，进程是分配资源的最小单位，一个进程可以生成多个线程，这些线程拥有共享的进程资源。就每个线程而言，只有很少的独有资源，如：控制线程运行的线程控制块，保留局部变量和少数参数的栈空间等。线程有就绪、阻塞和运行三种状态，并可以在这之间切换。也正因为多个线程会共享进程资源，所以当它们对同一个共享变量/对象进行操作的时候，线程的冲突和不一致性就产生了。</p>
<p>多线程并发环境下，本质上要解决地是这两个问题：</p>
<blockquote>
<ol>
<li>线程之间如何通信；</li>
<li>线程之间如何同步；</li>
</ol>
</blockquote>
<p>概括起来说就是：线程之间如何正确地通信。虽然说的是在Java层面如何保证，但会涉及到 Java虚拟机、Java内存模型，以及Java这样的高级语言最终是要映射到CPU来执行（关键原因：如今的CPU有缓存、并且是多核的），虽然有些难懂，但对于深刻把握多线程是至关重要的，所以需要多花一些时间。</p>
<h5 id="2-2-锁"><a href="#2-2-锁" class="headerlink" title="2.2 锁"></a>2.2 锁</h5><p>当多个线程对同一个共享变量/对象进行操作，即使是最简单的操作，如：i++，在处理上实际也涉及到读取、自增、赋值这三个操作，也就是说 这中间存在时间差，导致多个线程没有按照如程序编写者所设想的去顺序执行，出现错位，从而导致最终结果与预期不一致。</p>
<p>Java中的多线程同步是通过锁的概念来体现。锁不是一个对象、不是一个具体的东西，而是一种机制的名称。锁机制需要保证如下两种特性：</p>
<blockquote>
<p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性；<br>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致；</p>
</blockquote>
<h5 id="2-3-挂起、休眠、阻塞与非阻塞"><a href="#2-3-挂起、休眠、阻塞与非阻塞" class="headerlink" title="2.3 挂起、休眠、阻塞与非阻塞"></a>2.3 挂起、休眠、阻塞与非阻塞</h5><p>挂起（Suspend）：当线程被挂起的时候，其会失去CPU的使用时间，直到被其他线程（用户线程或调度线程）唤醒。</p>
<p>休眠（Sleep）：同样是会失去CPU的使用时间，但是在过了指定的休眠时间之后，它会自动激活，无需唤醒（整个唤醒表面看是自动的，但实际上也得有守护线程去唤醒，只是不需编程者手动干预）。</p>
<p>阻塞（Block）：在线程执行时，所需要的资源不能得到，则线程被挂起，直到满足可操作的条件。</p>
<p>非阻塞(Block)：在线程执行时，所需要的资源不能得到，则线程不是被挂起等待，而是继续执行其余事情，待条件满足了之后，收到了通知（同样是守护线程去做）再执行。</p>
<p>挂起和休眠是独立的操作系统的概念，而阻塞与非阻塞则是在资源不能得到时的两种处理方式，不限于操作系统，当资源申请不到时，要么挂起线程等待、要么继续执行其他操作，资源被满足后再通知该线程重新请求。显然非阻塞的效率要高于阻塞，相应的实现的复杂度也要高一些。</p>
<p>在Java中显式的挂起之前是通过Thread的suspend方法来体现，现在此概念已经消失，原因是suspend/resume方法已经被废弃，它们容易产生死锁，在suspend方法的注释里有这么一段话：当suspend的线程持有某个对象锁，而resume它的线程又正好需要使用此锁的时候，死锁就产生了。</p>
<p>所以，现在的JDK版本中，挂起是JVM的系统行为，程序员无需干涉。休眠的过程中也不会释放锁，但它一定会在某个时间后被唤醒，所以不会死锁。现在我们所说的挂起，往往并非指编写者的程序里主动挂起，而是由操作系统的线程调度器去控制。</p>
<p>所以，我们常常说的“线程在申请锁失败后会被挂起、然后等待调度”这样有一定歧义，因为这里的“挂起”是操作系统级别的挂起，其实是在申请资源失败时的阻塞，和Java中的线程的挂起（可能已经获得锁，也可能没有锁，总之和锁无关）不是一个概念，很容易混淆，所以在后文中说的挂起，一般指的是操作系统的操作，而不是Thread中的suspend()。</p>
<p>相应地有必要提下java.lang.Object的wait/notify，这两个方法同样是等待/通知，但它们的前提是已经获得了锁，且在wait（等待）期间会释放锁。在wait方法的注释里明确提到：线程要调用wait方法，必须先获得该对象的锁，在调用wait之后，当前线程释放该对象锁并进入休眠（这里到底是进入休眠还是挂起？文档没有细说，从该方法能指定等待时间来看，更可能是休眠，没有指定等待时间的，则可能是挂起，不管如何，在休眠/挂起之前，JVM都会从当前线程中把该对象锁释放掉），只有以下几种情况下会被唤醒：其他线程调用了该对象的notify或notifyAll、当前线程被中断、调用wait时指定的时间已到。</p>
<h5 id="2-4-内核态与用户态"><a href="#2-4-内核态与用户态" class="headerlink" title="2.4 内核态与用户态"></a>2.4 内核态与用户态</h5><p>这是两个操作系统的概念，但理解它们对我们理解Java的线程机制有着一定帮助。</p>
<p>有一些系统级的调用，比如：清除时钟、创建进程等这些系统指令，如果这些底层系统级指令能够被应用程序任意访问的话，那么后果是危险的，系统随时可能崩溃，所以 CPU将所执行的指令设置为多个特权级别，在硬件执行每条指令时都会校验指令的特权，比如：Intel x86架构的CPU将特权分为0-3四个特权级，0级的权限最高，3权限最低。</p>
<p>而操作系统根据这系统调用的安全性分为两种：内核态和用户态。内核态执行的指令的特权是0，用户态执行的指令的特权是3。</p>
<blockquote>
<p>1.当一个任务（进程）执行系统调用而进入内核指令执行时，进程处于内核运行态（或简称为内核态）；<br>2. 当任务（进程）执行自己的代码时，进程就处于用户态；</p>
</blockquote>
<p>明白了内核态和用户态的概念之后，那么在这两种状态之间切换会造成什么样的效率影响？</p>
<blockquote>
<p>在执行系统级调用时，需要将变量传递进去、可能要拷贝、计数、保存一些上下文信息，然后内核态执行完成之后需要再将参数传递到用户进程中去，这个切换的代价相对来说是比较大的，所以应该是 尽量避免频繁地在内核态和用户态之间切换。</p>
</blockquote>
<p>那操作系统的这两种形态和我们的线程主题有什么关系呢？这里是关键。Java并没有自己的线程模型，而是使用了操作系统的原生线程！</p>
<p>如果要实现自己的线程模型，那么有些问题就特别复杂，难以解决，比如：如何处理阻塞、如何在多CPU之间合理地分配线程、如何锁定，包括创建、销毁线程这些，都需要Java自己来做，在JDK1.2之前Java曾经使用过自己实现的线程模型，后来放弃了，转向使用操作系统的线程模型，因此创建、销毁、调度、阻塞等这些事都交由操作系统来做，而 线程方面的事在操作系统来说属于系统级的调用，需要在内核态完成，所以如果频繁地执行线程挂起、调度，就会频繁造成在内核态和用户态之间切换，影响效率（当然，操作系统的线程操作是不允许外界（包括Java虚拟机）直接访问的，而是开放了叫“轻量级进程”的接口供外界使用，其与内核线程在Window和Linux上是一对一的关系，这里不多叙述）。</p>
<blockquote>
<p>前面说JDK5之前的synchronized效率低下，是 因为在阻塞时线程就会被挂起、然后等待重新调度，而线程操作属于内核态，这频繁的挂起、调度使得操作系统频繁处于内核态和用户态的转换，造成频繁的变量传递、上下文保存等，从而性能较低。</p>
</blockquote>
<h5 id="3-线程优势"><a href="#3-线程优势" class="headerlink" title="3 线程优势"></a>3 线程优势</h5><p>尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是：</p>
<blockquote>
<ol>
<li>资源利用率更好；</li>
<li>程序设计在某些情况下更简单；</li>
<li>程序响应更快速；</li>
</ol>
</blockquote>
<h5 id="4-创建运行"><a href="#4-创建运行" class="headerlink" title="4 创建运行"></a>4 创建运行</h5><p>编写线程运行时执行的代码有两种方式：一种是创建Thread子类的一个实例并重写run方法，第二种是创建类的时候实现Runnable接口。</p>
<h5 id="5-Main线程与子线程关系"><a href="#5-Main线程与子线程关系" class="headerlink" title="5 Main线程与子线程关系"></a>5 Main线程与子线程关系</h5><p><strong>1. Main线程是个非守护线程，不能设置成守护线程</strong></p>
<p>这是因为，Main线程是由Java虚拟机在启动的时候创建的。main方法开始执行的时候，主线程已经创建好并在运行了。对于运行中的线程，调用Thread.setDaemon()会抛出异常Exception in thread “main” java.lang.IllegalThreadStateException。</p>
<p><strong>2. Main线程结束，其他线程一样可以正常运行</strong></p>
<p>主线程，只是个普通的非守护线程，用来启动应用程序，不能设置成守护线程；除此之外，它跟其他非守护线程没有什么不同。主线程执行结束，其他线程一样可以正常执行。</p>
<p>这样其实是很合理的，按照操作系统的理论，进程是资源分配的基本单位，线程是CPU调度的基本单位。对于CPU来说，其实并不存在java的主线程和子线程之分，都只是个普通的线程。进程的资源是线程共享的，只要进程还在，线程就可以正常执行，换句话说线程是强依赖于进程的。也就是说：</p>
<blockquote>
<p>线程其实并不存在互相依赖的关系，一个线程的死亡从理论上来说，不会对其他线程有什么影响。</p>
</blockquote>
<p><strong>3. Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程</strong></p>
<p>Java虚拟机（相当于进程）退出的时机是：虚拟机中所有存活的线程都是守护线程。只要还有存活的非守护线程虚拟机就不会退出，而是等待非守护线程执行完毕；反之，如果虚拟机中的线程都是守护线程，那么不管这些线程的死活java虚拟机都会退出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">数据结构 -- 查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 19:57:11" itemprop="dateCreated datePublished" datetime="2020-05-31T19:57:11+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><img src="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/2062729-6175e9c6b5ecbb36.png" class="" title="[查找算法]">

<h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h4><p>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int SequenceSearch(int a[], int value, int n) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        if(a[i] &#x3D;&#x3D; value) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2. 折半查找"></a>2. 折半查找</h4><p>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int BinarySearch1(int a[], int value, int n) &#123;</span><br><span class="line">    int low, high, mid;</span><br><span class="line">    low &#x3D; 0;</span><br><span class="line">    high &#x3D; n - 1;</span><br><span class="line">    while (low &lt;&#x3D; high) &#123;</span><br><span class="line">        mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">        if (a[mid] &#x3D;&#x3D; value)</span><br><span class="line">            return mid;</span><br><span class="line">        if (a[mid] &gt; value)</span><br><span class="line">            high &#x3D; mid - 1;</span><br><span class="line">        if (a[mid] &lt; value)</span><br><span class="line">            low &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见查找算法题"><a href="#常见查找算法题" class="headerlink" title="常见查找算法题"></a>常见查找算法题</h4><h5 id="1-找出一个无序整型数组中第k大的数"><a href="#1-找出一个无序整型数组中第k大的数" class="headerlink" title="1. 找出一个无序整型数组中第k大的数"></a>1. 找出一个无序整型数组中第k大的数</h5><p>变种： 找出无序数组中第二大的数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">取基准元素，将元素分为两个集合，一个集合元素比基准小，另一个比基准大 ，三种情况。</span><br><span class="line">1.比基准大的元素数目标志位m正好为k-1，基准就是目的元素。</span><br><span class="line">2.比基准大的元素标志位m小于k, 那么就在比基准小的集合里面找第(k-m)大的元素</span><br><span class="line">3.若是比基准大的元素为m大于k，那就继续在该集合里面找第k大的元素。</span><br><span class="line">如下是代码：</span><br><span class="line"></span><br><span class="line">static void findKMax(int[] arr, int left, int right, int k) &#123;</span><br><span class="line">    int temp &#x3D; partition(arr, left, right);</span><br><span class="line">    if (temp &#x3D;&#x3D; k - 1) &#123;</span><br><span class="line">        System.out.println(arr[temp]);</span><br><span class="line">    &#125; else if (temp &gt; k - 1) &#123;</span><br><span class="line">        findKMax(arr, left, temp - 1, k);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        findKMax(arr, temp + 1, right, k - temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">    int temp &#x3D; arr[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (temp &gt;&#x3D; arr[right] &amp;&amp; left &lt; right)</span><br><span class="line">            --right;</span><br><span class="line">           arr[left] &#x3D; arr[right];</span><br><span class="line">        while (temp &lt;&#x3D; arr[left] &amp;&amp; left &lt; right)</span><br><span class="line">            ++left;</span><br><span class="line">        arr[right] &#x3D; arr[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[right] &#x3D; temp;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr &#x3D; new int[] &#123; 12, 23, 2, 3, 2, 432, 43, 534, 5, 345, 3453, 53, 43 &#125;;</span><br><span class="line">    findKMax(arr,0,arr.length - 1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-无序数组中，和为sum的2个数-用HashMap、不用HashMap"><a href="#2-无序数组中，和为sum的2个数-用HashMap、不用HashMap" class="headerlink" title="2. 无序数组中，和为sum的2个数(用HashMap、不用HashMap)"></a>2. 无序数组中，和为sum的2个数(用HashMap、不用HashMap)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-数组中位数"><a href="#3-数组中位数" class="headerlink" title="3. 数组中位数"></a>3. 数组中位数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E4%B8%B2/" class="post-title-link" itemprop="url">数据结构 -- 串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:36:38 / 修改时间：21:07:48" itemprop="dateCreated datePublished" datetime="2020-05-31T19:36:38+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a>Java String</h4><blockquote>
<p>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;abc&quot;) ;</span><br><span class="line">System.out.println(str&#x3D;&#x3D;&quot;abc&quot;);</span><br></pre></td></tr></table></figure>
<p>=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。<br>输出为false!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class String_Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        String str1 &#x3D; new String() ;</span><br><span class="line">        String str2 &#x3D; null ;</span><br><span class="line">        String str3 &#x3D; &quot;&quot; ;</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str2);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str2));         &#x2F;&#x2F;值的比较，返回false</span><br><span class="line">        System.out.println(str2&#x3D;&#x3D;str3);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str3.equals(str2));         &#x2F;&#x2F;值的比较，返回false</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str3);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str3));         &#x2F;&#x2F;值的比较，返回true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h4><h5 id="1-朴素的模式匹配算法（BF-Brute-Force-算法）"><a href="#1-朴素的模式匹配算法（BF-Brute-Force-算法）" class="headerlink" title="1. 朴素的模式匹配算法（BF(Brute Force)算法）"></a>1. 朴素的模式匹配算法（BF(Brute Force)算法）</h5><p>朴素模式匹配算法的基本思想是穷举法，即就是将目标串S的第一个字符与模式串P的第一个字符进行匹配，若相等，则继续比较S的第二个字符和P的第二个字符；若不相等，则比较S的第二个字符和P的第一个字符，依次比较下去，直到得出最后的匹配结果（如图1所示）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int bf(String T, String P) &#123;</span><br><span class="line">    int i &#x3D; 0; &#x2F;&#x2F;目标串的下标</span><br><span class="line">    int j &#x3D; 0; &#x2F;&#x2F;模式串的下标</span><br><span class="line">    int tLen &#x3D; T.length();</span><br><span class="line">    int pLen &#x3D; P.length();</span><br><span class="line">    if (tLen &lt; pLen) return -1;&#x2F;&#x2F;长度不够直接返回</span><br><span class="line">    while(i &lt; tLen &amp; j &lt; pLen) &#123;&#x2F;&#x2F;逐个匹配</span><br><span class="line">        if(T.charAt(i) &#x3D;&#x3D; P.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i &#x3D; i-j+1;</span><br><span class="line">            j &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j &#x3D;&#x3D; pLen) &#123;</span><br><span class="line">        return i-j+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-KMP模式匹配算法"><a href="#2-KMP模式匹配算法" class="headerlink" title="2. KMP模式匹配算法"></a>2. KMP模式匹配算法</h5><p>首先是next数组的计算，下图是next数组计算公式<br><img src="https://upload-images.jianshu.io/upload_images/12455188-11a97f211ace9892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/573/format/webp" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static int[] getNext(String ps) &#123;</span><br><span class="line">    char[] p &#x3D; ps.toCharArray();</span><br><span class="line">    int[] next &#x3D; new int[p.length];</span><br><span class="line">    next[0] &#x3D; -1;</span><br><span class="line">    int j &#x3D; 0;</span><br><span class="line">    int k &#x3D; -1;</span><br><span class="line">    while (j &lt; p.length - 1) &#123;</span><br><span class="line">       if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;</span><br><span class="line">           if (p[++j] &#x3D;&#x3D; p[++k]) &#123; &#x2F;&#x2F; 当两个字符相等时要跳过</span><br><span class="line">              next[j] &#x3D; next[k];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">              next[j] &#x3D; k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           k &#x3D; next[k];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int KMP(String ts, String ps) &#123;</span><br><span class="line">    char[] t &#x3D; ts.toCharArray();</span><br><span class="line">    char[] p &#x3D; ps.toCharArray();</span><br><span class="line">    int i &#x3D; 0; &#x2F;&#x2F; 主串的位置</span><br><span class="line">    int j &#x3D; 0; &#x2F;&#x2F; 模式串的位置</span><br><span class="line">    int[] next &#x3D; getNext(ps);</span><br><span class="line">    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line">       if (j &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; p[j]) &#123; &#x2F;&#x2F; 当j为-1时，要移动的是i，当然j也要归0</span><br><span class="line">           i++;</span><br><span class="line">           j++;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; i不需要回溯了</span><br><span class="line">           &#x2F;&#x2F; i &#x3D; i - j + 1;</span><br><span class="line">           j &#x3D; next[j]; &#x2F;&#x2F; j回到指定位置</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &#x3D;&#x3D; p.length) &#123;</span><br><span class="line">       return i - j;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">数据结构 -- 红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:36:37 / 修改时间：19:56:56" itemprop="dateCreated datePublished" datetime="2020-05-31T19:36:37+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="R-B-Tree简介"><a href="#R-B-Tree简介" class="headerlink" title="R-B Tree简介"></a>R-B Tree简介</h4><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。</p>
<p>红黑树的特性:</p>
<ul>
<li>（1）每个节点或者是黑色，或者是红色。</li>
<li>（2）根节点是黑色。</li>
<li>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>注意：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p><img src="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" alt=""></p>
<h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p>
<ul>
<li>从根结点开始查找，把根结点设置为当前结点；</li>
<li>若当前结点为空，返回null；</li>
<li>若当前结点不为空，用当前结点的key跟查找key作比较；</li>
<li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li>
<li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2392382-07b47eb3722981e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p>
<h4 id="红黑树的基本操作-一-左旋和右旋"><a href="#红黑树的基本操作-一-左旋和右旋" class="headerlink" title="红黑树的基本操作(一) 左旋和右旋"></a>红黑树的基本操作(一) 左旋和右旋</h4><h5 id="1-左旋"><a href="#1-左旋" class="headerlink" title="1. 左旋"></a>1. 左旋</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251733282013849.jpg" alt="左旋"></p>
<h5 id="2-右旋"><a href="#2-右旋" class="headerlink" title="2. 右旋"></a>2. 右旋</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg" alt="左旋"></p>
<h4 id="红黑树的基本操作-二-添加"><a href="#红黑树的基本操作-二-添加" class="headerlink" title="红黑树的基本操作(二) 添加"></a>红黑树的基本操作(二) 添加</h4><table>
<thead>
<tr>
<th></th>
<th>现象说明</th>
<th align="center">处理策略</th>
</tr>
</thead>
<tbody><tr>
<td>Case 1</td>
<td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td>
<td align="center">(01) 将“父节点”设为黑色。  <br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</td>
</tr>
<tr>
<td>Case 2</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td>
<td align="center">(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</td>
</tr>
<tr>
<td>Case 3</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td>
<td align="center">(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</td>
</tr>
</tbody></table>
<h5 id="Case-1-叔叔是红色"><a href="#Case-1-叔叔是红色" class="headerlink" title="(Case 1) 叔叔是红色"></a>(Case 1) 叔叔是红色</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" alt="(Case 1)叔叔是红色"></p>
<h5 id="Case-2-叔叔是黑色，且当前节点是右孩子"><a href="#Case-2-叔叔是黑色，且当前节点是右孩子" class="headerlink" title="(Case 2)叔叔是黑色，且当前节点是右孩子"></a>(Case 2)叔叔是黑色，且当前节点是右孩子</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" alt=""></p>
<h5 id="Case-3-叔叔是黑色，且当前节点是左孩子"><a href="#Case-3-叔叔是黑色，且当前节点是左孩子" class="headerlink" title="(Case 3)叔叔是黑色，且当前节点是左孩子"></a>(Case 3)叔叔是黑色，且当前节点是左孩子</h5><p><img src="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构 -- 排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 19:01:45" itemprop="dateCreated datePublished" datetime="2020-05-31T19:01:45+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><img src="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2062729-6906429ed882a5b0.png" class="" title="[线程池的主要工作流程]">

<h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h4><p>冒泡排序算法的基本流程是：每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。 （稳定排序算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] num) &#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; num.length - 1; i++)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; num.length - i; j++) &#123;</span><br><span class="line">            if (num[j] &gt; num[j+1]) &#123;</span><br><span class="line">                swap(num, j, j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h4><p>选择排序是将一轮比较完后，把最小的放到最前的位置（或者把最大的放到最后） （不稳定排序算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] num) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; num.length; i++) &#123;</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; num.length - i; j++) &#123;</span><br><span class="line">                if (num[max] &lt; num[j]) max &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num, max, num.length - i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h4><p>插入排序的实现步骤为：从第一个元素开始，该元素可以认为已经被排序 -&gt; 取出下一个元素，在已经排序的元素序列中从后向前扫描 -&gt; 如果该元素小于前一个元素，则将两者调换，再与前一个元素比较–&gt; 重复第三步，直到找到已排序的元素小于或者等于新元素的位置 -&gt; 将新元素插入到该位置中 -&gt; 重复第二步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] num) &#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; num.length; i++) &#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        int temp &#x3D; num[i];</span><br><span class="line">        while(num[j - 1] &gt; temp &amp;&amp; j &gt; 0) j--;</span><br><span class="line">        for (int m &#x3D; i; m &gt; j; m--) &#123;</span><br><span class="line">            num[m] &#x3D; num[m-1];</span><br><span class="line">        &#125;</span><br><span class="line">        num[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h4><p>希尔排序的中心思想是将数据进行分组，然后对每一组数据进行插入排序，在每一组数据都有序后，再对所有的分组利用插入排序进行最后一次排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] num) &#123;</span><br><span class="line">    int h &#x3D; num.length &#x2F; 2;</span><br><span class="line">    while (h &gt;&#x3D; 1) &#123;</span><br><span class="line">        for (int i &#x3D; h; i &lt; num.length; i++) &#123;</span><br><span class="line">            int temp &#x3D; num[i];</span><br><span class="line">            int j &#x3D; i;</span><br><span class="line">            while ((j - h) &gt; 0 &amp;&amp; num[j - h] &gt; temp) &#123;</span><br><span class="line">                num[j] &#x3D; num[j-h];</span><br><span class="line">                j &#x3D; j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            num[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        h &#x3D; h &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-快速排序-（重点）"><a href="#5-快速排序-（重点）" class="headerlink" title="5. 快速排序  （重点）"></a>5. 快速排序  （重点）</h4><p>快速排序本质上通过一个数组划分为两个子数组，然后递归地调用自身为每一个子数组进行快速排序来实现的，即算法分为三步：</p>
<ul>
<li>1 把数组或者子数组划分为左边（较小的关键字）的一组和右边（较大的关键字）的一组；</li>
<li>2 调用自身对左边的一组进行排序；</li>
<li>3 调用自身对右边的一组进行排序。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void quickSort(int[] num, int left, int right) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int position &#x3D; paration(num, left, right);</span><br><span class="line">        System.out.println(&quot;position:&quot; + position);</span><br><span class="line">        quickSort(num, left, position - 1);</span><br><span class="line">        quickSort(num, position + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int paration(int[] num, int left, int right) &#123;</span><br><span class="line">    int temp &#x3D; num[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (num[right] &gt;&#x3D; temp &amp;&amp; right &gt; left) right--;</span><br><span class="line">        num[left] &#x3D; num[right];</span><br><span class="line">        while (num[left] &lt;&#x3D; temp &amp;&amp; left &lt; right) left++;</span><br><span class="line">        num[right] &#x3D; num[left];</span><br><span class="line">    &#125;</span><br><span class="line">    num[left] &#x3D; temp;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<a href="https://www.cnblogs.com/l199616j/p/10597245.html" target="_blank" rel="noopener">八大排序算法——快速排序</a></p>
<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h4><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void heapSort(int[] num) &#123;</span><br><span class="line">    int length &#x3D; num.length;</span><br><span class="line">    for (int i &#x3D; num.length &#x2F; 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        buildHeap(num, i, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; num.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(num, 0, i);</span><br><span class="line">        length--;</span><br><span class="line">        buildHeap(num, 0, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void buildHeap(int[] num, int i, int length) &#123;</span><br><span class="line">    int left &#x3D; 2 * i + 1;</span><br><span class="line">    int right &#x3D; 2 * i + 2;</span><br><span class="line">    int target &#x3D; i;</span><br><span class="line">    if (left &lt; length &amp;&amp; num[left] &gt; num[i]) target &#x3D; left;</span><br><span class="line">    if (right &lt; length &amp;&amp; num[right] &gt; num[target]) target &#x3D; right;</span><br><span class="line">    if (target !&#x3D; i) &#123;</span><br><span class="line">        swap(num, i, target);</span><br><span class="line">        buildHeap(num, target, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] num, int i, int j) &#123;</span><br><span class="line">    int temp &#x3D; num[i];</span><br><span class="line">    num[i] &#x3D; num[j];</span><br><span class="line">    num[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h4><p>归并排序的思想是把一个数组分成两半，排序每一半。然后用 merge 方法将数组的两半归并成一个有序的数组。被分的每一半使用递归，再次划分排序，直到得到的子数组只含有一个数据项为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static void mergeSort(int[] num, int low, int high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        int mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">        mergeSort(num, low, mid);</span><br><span class="line">        mergeSort(num, mid + 1, high);</span><br><span class="line">        merge(num, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] num, int low, int mid, int high) &#123;</span><br><span class="line">    int[] temp &#x3D; new int[num.length];</span><br><span class="line">    int t &#x3D; 0;</span><br><span class="line">    int i &#x3D; low;</span><br><span class="line">    int j &#x3D; mid;</span><br><span class="line">    while (i &lt; mid &amp;&amp; j &lt;&#x3D; high) &#123;</span><br><span class="line">        if (num[i] &lt; num[j]) &#123;</span><br><span class="line">            temp[t++] &#x3D; num[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[t++] &#x3D; num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i &lt; mid) &#123;</span><br><span class="line">        temp[t++] &#x3D; num[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (j &lt;&#x3D; high) &#123;</span><br><span class="line">        temp[t++] &#x3D; num[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m &#x3D; 0;</span><br><span class="line">    for (t &#x3D; low; t &lt; high; t++) &#123;</span><br><span class="line">        num[t] &#x3D; temp[m++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-二叉排序树"><a href="#8-二叉排序树" class="headerlink" title="8. 二叉排序树"></a>8. 二叉排序树</h4><p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），也称二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>（1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</li>
<li>（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>（3）左、右子树也分别为二叉排序树；<br>二叉排序树删除：<br>二叉排序树的删除分为三种情况讨论：</li>
<li>①当删除结点仅有左子树时，只需将此结点的左孩子替换它自己，就相当于删除了该结点。</li>
<li>②当删除结点仅有右子树时，只需将此结点的右孩子替换它自己即可。</li>
<li>③当删除结点左右子树都不为空时，可以在左子树中找到小于但最接近该值的结点替换它，即找到中序遍历中的前驱；也可以在右子树中找到大于但最接近该值的结点替换，即中序遍历中的后驱。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public class BiNode &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public BiNode left &#x3D; null;</span><br><span class="line">    public BiNode right &#x3D; null;</span><br><span class="line">    public BiNode(int t) &#123;</span><br><span class="line">        value &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中序遍历</span><br><span class="line">public void InOrderTraverse(BiNode node) &#123;</span><br><span class="line">    if (node &#x3D;&#x3D; null) return;</span><br><span class="line">    InOrderTraverse(node.left);</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    InOrderTraverse(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉排序树查找</span><br><span class="line">public BiNode searchBST(BiNode node, int key) &#123;</span><br><span class="line">    if (node &#x3D;&#x3D; null) return null;</span><br><span class="line">    if (node.value &#x3D;&#x3D; key) return node;</span><br><span class="line">    if (key &lt; node.value) &#123;</span><br><span class="line">        searchBST(node.left, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        searchBST(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉排序树查找</span><br><span class="line">public BiNode searchBST(BiNode node, int key) &#123;</span><br><span class="line">    if (node &#x3D;&#x3D; null) return null;</span><br><span class="line">    BiNode root &#x3D; node;</span><br><span class="line">    while (root !&#x3D; null) &#123;</span><br><span class="line">        if (root.value &#x3D;&#x3D; key) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if (key &lt; root.value) root &#x3D; root.left;</span><br><span class="line">        if (key &gt; root.value) root &#x3D; root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉排序树插入</span><br><span class="line">public void insertBST(BiNode root, int key) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">        root &#x3D; new BiNode(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key &lt; root.value) &#123;</span><br><span class="line">        if (root.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root.left &#x3D; new BiNode(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            insertBST(root.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root.right &#x3D; new BiNode(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            insertBST(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉树删除</span><br><span class="line">public BiNode deleteBST(BiNode root, int value) &#123;</span><br><span class="line">    BiNode cur &#x3D; root;        &#x2F;&#x2F;当前结点</span><br><span class="line">    BiNode parent &#x3D; null;     &#x2F;&#x2F;待删结点的父结点</span><br><span class="line">    BiNode delNode &#x3D; null;    &#x2F;&#x2F;在后面用来引用待删结点</span><br><span class="line">    BiNode temp &#x3D; null;       &#x2F;&#x2F;作为一个局域内的根结点</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找待删结点p和待删结点的父结点f</span><br><span class="line">    while (cur !&#x3D; null) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; cur.value) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        parent &#x3D; cur;</span><br><span class="line">        if (value &gt; cur.value) &#123;</span><br><span class="line">            cur &#x3D; cur.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cur &#x3D; cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前结点为null，即没有找到待删结点。  此时cur指向待删结点</span><br><span class="line">    if (cur &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;待删结点只有右子树</span><br><span class="line">    if (cur.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;待删结点的父结点为null，即待删结点为根结点</span><br><span class="line">        if (parent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;根结点为待删结点的右子树</span><br><span class="line">            root &#x3D; cur.right;</span><br><span class="line">        &#125; else if (parent.left &#x3D;&#x3D; cur) &#123;    &#x2F;&#x2F;待删结点为父结点的左子树</span><br><span class="line">            &#x2F;&#x2F;把待删结点的右子树作为待删结点父结点的左子树</span><br><span class="line">            parent.left &#x3D; cur.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;待删结点为父结点的右子树</span><br><span class="line">            parent.right &#x3D; cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;待删结点有左子树，要找左子树的最右下角的结点</span><br><span class="line">        temp &#x3D; cur;</span><br><span class="line">        delNode &#x3D; cur.left;</span><br><span class="line">        &#x2F;&#x2F;此时s指向待删结点</span><br><span class="line">        while (delNode.right !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;查找待删结点的最右下角结点</span><br><span class="line">            temp &#x3D; delNode;</span><br><span class="line">            delNode &#x3D; delNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp &#x3D;&#x3D; cur) &#123;</span><br><span class="line">            &#x2F;&#x2F;即，待删结点没有右子树，把左子树向上移动</span><br><span class="line">            temp.left &#x3D; delNode.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;即，待删结点有右子树</span><br><span class="line">            temp.right&#x3D; delNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.value &#x3D; delNode.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E4%BB%BFButterKnife%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E4%BB%BFButterKnife%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">仿ButterKnife注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 18:53:43 / 修改时间：18:54:00" itemprop="dateCreated datePublished" datetime="2020-05-31T18:53:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、Java-注解介绍"><a href="#一、Java-注解介绍" class="headerlink" title="一、Java 注解介绍"></a>一、Java 注解介绍</h4><p>ButterKnife插件让我们从繁琐的findViewById函数中解脱出来。深入过其原理的同学都知道，使用了Java的高级技术Annotation。一般来说Java的注解有三种方式：</p>
<ul>
<li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 </li>
<li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中，使用的是Java Annotation Processing 用于编译时扫描和解析Java注解的工具。 </li>
<li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，实用的是反射机制可以在程序运行时可以获取到它们。</li>
</ul>
<h4 id="二、自定义Java-注解"><a href="#二、自定义Java-注解" class="headerlink" title="二、自定义Java 注解"></a>二、自定义Java 注解</h4><p>接下来开始仿照ButterKnife定义自己我们自己的BindView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @Retention 用于声明注解生效的生命周期, 有三个枚举值可以选择</span><br><span class="line"> * 1.RetentionPolicy.SOURCE 注解只保留在源码上，编译成class时自动被编译器抹去</span><br><span class="line"> * 2.RetentionPolicy.CLASS 注解只保留在字节码上，vm加载字节码时自动抹去</span><br><span class="line"> * 3.RetentionPolicy.RUNTIME 注解永久保留，可以被vm加载到内存</span><br><span class="line"> * 由于我们想在运行时对Filed上的注解进行反射操作，因此Retention值必须设为RUNTIME</span><br><span class="line"> *</span><br><span class="line"> * @target 用于指定注解可以声明在哪些成员上面，我们设置的值有Filed和Method</span><br><span class="line"> * 由于我们当前注解类是要声明在Filed上，因此我们设置为ElementType.FILED</span><br><span class="line"> *</span><br><span class="line"> * @interface 是声明注解类组合关键字</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Target(ElementType.FIELD) </span><br><span class="line">@Retention(RetentionPolicy.CLASS) </span><br><span class="line">public @interface BindView &#123; </span><br><span class="line">    int value() default -1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在实际的使用过程中就可以这样子来写了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@BindView(R.id.btn) </span><br><span class="line">protected Button mBtn;</span><br></pre></td></tr></table></figure>

<h6 id="2-1-编译时注解"><a href="#2-1-编译时注解" class="headerlink" title="2.1 编译时注解"></a>2.1 编译时注解</h6><p>在编译时候如果想要获取注解就只能通过继承于AbstractProcessor的方式了。<br>如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public class MyAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line">    &#x2F;&#x2F; 主要用于生产文件</span><br><span class="line">    private Filer mFiler;</span><br><span class="line">    &#x2F;&#x2F; 主要是日志打印</span><br><span class="line">    private Messager mMessager;</span><br><span class="line">    &#x2F;&#x2F; 获取注解元素</span><br><span class="line">    private Elements mElementUtils;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnvironment) &#123;</span><br><span class="line">        super.init(processingEnvironment);</span><br><span class="line">        &#x2F;&#x2F; 初始化 </span><br><span class="line">        mFiler &#x3D; processingEnvironment.getFiler();</span><br><span class="line">        mMessager &#x3D; processingEnvironment.getMessager();</span><br><span class="line">        mElementUtils &#x3D; processingEnvironment.getElementUtils();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        Set&lt;String&gt; annotations &#x3D; new LinkedHashSet&lt;&gt;();</span><br><span class="line">        annotations.add(BindView.class.getCanonicalName());</span><br><span class="line">        return annotations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; set, </span><br><span class="line">                           RoundEnvironment roundEnvironment) &#123;</span><br><span class="line">        Set&lt;? extends Element&gt; bindViewElements &#x3D; roundEnvironment</span><br><span class="line">                                        .getElementsAnnotatedWith(BindView.class);</span><br><span class="line">        for (Element element : bindViewElements) &#123;</span><br><span class="line">            &#x2F;&#x2F;1.获取包名</span><br><span class="line">            PackageElement packageElement &#x3D; mElementUtils.getPackageOf(element);</span><br><span class="line">            String pkName &#x3D; packageElement.getQualifiedName().toString();</span><br><span class="line">            note(String.format(&quot;package &#x3D; %s&quot;, pkName));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;2.获取包装类类型</span><br><span class="line">            TypeElement enclosingElement &#x3D; (TypeElement) element</span><br><span class="line">                                            .getEnclosingElement();</span><br><span class="line">            String enclosingName &#x3D; enclosingElement.getQualifiedName().toString();</span><br><span class="line">            note(String.format(&quot;enclosindClass &#x3D; %s&quot;, enclosingElement));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;因为BindView只作用于filed，所以这里可直接进行强转</span><br><span class="line">            VariableElement bindViewElement &#x3D; (VariableElement) element;</span><br><span class="line">            &#x2F;&#x2F;3.获取注解的成员变量名</span><br><span class="line">            String bindViewFiledName &#x3D; bindViewElement.getSimpleName().toString();</span><br><span class="line">            &#x2F;&#x2F;3.获取注解的成员变量类型</span><br><span class="line">            String bindViewFiledClassType &#x3D; bindViewElement.asType().toString();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;4.获取注解元数据</span><br><span class="line">            BindView bindView &#x3D; element.getAnnotation(BindView.class);</span><br><span class="line">            int id &#x3D; bindView.value();</span><br><span class="line">            note(String.format(&quot;%s %s &#x3D; %d&quot;, bindViewFiledClassType</span><br><span class="line">                               , bindViewFiledName, id));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;4.生成文件</span><br><span class="line">            createFile(enclosingElement, bindViewFiledClassType</span><br><span class="line">                       , bindViewFiledName, id);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void createFile(TypeElement enclosingElement</span><br><span class="line">        , String bindViewFiledClassType, String bindViewFiledName, int id) &#123;</span><br><span class="line">        String pkName &#x3D; mElementUtils.getPackageOf(enclosingElement)</span><br><span class="line">                        .getQualifiedName().toString();</span><br><span class="line">        try &#123;</span><br><span class="line">            JavaFileObject jfo &#x3D; mFiler.createSourceFile(pkName + &quot;.ViewBinding&quot;</span><br><span class="line">                                 , new Element[]&#123;&#125;);</span><br><span class="line">            Writer writer &#x3D; jfo.openWriter();</span><br><span class="line">            writer.write(brewCode(pkName, bindViewFiledClassType</span><br><span class="line">                                  , bindViewFiledName, id));</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String brewCode(String pkName, String bindViewFiledClassType, </span><br><span class="line">                            String bindViewFiledName, int id) &#123;</span><br><span class="line">        StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">        builder.append(&quot;package &quot; + pkName + &quot;;\n\n&quot;);</span><br><span class="line">        builder.append(&quot;&#x2F;&#x2F;Auto generated by apt,do not modify!!\n\n&quot;);</span><br><span class="line">        builder.append(&quot;public class ViewBinding &#123; \n\n&quot;);</span><br><span class="line">        builder.append(&quot;public static void main(String[] args)&#123; \n&quot;);</span><br><span class="line">        String info &#x3D; String.format(&quot;%s %s &#x3D; %d&quot;, bindViewFiledClassType</span><br><span class="line">                                     , bindViewFiledName, id);</span><br><span class="line">        builder.append(&quot;System.out.println(\&quot;&quot; + info + &quot;\&quot;);\n&quot;);</span><br><span class="line">        builder.append(&quot;&#125;\n&quot;);</span><br><span class="line">        builder.append(&quot;&#125;&quot;);</span><br><span class="line">        return builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void note(String msg) &#123;</span><br><span class="line">        mMessager.printMessage(Diagnostic.Kind.NOTE, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void note(String format, Object... args) &#123;</span><br><span class="line">        mMessager.printMessage(Diagnostic.Kind.NOTE, String.format(format, args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK,这样子就可以在编译的时候获取到注解的所有信息了，有了这些信息，想干啥都可以了。</p>
<p>参考博客:<br><a href="https://www.jianshu.com/p/d7567258ae85" target="_blank" rel="noopener">注解处理器（Annotation Processor）简析</a></p>
<h6 id="2-2-运行时注解"><a href="#2-2-运行时注解" class="headerlink" title="2.2 运行时注解"></a>2.2 运行时注解</h6><p>运行时注解关键技术就是反射了。<br>定义ViewBind 注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface ViewBind  &#123;</span><br><span class="line">    &#x2F;&#x2F;value是所有注解类的默认属性名</span><br><span class="line">    int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义Click 注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Click &#123;</span><br><span class="line">    &#x2F;&#x2F;int[]数组用于绑定多个id</span><br><span class="line">    int[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时反射处理注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void bind(final Activity activity)&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过字节码获取activity中所有字段，并且使用getDeclaredFields方法</span><br><span class="line">     * 因为这样才能获取到任何权限修饰的Field。包括private</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Field[] declaredFileds &#x3D; activity.getClass().getDeclaredFields();</span><br><span class="line">    for (int i&#x3D;0;i&lt;declaredFileds.length;i++)&#123;</span><br><span class="line">        Field field &#x3D; declaredFileds[i];</span><br><span class="line">        &#x2F;&#x2F;设置为可访问，即使为私有，暴力反射</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        &#x2F;&#x2F;获取字段上的注解对象</span><br><span class="line">        ViewBind annotation &#x3D; field.getAnnotation(ViewBind.class);</span><br><span class="line">        if (annotation!&#x3D;null)&#123;</span><br><span class="line">            int id &#x3D; annotation.value();</span><br><span class="line">            &#x2F;&#x2F;获取控件</span><br><span class="line">            View view &#x3D; activity.findViewById(id);</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;参数1为当前Field所属的对象</span><br><span class="line">                &#x2F;&#x2F;参数2为要给Field设置的值</span><br><span class="line">                field.set(activity,view);</span><br><span class="line">            &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method[] declaredMehtod &#x3D; activity.getClass().getDeclaredMethods();</span><br><span class="line">    for (int i&#x3D;0;i&lt;declaredMehtod.length;i++)&#123;</span><br><span class="line">        final Method method &#x3D; declaredMehtod[i];</span><br><span class="line">        method.setAccessible(true);</span><br><span class="line">        &#x2F;&#x2F;获取方法上的注解</span><br><span class="line">        Click annotation &#x3D; method.getAnnotation(HunterKnife.Click.class);</span><br><span class="line">        &#x2F;&#x2F;如果没有循环下一个</span><br><span class="line">        if (annotation &#x3D;&#x3D; null)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取注解中的数据</span><br><span class="line">        int[] ids &#x3D; annotation.value();</span><br><span class="line">        for (int j&#x3D;0;j&lt;ids.length;j++)&#123;</span><br><span class="line">            final View button &#x3D; activity.findViewById(ids[i]);</span><br><span class="line">            button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(View v) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        method.invoke(activity,button);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Android%E6%8F%92%E4%BB%B6%E5%8C%96&%E7%83%AD%E4%BF%AE%E5%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Android%E6%8F%92%E4%BB%B6%E5%8C%96&%E7%83%AD%E4%BF%AE%E5%A4%8D/" class="post-title-link" itemprop="url">Android插件化&热修复</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 14:15:10 / 修改时间：14:39:47" itemprop="dateCreated datePublished" datetime="2020-05-31T14:15:10+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Android插件化-amp-热修复"><a href="#Android插件化-amp-热修复" class="headerlink" title="Android插件化&amp;热修复"></a>Android插件化&amp;热修复</h4><h5 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h5><p>每个类有自己的类加载器，用户也可以自己定义自己的类加载器，同一个类文件被不同加载器加载时，他们就不是同一个类了，使用isInstance()等将会得到False。验证多个类是同一个类的成立条件：</p>
<ul>
<li>相同的ClassName</li>
<li>相同的PackageName</li>
<li>被相同的ClassLoader加载</li>
</ul>
<p>Java类加载机制相关见：<a href="">Java类加载机制</a>。</p>
<h4 id="Android类加载器"><a href="#Android类加载器" class="headerlink" title="Android类加载器"></a>Android类加载器</h4><p><img src="img/Android_ClassLoader_UML.png" alt=""></p>
<h5 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    static private class SystemClassLoader &#123;</span><br><span class="line">        public static ClassLoader loader &#x3D; ClassLoader.createSystemClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    private static ClassLoader createSystemClassLoader() &#123;</span><br><span class="line">        String classPath &#x3D; System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;);</span><br><span class="line">        String librarySearchPath &#x3D; System.getProperty(&quot;java.library.path&quot;, &quot;&quot;);</span><br><span class="line">        return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Void checkCreateClassLoader() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ClassLoader(Void unused, ClassLoader parent) &#123;</span><br><span class="line">        this.parent &#x3D; parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected ClassLoader(ClassLoader parent) &#123;</span><br><span class="line">        this(checkCreateClassLoader(), parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected ClassLoader() &#123;</span><br><span class="line">        this(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">        return SystemClassLoader.loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getSystemClassLoader() 得到的是一个 PathClassLoader，它的父类加载器是一个 BootClassLoader。也就是说，系统默认的类加载器是 PathClassLoader。</p>
<h5 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BaseDexClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">            String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        this(dexPath, optimizedDirectory, librarySearchPath, parent, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseDexClassLoader(String dexPath, File optimizedDirectory,</span><br><span class="line">            String librarySearchPath, ClassLoader parent, boolean isTrusted) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        this.pathList &#x3D; new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);</span><br><span class="line">        if (reporter !&#x3D; null) &#123;</span><br><span class="line">            reportClassLoaderChain();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dexPath：包含类或者资源的.jar/.apk路径，如果是多个路径，则用 File.pathSeparator(默认是:) 来分隔。当然也可以直接传 dex 的路径。</li>
<li>optimizedDirectory：在 API 26(Android 8.0)的版本中，它表示 odex(optimized dex) 读写存放目录，如果传 null 则表示使用系统默认的目录来存储。自 Android 8.0 起，这个参数已经被弃用，不再生效，使用系统默认的目录。</li>
<li>librarySearchPath：native 库文件存放目录，多个库文件则用 File.pathSeparator(默认是:) 分隔。</li>
<li>parent: 父类加载器</li>
<li>isTrusted: 当前加载的dex是否受信任，如果受信任则可以访问平台隐藏的API，默认为 false</li>
</ul>
<p>BaseDexClassLoader 中有一个 DexPathList 类的 pathList 成员变量，它表示 dexPath 下的 .dex 列表。</p>
<h5 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PathClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public PathClassLoader(String dexPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, null, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PathClassLoader 构造函数很简单，直接调用父类 BaseDexClassLoader 的构造函数。第二个构造参数始终是 null，表示 optimizedDirectory 始终为 null。</p>
<h5 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DexClassLoader extends BaseDexClassLoader &#123;</span><br><span class="line">    public DexClassLoader(String dexPath, String optimizedDirectory,</span><br><span class="line">            String librarySearchPath, ClassLoader parent) &#123;</span><br><span class="line">        super(dexPath, null, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DexClassLoader 跟 PathClassLoader 相似。和前面一样，第二个参数 optimizedDirectory 也从 Android 8.0 开始弃用，不再有效。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>BaseDexClassLoader 类（PathClassLoader 和 DexClassLoader）在初始化过程中，会找到其相关的 .dex 列表进行初始化。</li>
<li>系统默认的类加载器就是 PathClassLoader</li>
</ul>
<h5 id="DexPathList"><a href="#DexPathList" class="headerlink" title="DexPathList"></a>DexPathList</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@hide</span><br><span class="line">public final class DexPathList &#123;</span><br><span class="line">    private static final String DEX_SUFFIX &#x3D; &quot;.dex&quot;;</span><br><span class="line">    private static final String zipSeparator &#x3D; &quot;!&#x2F;&quot;;</span><br><span class="line"></span><br><span class="line">    private Element[] dexElements;</span><br><span class="line">    NativeLibraryElement[] nativeLibraryPathElements;</span><br><span class="line"></span><br><span class="line">    public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String librarySearchPath, File optimizedDirectory) &#123;</span><br><span class="line">        this(definingContext, dexPath, librarySearchPath, optimizedDirectory, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">            String librarySearchPath, File optimizedDirectory, boolean isTrusted) &#123;</span><br><span class="line">        this.dexElements &#x3D; makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                           suppressedExceptions, definingContext, isTrusted);</span><br><span class="line"></span><br><span class="line">        this.nativeLibraryDirectories &#x3D; splitPaths(librarySearchPath, false);</span><br><span class="line">        this.systemNativeLibraryDirectories &#x3D;</span><br><span class="line">                splitPaths(System.getProperty(&quot;java.library.path&quot;), true);</span><br><span class="line">        List&lt;File&gt; allNativeLibraryDirectories &#x3D; new ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">        allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">        this.nativeLibraryPathElements &#x3D; makePathElements(allNativeLibraryDirectories);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类 Element 用来描述一个 dex 文件所代表的元素。字段 dexElements 则为 dex 文件元素列表，通过 makeDexElements() 方法来初始化。<br>类 NativeLibraryElement 用来描述一个库文件所代表的元素，字段 nativeLibraryPathElements 则为库文件元素列表，通过 makePathElements 方法来初始化。</p>
<h5 id="makeDexEleemnts"><a href="#makeDexEleemnts" class="headerlink" title="makeDexEleemnts"></a>makeDexEleemnts</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, boolean isTrusted) &#123;</span><br><span class="line">    Element[] elements &#x3D; new Element[files.size()];</span><br><span class="line">    int elementsPos &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; Open all files and load the (direct or contained) dex files up front.</span><br><span class="line">    for (File file : files) &#123;</span><br><span class="line">        if (file.isDirectory()) &#123;</span><br><span class="line">            &#x2F;&#x2F; We support directories for looking up resources. Looking up resources in directories is useful for running libcore tests.</span><br><span class="line">            elements[elementsPos++] &#x3D; new Element(file);</span><br><span class="line">        &#125; else if (file.isFile()) &#123;</span><br><span class="line">            String name &#x3D; file.getName();</span><br><span class="line"></span><br><span class="line">            DexFile dex &#x3D; null;</span><br><span class="line">            if (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Raw dex file (not inside a zip&#x2F;jar).</span><br><span class="line">                try &#123;</span><br><span class="line">                    dex &#x3D; loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">                    if (dex !&#x3D; null) &#123;</span><br><span class="line">                        elements[elementsPos++] &#x3D; new Element(dex, null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException suppressed) &#123;</span><br><span class="line">                    System.logE(&quot;Unable to load dex file: &quot; + file, suppressed);</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dex &#x3D; loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">                &#125; catch (IOException suppressed) &#123;</span><br><span class="line">                    &#x2F;*</span><br><span class="line">                    * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if</span><br><span class="line">                    * the zip file turns out to be resource-only (that is, no classes.dex file</span><br><span class="line">                    * in it).</span><br><span class="line">                    * Let dex &#x3D;&#x3D; null and hang on to the exception to add to the tea-leaves for</span><br><span class="line">                    * when findClass returns null.</span><br><span class="line">                    *&#x2F;</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (dex &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    elements[elementsPos++] &#x3D; new Element(file);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    elements[elementsPos++] &#x3D; new Element(dex, file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dex !&#x3D; null &amp;&amp; isTrusted) &#123;</span><br><span class="line">                dex.setTrusted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (elementsPos !&#x3D; elements.length) &#123;</span><br><span class="line">        elements &#x3D; Arrays.copyOf(elements, elementsPos);</span><br><span class="line">    &#125;</span><br><span class="line">    return elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Constructs a &#123;@code DexFile&#125; instance, as appropriate depending on whether</span><br><span class="line"> * &#123;@code optimizedDirectory&#125; is &#123;@code null&#125;. An application image file may be associated with</span><br><span class="line"> * the &#123;@code loader&#125; if it is not null.</span><br><span class="line">*&#x2F;</span><br><span class="line">private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">    if (optimizedDirectory &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return new DexFile(file, loader, elements);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String optimizedPath &#x3D; optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeDexElements() 就是找到指定文件列表中的所有的 .dex 文件，以数组的形式返回。 loadDexFile 会初始化对应的 DexFile 类，DexFile 代表 .dex 文件。DexFile 在初始化过程中会打开对应的 .dex 文件：</p>
<h5 id="DexFile"><a href="#DexFile" class="headerlink" title="DexFile"></a>DexFile</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final class DexFile &#123;</span><br><span class="line">    private Object mCookie;</span><br><span class="line">    private Object mInternalCookie;</span><br><span class="line">    private final String mFileName;</span><br><span class="line"></span><br><span class="line">    DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class="line">        mCookie &#x3D; openDexFile(fileName, null, 0, loader, elements);</span><br><span class="line">        mInternalCookie &#x3D; mCookie;</span><br><span class="line">        mFileName &#x3D; fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 打开 Dex 文件</span><br><span class="line">    private static Object openDexFile(String sourceName, String outputName, int flags,</span><br><span class="line">        ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123;</span><br><span class="line">        return openDexFileNative(new File(sourceName).getAbsolutePath(),</span><br><span class="line">                                 (outputName &#x3D;&#x3D; null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; native 方法： 打开 Dex 文件</span><br><span class="line">    private static native Object openDexFileNative(String sourceName, String outputName, int flags,</span><br><span class="line">        ClassLoader loader, DexPathList.Element[] elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><h5 id="ClassLoader-loadClass"><a href="#ClassLoader-loadClass" class="headerlink" title="ClassLoader#loadClass()"></a>ClassLoader#loadClass()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ClassLoader &#123;</span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断当前类加载器是否已经加载过指定类，若已加载则直接返回</span><br><span class="line">        Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果没有加载过，则调用parent的类加载递归加载该类，若已加载则直接返回</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 还没加载，则调用当前类加载器来加载</span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类加载过程采用的遵循双亲委派原则。ClassLoader#findClass() 方法会直接抛出异常，说明 ClassLoader 的子类需要重写该方法才有意义。</p>
<h5 id="BaseDexClassLoader-findClass"><a href="#BaseDexClassLoader-findClass" class="headerlink" title="BaseDexClassLoader#findClass()"></a>BaseDexClassLoader#findClass()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class BaseDexClassLoader extends ClassLoader &#123;</span><br><span class="line">    private final DexPathList pathList;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions &#x3D; new ArrayList&lt;Throwable&gt;();</span><br><span class="line">        Class c &#x3D; pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            ClassNotFoundException cnfe &#x3D; new ClassNotFoundException(</span><br><span class="line">                    &quot;Didn&#39;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);</span><br><span class="line">            for (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            throw cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseDexClassLoader 实现了 findClass 方法，实际上是在通过 DexPathList#findClass() 方法在 pathList 中找有没有指定的类。</p>
<h5 id="DexPathList-findClass"><a href="#DexPathList-findClass" class="headerlink" title="DexPathList#findClass()"></a>DexPathList#findClass()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final class DexPathList &#123;</span><br><span class="line">    private Element[] dexElements;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">        for (Element element : dexElements) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; element.findClass(name, definingContext, suppressed);</span><br><span class="line">            if (clazz !&#x3D; null) &#123;</span><br><span class="line">                return clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (dexElementsSuppressedExceptions !&#x3D; null) &#123;</span><br><span class="line">            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Element &#123;</span><br><span class="line">        private final File path;</span><br><span class="line">        private final DexFile dexFile;</span><br><span class="line">        </span><br><span class="line">        public Class&lt;?&gt; findClass(String name, ClassLoader definingContext, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">            return dexFile !&#x3D; null ? dexFile.loadClassBinaryName(name, definingContext, suppressed)</span><br><span class="line">                    : null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面源码中，可以发现，类加载是在 dexElements 数组中寻找对应的类，一旦在某一个 .dex 文件中找到指定的类，则不再继续查找，并直接返回。</p>
<h5 id="DexFile-loadClassBinaryName"><a href="#DexFile-loadClassBinaryName" class="headerlink" title="DexFile#loadClassBinaryName()"></a>DexFile#loadClassBinaryName()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final class DexFile &#123;</span><br><span class="line">    public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">        return defineClass(name, loader, mCookie, this, suppressed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Class defineClass(String name, ClassLoader loader, Object cookie,</span><br><span class="line">                                     DexFile dexFile, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">        Class result &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            result &#x3D; defineClassNative(name, loader, cookie, dexFile);</span><br><span class="line">        &#125; catch (NoClassDefFoundError e) &#123;</span><br><span class="line">            if (suppressed !&#x3D; null) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            if (suppressed !&#x3D; null) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Class defineClassNative(String name, ClassLoader loader, Object cookie, DexFile dexFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="类加载相关总结"><a href="#类加载相关总结" class="headerlink" title="类加载相关总结"></a>类加载相关总结</h4><p>几种类加载器：</p>
<ul>
<li>PathClassLoader: 主要用于系统和app的类加载器,其中optimizedDirectory为null, 采用默认目录/data/dalvik-cache/</li>
<li>DexClassLoader: 可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载,但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 因此很多插件化方案都是采用DexClassLoader;</li>
<li>BaseDexClassLoader: 比较基础的类加载器, </li>
<li>PathClassLoader和DexClassLoader都只是在构造函数上对其简单封装而已.</li>
<li>BootClassLoader: 作为父类的类构造器。</li>
</ul>
<p>热修复核心逻辑：在DexPathList.findClass()过程，一个Classloader可以包含多个dex文件，每个dex文件被封装到一个Element对象，这些Element对象排列成有序的数组dexElements。当查找某个类时，会遍历所有的dex文件，如果找到则直接返回，不再继续遍历dexElements。也就是说当两个类不同的dex中出现，会优先处理排在前面的dex文件，这便是热修复的核心精髓，将需要修复的类所打包的dex文件插入到dexElements前面。</p>
<h4 id="热修复-插件化原理"><a href="#热修复-插件化原理" class="headerlink" title="热修复/插件化原理"></a>热修复/插件化原理</h4><p>在Android中应用插件化技术，其实就是动态加载的过程，分为以下几步：</p>
<ul>
<li>把可执行文件（ .so/dex/jar/apk 等）拷贝到应用 APP 内部。</li>
<li>加载可执行文件，更换静态资源</li>
<li>调用具体的方法执行业务逻辑</li>
</ul>
<p>Android 项目中，动态加载技术按照加载的可执行文件的不同大致可以分为两种：</p>
<ul>
<li>动态加载 .so 库</li>
<li>动态加载 dex/jar/apk文件</li>
</ul>
<p>第一点，Android 中 NDK 中其实就使用了动态加载，动态加载 .so 库并通过 JNI 调用其封装好的方法。后者一般是由 C/C++ 编译而成，运行在 Native 层，效率会比执行在虚拟机层的 Java 代码高很多，所以 Android 中经常通过动态加载 .so 库来完成一些对性能比较有需求的工作（比如 Bitmap 的解码、图片高斯模糊处理等）。此外，由于 .so 库是由 C/C++ 编译而来的，只能被反编译成汇编代码，相比中 dex 文件反编译得到的 Smali 代码更难被破解，因此 .so 库也可以被用于安全领域。</p>
<p>第二点，“基于 ClassLoader 的动态加载 dex/jar/apk 文件”，就是我们指在 Android 中 动态加载由 Java 代码编译而来的 dex 包并执行其中的代码逻辑，这是常规 Android 开发比较少用到的一种技术，目前说的动态加载指的就是这种。<br>ClassLoader在加载Class时，是顺序从DexPathList的dexElements中寻找类的，因此可以通过反射的方式，将我们要替换或者修复的apk/dex等模块插入到dexElements前端，这样类加载器会首先加载我们更新的模块。</p>
<h4 id="插件化-热修复的限制"><a href="#插件化-热修复的限制" class="headerlink" title="插件化/热修复的限制"></a>插件化/热修复的限制</h4><ul>
<li>插件化中使用了许多反射的功能，由于Android P的到来，Google发布了一些禁令，它维护三个名单，分别是浅灰名单，深灰名单，黑名单：</li>
<li>浅灰名单中的接口还可以继续在 AndroidP 中使用，但是在未来的版本中就有可能会移到黑名单中，也可能会开发新的public API来供开发者光明正大的使用。</li>
<li>深灰名单中的接口，在Android P 的后续预览版中将不可访问，所以如果有使用深灰名单中的接口，必须马上进行整改。</li>
<li>黑名单中的接口就不允许调用了，如果调用直接就是抛异常等行为。</li>
</ul>
<p>因此要想提高稳定性，需要更少地Hook Android系统的API。</p>
<h4 id="热修复示例"><a href="#热修复示例" class="headerlink" title="热修复示例"></a>热修复示例</h4><p>反射工具类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public final class ReflectUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static Field getField(Class&lt;?&gt; cls, String fieldName) &#123;</span><br><span class="line">        for (Class&lt;?&gt; acls &#x3D; cls; acls !&#x3D; null; acls &#x3D; acls.getSuperclass()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Field field &#x3D; acls.getDeclaredField(fieldName);</span><br><span class="line">                setAccessible(field, true);</span><br><span class="line"></span><br><span class="line">                return field;</span><br><span class="line">            &#125; catch (final NoSuchFieldException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Field match &#x3D; null;</span><br><span class="line">        for (final Class&lt;?&gt; class1 : cls.getInterfaces()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                match &#x3D; class1.getField(fieldName);</span><br><span class="line">            &#125; catch (final NoSuchFieldException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return match;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object readField(Object target, String fieldName) throws Exception &#123;</span><br><span class="line">        return readField(target.getClass(), target, fieldName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Object readField(Class&lt;?&gt; c, Object target, String fieldName) throws Exception &#123;</span><br><span class="line">        Field f &#x3D; getField(c, fieldName);</span><br><span class="line"></span><br><span class="line">        return readField(f, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Object readField(final Field field, final Object target) throws Exception &#123;</span><br><span class="line">        return field.get(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writeField(Object target, String fName, Object value) throws Exception &#123;</span><br><span class="line">        writeField(target.getClass(), target, fName, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void writeField(Class&lt;?&gt; c, Object object, String fName, Object value) throws Exception &#123;</span><br><span class="line">        Field f &#x3D; getField(c, fName);</span><br><span class="line">        writeField(f, object, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void writeField(final Field field, final Object target, final Object value) throws Exception &#123;</span><br><span class="line">        field.set(target, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void setAccessible(AccessibleObject ao, boolean value) &#123;</span><br><span class="line">        if (ao.isAccessible() !&#x3D; value) &#123;</span><br><span class="line">            ao.setAccessible(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object combineArray(Object arrayLhs, Object arrayRhs) throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; arrayLhs.getClass().getComponentType();</span><br><span class="line">        int i &#x3D; Array.getLength(arrayLhs);</span><br><span class="line">        int j &#x3D; Array.getLength(arrayRhs);</span><br><span class="line">        int k &#x3D; i + j;</span><br><span class="line">        Object result &#x3D; Array.newInstance(clazz, k);</span><br><span class="line">        System.arraycopy(arrayLhs, 0, result, 0, i);</span><br><span class="line">        System.arraycopy(arrayRhs, 0, result, i, j);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修复工具类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class FixDexUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final String DEX_SUFFIX &#x3D; &quot;.dex&quot;;</span><br><span class="line">    private static final String APK_SUFFIX &#x3D; &quot;.apk&quot;;</span><br><span class="line"></span><br><span class="line">    private static final String PATCH_DIR &#x3D; &quot;patch&quot;;</span><br><span class="line"></span><br><span class="line">    private static HashSet&lt;File&gt; sLoadedDex &#x3D; new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static boolean needFix(@NonNull Context context) &#123;</span><br><span class="line">        sLoadedDex.clear();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; &#x2F;data&#x2F;data&#x2F;包名&#x2F;files&#x2F;patch</span><br><span class="line">        File fileDir &#x3D; new File(context.getFilesDir(), PATCH_DIR);</span><br><span class="line">        if (!fileDir.exists()) &#123;</span><br><span class="line">            fileDir.mkdirs();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!fileDir.isDirectory()) &#123;</span><br><span class="line">            fileDir.delete();</span><br><span class="line">            fileDir.mkdirs();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean canFix &#x3D; false;</span><br><span class="line">        File[] listFiles &#x3D; fileDir.listFiles();</span><br><span class="line">        if (listFiles &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (File file : listFiles) &#123;</span><br><span class="line">            if ((file.getName().endsWith(DEX_SUFFIX)</span><br><span class="line">                    || file.getName().endsWith(APK_SUFFIX))) &#123;</span><br><span class="line">                sLoadedDex.add(file);</span><br><span class="line">                canFix &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return canFix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fix(Application application) &#123;</span><br><span class="line">        doFix(application, sLoadedDex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void doFix(Application application, HashSet&lt;File&gt; loadedDex) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Context base &#x3D; application.getBaseContext();</span><br><span class="line">            if (base &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.d(&quot;LLL&quot;, &quot;base &#x3D;&#x3D; null&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object packageInfo &#x3D; ReflectUtils.readField(base, &quot;mPackageInfo&quot;);</span><br><span class="line">            if (packageInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.d(&quot;LLL&quot;, &quot;packageInfo &#x3D;&#x3D; null&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这里也可以由context.getClassLoader()得到PathClassLoader</span><br><span class="line">            &#x2F;&#x2F; 而loadedDex.getClass().getClassLoader()返回的是BootCLassLoader</span><br><span class="line">            ClassLoader classLoader &#x3D; (ClassLoader) ReflectUtils.readField(packageInfo, &quot;mClassLoader&quot;);</span><br><span class="line">            if (!(classLoader instanceof PathClassLoader)) &#123;</span><br><span class="line">                Log.d(&quot;LLL&quot;, &quot;classLoader &#x3D;&#x3D; null&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PathClassLoader pathLoader &#x3D; (PathClassLoader) classLoader;</span><br><span class="line"></span><br><span class="line">            for (File dex : loadedDex) &#123;</span><br><span class="line">                DexClassLoader dexLoader &#x3D; new DexClassLoader(dex.getAbsolutePath(), null, null, pathLoader);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 3.开始合并: 合并的目标是Element[], 重新赋值它的值即可</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;3.1 准备好pathList的引用</span><br><span class="line">                Object dexPathList &#x3D; ReflectUtils.readField(dexLoader, &quot;pathList&quot;);</span><br><span class="line">                Object pathPathList &#x3D; ReflectUtils.readField(pathLoader, &quot;pathList&quot;);</span><br><span class="line">                &#x2F;&#x2F;3.2 从pathList中反射出element集合</span><br><span class="line">                Object leftDexElements &#x3D; ReflectUtils.readField(dexPathList, &quot;dexElements&quot;);</span><br><span class="line">                Object rightDexElements &#x3D; ReflectUtils.readField(pathPathList, &quot;dexElements&quot;);</span><br><span class="line">                &#x2F;&#x2F;3.3 合并两个dex数组</span><br><span class="line">                Object dexElements &#x3D; ReflectUtils.combineArray(leftDexElements, rightDexElements);</span><br><span class="line"></span><br><span class="line">                Object pathList &#x3D; ReflectUtils.readField(pathLoader, &quot;pathList&quot;);</span><br><span class="line">                ReflectUtils.writeField(pathList, &quot;dexElements&quot;, dexElements);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application启动调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PatchApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        super.attachBaseContext(base);</span><br><span class="line">        if (FixDexUtil.needFix(this)) &#123;</span><br><span class="line">            Log.d(&quot;LLL&quot;, &quot;begin to fix&quot;);</span><br><span class="line">            FixDexUtil.fix(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要修复的工具类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修复前</span><br><span class="line">public class Util &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;LLL&quot;;</span><br><span class="line"></span><br><span class="line">    public static void test() &#123;</span><br><span class="line">        Log.d(TAG, &quot;first publish.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修复后</span><br><span class="line">public class Util &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;LLL&quot;;</span><br><span class="line"></span><br><span class="line">    public static void test() &#123;</span><br><span class="line">        Log.d(TAG, &quot;first publish.&quot;);</span><br><span class="line">        Log.d(TAG, &quot;patch publish.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先在手机上安装修复前的版本，调用Util.test()，会输出first publish.；</li>
<li>然后修改Util类，打包成apk，也可以只将Util类单独打包成dex，push到/data/data/pkg/files/patch下，由于我的测试机已经root，所以直接使用这个目录，否则可以添加从sd卡拷贝到私有目录的逻辑；</li>
<li>重启后会加载修复包，多输出一行patch publish.。</li>
<li>打包成dex的命令：dx –dex –output=util.dex com\hearing\gopatch\Util.class。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
