<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">28 电源开关机按键事件流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。</p>
<p>和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。</p>
<p>下面首先看一下dispatchUnhandledKey方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode&#x3D;&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState&#x3D;&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过前面两篇文章的分析<br>（<a href="http://blog.csdn.net/qq_23547831/article/details/51474288" target="_blank" rel="noopener"> android源码解析（二十六）–&gt;截屏事件流程</a>&nbsp;&nbsp;<br><a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）<br>我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">            case KeyEvent.KEYCODE_POWER: &#123;</span><br><span class="line">                result &amp;&#x3D; ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey &#x3D; false; &#x2F;&#x2F; wake-up will be handled separately</span><br><span class="line">                if (down) &#123;</span><br><span class="line">                    interceptPowerKeyDown(event, interactive);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    interceptPowerKeyUp(event, interactive, canceled);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private void interceptPowerKeyDown(KeyEvent event, boolean interactive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Latch power key state to detect screenshot chord.</span><br><span class="line">        if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mScreenshotChordPowerKeyTriggered &#x3D; true;</span><br><span class="line">            mScreenshotChordPowerKeyTime &#x3D; event.getDownTime();</span><br><span class="line">            interceptScreenshotChord();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Stop ringing or end call if configured to do so when power is pressed.</span><br><span class="line">        TelecomManager telecomManager &#x3D; getTelecommService();</span><br><span class="line">        boolean hungUp &#x3D; false;</span><br><span class="line">        if (telecomManager !&#x3D; null) &#123;</span><br><span class="line">            if (telecomManager.isRinging()) &#123;</span><br><span class="line">                &#x2F;&#x2F; Pressing Power while there&#39;s a ringing incoming</span><br><span class="line">                &#x2F;&#x2F; call should silence the ringer.</span><br><span class="line">                telecomManager.silenceRinger();</span><br><span class="line">            &#125; else if ((mIncallPowerBehavior</span><br><span class="line">                    &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) !&#x3D; 0</span><br><span class="line">                    &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; Otherwise, if &quot;Power button ends call&quot; is enabled,</span><br><span class="line">                &#x2F;&#x2F; the Power button will hang up any current active call.</span><br><span class="line">                hungUp &#x3D; telecomManager.endCall();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the power key has still not yet been handled, then detect short</span><br><span class="line">        &#x2F;&#x2F; press, long press, or multi press and decide what to do.</span><br><span class="line">        mPowerKeyHandled &#x3D; hungUp || mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                || mScreenshotChordVolumeUpKeyTriggered;</span><br><span class="line">        if (!mPowerKeyHandled) &#123;</span><br><span class="line">            if (interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; When interactive, we&#39;re already awake.</span><br><span class="line">                &#x2F;&#x2F; Wait for a long press or for the button to be released to decide what to do.</span><br><span class="line">                if (hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                wakeUpFromPowerKey(event.getDownTime());</span><br><span class="line"></span><br><span class="line">                if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                    mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int maxCount &#x3D; getMaxMultiPressPowerCount();</span><br><span class="line"></span><br><span class="line">                    if (maxCount &lt;&#x3D; 1) &#123;</span><br><span class="line">                        mPowerKeyHandled &#x3D; true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case MSG_POWER_LONG_PRESS:</span><br><span class="line">                    powerLongPress();</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void powerLongPress() &#123;</span><br><span class="line">        final int behavior &#x3D; getResolvedLongPressOnPowerBehavior();</span><br><span class="line">        switch (behavior) &#123;</span><br><span class="line">        case LONG_PRESS_POWER_NOTHING:</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_GLOBAL_ACTIONS:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) &#123;</span><br><span class="line">                performAuditoryFeedbackForAccessibilityIfNeed();</span><br><span class="line">            &#125;</span><br><span class="line">            showGlobalActionsInternal();</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF:</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">            mWindowManagerFuncs.shutdown(behavior &#x3D;&#x3D; LONG_PRESS_POWER_SHUT_OFF);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面：<br><img src="http://img.blog.csdn.net/20160524153125405" alt="这里写图片描述"></p>
<p>然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void showGlobalActionsInternal() &#123;</span><br><span class="line">        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">        if (mGlobalActions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mGlobalActions &#x3D; new GlobalActions(mContext, mWindowManagerFuncs);</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean keyguardShowing &#x3D; isKeyguardShowingAndNotOccluded();</span><br><span class="line">        mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned());</span><br><span class="line">        if (keyguardShowing) &#123;</span><br><span class="line">            &#x2F;&#x2F; since it took two seconds of long press to bring this up,</span><br><span class="line">            &#x2F;&#x2F; poke the wake lock so they have some time to see the dialog.</span><br><span class="line">            mPowerManager.userActivity(SystemClock.uptimeMillis(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（<a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">        mAudioManager &#x3D; (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">        mDreamManager &#x3D; IDreamManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(DreamService.DREAM_SERVICE));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; receive broadcasts</span><br><span class="line">        IntentFilter filter &#x3D; new IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);</span><br><span class="line">        context.registerReceiver(mBroadcastReceiver, filter);</span><br><span class="line"></span><br><span class="line">        ConnectivityManager cm &#x3D; (ConnectivityManager)</span><br><span class="line">                context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        mHasTelephony &#x3D; cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; get notified of phone state changes</span><br><span class="line">        TelephonyManager telephonyManager &#x3D;</span><br><span class="line">                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);</span><br><span class="line">        mContext.getContentResolver().registerContentObserver(</span><br><span class="line">                Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true,</span><br><span class="line">                mAirplaneModeObserver);</span><br><span class="line">        Vibrator vibrator &#x3D; (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">        mHasVibrator &#x3D; vibrator !&#x3D; null &amp;&amp; vibrator.hasVibrator();</span><br><span class="line"></span><br><span class="line">        mShowSilentToggle &#x3D; SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_useFixedVolume);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) &#123;</span><br><span class="line">        mKeyguardShowing &#x3D; keyguardShowing;</span><br><span class="line">        mDeviceProvisioned &#x3D; isDeviceProvisioned;</span><br><span class="line">        if (mDialog !&#x3D; null) &#123;</span><br><span class="line">            mDialog.dismiss();</span><br><span class="line">            mDialog &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; Show delayed, so that the dismiss of the previous dialog completes</span><br><span class="line">            mHandler.sendEmptyMessage(MESSAGE_SHOW);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleShow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void handleShow() &#123;</span><br><span class="line">        awakenIfNecessary();</span><br><span class="line">        mDialog &#x3D; createDialog();</span><br><span class="line">        prepareDialog();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we only have 1 item and it&#39;s a simple press action, just do this action.</span><br><span class="line">        if (mAdapter.getCount() &#x3D;&#x3D; 1</span><br><span class="line">                &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction</span><br><span class="line">                &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) &#123;</span><br><span class="line">            ((SinglePressAction) mAdapter.getItem(0)).onPress();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            WindowManager.LayoutParams attrs &#x3D; mDialog.getWindow().getAttributes();</span><br><span class="line">            attrs.setTitle(&quot;GlobalActions&quot;);</span><br><span class="line">            mDialog.getWindow().setAttributes(attrs);</span><br><span class="line">            mDialog.show();</span><br><span class="line">            mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">private GlobalActionsDialog createDialog() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mAirplaneModeOn &#x3D; new ToggleAction(</span><br><span class="line">                R.drawable.ic_lock_airplane_mode,</span><br><span class="line">                R.drawable.ic_lock_airplane_mode_off,</span><br><span class="line">                R.string.global_actions_toggle_airplane_mode,</span><br><span class="line">                R.string.global_actions_airplane_mode_on_status,</span><br><span class="line">                R.string.global_actions_airplane_mode_off_status) &#123;</span><br><span class="line"></span><br><span class="line">            void onToggle(boolean on) &#123;</span><br><span class="line">                if (mHasTelephony &amp;&amp; Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) &#123;</span><br><span class="line">                    mIsWaitingForEcmExit &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; Launch ECM exit dialog</span><br><span class="line">                    Intent ecmDialogIntent &#x3D;</span><br><span class="line">                            new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);</span><br><span class="line">                    ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                    mContext.startActivity(ecmDialogIntent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    changeAirplaneModeSystemSetting(on);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected void changeStateFromPress(boolean buttonOn) &#123;</span><br><span class="line">                if (!mHasTelephony) return;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; In ECM mode airplane state cannot be changed</span><br><span class="line">                if (!(Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) &#123;</span><br><span class="line">                    mState &#x3D; buttonOn ? State.TurningOn : State.TurningOff;</span><br><span class="line">                    mAirplaneState &#x3D; mState;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showDuringKeyguard() &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showBeforeProvisioning() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        onAirplaneModeChanged();</span><br><span class="line"></span><br><span class="line">        mItems &#x3D; new ArrayList&lt;Action&gt;();</span><br><span class="line">        String[] defaultActions &#x3D; mContext.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_globalActionsList);</span><br><span class="line"></span><br><span class="line">        ArraySet&lt;String&gt; addedKeys &#x3D; new ArraySet&lt;String&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; defaultActions.length; i++) &#123;</span><br><span class="line">            String actionKey &#x3D; defaultActions[i];</span><br><span class="line">            if (addedKeys.contains(actionKey)) &#123;</span><br><span class="line">                &#x2F;&#x2F; If we already have added this, don&#39;t add it again.</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(new PowerAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(mAirplaneModeOn);</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) &#123;</span><br><span class="line">                if (Settings.Global.getInt(mContext.getContentResolver(),</span><br><span class="line">                        Settings.Global.BUGREPORT_IN_POWER_MENU, 0) !&#x3D; 0 &amp;&amp; isCurrentUserOwner()) &#123;</span><br><span class="line">                    mItems.add(getBugReportAction());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) &#123;</span><br><span class="line">                if (mShowSilentToggle) &#123;</span><br><span class="line">                    mItems.add(mSilentModeAction);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) &#123;</span><br><span class="line">                if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) &#123;</span><br><span class="line">                    addUsersToMenu(mItems);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getSettingsAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getLockdownAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getVoiceAssistAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getAssistAction());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;Invalid global action key &quot; + actionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Add here so we don&#39;t add more than one.</span><br><span class="line">            addedKeys.add(actionKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdapter &#x3D; new MyAdapter();</span><br><span class="line"></span><br><span class="line">        AlertParams params &#x3D; new AlertParams(mContext);</span><br><span class="line">        params.mAdapter &#x3D; mAdapter;</span><br><span class="line">        params.mOnClickListener &#x3D; this;</span><br><span class="line">        params.mForceInverseBackground &#x3D; true;</span><br><span class="line"></span><br><span class="line">        GlobalActionsDialog dialog &#x3D; new GlobalActionsDialog(mContext, params);</span><br><span class="line">        dialog.setCanceledOnTouchOutside(false); &#x2F;&#x2F; Handled by the custom class.</span><br><span class="line"></span><br><span class="line">        dialog.getListView().setItemsCanFocus(true);</span><br><span class="line">        dialog.getListView().setLongClickable(true);</span><br><span class="line">        dialog.getListView().setOnItemLongClickListener(</span><br><span class="line">                new AdapterView.OnItemLongClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position,</span><br><span class="line">                            long id) &#123;</span><br><span class="line">                        final Action action &#x3D; mAdapter.getItem(position);</span><br><span class="line">                        if (action instanceof LongPressAction) &#123;</span><br><span class="line">                            return ((LongPressAction) action).onLongPress();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        dialog.setOnDismissListener(this);</span><br><span class="line"></span><br><span class="line">        return dialog;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面：<br><img src="http://img.blog.csdn.net/20160525144307466" alt="这里写图片描述"></p>
<p>好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mItems.add(new PowerAction());</span><br></pre></td></tr></table></figure>
<p>这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final class PowerAction extends SinglePressAction implements LongPressAction &#123;</span><br><span class="line">        private PowerAction() &#123;</span><br><span class="line">            super(com.android.internal.R.drawable.ic_lock_power_off,</span><br><span class="line">                R.string.global_action_power_off);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onLongPress() &#123;</span><br><span class="line">            UserManager um &#x3D; (UserManager) mContext.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) &#123;</span><br><span class="line">                mWindowManagerFuncs.rebootSafeMode(true);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showDuringKeyguard() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showBeforeProvisioning() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onPress() &#123;</span><br><span class="line">            &#x2F;&#x2F; shutdown by making sure radio and power are handled accordingly.</span><br><span class="line">            mWindowManagerFuncs.shutdown(false &#x2F;* confirm *&#x2F;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">		...</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。</p>
<p>经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initPolicy() &#123;</span><br><span class="line">        UiThread.getHandler().runWithScissors(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line"></span><br><span class="line">                mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。</p>
<p>然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false /* confirm */);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void shutdown(boolean confirm) &#123;</span><br><span class="line">        ShutdownThread.shutdown(mContext, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void shutdown(final Context context, boolean confirm) &#123;</span><br><span class="line">        mReboot &#x3D; false;</span><br><span class="line">        mRebootSafeMode &#x3D; false;</span><br><span class="line">        shutdownInner(context, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void shutdownInner(final Context context, boolean confirm) &#123;</span><br><span class="line">        &#x2F;&#x2F; ensure that only one thread is trying to power down.</span><br><span class="line">        &#x2F;&#x2F; any additional calls are just returned</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int longPressBehavior &#x3D; context.getResources().getInteger(</span><br><span class="line">                        com.android.internal.R.integer.config_longPressOnPowerBehavior);</span><br><span class="line">        final int resourceId &#x3D; mRebootSafeMode</span><br><span class="line">                ? com.android.internal.R.string.reboot_safemode_confirm</span><br><span class="line">                : (longPressBehavior &#x3D;&#x3D; 2</span><br><span class="line">                        ? com.android.internal.R.string.shutdown_confirm_question</span><br><span class="line">                        : com.android.internal.R.string.shutdown_confirm);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior&#x3D;&quot; + longPressBehavior);</span><br><span class="line"></span><br><span class="line">        if (confirm) &#123;</span><br><span class="line">            final CloseDialogReceiver closer &#x3D; new CloseDialogReceiver(context);</span><br><span class="line">            if (sConfirmDialog !&#x3D; null) &#123;</span><br><span class="line">                sConfirmDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">            sConfirmDialog &#x3D; new AlertDialog.Builder(context)</span><br><span class="line">                    .setTitle(mRebootSafeMode</span><br><span class="line">                            ? com.android.internal.R.string.reboot_safemode_title</span><br><span class="line">                            : com.android.internal.R.string.power_off)</span><br><span class="line">                    .setMessage(resourceId)</span><br><span class="line">                    .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            beginShutdownSequence(context);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(com.android.internal.R.string.no, null)</span><br><span class="line">                    .create();</span><br><span class="line">            closer.dialog &#x3D; sConfirmDialog;</span><br><span class="line">            sConfirmDialog.setOnDismissListener(closer);</span><br><span class="line">            sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line">            sConfirmDialog.show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            beginShutdownSequence(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">private static void beginShutdownSequence(Context context) &#123;</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            sIsStarted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) &#123;</span><br><span class="line">            mRebootUpdate &#x3D; new File(UNCRYPT_PACKAGE_FILE).exists();</span><br><span class="line">            if (mRebootUpdate) &#123;</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_update_prepare));</span><br><span class="line">                pd.setMax(100);</span><br><span class="line">                pd.setProgressNumberFormat(null);</span><br><span class="line">                pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">                pd.setProgress(0);</span><br><span class="line">                pd.setIndeterminate(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Factory reset path. Set the dialog message accordingly.</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pd.setTitle(context.getText(com.android.internal.R.string.power_off));</span><br><span class="line">            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));</span><br><span class="line">            pd.setIndeterminate(true);</span><br><span class="line">        &#125;</span><br><span class="line">        pd.setCancelable(false);</span><br><span class="line">        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        pd.show();</span><br><span class="line"></span><br><span class="line">        sInstance.mProgressDialog &#x3D; pd;</span><br><span class="line">        sInstance.mContext &#x3D; context;</span><br><span class="line">        sInstance.mPowerManager &#x3D; (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; make sure we never fall asleep again</span><br><span class="line">        sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                    PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;);</span><br><span class="line">            sInstance.mCpuWakeLock.setReferenceCounted(false);</span><br><span class="line">            sInstance.mCpuWakeLock.acquire();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; also make sure the screen stays on for better user experience</span><br><span class="line">        sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">        if (sInstance.mPowerManager.isScreenOn()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                        PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;);</span><br><span class="line">                sInstance.mScreenWakeLock.setReferenceCounted(false);</span><br><span class="line">                sInstance.mScreenWakeLock.acquire();</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; start the thread that initiates shutdown</span><br><span class="line">        sInstance.mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        sInstance.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。</p>
<p>总结：</p>
<ul>
<li><p>电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中；</p>
</li>
<li><p>在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等；</p>
</li>
<li><p>当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/27%20HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/27%20HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">27 HOME事件流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章中我们介绍了android系统的截屏事件，由于截屏事件是一种系统全局处理事件，所以事件的处理逻辑不是在App中执行，而是在PhoneWindowManager中执行。而本文我们现在主要讲解android系统中HOME按键的事件处理，和截屏事件类似，这里的HOME按键也是系统级别的按键事件监听，所以其处理事件的逻辑也应该和截屏事件处理流程类似，从上一篇文章的分析过冲中我们不难发现，系统级别的按键处理逻辑其实都是在PhoneWindowManager中，所以HOME按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中执行，那么我们就从dispatchUnhandleKey方法开始分析HOME按键的处理流程。</p>
<p>好吧我们看一下PhoneWindowManager的dispatchUnhandleKey方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode&#x3D;&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState&#x3D;&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_INPUT) &#123;</span><br><span class="line">            if (fallbackEvent &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Slog.d(TAG, &quot;No fallback.&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.d(TAG, &quot;Performing fallback: &quot; + fallbackEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过查看源码，我们重点看一下dispatchUnhandledKey方法中调用的interceptFallback方法，关于HOME按键的处理逻辑也是在这个方法体中的，所以继续看一下interceptFallback方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析源码我们知道关于HOME按键的处理逻辑主要是在interceptKeyBeforeDispatching方法的实现的，既然这样，我们看一下interceptKeyBeforeDispatching方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; First we always handle the home key here, so applications</span><br><span class="line">        &#x2F;&#x2F; can never break it, although if keyguard is on, we do let</span><br><span class="line">        &#x2F;&#x2F; it handle it, because that gives us the correct 5 second</span><br><span class="line">        &#x2F;&#x2F; timeout.</span><br><span class="line">        if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_HOME) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If we have released the home key, and didn&#39;t do anything else</span><br><span class="line">            &#x2F;&#x2F; while it was pressed, then it is time to go home!</span><br><span class="line">            if (!down) &#123;</span><br><span class="line">                cancelPreloadRecentApps();</span><br><span class="line"></span><br><span class="line">                mHomePressed &#x3D; false;</span><br><span class="line">                if (mHomeConsumed) &#123;</span><br><span class="line">                    mHomeConsumed &#x3D; false;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (canceled) &#123;</span><br><span class="line">                    Log.i(TAG, &quot;Ignoring HOME; event canceled.&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; If an incoming call is ringing, HOME is totally disabled.</span><br><span class="line">                &#x2F;&#x2F; (The user is already on the InCallUI at this point,</span><br><span class="line">                &#x2F;&#x2F; and his ONLY options are to answer or reject the call.)</span><br><span class="line">                TelecomManager telecomManager &#x3D; getTelecommService();</span><br><span class="line">                if (telecomManager !&#x3D; null &amp;&amp; telecomManager.isRinging()) &#123;</span><br><span class="line">                    Log.i(TAG, &quot;Ignoring HOME; there&#39;s a ringing incoming call.&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Delay handling home if a double-tap is possible.</span><br><span class="line">                if (mDoubleTapOnHomeBehavior !&#x3D; DOUBLE_TAP_HOME_NOTHING) &#123;</span><br><span class="line">                    mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); &#x2F;&#x2F; just in case</span><br><span class="line">                    mHomeDoubleTapPending &#x3D; true;</span><br><span class="line">                    mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,</span><br><span class="line">                            ViewConfiguration.getDoubleTapTimeout());</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                handleShortPressOnHome();</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If a system window has focus, then it doesn&#39;t make sense</span><br><span class="line">            &#x2F;&#x2F; right now to interact with applications.</span><br><span class="line">            WindowManager.LayoutParams attrs &#x3D; win !&#x3D; null ? win.getAttrs() : null;</span><br><span class="line">            if (attrs !&#x3D; null) &#123;</span><br><span class="line">                final int type &#x3D; attrs.type;</span><br><span class="line">                if (type &#x3D;&#x3D; WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM</span><br><span class="line">                        || type &#x3D;&#x3D; WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG</span><br><span class="line">                        || (attrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) !&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; the &quot;app&quot; is keyguard, so give it the key</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                final int typeCount &#x3D; WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;</span><br><span class="line">                for (int i&#x3D;0; i&lt;typeCount; i++) &#123;</span><br><span class="line">                    if (type &#x3D;&#x3D; WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) &#123;</span><br><span class="line">                        &#x2F;&#x2F; don&#39;t do anything, but also don&#39;t pass it to the app</span><br><span class="line">                        return -1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Remember that home is pressed and handle special actions.</span><br><span class="line">            if (repeatCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                mHomePressed &#x3D; true;</span><br><span class="line">                if (mHomeDoubleTapPending) &#123;</span><br><span class="line">                    mHomeDoubleTapPending &#x3D; false;</span><br><span class="line">                    mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);</span><br><span class="line">                    handleDoubleTapOnHome();</span><br><span class="line">                &#125; else if (mLongPressOnHomeBehavior &#x3D;&#x3D; LONG_PRESS_HOME_RECENT_SYSTEM_UI</span><br><span class="line">                        || mDoubleTapOnHomeBehavior &#x3D;&#x3D; DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) &#123;</span><br><span class="line">                    preloadRecentApps();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) !&#x3D; 0) &#123;</span><br><span class="line">                if (!keyguardOn) &#123;</span><br><span class="line">                    handleLongPressOnHome(event.getDeviceId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Let the application handle the key.</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们主要看一下对android系统HOME按键的处理逻辑，通过分析源码我们知道HOME按键进入launcher界面的主要逻辑是在handleShortPressOnHome();方法中执行的，所以我们继续看一下handleShortPressOnHome方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void handleShortPressOnHome() &#123;</span><br><span class="line">        &#x2F;&#x2F; Turn on the connected TV and switch HDMI input if we&#39;re a HDMI playback device.</span><br><span class="line">        getHdmiControl().turnOnTv();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If there&#39;s a dream running then use home to escape the dream</span><br><span class="line">        &#x2F;&#x2F; but don&#39;t actually go home.</span><br><span class="line">        if (mDreamManagerInternal !&#x3D; null &amp;&amp; mDreamManagerInternal.isDreaming()) &#123;</span><br><span class="line">            mDreamManagerInternal.stopDream(false &#x2F;*immediate*&#x2F;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Go home!</span><br><span class="line">        launchHomeFromHotKey();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在handleShortPressOnHome方法中调用了launchHomeFromHotKey方法，该方法的注释用于go home，所以继续看一下该方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void launchHomeFromHotKey() &#123;</span><br><span class="line">        launchHomeFromHotKey(true &#x2F;* awakenFromDreams *&#x2F;, true &#x2F;*respectKeyguard*&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在launchHomeFromHotKey方法中我们又调用了launchHomeFromHotkey的重构方法，这样我们看一下这个重构方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) &#123;</span><br><span class="line">        if (respectKeyguard) &#123;</span><br><span class="line">            if (isKeyguardShowingAndNotOccluded()) &#123;</span><br><span class="line">                &#x2F;&#x2F; don&#39;t launch home if keyguard showing</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!mHideLockScreen &amp;&amp; mKeyguardDelegate.isInputRestricted()) &#123;</span><br><span class="line">                &#x2F;&#x2F; when in keyguard restricted mode, must first verify unlock</span><br><span class="line">                &#x2F;&#x2F; before launching home</span><br><span class="line">                mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onKeyguardExitResult(boolean success) &#123;</span><br><span class="line">                        if (success) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                ActivityManagerNative.getDefault().stopAppSwitches();</span><br><span class="line">                            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);</span><br><span class="line">                            startDockOrHome(true &#x2F;*fromHomeKey*&#x2F;, awakenFromDreams);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; no keyguard stuff to worry about, just launch home!</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().stopAppSwitches();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mRecentsVisible) &#123;</span><br><span class="line">            &#x2F;&#x2F; Hide Recents and notify it to launch Home</span><br><span class="line">            if (awakenFromDreams) &#123;</span><br><span class="line">                awakenDreams();</span><br><span class="line">            &#125;</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);</span><br><span class="line">            hideRecentApps(false, true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Otherwise, just launch Home</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);</span><br><span class="line">            startDockOrHome(true &#x2F;*fromHomeKey*&#x2F;, awakenFromDreams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在方法中我们首先调用了ActivityManagerNative.getDefault().stopAppSwitches();该方法主要用于暂停后台的打开Activity的操作，避免打扰用户的操作。比如这时候我们在后台打开一个新的App，那么这时候由于要回到home页面，所以需要先延时打开。方法执行这个方法之后然后执行了sendCloseSystemWindows方法，该方法主要实现了对当前系统App页面的关闭操作，下面我们先看一下ActivityManagerNative.getDefault().stopAppSwitches();方法的实现，这里的ActivityManagerNative.getDefault我们在前面已经多次说过了其是一个Binder对象，是应用进程Binder客户端用于与ActivityManagerService之间通讯，所以这里最终调用的是ActivityManagerService的stopAppsSwitches方法，这样我们就继续看一下ActivityManagerService的stopAppsSwitches方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void stopAppSwitches() &#123;</span><br><span class="line">        if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES)</span><br><span class="line">                !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(&quot;Requires permission &quot;</span><br><span class="line">                    + android.Manifest.permission.STOP_APP_SWITCHES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            mAppSwitchesAllowedTime &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">                    + APP_SWITCH_DELAY_TIME;</span><br><span class="line">            mDidAppSwitch &#x3D; false;</span><br><span class="line">            mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG);</span><br><span class="line">            Message msg &#x3D; mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG);</span><br><span class="line">            mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里主要是发送了一个异步消息，并且msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG，即跳转Activity，然后我们继续我们看一下mHandler的handleMessage方法当msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG时的操作。而且我们可以发现这里的异步消息是一个延时的异步消息，延时的时间为APP_SWITCH_DELAY_TIME，我们可以看一下该变量的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Amount of time after a call to stopAppSwitches() during which we will</span><br><span class="line">    &#x2F;&#x2F; prevent further untrusted switches from happening.</span><br><span class="line">    static final long APP_SWITCH_DELAY_TIME &#x3D; 5*1000;</span><br></pre></td></tr></table></figure>
<p>然后我们可以看一下mHander的handleMessage方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case DO_PENDING_ACTIVITY_LAUNCHES_MSG: &#123;</span><br><span class="line">                synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                    mStackSupervisor.doPendingActivityLaunchesLocked(true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br></pre></td></tr></table></figure>
<p>可以发现这里直接调用了mStackSupervisor.doPendingActivityLaunchesLocked方法，好吧，继续看一下doPendingActivityLaunchesLocked方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void doPendingActivityLaunchesLocked(boolean doResume) &#123;</span><br><span class="line">        while (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class="line">            PendingActivityLaunch pal &#x3D; mPendingActivityLaunches.remove(0);</span><br><span class="line">            startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags,</span><br><span class="line">                    doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里就是调用了startActivity的操作了，看过Activity启动流程的同学应该知道：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">android源码解析之（十四）–&gt;Activity启动流程</a> 这里就是开始启动Activity了，所以当我们按下HOME按键的时候，后台的startActivity都会延时5秒钟执行…</p>
<p>然后回到我们的launchHomeFromHotKey方法，看一下launchHomeFromHotKey方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void sendCloseSystemWindows(String reason) &#123;</span><br><span class="line">        PhoneWindow.sendCloseSystemWindows(mContext, reason);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里调用了PhoneWindow的静态方法sendCloseSystemWindow,继续看一下该方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void sendCloseSystemWindows(Context context, String reason) &#123;</span><br><span class="line">        if (ActivityManagerNative.isSystemReady()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().closeSystemDialogs(reason);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，很明显了又是调用了Binder的进程间通讯，最终ActivityManagerService的closeSystemDialogs方法会被执行，所以我们继续看一下ActivityManagerService的closeSystemDialogs方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void closeSystemDialogs(String reason) &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;closeSystemDialogs&quot;);</span><br><span class="line"></span><br><span class="line">        final int pid &#x3D; Binder.getCallingPid();</span><br><span class="line">        final int uid &#x3D; Binder.getCallingUid();</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                &#x2F;&#x2F; Only allow this from foreground processes, so that background</span><br><span class="line">                &#x2F;&#x2F; applications can&#39;t abuse it to prevent system UI from being shown.</span><br><span class="line">                if (uid &gt;&#x3D; Process.FIRST_APPLICATION_UID) &#123;</span><br><span class="line">                    ProcessRecord proc;</span><br><span class="line">                    synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                        proc &#x3D; mPidsSelfLocked.get(pid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Ignoring closeSystemDialogs &quot; + reason</span><br><span class="line">                                + &quot; from background process &quot; + proc);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                closeSystemDialogsLocked(reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其实在方法体中将关闭窗口的逻辑下发到了closeSystemDialogsLocked中，所以我们继续看一下closeSystemDialogsLocked方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void closeSystemDialogsLocked(String reason) &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        if (reason !&#x3D; null) &#123;</span><br><span class="line">            intent.putExtra(&quot;reason&quot;, reason);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager.closeSystemDialogs(reason);</span><br><span class="line"></span><br><span class="line">        mStackSupervisor.closeSystemDialogsLocked();</span><br><span class="line"></span><br><span class="line">        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null,</span><br><span class="line">                AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                -1, Process.SYSTEM_UID, UserHandle.USER_ALL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在方法体中首先调用了mWindowManager.closeSystemDialogs方法，该方法就是关闭当前页面中存在的系统窗口，比如输入法，壁纸等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void closeSystemDialogs(String reason) &#123;</span><br><span class="line">        synchronized(mWindowMap) &#123;</span><br><span class="line">            final int numDisplays &#x3D; mDisplayContents.size();</span><br><span class="line">            for (int displayNdx &#x3D; 0; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">                final WindowList windows &#x3D; mDisplayContents.valueAt(displayNdx).getWindowList();</span><br><span class="line">                final int numWindows &#x3D; windows.size();</span><br><span class="line">                for (int winNdx &#x3D; 0; winNdx &lt; numWindows; ++winNdx) &#123;</span><br><span class="line">                    final WindowState w &#x3D; windows.get(winNdx);</span><br><span class="line">                    if (w.mHasSurface) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            w.mClient.closeSystemDialogs(reason);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>讲过这样一层操作之后，我们就关闭了当前中存在的系统窗口。然后还是回到我们的launchHomeFromHotKey方法，我们发现在方法体的最后我们调用了startDockOrHome方法，这个方法就是实际的跳转HOME页面的方法了，我们可以具体看一下该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void startDockOrHome(boolean fromHomeKey, boolean awakenFromDreams) &#123;</span><br><span class="line">        if (awakenFromDreams) &#123;</span><br><span class="line">            awakenDreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Intent dock &#x3D; createHomeDockIntent();</span><br><span class="line">        if (dock !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fromHomeKey) &#123;</span><br><span class="line">                    dock.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey);</span><br><span class="line">                &#125;</span><br><span class="line">                startActivityAsUser(dock, UserHandle.CURRENT);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (ActivityNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Intent intent;</span><br><span class="line"></span><br><span class="line">        if (fromHomeKey) &#123;</span><br><span class="line">            intent &#x3D; new Intent(mHomeIntent);</span><br><span class="line">            intent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            intent &#x3D; mHomeIntent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startActivityAsUser(intent, UserHandle.CURRENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们在方法体中调用了createHomeDockIntent，这个方法的作用就是创建到达HOME页面的Intent对象，然后我们调用了startActivityAsUser方法，这样经过一系列的调用之后就调起了home页面的Activity，所以这时候系统就返回到了HOME页面。</p>
<p>总结：</p>
<ul>
<li><p>系统也是在PhoneWindowManager中监听HOME按键的点击并进行处理；</p>
</li>
<li><p>系统监听到HOME按键之后会首先关闭相应的系统弹窗；</p>
</li>
<li><p>通过创建Intent对象，并调用startActivity方法使系统跳转到HOME页面；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/26%20%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/26%20%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">26 截屏事件流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。</p>
<p>我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。</p>
<p>在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** &#123;@inheritDoc&#125; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        if (!mSystemBooted) &#123;</span><br><span class="line">            &#x2F;&#x2F; If we have not yet booted, don&#39;t let key events do anything.</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Handle special keys.</span><br><span class="line">        switch (keyCode) &#123;</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_DOWN:</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_UP:</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_MUTE: &#123;</span><br><span class="line">                if (mUseTvRouting) &#123;</span><br><span class="line">                    &#x2F;&#x2F; On TVs volume keys never go to the foreground app</span><br><span class="line">                    result &amp;&#x3D; ~ACTION_PASS_TO_USER;</span><br><span class="line">                &#125;</span><br><span class="line">                if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_VOLUME_DOWN) &#123;</span><br><span class="line">                    if (down) &#123;</span><br><span class="line">                        if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered &#x3D; true;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime &#x3D; event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed &#x3D; false;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mScreenshotChordVolumeDownKeyTriggered &#x3D; false;</span><br><span class="line">                        cancelPendingScreenshotChordAction();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里首先判断当前系统是否已经boot完毕，若尚未启动完毕，则所有的按键操作都将失效，若启动完成，则执行后续的操作，这里我们只是关注音量减少按键和电源按键组合的处理事件。另外这里多说一句想安卓系统的HOME按键事件，MENU按键事件，进程列表按键事件等等都是在这里实现的，后续中我们会陆续介绍这方面的内容。</p>
<p>回到我们的interceptKeyBeforeQueueing方法，当我用按下音量减少按键的时候回进入到：case KeyEvent.KEYCODE_VOLUME_MUTE分支并执行相应的逻辑，然后同时判断用户是否按下了电源键，若同时按下了电源键，则执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered &#x3D; true;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime &#x3D; event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed &#x3D; false;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里的interceptScreenshotChrod方法就是系统准备开始执行截屏操作的开始，我们继续看一下interceptcreenshotChord方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void interceptScreenshotChord() &#123;</span><br><span class="line">        if (mScreenshotChordEnabled</span><br><span class="line">                &amp;&amp; mScreenshotChordVolumeDownKeyTriggered &amp;&amp; mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; !mScreenshotChordVolumeUpKeyTriggered) &#123;</span><br><span class="line">            final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            if (now &lt;&#x3D; mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS</span><br><span class="line">                    &amp;&amp; now &lt;&#x3D; mScreenshotChordPowerKeyTime</span><br><span class="line">                            + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) &#123;</span><br><span class="line">                mScreenshotChordVolumeDownKeyConsumed &#x3D; true;</span><br><span class="line">                cancelPendingPowerKeyAction();</span><br><span class="line"></span><br><span class="line">                mHandler.postDelayed(mScreenshotRunnable, getScreenshotChordLongPressDelay());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们最终会执行发送一个延迟的异步消息，请求执行截屏的操作而这里的延时时间，若当前输入框是打开状态，则延时时间为输入框关闭时间加上系统配置的按键超时时间，若当前输入框没有打开则直接是系统配置的按键超时处理时间，可看一下getScreenshotChordLongPressDelay方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private long getScreenshotChordLongPressDelay() &#123;</span><br><span class="line">        if (mKeyguardDelegate.isShowing()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Double the time it takes to take a screenshot from the keyguard</span><br><span class="line">            return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER *</span><br><span class="line">                    ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">        &#125;</span><br><span class="line">        return ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>回到我们的interceptScreenshotChord方法，发送了异步消息之后系统最终会被我们发送的Runnable对象的run方法执行，这里关于异步消息的逻辑可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/50751687" target="_blank" rel="noopener">android源码解析之（二）–&gt;异步消息机制</a></p>
<p>这样我们看一下Runnable类型的mScreenshotRunnable的run方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable mScreenshotRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            takeScreenshot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体中并未执行其他操作，直接就是调用了takeScreenshot方法，这样我们继续看一下takeScreenshot方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void takeScreenshot() &#123;</span><br><span class="line">        synchronized (mScreenshotLock) &#123;</span><br><span class="line">            if (mScreenshotConnection !&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ComponentName cn &#x3D; new ComponentName(&quot;com.android.systemui&quot;,</span><br><span class="line">                    &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);</span><br><span class="line">            Intent intent &#x3D; new Intent();</span><br><span class="line">            intent.setComponent(cn);</span><br><span class="line">            ServiceConnection conn &#x3D; new ServiceConnection() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">                    synchronized (mScreenshotLock) &#123;</span><br><span class="line">                        if (mScreenshotConnection !&#x3D; this) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Messenger messenger &#x3D; new Messenger(service);</span><br><span class="line">                        Message msg &#x3D; Message.obtain(null, 1);</span><br><span class="line">                        final ServiceConnection myConn &#x3D; this;</span><br><span class="line">                        Handler h &#x3D; new Handler(mHandler.getLooper()) &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void handleMessage(Message msg) &#123;</span><br><span class="line">                                synchronized (mScreenshotLock) &#123;</span><br><span class="line">                                    if (mScreenshotConnection &#x3D;&#x3D; myConn) &#123;</span><br><span class="line">                                        mContext.unbindService(mScreenshotConnection);</span><br><span class="line">                                        mScreenshotConnection &#x3D; null;</span><br><span class="line">                                        mHandler.removeCallbacks(mScreenshotTimeout);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        msg.replyTo &#x3D; new Messenger(h);</span><br><span class="line">                        msg.arg1 &#x3D; msg.arg2 &#x3D; 0;</span><br><span class="line">                        if (mStatusBar !&#x3D; null &amp;&amp; mStatusBar.isVisibleLw())</span><br><span class="line">                            msg.arg1 &#x3D; 1;</span><br><span class="line">                        if (mNavigationBar !&#x3D; null &amp;&amp; mNavigationBar.isVisibleLw())</span><br><span class="line">                            msg.arg2 &#x3D; 1;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            messenger.send(msg);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void onServiceDisconnected(ComponentName name) &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            if (mContext.bindServiceAsUser(</span><br><span class="line">                    intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) &#123;</span><br><span class="line">                mScreenshotConnection &#x3D; conn;</span><br><span class="line">                mHandler.postDelayed(mScreenshotTimeout, 10000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里通过反射机制创建了一个TakeScreenshotService对象然后调用了bindServiceAsUser，这样就创建了TakeScreenshotService服务并在服务创建之后发送了一个异步消息。好了，我们看一下TakeScreenshotService的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TakeScreenshotService extends Service &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;TakeScreenshotService&quot;;</span><br><span class="line"></span><br><span class="line">    private static GlobalScreenshot mScreenshot;</span><br><span class="line"></span><br><span class="line">    private Handler mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    final Messenger callback &#x3D; msg.replyTo;</span><br><span class="line">                    if (mScreenshot &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        mScreenshot &#x3D; new GlobalScreenshot(TakeScreenshotService.this);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mScreenshot.takeScreenshot(new Runnable() &#123;</span><br><span class="line">                        @Override public void run() &#123;</span><br><span class="line">                            Message reply &#x3D; Message.obtain(null, 1);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                callback.send(reply);</span><br><span class="line">                            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, msg.arg1 &gt; 0, msg.arg2 &gt; 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new Messenger(mHandler).getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在在TakeScreenshotService类的定义中有一个Handler成员变量，而我们在启动TakeScreentshowService的时候回发送一个异步消息，这样就会执行mHandler的handleMessage方法，然后在handleMessage方法中我们创建了一个GlobalScreenshow对象，然后执行了takeScreenshot方法，好吧，继续看一下takeScreentshot方法的执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Takes a screenshot of the current display and shows an animation.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to orient the screenshot correctly (and the Surface api seems to take screenshots</span><br><span class="line">        &#x2F;&#x2F; only in the natural orientation of the device :!)</span><br><span class="line">        mDisplay.getRealMetrics(mDisplayMetrics);</span><br><span class="line">        float[] dims &#x3D; &#123;mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels&#125;;</span><br><span class="line">        float degrees &#x3D; getDegreesForRotation(mDisplay.getRotation());</span><br><span class="line">        boolean requiresRotation &#x3D; (degrees &gt; 0);</span><br><span class="line">        if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Get the dimensions of the device in its native orientation</span><br><span class="line">            mDisplayMatrix.reset();</span><br><span class="line">            mDisplayMatrix.preRotate(-degrees);</span><br><span class="line">            mDisplayMatrix.mapPoints(dims);</span><br><span class="line">            dims[0] &#x3D; Math.abs(dims[0]);</span><br><span class="line">            dims[1] &#x3D; Math.abs(dims[1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Take the screenshot</span><br><span class="line">        mScreenBitmap &#x3D; SurfaceControl.screenshot((int) dims[0], (int) dims[1]);</span><br><span class="line">        if (mScreenBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">            notifyScreenshotError(mContext, mNotificationManager);</span><br><span class="line">            finisher.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rotate the screenshot to the current orientation</span><br><span class="line">            Bitmap ss &#x3D; Bitmap.createBitmap(mDisplayMetrics.widthPixels,</span><br><span class="line">                    mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">            Canvas c &#x3D; new Canvas(ss);</span><br><span class="line">            c.translate(ss.getWidth() &#x2F; 2, ss.getHeight() &#x2F; 2);</span><br><span class="line">            c.rotate(degrees);</span><br><span class="line">            c.translate(-dims[0] &#x2F; 2, -dims[1] &#x2F; 2);</span><br><span class="line">            c.drawBitmap(mScreenBitmap, 0, 0, null);</span><br><span class="line">            c.setBitmap(null);</span><br><span class="line">            &#x2F;&#x2F; Recycle the previous bitmap</span><br><span class="line">            mScreenBitmap.recycle();</span><br><span class="line">            mScreenBitmap &#x3D; ss;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Optimizations</span><br><span class="line">        mScreenBitmap.setHasAlpha(false);</span><br><span class="line">        mScreenBitmap.prepareToDraw();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start the post-screenshot animation</span><br><span class="line">        startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里后两个参数：statusBarVisible，navBarVisible是否可见，而这两个参数在我们PhoneWindowManager.takeScreenshot方法传递的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (mStatusBar !&#x3D; null &amp;&amp; mStatusBar.isVisibleLw())</span><br><span class="line">                            msg.arg1 &#x3D; 1;</span><br><span class="line">                        if (mNavigationBar !&#x3D; null &amp;&amp; mNavigationBar.isVisibleLw())</span><br><span class="line">                            msg.arg2 &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>可见若果mStatusBar可见，则传递的statusBarVisible为true，若mNavigationBar可见，则传递的navBarVisible为true。然后我们在截屏的时候判断nStatusBar是否可见，mNavigationBar是否可见，若可见的时候则截屏同样将其截屏出来。继续回到我们的takeScreenshot方法，然后调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Take the screenshot</span><br><span class="line">mScreenBitmap &#x3D; SurfaceControl.screenshot((int) dims[0], (int) dims[1]);</span><br></pre></td></tr></table></figure>
<p>方法，看注释，这里就是执行截屏事件的具体操作了，然后我看一下SurfaceControl.screenshot方法的具体实现，另外这里需要注意的是，截屏之后返回的是一个Bitmap对象，其实熟悉android绘制机制的童鞋应该知道android中所有显示能够显示的东西，在内存中表现都是Bitmap对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap screenshot(int width, int height) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: should take the display as a parameter</span><br><span class="line">        IBinder displayToken &#x3D; SurfaceControl.getBuiltInDisplay(</span><br><span class="line">                SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN);</span><br><span class="line">        return nativeScreenshot(displayToken, new Rect(), width, height, 0, 0, true,</span><br><span class="line">                false, Surface.ROTATION_0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里调用的是nativeScreenshot方法，它是一个native方法，具体的实现在JNI层，这里就不做过多的介绍了。继续回到我们的takeScreenshot方法，在调用了截屏方法screentshot之后，判断是否截屏成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mScreenBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">            notifyScreenshotError(mContext, mNotificationManager);</span><br><span class="line">            finisher.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>若截屏之后，截屏的bitmap对象为空，这里判断截屏失败，调用了notifyScreenshotError方法，发送截屏失败的notification通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void notifyScreenshotError(Context context, NotificationManager nManager) &#123;</span><br><span class="line">        Resources r &#x3D; context.getResources();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Clear all existing notification, compose the new notification and show it</span><br><span class="line">        Notification.Builder b &#x3D; new Notification.Builder(context)</span><br><span class="line">            .setTicker(r.getString(R.string.screenshot_failed_title))</span><br><span class="line">            .setContentTitle(r.getString(R.string.screenshot_failed_title))</span><br><span class="line">            .setContentText(r.getString(R.string.screenshot_failed_text))</span><br><span class="line">            .setSmallIcon(R.drawable.stat_notify_image_error)</span><br><span class="line">            .setWhen(System.currentTimeMillis())</span><br><span class="line">            .setVisibility(Notification.VISIBILITY_PUBLIC) &#x2F;&#x2F; ok to show outside lockscreen</span><br><span class="line">            .setCategory(Notification.CATEGORY_ERROR)</span><br><span class="line">            .setAutoCancel(true)</span><br><span class="line">            .setColor(context.getColor(</span><br><span class="line">                        com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line">        Notification n &#x3D;</span><br><span class="line">            new Notification.BigTextStyle(b)</span><br><span class="line">                .bigText(r.getString(R.string.screenshot_failed_text))</span><br><span class="line">                .build();</span><br><span class="line">        nManager.notify(R.id.notification_screenshot, n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后继续看takeScreenshot方法，判断截屏的图像是否需要旋转，若需要的话，则旋转图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rotate the screenshot to the current orientation</span><br><span class="line">            Bitmap ss &#x3D; Bitmap.createBitmap(mDisplayMetrics.widthPixels,</span><br><span class="line">                    mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">            Canvas c &#x3D; new Canvas(ss);</span><br><span class="line">            c.translate(ss.getWidth() &#x2F; 2, ss.getHeight() &#x2F; 2);</span><br><span class="line">            c.rotate(degrees);</span><br><span class="line">            c.translate(-dims[0] &#x2F; 2, -dims[1] &#x2F; 2);</span><br><span class="line">            c.drawBitmap(mScreenBitmap, 0, 0, null);</span><br><span class="line">            c.setBitmap(null);</span><br><span class="line">            &#x2F;&#x2F; Recycle the previous bitmap</span><br><span class="line">            mScreenBitmap.recycle();</span><br><span class="line">            mScreenBitmap &#x3D; ss;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在takeScreenshot方法的最后若截屏成功，我们调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Start the post-screenshot animation</span><br><span class="line">        startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br></pre></td></tr></table></figure>
<p>开始截屏的动画，好吧，看一下动画效果的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Starts the animation after taking the screenshot</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible,</span><br><span class="line">            boolean navBarVisible) &#123;</span><br><span class="line">        &#x2F;&#x2F; Add the view for the animation</span><br><span class="line">        mScreenshotView.setImageBitmap(mScreenBitmap);</span><br><span class="line">        mScreenshotLayout.requestFocus();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Setup the animation with the screenshot just taken</span><br><span class="line">        if (mScreenshotAnimation !&#x3D; null) &#123;</span><br><span class="line">            mScreenshotAnimation.end();</span><br><span class="line">            mScreenshotAnimation.removeAllListeners();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams);</span><br><span class="line">        ValueAnimator screenshotDropInAnim &#x3D; createScreenshotDropInAnimation();</span><br><span class="line">        ValueAnimator screenshotFadeOutAnim &#x3D; createScreenshotDropOutAnimation(w, h,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br><span class="line">        mScreenshotAnimation &#x3D; new AnimatorSet();</span><br><span class="line">        mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim);</span><br><span class="line">        mScreenshotAnimation.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                &#x2F;&#x2F; Save the screenshot once we have a bit of time now</span><br><span class="line">                saveScreenshotInWorkerThread(finisher);</span><br><span class="line">                mWindowManager.removeView(mScreenshotLayout);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Clear any references to the bitmap</span><br><span class="line">                mScreenBitmap &#x3D; null;</span><br><span class="line">                mScreenshotView.setImageBitmap(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mScreenshotLayout.post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; Play the shutter sound to notify that we&#39;ve taken a screenshot</span><br><span class="line">                mCameraSound.play(MediaActionSound.SHUTTER_CLICK);</span><br><span class="line"></span><br><span class="line">                mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null);</span><br><span class="line">                mScreenshotView.buildLayer();</span><br><span class="line">                mScreenshotAnimation.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，经过着一些列的操作之后我们实现了截屏之后的动画效果了，这里暂时不分析动画效果，我们看一下动画效果之后做了哪些？还记不记的一般情况下我们截屏之后都会收到一个截屏的notification通知？这里应该也是在其AnimatorListenerAdapter的onAnimationEnd方法中实现的，也就是动画执行完成之后，我们看一下其saveScreenshotInWorkerThread方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Creates a new worker thread and saves the screenshot to the media store.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void saveScreenshotInWorkerThread(Runnable finisher) &#123;</span><br><span class="line">        SaveImageInBackgroundData data &#x3D; new SaveImageInBackgroundData();</span><br><span class="line">        data.context &#x3D; mContext;</span><br><span class="line">        data.image &#x3D; mScreenBitmap;</span><br><span class="line">        data.iconSize &#x3D; mNotificationIconSize;</span><br><span class="line">        data.finisher &#x3D; finisher;</span><br><span class="line">        data.previewWidth &#x3D; mPreviewWidth;</span><br><span class="line">        data.previewheight &#x3D; mPreviewHeight;</span><br><span class="line">        if (mSaveInBgTask !&#x3D; null) &#123;</span><br><span class="line">            mSaveInBgTask.cancel(false);</span><br><span class="line">        &#125;</span><br><span class="line">        mSaveInBgTask &#x3D; new SaveImageInBackgroundTask(mContext, data, mNotificationManager,</span><br><span class="line">                R.id.notification_screenshot).execute(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里主要逻辑就是构造了一个SaveImageInBackgroundTask对象，看样子发送截屏成功的通知应该是在这里实现的，我们看一下SaveImageInBackgroundTask构造方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data,</span><br><span class="line">            NotificationManager nManager, int nId) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Show the intermediate notification</span><br><span class="line">        mTickerAddSpace &#x3D; !mTickerAddSpace;</span><br><span class="line">        mNotificationId &#x3D; nId;</span><br><span class="line">        mNotificationManager &#x3D; nManager;</span><br><span class="line">        final long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        mNotificationBuilder &#x3D; new Notification.Builder(context)</span><br><span class="line">            .setTicker(r.getString(R.string.screenshot_saving_ticker)</span><br><span class="line">                    + (mTickerAddSpace ? &quot; &quot; : &quot;&quot;))</span><br><span class="line">            .setContentTitle(r.getString(R.string.screenshot_saving_title))</span><br><span class="line">            .setContentText(r.getString(R.string.screenshot_saving_text))</span><br><span class="line">            .setSmallIcon(R.drawable.stat_notify_image)</span><br><span class="line">            .setWhen(now)</span><br><span class="line">            .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line"></span><br><span class="line">        mNotificationStyle &#x3D; new Notification.BigPictureStyle()</span><br><span class="line">            .bigPicture(picture.createAshmemBitmap());</span><br><span class="line">        mNotificationBuilder.setStyle(mNotificationStyle);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; For &quot;public&quot; situations we want to show all the same info but</span><br><span class="line">        &#x2F;&#x2F; omit the actual screenshot image.</span><br><span class="line">        mPublicNotificationBuilder &#x3D; new Notification.Builder(context)</span><br><span class="line">                .setContentTitle(r.getString(R.string.screenshot_saving_title))</span><br><span class="line">                .setContentText(r.getString(R.string.screenshot_saving_text))</span><br><span class="line">                .setSmallIcon(R.drawable.stat_notify_image)</span><br><span class="line">                .setCategory(Notification.CATEGORY_PROGRESS)</span><br><span class="line">                .setWhen(now)</span><br><span class="line">                .setColor(r.getColor(</span><br><span class="line">                        com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line"></span><br><span class="line">        mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());</span><br><span class="line"></span><br><span class="line">        Notification n &#x3D; mNotificationBuilder.build();</span><br><span class="line">        n.flags |&#x3D; Notification.FLAG_NO_CLEAR;</span><br><span class="line">        mNotificationManager.notify(nId, n);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; On the tablet, the large icon makes the notification appear as if it is clickable (and</span><br><span class="line">        &#x2F;&#x2F; on small devices, the large icon is not shown) so defer showing the large icon until</span><br><span class="line">        &#x2F;&#x2F; we compose the final post-save notification below.</span><br><span class="line">        mNotificationBuilder.setLargeIcon(icon.createAshmemBitmap());</span><br><span class="line">        &#x2F;&#x2F; But we still don&#39;t set it for the expanded view, allowing the smallIcon to show here.</span><br><span class="line">        mNotificationStyle.bigLargeIcon((Bitmap) null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在构造方法的后面狗仔了一个NotificationBuilder对象，然后发送了一个截屏成功的Notification，这样我们在截屏动画之后就收到了Notification的通知了。</p>
<p>总结：</p>
<ul>
<li><p>在PhoneWindowManager的dispatchUnhandledKey方法中处理App无法处理的按键事件，当然也包括音量减少键和电源按键的组合按键</p>
</li>
<li><p>通过一系列的调用启动TakeScreenshotService服务，并通过其执行截屏的操作。</p>
</li>
<li><p>具体的截屏代码是在native层实现的。</p>
</li>
<li><p>截屏操作时候，若截屏失败则直接发送截屏失败的notification通知。</p>
</li>
<li><p>截屏之后，若截屏成功，则先执行截屏的动画，并在动画效果执行完毕之后，发送截屏成功的notification的通知。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/25%20onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/25%20onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">25 onLowMemory执行流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上篇文章中我们分析了Activity的onSaveInstanceState方法执行时机，知道了Activity在一般情况下，若只是执行onPause方法则不会执行onSaveInstanceState方法，而一旦执行了onStop方法就会执行onSaveInstanceState方法，具体的信息，可以参见onSaveInstanceState方法执行时机：<a href="http://blog.csdn.net/qq_23547831/article/details/51464535" target="_blank" rel="noopener">android源码解析（二十四）–&gt;onSaveInstanceState执行时机</a> 这篇文章中同样的我们分析一下Actvity（当然不只是Activity，同样包含Servier，ContentProvider，Application等）的另一个内部方法：onLowMemory。该方法主要用于当前系统可用内存比较低的时候回调使用。</p>
<p>这里简单介绍一下Android系统的内存分配机制。Android系统中一个个的App都是一个个不同的应用进程，拥有各自的JVM与运行时，每个App的进程可使用的内存大小都是固定的，当系统中App打开数量过多时，就会使Android系统的可用内存降低，对于当前正在使用的App而言，可能还需要继续申请系统内存，而我们的剩余系统内存已经不足以被当前App所申请了，这时候系统会自动的清理那些后台进程，进而释放出可用内存用于前台进程的使用，当然这里系统清理后台进程的算法不是我们讨论的重点。这里我们只是大概的分析Android系统回调Activity的onLowMemory方法的流程。</p>
<p>通过前面关于Activity的启动流程分析我们知道ActivityManagerService是整个Android系统的管理中枢，负责Activity，Servier等四大组件的启动与销毁等工作，同样的对于应用进程的管理工作也是在ActivityMaangerServier中完成的，我们知道android系统中有两个比较重要的进程Zygote进程和SystemServer进程，其中Zygote进程是整个Android系统的根进程，其他所有的进程都是通过Zygote进程fork出来的。而SystemServer进程则用于运行各种服务，为其他的应用进程提供各种功能接口等，在前面我们分析过SystemServer进程的启动流程（参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51105171" target="_blank" rel="noopener"> android源码解析之（九）–&gt;SystemServer进程启动流程</a>）其中在SystemServer的startBootService方法中我们调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Set up the Application instance for the system process and get started.</span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br></pre></td></tr></table></figure>
<p>方法，看其注释说明，说的是为System进程初始化Application实例，这里我们可以看一下该方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void setSystemProcess() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);</span><br><span class="line">            ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">            ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this));</span><br><span class="line">            ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this));</span><br><span class="line">            ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this));</span><br><span class="line">            if (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">                ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this));</span><br><span class="line">            &#125;</span><br><span class="line">            ServiceManager.addService(&quot;permission&quot;, new PermissionController(this));</span><br><span class="line">            ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this));</span><br><span class="line"></span><br><span class="line">            ApplicationInfo info &#x3D; mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                    &quot;android&quot;, STOCK_PM_FLAGS);</span><br><span class="line">            mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                ProcessRecord app &#x3D; newProcessRecordLocked(info, info.processName, false, 0);</span><br><span class="line">                app.persistent &#x3D; true;</span><br><span class="line">                app.pid &#x3D; MY_PID;</span><br><span class="line">                app.maxAdj &#x3D; ProcessList.SYSTEM_ADJ;</span><br><span class="line">                app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">                synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                    mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">                &#125;</span><br><span class="line">                updateLruProcessLocked(app, false, null);</span><br><span class="line">                updateOomAdjLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find android system package&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里简单介绍一下ServierManager是一个管理服务的服务，而其addServier方法就是注册各种服务（服务注册到JNI层，具体的关于是如何注册到JNI层的这里暂不做过多的解释）。可以发现在方法体中我们注册了名称为：memInfo的服务MemBinder，MemBinder是一个Binder类型的服务，主要用于检测系统内存情况，这里可以看一下其具体的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static class MemBinder extends Binder &#123;</span><br><span class="line">        ActivityManagerService mActivityManagerService;</span><br><span class="line">        MemBinder(ActivityManagerService activityManagerService) &#123;</span><br><span class="line">            mActivityManagerService &#x3D; activityManagerService;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123;</span><br><span class="line">            if (mActivityManagerService.checkCallingPermission(android.Manifest.permission.DUMP)</span><br><span class="line">                    !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                pw.println(&quot;Permission Denial: can&#39;t dump meminfo from from pid&#x3D;&quot;</span><br><span class="line">                        + Binder.getCallingPid() + &quot;, uid&#x3D;&quot; + Binder.getCallingUid()</span><br><span class="line">                        + &quot; without permission &quot; + android.Manifest.permission.DUMP);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, &quot;  &quot;, args, false, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看源码，我们可以发现MemBinder类继承于Binder类也就是说其实一个Binder类型的服务，并且有一个成员方法dump，该方法主要用于执行shell命令，当系统可用内存比较低的时候就会执行了该方法，然后回调到ActivityManagerService中的killAllBackground方法，下面我们重点看一下killAllBackground方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void killAllBackgroundProcesses() &#123;</span><br><span class="line">        ...</span><br><span class="line">           doLowMemReportIfNeededLocked(null);</span><br><span class="line">        ...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(callingId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法体中会执行doLowMemReportIfNeededLocked方法，该方法是做什么的呢?我们继续看一下doLowMemReportIfNeededLoced方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) &#123;</span><br><span class="line">        ...</span><br><span class="line">        scheduleAppGcsLocked();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，在这个方法中我们又调用了scheduleAppGcsLocked方法，这样我们就继续看一下scheduleAppGcsLocked方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Schedule the execution of all pending app GCs.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void scheduleAppGcsLocked() &#123;</span><br><span class="line">        mHandler.removeMessages(GC_BACKGROUND_PROCESSES_MSG);</span><br><span class="line"></span><br><span class="line">        if (mProcessesToGc.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Schedule a GC for the time to the next process.</span><br><span class="line">            ProcessRecord proc &#x3D; mProcessesToGc.get(0);</span><br><span class="line">            Message msg &#x3D; mHandler.obtainMessage(GC_BACKGROUND_PROCESSES_MSG);</span><br><span class="line"></span><br><span class="line">            long when &#x3D; proc.lastRequestedGc + GC_MIN_INTERVAL;</span><br><span class="line">            long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            if (when &lt; (now+GC_TIMEOUT)) &#123;</span><br><span class="line">                when &#x3D; now + GC_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line">            mHandler.sendMessageAtTime(msg, when);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里执行的逻辑就是通过mHandler发送一个msg.what为GC_BACKGROUND_PROCESSES_MSG的异步消息，这样消息体最终会被mHandler的handleMessage方法所执行，继续看一下mHandler的handleMessage方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case GC_BACKGROUND_PROCESSES_MSG: &#123;</span><br><span class="line">                synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                    performAppGcsIfAppropriateLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br></pre></td></tr></table></figure>
<p>在mHandler的handleMessage方法中，首先会判断msg的what是否为GC_BACKGROUND_PROCESSES_MSG，然后会执行performAppGcsIfAppropriateLocked方法，这样我们继续看一下performAppGcsIfAppropriateLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * If all looks good, perform GCs on all processes waiting for them.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void performAppGcsIfAppropriateLocked() &#123;</span><br><span class="line">        if (canGcNowLocked()) &#123;</span><br><span class="line">            performAppGcsLocked();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Still not idle, wait some more.</span><br><span class="line">        scheduleAppGcsLocked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里首先判断是否能够执行gc操作，若不能继续执行上面的scheduleAppGcsLocked方法，然后继续执行发送异步消息的逻辑，直到变量canGcNowLocked为true，并执行performAppGcsLocked方法，然后return掉，这样我们继续跟踪代码，看一下performAppGcsLocked方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Perform GCs on all processes that are waiting for it, but only</span><br><span class="line">     * if things are idle.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void performAppGcsLocked() &#123;</span><br><span class="line">        final int N &#x3D; mProcessesToGc.size();</span><br><span class="line">        if (N &lt;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (canGcNowLocked()) &#123;</span><br><span class="line">            while (mProcessesToGc.size() &gt; 0) &#123;</span><br><span class="line">                ProcessRecord proc &#x3D; mProcessesToGc.remove(0);</span><br><span class="line">                if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory) &#123;</span><br><span class="line">                    if ((proc.lastRequestedGc+GC_MIN_INTERVAL)</span><br><span class="line">                            &lt;&#x3D; SystemClock.uptimeMillis()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; To avoid spamming the system, we will GC processes one</span><br><span class="line">                        &#x2F;&#x2F; at a time, waiting a few seconds between each.</span><br><span class="line">                        performAppGcLocked(proc);</span><br><span class="line">                        scheduleAppGcsLocked();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; It hasn&#39;t been long enough since we last GCed this</span><br><span class="line">                        &#x2F;&#x2F; process...  put it in the list to wait for its time.</span><br><span class="line">                        addProcessToGcListLocked(proc);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scheduleAppGcsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现该方法经过一系列的逻辑判断之后会执行performAppGcLocked方法，我们继续看一下该方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Ask a given process to GC right now.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final void performAppGcLocked(ProcessRecord app) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            app.lastRequestedGc &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            if (app.thread !&#x3D; null) &#123;</span><br><span class="line">                if (app.reportLowMemory) &#123;</span><br><span class="line">                    app.reportLowMemory &#x3D; false;</span><br><span class="line">                    app.thread.scheduleLowMemory();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    app.thread.processInBackground();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F; whatever.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现最终执行的是app.thread.scheduleLowMemory方法，而这里的app.thread是ActivityThread.ApplicationThread对象，所以这里最终是通过Binder进程间通讯，执行的是ActivityThread.ApplicationThread的scheduleLowMemory方法，好吧让我们看一下ActivityThread.ApplicationThread的scheduleLowMemory<br>方法的实现逻辑…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void scheduleLowMemory() &#123;</span><br><span class="line">            sendMessage(H.LOW_MEMORY, null);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在ActivityThread中的scheduleLowMemory方法中并没有执行额外逻辑，而是直接调用了sendMessage方法，继续跟踪方法的执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">        Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.what &#x3D; what;</span><br><span class="line">        msg.obj &#x3D; obj;</span><br><span class="line">        msg.arg1 &#x3D; arg1;</span><br><span class="line">        msg.arg2 &#x3D; arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在sendMessage方法中最终通过一个Handler类型的mH成员变量发送一个异步消息，这样异步消息最终会被mH的handleMessage方法执行。。。。，经过查看源代码我们知道在mH的handleMessage方法中最终调用的是handleLowMemory方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final void handleLowMemory() &#123;</span><br><span class="line">        ArrayList&lt;ComponentCallbacks2&gt; callbacks &#x3D; collectComponentCallbacks(true, null);</span><br><span class="line"></span><br><span class="line">        final int N &#x3D; callbacks.size();</span><br><span class="line">        for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">            callbacks.get(i).onLowMemory();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Ask SQLite to free up as much memory as it can, mostly from its page caches.</span><br><span class="line">        if (Process.myUid() !&#x3D; Process.SYSTEM_UID) &#123;</span><br><span class="line">            int sqliteReleased &#x3D; SQLiteDatabase.releaseMemory();</span><br><span class="line">            EventLog.writeEvent(SQLITE_MEM_RELEASED_EVENT_LOG_TAG, sqliteReleased);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Ask graphics to free up as much as possible (font&#x2F;image caches)</span><br><span class="line">        Canvas.freeCaches();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Ask text layout engine to free also as much as possible</span><br><span class="line">        Canvas.freeTextLayoutCaches();</span><br><span class="line"></span><br><span class="line">        BinderInternal.forceGc(&quot;mem&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里通过遍历ComponentCallbacks2并执行了其onLowMemory方法，那么这里的ComponentCallBacks2是什么呢？这里我们查看一下collectComponentCallbacks方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ComponentCallbacks2&gt; collectComponentCallbacks(</span><br><span class="line">            boolean allActivities, Configuration newConfig) &#123;</span><br><span class="line">        ArrayList&lt;ComponentCallbacks2&gt; callbacks</span><br><span class="line">                &#x3D; new ArrayList&lt;ComponentCallbacks2&gt;();</span><br><span class="line"></span><br><span class="line">        synchronized (mResourcesManager) &#123;</span><br><span class="line">            final int NAPP &#x3D; mAllApplications.size();</span><br><span class="line">            for (int i&#x3D;0; i&lt;NAPP; i++) &#123;</span><br><span class="line">                callbacks.add(mAllApplications.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            final int NACT &#x3D; mActivities.size();</span><br><span class="line">            for (int i&#x3D;0; i&lt;NACT; i++) &#123;</span><br><span class="line">                ActivityClientRecord ar &#x3D; mActivities.valueAt(i);</span><br><span class="line">                Activity a &#x3D; ar.activity;</span><br><span class="line">                if (a !&#x3D; null) &#123;</span><br><span class="line">                    Configuration thisConfig &#x3D; applyConfigCompatMainThread(</span><br><span class="line">                            mCurDefaultDisplayDpi, newConfig,</span><br><span class="line">                            ar.packageInfo.getCompatibilityInfo());</span><br><span class="line">                    if (!ar.activity.mFinished &amp;&amp; (allActivities || !ar.paused)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; If the activity is currently resumed, its configuration</span><br><span class="line">                        &#x2F;&#x2F; needs to change right now.</span><br><span class="line">                        callbacks.add(a);</span><br><span class="line">                    &#125; else if (thisConfig !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Otherwise, we will tell it about the change</span><br><span class="line">                        &#x2F;&#x2F; the next time it is resumed or shown.  Note that</span><br><span class="line">                        &#x2F;&#x2F; the activity manager may, before then, decide the</span><br><span class="line">                        &#x2F;&#x2F; activity needs to be destroyed to handle its new</span><br><span class="line">                        &#x2F;&#x2F; configuration.</span><br><span class="line">                        if (DEBUG_CONFIGURATION) &#123;</span><br><span class="line">                            Slog.v(TAG, &quot;Setting activity &quot;</span><br><span class="line">                                    + ar.activityInfo.name + &quot; newConfig&#x3D;&quot; + thisConfig);</span><br><span class="line">                        &#125;</span><br><span class="line">                        ar.newConfig &#x3D; thisConfig;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            final int NSVC &#x3D; mServices.size();</span><br><span class="line">            for (int i&#x3D;0; i&lt;NSVC; i++) &#123;</span><br><span class="line">                callbacks.add(mServices.valueAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (mProviderMap) &#123;</span><br><span class="line">            final int NPRV &#x3D; mLocalProviders.size();</span><br><span class="line">            for (int i&#x3D;0; i&lt;NPRV; i++) &#123;</span><br><span class="line">                callbacks.add(mLocalProviders.valueAt(i).mLocalProvider);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return callbacks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现该方法最终返回类型为ArrayList<ComponentCallbacks2>类型的callBacks而我们的callBacks中保存的是我们应用进程中的Activity，Service，Provider已经Application等。咦？Activity，Service，Provider，Application都是ComponentCallBacks2类型的么？我们看一看一下具体的定义：</p>
<p>Actvity的类定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Activity extends ContextThemeWrapper</span><br><span class="line">        implements LayoutInflater.Factory2,</span><br><span class="line">        Window.Callback, KeyEvent.Callback,</span><br><span class="line">        OnCreateContextMenuListener, ComponentCallbacks2,</span><br><span class="line">        Window.OnWindowDismissedCallback</span><br></pre></td></tr></table></figure>
<p>Service的类定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Service extends ContextWrapper implements ComponentCallbacks2</span><br></pre></td></tr></table></figure>

<p>ContentProvider的类定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ContentProvider implements ComponentCallbacks2</span><br></pre></td></tr></table></figure>
<p>Application的类定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Application extends ContextWrapper implements ComponentCallbacks2</span><br></pre></td></tr></table></figure>
<p>可以发现其都是继承与ComponentCalbacks2，所以其都可以被当做是ComponentCallbacks2类型的变量。而同样是四大组件的BroadcastReceiver，我们可以下其类定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BroadcastReceiver</span><br></pre></td></tr></table></figure>
<p>可以看到其并未继承与ComponentCallbacks2，所以并未执行，所以通过这样的分析，我们知道了，最终应用程序中的Activity，Servier，ContentProvider，Application的onLowMemory方法会被执行。而由于我们是在系统内存紧张的时候会执行killAllBackground方法进而通过层层条用执行Activity、Service、ContentProvider、Application的onLowMemory方法，所以我们可以在这些组件的onLowMemory方法中执行了一些清理资源的操作，释放一些内存，尽量保证自身的应用进程不被杀死。</p>
<p>总结：</p>
<ul>
<li><p>系统在JNI层会时时检测内存变量，当内存过低时会通过kiilbackground的方法清理后台进程。</p>
</li>
<li><p>经过层层的调用过程最终会执行Activity、Service、ContentProvider、Application的onLowMemory方法。</p>
</li>
<li><p>可以在组件的onLowMemory方法中执行一些清理资源的操作，释放内存防止进程被杀死。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/24%20onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/24%20onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/" class="post-title-link" itemprop="url">24 onSaveInstanceState执行时机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。<br>可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍：</p>
<blockquote>
<p>This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state.  For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}.</p>
</blockquote>
<p>可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。</p>
<p>通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。</p>
<p>Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考:<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener"> android源码解析之（十四）–&gt;Activity启动流程</a>，文章中有对Activity生命周期的详细讲解。</p>
<p>好吧，先具体看一下ActivityThread.handlePauseActivity的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;Slog.v(TAG, &quot;userLeaving&#x3D;&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        return r !&#x3D; null ? performPauseActivity(r, finished, saveState) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(ActivityClientRecord r, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">            callCallActivityOnSaveInstanceState(r);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里调用了callCallActivityOnSaveInstanceState方法，看名称可以发现这里应该回调的是Activity的onSaveInstanceState方法，但是这里执行之前有一个条件判断，首先会判断这里的Activity是否被finish？应为这时候刚刚执行onPause方法所以这里的mFinished变量为false，所以判断执行callCallActivityOnSaveInstanceState方法只要需要通过saveState变量来判断了，而这里的saveState方法是performPauseActivity方法传递过来的。。。。好吧，我们来看一下调用performPauseActivity方法时saveState变量是如何赋值的。回到我们的handlePauseActivity方法，看一下performPauseActivity方法是如何调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performPauseActivity(token, finished, r.isPreHoneycomb());</span><br></pre></td></tr></table></figure>
<p>可以发现saveState boolean变量是通过r.isPreHoneycomb方法赋值的，这里我们看一下IsPreHoneycomb方法是如何实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPreHoneycomb() &#123;</span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                return activity.getApplicationInfo().targetSdkVersion</span><br><span class="line">                        &lt; android.os.Build.VERSION_CODES.HONEYCOMB;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现当我们的App设置的targetSdk版本号小于android versionCode 11也就是android3.0的时候返回为true，其他的时候返回为false，也就是说当我们App设置的targetVersion大于android3.0的时候才会执行callCallActivityOnSaveInstanceState方法，好吧，继续看一下callCallActivityOnSaveInstanceState方法是如何实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123;</span><br><span class="line">        r.state &#x3D; new Bundle();</span><br><span class="line">        r.state.setAllowFds(false);</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">            r.persistentState &#x3D; new PersistableBundle();</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现方法体主要调用了mInstrumentation的callActivityOnSaveInstanceState方法，既然这样，我们再来看一下callActivityOnSaveInstanceState方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnSaveInstanceState(Activity activity, Bundle outState,</span><br><span class="line">            PersistableBundle outPersistentState) &#123;</span><br><span class="line">        activity.performSaveInstanceState(outState, outPersistentState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里方法体中又回调了Activity的performSaveInstanceState方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void performSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">        onSaveInstanceState(outState);</span><br><span class="line">        saveManagedDialogs(outState);</span><br><span class="line">        mActivityTransitionState.saveState(outState);</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里回调了Activity的onSaveInstanceState方法，这样经过一系列的方法回调之后我们就执行了onSaveInstanceState方法。</p>
<p>这样我们当只执行onPause方法的时候一般通过设置targetVersion控制是否执行onSaveInstanceState方法，当设置的targetVersionCode大于android3.0的时候默认不会执行onSaveInstanceState方法。</p>
<p>然后我们看一下当Activity执行onStop方法的时候是否会执行onSaveInstanceState方法，通过之前分析的Activity的启动流程，我们知道Actvitiy执行onStop方法会回调ActivityThread的handleStopActivity，这样我们先看一下handleStopActivity方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopActivity(IBinder token, boolean show, int configChanges) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line"></span><br><span class="line">        StopInfo info &#x3D; new StopInfo();</span><br><span class="line">        performStopActivityInner(r, info, show, true);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">            TAG, &quot;Finishing stop of &quot; + r + &quot;: show&#x3D;&quot; + show</span><br><span class="line">            + &quot; win&#x3D;&quot; + r.window);</span><br><span class="line"></span><br><span class="line">        updateVisibility(r, show);</span><br><span class="line"></span><br><span class="line">        info.activity &#x3D; r;</span><br><span class="line">        info.state &#x3D; r.state;</span><br><span class="line">        info.persistentState &#x3D; r.persistentState;</span><br><span class="line">        mH.post(info);</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们发现在方法performStopActivity方法中调用了performStopActivityInner方法，我们继续看一下performStopActivityInner方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void performStopActivityInner(ActivityClientRecord r,</span><br><span class="line">            StopInfo info, boolean keepShown, boolean saveState) &#123;</span><br><span class="line">        ...</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">                if (r.state &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    callCallActivityOnSaveInstanceState(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现还是通过saveState变量来控制是否调用onSaveInstanceState，而这里的saveState变量是在performStopActivityInner方法调用的时候传递的，回到我们的handleStopActivity方法中关于performStopActivityInner调用的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performStopActivityInner(r, info, show, true);</span><br></pre></td></tr></table></figure>
<p>好吧，这里直接传值为true，这样我们执行Activity的stop方法一定执行onSaveInstanceState方法。</p>
<p>总结</p>
<ul>
<li><p>onSaveInstanceState方法是Activity的生命周期方法，主要用于在Activity销毁时保存一些信息。</p>
</li>
<li><p>当Activity只执行onPause方法时（Activity a打开一个透明Activity b）这时候如果App设置的targetVersion大于android3.0则不会执行onSaveInstanceState方法。</p>
</li>
<li><p>当Activity执行onStop方法时，通过分析源码我们知道调用onSaveInstanceState的方法直接传值为true，所以都会执行onSaveInstanceState方法。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/23%20Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/23%20Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">23 Android异常处理流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面的几篇文章都是讲解的android中的窗口显示机制，包括Activity窗口加载绘制流程，Dialog窗口加载绘制流程，PopupWindow窗口加载绘制流程，Toast窗口加载绘制流程等等。整个Android的界面显示的原理都是类似的，都是通过Window对象控制View组件，实现加载与绘制流程。</p>
<p>这篇文章休息一下，不在讲解Android的窗口绘制机制，穿插的讲解一下Android系统的异常处理流程。O(∩_∩)O哈哈~</p>
<p>开发过android项目的童鞋对android系统中错误弹窗，force close应该不陌生了，当我们的App异常崩溃时，就会弹出一个force close的弹窗，告诉我们App崩溃，以及一下简易的错误信息：<br><img src="http://img.blog.csdn.net/20160512110851449" alt="这里写图片描述"></p>
<p>那么这里的force close弹窗是如何弹出的呢？</p>
<p>还有我们在开发App的过程中，经常会自定义Application，自定义UncaughtExceptionHandler实现App的全局异常处理，那么这里的UncaughtExceptionHandler是如何实现对异常的全局处理的呢？（可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/41725069" target="_blank" rel="noopener"> 在Android中自定义捕获Application全局异常</a>）</p>
<p>带着这两个问题，我们开始今天的异常流程分析。</p>
<p>在android应用进程的启动流程中我们在经过一系列的操作之后会调用RuntimeInit.zygoteInit方法（可参考：<a href="http://blog.csdn.net/luoshengyang/article/details/6747696" target="_blank" rel="noopener">Android应用程序进程启动过程的源代码分析</a>）</p>
<p>而我们也是从这里开始分析我们的Android系统异常处理流程，好了，让我们先来看一下zygoteInit方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</span><br><span class="line">        redirectLogStreams();</span><br><span class="line"></span><br><span class="line">        commonInit();</span><br><span class="line">        nativeZygoteInit();</span><br><span class="line">        applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中我们调用了commonInit方法，这个方法是用于初始化操作的，继续看一下commonInit方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final void commonInit() &#123;</span><br><span class="line">        ...</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这里我们调用了Thread.setDefaultUncaughtExceptionHandler方法，这样当我们的进程出现异常的时候，异常信息就会被我们新创建的UncaughtHandler所捕获。</p>
<p>看过我们前面写过的关于Android全局异常处理文章的童鞋应该知道，我们实现对Android异常全局处理的操作也是通过设置Thread.setDefaultUncaughtExceptionHandler来实现的，具体可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/41725069" target="_blank" rel="noopener"> 在Android中自定义捕获Application全局异常</a><br>所以Android系统默认的异常信息都会被这里的UncaughtHandler所捕获并被其uncaughtException方法回调，所以若我们不重写Thread.setDefaultUncaughtExceptionHandler方法，那么这里的UncaughtHandler就是我们默认的异常处理操作 这样我们看一下UncaughtHandler的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static class UncaughtHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">        public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t re-enter -- avoid infinite loops if crash-reporting crashes.</span><br><span class="line">                if (mCrashing) return;</span><br><span class="line">                mCrashing &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (mApplicationObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    Clog_e(TAG, &quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot; + t.getName(), e);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    StringBuilder message &#x3D; new StringBuilder();</span><br><span class="line">                    message.append(&quot;FATAL EXCEPTION: &quot;).append(t.getName()).append(&quot;\n&quot;);</span><br><span class="line">                    final String processName &#x3D; ActivityThread.currentProcessName();</span><br><span class="line">                    if (processName !&#x3D; null) &#123;</span><br><span class="line">                        message.append(&quot;Process: &quot;).append(processName).append(&quot;, &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    message.append(&quot;PID: &quot;).append(Process.myPid());</span><br><span class="line">                    Clog_e(TAG, message.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Bring up crash dialog, wait for it to be dismissed</span><br><span class="line">                ActivityManagerNative.getDefault().handleApplicationCrash(</span><br><span class="line">                        mApplicationObject, new ApplicationErrorReport.CrashInfo(e));</span><br><span class="line">            &#125; catch (Throwable t2) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Clog_e(TAG, &quot;Error reporting crash&quot;, t2);</span><br><span class="line">                &#125; catch (Throwable t3) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Even Clog_e() fails!  Oh well.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; Try everything to make sure this process goes away.</span><br><span class="line">                Process.killProcess(Process.myPid());</span><br><span class="line">                System.exit(10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里uncaughtException方法最终会被执行异常信息的处理，我们看一下在这里我们调用了ActivityManagerNative.getDefault().handleApplicationCrash方法，看过我们前面Activity启动流程的童鞋应该知道这里的ActivityManagerNative其实是ActivityManagerService的Binder客户端，而这里的handleApplicationCrash方法最终会调用的是ActivityManagerService的handleApplicationCrash方法。最后在finally分之中，我们调用了Process.killProcess(Process.myPid)和System.exit(10)，这样我们的应用进程就会退出了。</p>
<p>然后我们在这里先简单的分析一下Binder的数据传输过程，看一下handleApplicationCrash方法具体做了哪些事，首先看一下ActivityManagerNative的getDefault方法是如何实现的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">        return gDefault.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，其是一个静态方法，并执行了gDefault.get方法，我们在看一下gDefault.get方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        protected IActivityManager create() &#123;</span><br><span class="line">            IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder &#x3D; &quot; + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am &#x3D; asInterface(b);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service &#x3D; &quot; + am);</span><br><span class="line">            &#125;</span><br><span class="line">            return am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现这里返回一个IActivityManager类型的am对象，而这个am对象是通过调用asInterface方法创建的，我们再来看一下这个asInterface方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager in &#x3D;</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现该方法最终返回的是一个ActivityManagerProxy对象，所以ActivityManagerNative.getDefault()方法最终返回的是一个ActivityManagerProxy对象，我们再来看一下ActivityManagerProxy的handleApplicationCrash方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void handleApplicationCrash(IBinder app,</span><br><span class="line">            ApplicationErrorReport.CrashInfo crashInfo) throws RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(app);</span><br><span class="line">        crashInfo.writeToParcel(data, 0);</span><br><span class="line">        mRemote.transact(HANDLE_APPLICATION_CRASH_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.readException();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是具体的Binder传输数据的逻辑了，这里ActivityManagerNative最为Binder的clent端，而我们的ActivityManagerService同样是继承与ActivityManagerNative，最为Binder的server端，通过传输最终ActivityManagerService的handleApplicationCrash方法会被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        ProcessRecord r &#x3D; findAppProcess(app, &quot;Crash&quot;);</span><br><span class="line">        final String processName &#x3D; app &#x3D;&#x3D; null ? &quot;system_server&quot;</span><br><span class="line">                : (r &#x3D;&#x3D; null ? &quot;unknown&quot; : r.processName);</span><br><span class="line"></span><br><span class="line">        handleApplicationCrashInner(&quot;crash&quot;, r, processName, crashInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ActivityManagerService的handleApplicationCrash方法中我们调用了handleApplicationCreashInner方法，这样我们继续看一下handleApplicationCrashInner方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName,</span><br><span class="line">            ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(),</span><br><span class="line">                UserHandle.getUserId(Binder.getCallingUid()), processName,</span><br><span class="line">                r &#x3D;&#x3D; null ? -1 : r.info.flags,</span><br><span class="line">                crashInfo.exceptionClassName,</span><br><span class="line">                crashInfo.exceptionMessage,</span><br><span class="line">                crashInfo.throwFileName,</span><br><span class="line">                crashInfo.throwLineNumber);</span><br><span class="line"></span><br><span class="line">        addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);</span><br><span class="line"></span><br><span class="line">        crashApplication(r, crashInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在handleApplicationCrashInner方法中主要调用了两个方法addErrorToDropBox和crashApplication，我们首先看一下addErrorToDropBox方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">public void addErrorToDropBox(String eventType,</span><br><span class="line">            ProcessRecord process, String processName, ActivityRecord activity,</span><br><span class="line">            ActivityRecord parent, String subject,</span><br><span class="line">            final String report, final File logFile,</span><br><span class="line">            final ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        &#x2F;&#x2F; NOTE -- this must never acquire the ActivityManagerService lock,</span><br><span class="line">        &#x2F;&#x2F; otherwise the watchdog may be prevented from resetting the system.</span><br><span class="line"></span><br><span class="line">        final String dropboxTag &#x3D; processClass(process) + &quot;_&quot; + eventType;</span><br><span class="line">        final DropBoxManager dbox &#x3D; (DropBoxManager)</span><br><span class="line">                mContext.getSystemService(Context.DROPBOX_SERVICE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Exit early if the dropbox isn&#39;t configured to accept this report type.</span><br><span class="line">        if (dbox &#x3D;&#x3D; null || !dbox.isTagEnabled(dropboxTag)) return;</span><br><span class="line"></span><br><span class="line">        final StringBuilder sb &#x3D; new StringBuilder(1024);</span><br><span class="line">        appendDropBoxProcessHeaders(process, processName, sb);</span><br><span class="line">        if (activity !&#x3D; null) &#123;</span><br><span class="line">            sb.append(&quot;Activity: &quot;).append(activity.shortComponentName).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent !&#x3D; null &amp;&amp; parent.app !&#x3D; null &amp;&amp; parent.app.pid !&#x3D; process.pid) &#123;</span><br><span class="line">            sb.append(&quot;Parent-Process: &quot;).append(parent.app.processName).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent !&#x3D; null &amp;&amp; parent !&#x3D; activity) &#123;</span><br><span class="line">            sb.append(&quot;Parent-Activity: &quot;).append(parent.shortComponentName).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subject !&#x3D; null) &#123;</span><br><span class="line">            sb.append(&quot;Subject: &quot;).append(subject).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;Build: &quot;).append(Build.FINGERPRINT).append(&quot;\n&quot;);</span><br><span class="line">        if (Debug.isDebuggerConnected()) &#123;</span><br><span class="line">            sb.append(&quot;Debugger: Connected\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Do the rest in a worker thread to avoid blocking the caller on I&#x2F;O</span><br><span class="line">        &#x2F;&#x2F; (After this point, we shouldn&#39;t access AMS internal data structures.)</span><br><span class="line">        Thread worker &#x3D; new Thread(&quot;Error dump: &quot; + dropboxTag) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (report !&#x3D; null) &#123;</span><br><span class="line">                    sb.append(report);</span><br><span class="line">                &#125;</span><br><span class="line">                if (logFile !&#x3D; null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        sb.append(FileUtils.readTextFile(logFile, DROPBOX_MAX_SIZE,</span><br><span class="line">                                    &quot;\n\n[[TRUNCATED]]&quot;));</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        Slog.e(TAG, &quot;Error reading &quot; + logFile, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (crashInfo !&#x3D; null &amp;&amp; crashInfo.stackTrace !&#x3D; null) &#123;</span><br><span class="line">                    sb.append(crashInfo.stackTrace);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String setting &#x3D; Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag;</span><br><span class="line">                int lines &#x3D; Settings.Global.getInt(mContext.getContentResolver(), setting, 0);</span><br><span class="line">                if (lines &gt; 0) &#123;</span><br><span class="line">                    sb.append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Merge several logcat streams, and take the last N lines</span><br><span class="line">                    InputStreamReader input &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        java.lang.Process logcat &#x3D; new ProcessBuilder(&quot;&#x2F;system&#x2F;bin&#x2F;logcat&quot;,</span><br><span class="line">                                &quot;-v&quot;, &quot;time&quot;, &quot;-b&quot;, &quot;events&quot;, &quot;-b&quot;, &quot;system&quot;, &quot;-b&quot;, &quot;main&quot;,</span><br><span class="line">                                &quot;-b&quot;, &quot;crash&quot;,</span><br><span class="line">                                &quot;-t&quot;, String.valueOf(lines)).redirectErrorStream(true).start();</span><br><span class="line"></span><br><span class="line">                        try &#123; logcat.getOutputStream().close(); &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">                        try &#123; logcat.getErrorStream().close(); &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">                        input &#x3D; new InputStreamReader(logcat.getInputStream());</span><br><span class="line"></span><br><span class="line">                        int num;</span><br><span class="line">                        char[] buf &#x3D; new char[8192];</span><br><span class="line">                        while ((num &#x3D; input.read(buf)) &gt; 0) sb.append(buf, 0, num);</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        Slog.e(TAG, &quot;Error running logcat&quot;, e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (input !&#x3D; null) try &#123; input.close(); &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dbox.addText(dropboxTag, sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (process &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; If process is null, we are being called from some internal code</span><br><span class="line">            &#x2F;&#x2F; and may be about to die -- run this synchronously.</span><br><span class="line">            worker.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体很长，但是逻辑比较简单，在方法体最后通过判断应用进程是否为空（是否被销毁）来执行worker.run方法或者是worker.start方法，这里的worker是一个Thread对象，而在我们的worker对象的run方法中主要的执行逻辑就是将崩溃信息写入系统log中，所以addErrorToDropBox方法的主要执行逻辑就是讲App的崩溃信息写入系统log中。。。。</p>
<p>继续回到我们的handleApplicationCrashInner方法中，看一下crashApplication方法是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">private void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        long timeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        String shortMsg &#x3D; crashInfo.exceptionClassName;</span><br><span class="line">        String longMsg &#x3D; crashInfo.exceptionMessage;</span><br><span class="line">        String stackTrace &#x3D; crashInfo.stackTrace;</span><br><span class="line">        if (shortMsg !&#x3D; null &amp;&amp; longMsg !&#x3D; null) &#123;</span><br><span class="line">            longMsg &#x3D; shortMsg + &quot;: &quot; + longMsg;</span><br><span class="line">        &#125; else if (shortMsg !&#x3D; null) &#123;</span><br><span class="line">            longMsg &#x3D; shortMsg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AppErrorResult result &#x3D; new AppErrorResult();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mController !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    String name &#x3D; r !&#x3D; null ? r.processName : null;</span><br><span class="line">                    int pid &#x3D; r !&#x3D; null ? r.pid : Binder.getCallingPid();</span><br><span class="line">                    int uid &#x3D; r !&#x3D; null ? r.info.uid : Binder.getCallingUid();</span><br><span class="line">                    if (!mController.appCrashed(name, pid,</span><br><span class="line">                            shortMsg, longMsg, timeMillis, crashInfo.stackTrace)) &#123;</span><br><span class="line">                        if (&quot;1&quot;.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, &quot;0&quot;))</span><br><span class="line">                                &amp;&amp; &quot;Native crash&quot;.equals(crashInfo.exceptionClassName)) &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Skip killing native crashed app &quot; + name</span><br><span class="line">                                    + &quot;(&quot; + pid + &quot;) during testing&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Force-killing crashed app &quot; + name</span><br><span class="line">                                    + &quot; at watcher&#39;s request&quot;);</span><br><span class="line">                            if (r !&#x3D; null) &#123;</span><br><span class="line">                                r.kill(&quot;crash&quot;, true);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                &#x2F;&#x2F; Huh.</span><br><span class="line">                                Process.killProcess(pid);</span><br><span class="line">                                killProcessGroup(uid, pid);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    mController &#x3D; null;</span><br><span class="line">                    Watchdog.getInstance().setActivityController(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If this process is running instrumentation, finish it.</span><br><span class="line">            if (r !&#x3D; null &amp;&amp; r.instrumentationClass !&#x3D; null) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Error in app &quot; + r.processName</span><br><span class="line">                      + &quot; running instrumentation &quot; + r.instrumentationClass + &quot;:&quot;);</span><br><span class="line">                if (shortMsg !&#x3D; null) Slog.w(TAG, &quot;  &quot; + shortMsg);</span><br><span class="line">                if (longMsg !&#x3D; null) Slog.w(TAG, &quot;  &quot; + longMsg);</span><br><span class="line">                Bundle info &#x3D; new Bundle();</span><br><span class="line">                info.putString(&quot;shortMsg&quot;, shortMsg);</span><br><span class="line">                info.putString(&quot;longMsg&quot;, longMsg);</span><br><span class="line">                finishInstrumentationLocked(r, Activity.RESULT_CANCELED, info);</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Log crash in battery stats.</span><br><span class="line">            if (r !&#x3D; null) &#123;</span><br><span class="line">                mBatteryStatsService.noteProcessCrash(r.processName, r.uid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If we can&#39;t identify the process or it&#39;s already exceeded its crash quota,</span><br><span class="line">            &#x2F;&#x2F; quit right away without showing a crash dialog.</span><br><span class="line">            if (r &#x3D;&#x3D; null || !makeAppCrashingLocked(r, shortMsg, longMsg, stackTrace)) &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Message msg &#x3D; Message.obtain();</span><br><span class="line">            msg.what &#x3D; SHOW_ERROR_MSG;</span><br><span class="line">            HashMap data &#x3D; new HashMap();</span><br><span class="line">            data.put(&quot;result&quot;, result);</span><br><span class="line">            data.put(&quot;app&quot;, r);</span><br><span class="line">            msg.obj &#x3D; data;</span><br><span class="line">            mUiHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res &#x3D; result.get();</span><br><span class="line"></span><br><span class="line">        Intent appErrorIntent &#x3D; null;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (r !&#x3D; null &amp;&amp; !r.isolated) &#123;</span><br><span class="line">                &#x2F;&#x2F; XXX Can&#39;t keep track of crash time for isolated processes,</span><br><span class="line">                &#x2F;&#x2F; since they don&#39;t have a persistent identity.</span><br><span class="line">                mProcessCrashTimes.put(r.info.processName, r.uid,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            if (res &#x3D;&#x3D; AppErrorDialog.FORCE_QUIT_AND_REPORT) &#123;</span><br><span class="line">                appErrorIntent &#x3D; createAppErrorIntentLocked(r, timeMillis, crashInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (appErrorIntent !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mContext.startActivityAsUser(appErrorIntent, new UserHandle(r.userId));</span><br><span class="line">            &#125; catch (ActivityNotFoundException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;bug report receiver dissappeared&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在方法体中我们调用了mUiHandler.sendMessage(msg)，其中mUiHandler是一个在主线程中创建的Handler对象，而这里的msg是一个what值为SHOW_ERROR_MSG的消息，这句话的本质就是向Ui线程中发送一个异步消息。我们来看一下mUiHander的处理逻辑。</p>
<p>在mUiHandler的handeMessage方法中，根据what值得不同，执行了如下逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">case SHOW_ERROR_MSG: &#123;</span><br><span class="line">                HashMap&lt;String, Object&gt; data &#x3D; (HashMap&lt;String, Object&gt;) msg.obj;</span><br><span class="line">                boolean showBackground &#x3D; Settings.Secure.getInt(mContext.getContentResolver(),</span><br><span class="line">                        Settings.Secure.ANR_SHOW_BACKGROUND, 0) !&#x3D; 0;</span><br><span class="line">                synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                    ProcessRecord proc &#x3D; (ProcessRecord)data.get(&quot;app&quot;);</span><br><span class="line">                    AppErrorResult res &#x3D; (AppErrorResult) data.get(&quot;result&quot;);</span><br><span class="line">                    if (proc !&#x3D; null &amp;&amp; proc.crashDialog !&#x3D; null) &#123;</span><br><span class="line">                        Slog.e(TAG, &quot;App already has crash dialog: &quot; + proc);</span><br><span class="line">                        if (res !&#x3D; null) &#123;</span><br><span class="line">                            res.set(0);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    boolean isBackground &#x3D; (UserHandle.getAppId(proc.uid)</span><br><span class="line">                            &gt;&#x3D; Process.FIRST_APPLICATION_UID</span><br><span class="line">                            &amp;&amp; proc.pid !&#x3D; MY_PID);</span><br><span class="line">                    for (int userId : mCurrentProfileIds) &#123;</span><br><span class="line">                        isBackground &amp;&#x3D; (proc.userId !&#x3D; userId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (isBackground &amp;&amp; !showBackground) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Skipping crash dialog of &quot; + proc + &quot;: background&quot;);</span><br><span class="line">                        if (res !&#x3D; null) &#123;</span><br><span class="line">                            res.set(0);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (mShowDialogs &amp;&amp; !mSleeping &amp;&amp; !mShuttingDown) &#123;</span><br><span class="line">                        Dialog d &#x3D; new AppErrorDialog(mContext,</span><br><span class="line">                                ActivityManagerService.this, res, proc);</span><br><span class="line">                        d.show();</span><br><span class="line">                        proc.crashDialog &#x3D; d;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; The device is asleep, so just pretend that the user</span><br><span class="line">                        &#x2F;&#x2F; saw a crash dialog and hit &quot;force quit&quot;.</span><br><span class="line">                        if (res !&#x3D; null) &#123;</span><br><span class="line">                            res.set(0);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ensureBootCompleted();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中我们创建了一个AppErrorDialog对象，并执行了show方法，这样该Dialog就会被显示出来。而这里的Dialog的显示内容就是：App already has crash dialog: ….</p>
<p>O(∩_∩)O哈哈~，原来我们App崩溃的时候弹出昂的异常提示框就是在这里弹出来的。这里对AppErrorDialog不做过多的介绍，在其的构造方法中，调用了如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; After the timeout, pretend the user clicked the quit button</span><br><span class="line">        mHandler.sendMessageDelayed(</span><br><span class="line">                mHandler.obtainMessage(FORCE_QUIT),</span><br><span class="line">                DISMISS_TIMEOUT);</span><br></pre></td></tr></table></figure>
<p>这里的常量DISMISS_TIME = 5 * 60 * 1000，也就是五分钟，相当于这里发送了一个延时异步消息五分钟之后取消崩溃弹窗的显示。所以我们的App若果崩溃之后不主动取消弹窗，崩溃弹窗也会默认在五分钟之后取消。</p>
<p>好吧，文章开头我们所提到的两个问题我们已经解决掉一个了，force close弹窗是如何弹出来的，相信大家已经有所了解了，其实第二个问题也已经说明了，我们知道系统默认的App异常处理流程就是从Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());开始的，并创建了自己的UncaughtHandler对象，那么我们接管系统默认的异常处理逻辑其实也就是从Thread.setDefaultUncaughtExceptionHandler开始的，并重写其uncaughtException方法，那么App异常信息就会被我们自定义的UncaughtHandler所捕获，捕获之后奔溃信息的记录与上报就可以做定制了。。。</p>
<p>这样我们就大概分析完成了Android系统的异常处理流程。O(∩_∩)O哈哈~</p>
<p>总结：</p>
<ul>
<li><p>App应用进程启动时会经过一系列的调用，执行Thread.setDefaultUncaughtExceptionHandler方法，创建默认的UncaughtHandler异常处理对象。</p>
</li>
<li><p>默认的UncaughtHandler异常处理对象，在其回调方法uncaughtException方法中会执行弹窗异常弹窗的操作，这也就是我们原生的force close弹窗，并且弹窗如果不主动取消的话，会在五分钟内默认取消。</p>
</li>
<li><p>自定义App的全局异常处理逻辑，需要接管UncaughtHandler，也就是创建自身的UncaughtHandler对象，并调用Thread.setDefaultUncaughtExceptionHandler方法，接管默认的异常处理逻辑。</p>
</li>
<li><p>force close弹窗，弹窗的时候App应用可能已经退出，该弹窗的弹窗是SystemServer进程中的ActivityManagerService服务控制的。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/22%20Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/22%20Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">22 Toast加载绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面我们分析了Activity、Dialog、PopupWindow的加载绘制流程，相信大家对整个Android系统中的窗口绘制流程已经有了一个比较清晰的认识了，这里最后再给大家介绍一下Toast的加载绘制流程。</p>
<p>其实Toast窗口和Activity、Dialog、PopupWindow有一个不太一样的地方，就是Toast窗口是属于系统级别的窗口，他和输入框等类似的，不属于某一个应用，即不属于某一个进程，所以自然而然的，一旦涉及到Toast的加载绘制流程就会涉及到进程间通讯，看过前面系列文章的同学应该知道，Android间的进程间通讯采用的是Android特有的Binder机制，所以Toast的加载绘制流程也会涉及到Binder进程间通讯。</p>
<p>Toast的显示流程其实内部还是通过Window的窗口机制实现加载绘制的，只不过由于是系统级别的窗口，在显示过程中涉及到了进程间通讯等机制。</p>
<p>下面我们来具体看一下Toast窗口的简单使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(context, msg, Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure>
<p>上面的代码是Toast的典型使用方式，通过makeText方法创建出一个Toast对象，然后调用show方法将Toast窗口显示出来。</p>
<p>下面我们来看一下makeText方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</span><br><span class="line">        Toast result &#x3D; new Toast(context);</span><br><span class="line"></span><br><span class="line">        LayoutInflater inflate &#x3D; (LayoutInflater)</span><br><span class="line">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        View v &#x3D; inflate.inflate(com.android.internal.R.layout.transient_notification, null);</span><br><span class="line">        TextView tv &#x3D; (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">        tv.setText(text);</span><br><span class="line">        </span><br><span class="line">        result.mNextView &#x3D; v;</span><br><span class="line">        result.mDuration &#x3D; duration;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体不是很长，在makeText方法中，我们首先通过Toast对象的构造方法，创建了一个新的Toast对象，这样我们就先来看一下Toast的构造方法做了哪些事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Toast(Context context) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mTN &#x3D; new TN();</span><br><span class="line">        mTN.mY &#x3D; context.getResources().getDimensionPixelSize(</span><br><span class="line">                com.android.internal.R.dimen.toast_y_offset);</span><br><span class="line">        mTN.mGravity &#x3D; context.getResources().getInteger(</span><br><span class="line">                com.android.internal.R.integer.config_toastDefaultGravity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里初始化了Toast对象的成员变量mContext和mTN，这里的mContext是一个Context类型的成员变量，那mTN是什么东西呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static class TN extends ITransientNotification.Stub</span><br></pre></td></tr></table></figure>
<p>从类的源码定义来看，我们知道TN是一个继承自ITransientNotification.Stub的类，这里我们暂时只用知道他的继承关系就好了，知道其是一个Binder对象，可以用于进程间通讯，然后回到我们的makeText方法，在调用了Toast的构造方法创建了Toast对象之后，我们又通过context.getSystemService方法获取到LayoutInflater，然后通过调用LayoutInflater的inflate方法加载到了Toast的布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflate &#x3D; (LayoutInflater)</span><br><span class="line">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        View v &#x3D; inflate.inflate(com.android.internal.R.layout.transient_notification, null);</span><br></pre></td></tr></table></figure>
<p>这里我们可以看一下布局文件的具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">    android:background&#x3D;&quot;?android:attr&#x2F;toastFrameBackground&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@android:id&#x2F;message&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">        android:layout_gravity&#x3D;&quot;center_horizontal&quot;</span><br><span class="line">        android:textAppearance&#x3D;&quot;@style&#x2F;TextAppearance.Toast&quot;</span><br><span class="line">        android:textColor&#x3D;&quot;@color&#x2F;bright_foreground_dark&quot;</span><br><span class="line">        android:shadowColor&#x3D;&quot;#BB000000&quot;</span><br><span class="line">        android:shadowRadius&#x3D;&quot;2.75&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现Toast加载的布局文件只有一个LinearLayout布局，并且只包含一个TextView组件。。。。</p>
<p>然后我们通过调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextView tv &#x3D; (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">        tv.setText(text);</span><br><span class="line">        </span><br><span class="line">        result.mNextView &#x3D; v;</span><br><span class="line">        result.mDuration &#x3D; duration;</span><br><span class="line"></span><br><span class="line">        return result;</span><br></pre></td></tr></table></figure>
<p>初始化了布局文件，Toast的mNextView和mDuration成员变量并返回Toast类型的result对象。这样我们的Toast对象就构造完成了。</p>
<p>然后我们回到我们的Toast.show方法，调用完这个方法之后就准备开始显示Toast窗口了，我们来具体看一下show方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void show() &#123;</span><br><span class="line">        if (mNextView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;setView must have been called&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        INotificationManager service &#x3D; getService();</span><br><span class="line">        String pkg &#x3D; mContext.getOpPackageName();</span><br><span class="line">        TN tn &#x3D; mTN;</span><br><span class="line">        tn.mNextView &#x3D; mNextView;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            service.enqueueToast(pkg, tn, mDuration);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; Empty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断我们的mNextView是否为空，为空的话，显示逻辑就无法进行了，所以这里判断如果mNextView为空的话，就直接抛出异常，不在往下执行。。。。</p>
<p>然后我们执行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INotificationManager service &#x3D; getService();</span><br></pre></td></tr></table></figure>
<p>这里的INotificationManager是服务器端NotificationManagerService的Binder客户端，我们可以看一下getService方法的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static private INotificationManager getService() &#123;</span><br><span class="line">        if (sService !&#x3D; null) &#123;</span><br><span class="line">            return sService;</span><br><span class="line">        &#125;</span><br><span class="line">        sService &#x3D; INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));</span><br><span class="line">        return sService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里获取了INotificationManager对象，然后我们调用了service.enqueueToast方法，并传递了package，TN对象，duration等参数，这里实际执行的是NotificationManagerService的内部类的INotificationManager.Stub的enqueueToast方法，而我们的NoticationManagerService是在SystemServer进程中执行的，这里的底层其实是通过Binder机制传输数据的，具体的Binder机制相关知识可自行学习。。</p>
<p>好吧，我们在看一下INotificationManager.Stub的enqueueToast方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void enqueueToast(String pkg, ITransientNotification callback, int duration)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            synchronized (mToastQueue) &#123;</span><br><span class="line">                int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">                long callingId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">                try &#123;</span><br><span class="line">                    ToastRecord record;</span><br><span class="line">                    int index &#x3D; indexOfToastLocked(pkg, callback);</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s already in the queue, we update it in place, we don&#39;t</span><br><span class="line">                    &#x2F;&#x2F; move it to the end of the queue.</span><br><span class="line">                    if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                        record &#x3D; mToastQueue.get(index);</span><br><span class="line">                        record.update(duration);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; Limit the number of toasts that any given package except the android</span><br><span class="line">                        &#x2F;&#x2F; package can enqueue.  Prevents DOS attacks and deals with leaks.</span><br><span class="line">                        if (!isSystemToast) &#123;</span><br><span class="line">                            int count &#x3D; 0;</span><br><span class="line">                            final int N &#x3D; mToastQueue.size();</span><br><span class="line">                            for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                                 final ToastRecord r &#x3D; mToastQueue.get(i);</span><br><span class="line">                                 if (r.pkg.equals(pkg)) &#123;</span><br><span class="line">                                     count++;</span><br><span class="line">                                     if (count &gt;&#x3D; MAX_PACKAGE_NOTIFICATIONS) &#123;</span><br><span class="line">                                         Slog.e(TAG, &quot;Package has already posted &quot; + count</span><br><span class="line">                                                + &quot; toasts. Not showing more. Package&#x3D;&quot; + pkg);</span><br><span class="line">                                         return;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        record &#x3D; new ToastRecord(callingPid, pkg, callback, duration);</span><br><span class="line">                        mToastQueue.add(record);</span><br><span class="line">                        index &#x3D; mToastQueue.size() - 1;</span><br><span class="line">                        keepProcessAliveLocked(callingPid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s at index 0, it&#39;s the current toast.  It doesn&#39;t matter if it&#39;s</span><br><span class="line">                    &#x2F;&#x2F; new or just been updated.  Call back and tell it to show itself.</span><br><span class="line">                    &#x2F;&#x2F; If the callback fails, this will remove it from the list, so don&#39;t</span><br><span class="line">                    &#x2F;&#x2F; assume that it&#39;s valid after this.</span><br><span class="line">                    if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        showNextToastLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(callingId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们首先将我们的ToastRecord（Toast对象在server端的对象）保存到一个List列表mToastQueue中，然后调用了showNextToastLocked方法，这样我们在看一下showNextToastLocked方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void showNextToastLocked() &#123;</span><br><span class="line">        ToastRecord record &#x3D; mToastQueue.get(0);</span><br><span class="line">        while (record !&#x3D; null) &#123;</span><br><span class="line">            if (DBG) Slog.d(TAG, &quot;Show pkg&#x3D;&quot; + record.pkg + &quot; callback&#x3D;&quot; + record.callback);</span><br><span class="line">            try &#123;</span><br><span class="line">                record.callback.show();</span><br><span class="line">                scheduleTimeoutLocked(record);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback</span><br><span class="line">                        + &quot; in package &quot; + record.pkg);</span><br><span class="line">                &#x2F;&#x2F; remove it from the list and let the process die</span><br><span class="line">                int index &#x3D; mToastQueue.indexOf(record);</span><br><span class="line">                if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                    mToastQueue.remove(index);</span><br><span class="line">                &#125;</span><br><span class="line">                keepProcessAliveLocked(record.pid);</span><br><span class="line">                if (mToastQueue.size() &gt; 0) &#123;</span><br><span class="line">                    record &#x3D; mToastQueue.get(0);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    record &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要执行了record.callback.show方法，而这里的callback对象就是我们创建Toast对象的时候传递的TN对象，显然的，这了的show方法就是我们的Toast内部类TN的show方法，然后我们调用了scheduleTimeoutLocked方法，这里先看一下scheduleTimeoutLocked方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void scheduleTimeoutLocked(ToastRecord r)</span><br><span class="line">    &#123;</span><br><span class="line">        mHandler.removeCallbacksAndMessages(r);</span><br><span class="line">        Message m &#x3D; Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</span><br><span class="line">        long delay &#x3D; r.duration &#x3D;&#x3D; Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;</span><br><span class="line">        mHandler.sendMessageDelayed(m, delay);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里发送了一个异步消息，并且这里的异步消息是在duration时间之后发送的，也就是说我们在Toast端传递的duration参数就是这里的message消息delay发送的时间，而我们发送MESSAGE_TIMEOUT异步消息之后最终会被方法handleTimeout执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void handleTimeout(ToastRecord record)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DBG) Slog.d(TAG, &quot;Timeout pkg&#x3D;&quot; + record.pkg + &quot; callback&#x3D;&quot; + record.callback);</span><br><span class="line">        synchronized (mToastQueue) &#123;</span><br><span class="line">            int index &#x3D; indexOfToastLocked(record.pkg, record.callback);</span><br><span class="line">            if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                cancelToastLocked(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体里面又调用了cancelToastLocked方法，然后我们看一下cancelToastLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void cancelToastLocked(int index) &#123;</span><br><span class="line">        ToastRecord record &#x3D; mToastQueue.get(index);</span><br><span class="line">        try &#123;</span><br><span class="line">            record.callback.hide();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback</span><br><span class="line">                    + &quot; in package &quot; + record.pkg);</span><br><span class="line">            &#x2F;&#x2F; don&#39;t worry about this, we&#39;re about to remove it from</span><br><span class="line">            &#x2F;&#x2F; the list anyway</span><br><span class="line">        &#125;</span><br><span class="line">        mToastQueue.remove(index);</span><br><span class="line">        keepProcessAliveLocked(record.pid);</span><br><span class="line">        if (mToastQueue.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Show the next one. If the callback fails, this will remove</span><br><span class="line">            &#x2F;&#x2F; it from the list, so don&#39;t assume that the list hasn&#39;t changed</span><br><span class="line">            &#x2F;&#x2F; after this point.</span><br><span class="line">            showNextToastLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里又是调用了record.callback.hide方法，显然的这里的hide方法和刚刚的show方法是相似的，都是调用的Toast内部类TN的hide方法，所以这里可以看出Toast的显示与隐藏操作都是在Toast内部类TN的show和hide方法实现的，然后我们调用了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mToastQueue.remove(index);</span><br></pre></td></tr></table></figure>
<p>清除这个Toast对象，并继续执行showNextToastLocked方法，直到mToastQueue的大小为0。。。</p>
<p>这样关于Toast窗口的显示与隐藏操作都是在Toast内部类TN的show方法和hide方法中，我们先看一下TN内部类的show方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void show() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</span><br><span class="line">            mHandler.post(mShow);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里也是发送一个异步消息，我们看一下Runnable类型的mShow的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final Runnable mShow &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                handleShow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到再其run方法中调用了handleShow方法，继续看handleShow方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void handleShow() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView&#x3D;&quot; + mView</span><br><span class="line">                    + &quot; mNextView&#x3D;&quot; + mNextView);</span><br><span class="line">            if (mView !&#x3D; mNextView) &#123;</span><br><span class="line">                &#x2F;&#x2F; remove the old view if necessary</span><br><span class="line">                handleHide();</span><br><span class="line">                mView &#x3D; mNextView;</span><br><span class="line">                Context context &#x3D; mView.getContext().getApplicationContext();</span><br><span class="line">                String packageName &#x3D; mView.getContext().getOpPackageName();</span><br><span class="line">                if (context &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    context &#x3D; mView.getContext();</span><br><span class="line">                &#125;</span><br><span class="line">                mWM &#x3D; (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">                &#x2F;&#x2F; We can resolve the Gravity here by using the Locale for getting</span><br><span class="line">                &#x2F;&#x2F; the layout direction</span><br><span class="line">                final Configuration config &#x3D; mView.getContext().getResources().getConfiguration();</span><br><span class="line">                final int gravity &#x3D; Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</span><br><span class="line">                mParams.gravity &#x3D; gravity;</span><br><span class="line">                if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#x3D;&#x3D; Gravity.FILL_HORIZONTAL) &#123;</span><br><span class="line">                    mParams.horizontalWeight &#x3D; 1.0f;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#x3D;&#x3D; Gravity.FILL_VERTICAL) &#123;</span><br><span class="line">                    mParams.verticalWeight &#x3D; 1.0f;</span><br><span class="line">                &#125;</span><br><span class="line">                mParams.x &#x3D; mX;</span><br><span class="line">                mParams.y &#x3D; mY;</span><br><span class="line">                mParams.verticalMargin &#x3D; mVerticalMargin;</span><br><span class="line">                mParams.horizontalMargin &#x3D; mHorizontalMargin;</span><br><span class="line">                mParams.packageName &#x3D; packageName;</span><br><span class="line">                if (mView.getParent() !&#x3D; null) &#123;</span><br><span class="line">                    if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);</span><br><span class="line">                    mWM.removeView(mView);</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);</span><br><span class="line">                mWM.addView(mView, mParams);</span><br><span class="line">                trySendAccessibilityEvent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，在handleShow方法中经过一系列的初始化操作，初始化mWN对象，初始化mView对象，初始化了mParams对象，然后调用了mWM的addView方法，到了这里大家应该就很熟悉了（不熟悉的同学可以看一下Activity的加载绘制流程等文章<br><a href="http://blog.csdn.net/qq_23547831/article/details/51285804" target="_blank" rel="noopener"> android源码解析（十八）–&gt;Activity布局绘制流程</a>&nbsp;&nbsp;<br><a href="http://blog.csdn.net/qq_23547831/article/details/51284556" target="_blank" rel="noopener"> android源码解析（十七）–&gt;Activity布局加载流程</a>）通过这个方法就实现了Toast窗口的显示逻辑。</p>
<p>继续看一下TN的hide方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void hide() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this);</span><br><span class="line">            mHandler.post(mHide);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，和show方法类似，也是发送了一个异步消息，这里看一下Runnable类型的mHide对象的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Runnable mHide &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                handleHide();</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t do this in handleHide() because it is also invoked by handleShow()</span><br><span class="line">                mNextView &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现在其run方法中调用了handleHide方法，显然的，与show方法类似，这里的handleHide方法也是执行Toast窗口销毁的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void handleHide() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView&#x3D;&quot; + mView);</span><br><span class="line">            if (mView !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; note: checking parent() just to make sure the view has</span><br><span class="line">                &#x2F;&#x2F; been added...  i have seen cases where we get here when</span><br><span class="line">                &#x2F;&#x2F; the view isn&#39;t yet added, so let&#39;s try not to crash.</span><br><span class="line">                if (mView.getParent() !&#x3D; null) &#123;</span><br><span class="line">                    if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);</span><br><span class="line">                    mWM.removeView(mView);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mView &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，在方法体重调用了mWM.removeView(mView),又是熟悉的代码，通过执行这里的removeView方法，我们可以实现Toast窗口的销毁流程，至此我们就分析完了Toast窗口的显示与销毁流程。</p>
<p>总结：</p>
<ul>
<li><p>Toast是一个系统窗口，Toast在显示与销毁流程设计到进程间通讯（Binder机制实现）</p>
</li>
<li><p>Toast的show方法首先会初始化一个Toast对象，然后将内部对象TN与duration传递给NotificationManagerService，并在NotificationManagerService端维护一个Toast对象列表。</p>
</li>
<li><p>NotificationManagerService接收到Toast的show请求之后，保存Toast对象并回调Toast.TN的show方法具体实现Toast窗口的显示逻辑。</p>
</li>
<li><p>Toast窗口的显示与销毁机制与Activity、Dialog、PopupWIndow都是类似的，都是通过WIndow对象实现的。</p>
</li>
<li><p>NotificationManagerService端在执行show方法执行会发送一个异步消息用于销毁Toast窗口，这个异步消息会在duration时间段之后发出，这样，在设置Toast显示的时间就会被传递到NotificationManagerService端，并在这段时间之后发送异步消息销毁Toast窗口。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/21%20PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/21%20PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">21 PopupWindow加载绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在前面的几篇文章中我们分析了Activity与Dialog的加载绘制流程，取消绘制流程，相信大家对Android系统的窗口绘制机制有了一个感性的认识了，这篇文章我们将继续分析一下PopupWindow加载绘制流程。</p>
<p>在分析PopupWindow之前，我们将首先说一下什么是PopupWindow？理解一个类最好的方式就是看一下这个类的定义，这里我们摘要了一下Android系统中PopupWindow的类的说明：</p>
<blockquote>
<p>A popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current<br> activity.</p>
</blockquote>
<p>一个PopupWindow能够被用于展示任意的View，PopupWindow是一个悬浮的容易展示在当前Activity的上面。<br>简单来说PopupWindow就是一个悬浮在Activity之上的窗口，可以用展示任意布局文件。</p>
<p>在说明PopupWindow的加载绘制机制之前，我们还是先写一个简单的例子用于说明一下PopupWindow的简单用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static View showPopupWindowMenu(Activity mContext, View anchorView, int layoutId) &#123;</span><br><span class="line">        LayoutInflater inflater &#x3D; (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        View view &#x3D; inflater.inflate(layoutId, null);</span><br><span class="line">        popupWindow &#x3D; new PopupWindow(view, DisplayUtil.dip2px(mContext, 148), WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">        popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_bg));</span><br><span class="line">        popupWindow.setFocusable(true);</span><br><span class="line">        popupWindow.setOutsideTouchable(true);</span><br><span class="line"></span><br><span class="line">        int[] location &#x3D; new int[2];</span><br><span class="line">        anchorView.getLocationOnScreen(location);</span><br><span class="line">        popupWindow.setAnimationStyle(R.style.popwin_anim_style);</span><br><span class="line">        popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY,</span><br><span class="line">                location[0] - popupWindow.getWidth() + anchorView.getWidth() - DisplayUtil.dip2px(mContext, 12),</span><br><span class="line">                location[1] + anchorView.getHeight() - DisplayUtil.dip2px(mContext, 10));</span><br><span class="line"></span><br><span class="line">        popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onDismiss() &#123;</span><br><span class="line">                popupWindow &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们首先通过LayoutInflater对象将布局文件解析到内存中View对象，然后创建了一个PopupWindow对象，可以看到传递了三个参数，一个是View对象，一个是PopupWindow的宽度和高度。</p>
<p>这里就是PopupWindow的初始化流程的开始了，好吧，我们来看一下PopupWindow的构造方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow(View contentView, int width, int height) &#123;</span><br><span class="line">        this(contentView, width, height, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了PopupWindow的重载构造方法，好吧，继续看一下这个重载构造方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow(View contentView, int width, int height, boolean focusable) &#123;</span><br><span class="line">        if (contentView !&#x3D; null) &#123;</span><br><span class="line">            mContext &#x3D; contentView.getContext();</span><br><span class="line">            mWindowManager &#x3D; (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setContentView(contentView);</span><br><span class="line">        setWidth(width);</span><br><span class="line">        setHeight(height);</span><br><span class="line">        setFocusable(focusable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里首先根据传入的View是否为空做了一下判断，若不为空，则初始化成员变量,Context和mWindowManager，可以发现这里的mContext对象就是传入的View组件中保留的Context对象，这里的mWindowManager是应用进程创建的时候注册的服务本地接口。然后调用了setContentView方法，这里就是为PopupWindow的contentView赋值。然后后面调用的setWidth、setHeight、setFocusable方法都是为PopupWindow的成员变量，width，height，focusable等赋值，这样PopupWindow的构造方法就执行完成了。</p>
<p>我们继续回到我们的例子代码中，在后续的代码中我们调用了：popupWindow.setBackgroundDrawable、popupWindow.setFocusable、PopupWindow.setOutsideTouchable、<br>PopupWindow.setAnimationStyle等方法，初始化了PopupWindow中的相关成员变量，最后我们调用了popupWindow.showAtLocation方法用于展示PopupWindow，这里我们具体看一下showAtLocation的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void showAtLocation(View parent, int gravity, int x, int y) &#123;</span><br><span class="line">        showAtLocation(parent.getWindowToken(), gravity, x, y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里调用了showAtLocation的重载函数，这样我们继续看一下这个重载函数的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void showAtLocation(IBinder token, int gravity, int x, int y) &#123;</span><br><span class="line">        if (isShowing() || mContentView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TransitionManager.endTransitions(mDecorView);</span><br><span class="line"></span><br><span class="line">        unregisterForScrollChanged();</span><br><span class="line"></span><br><span class="line">        mIsShowing &#x3D; true;</span><br><span class="line">        mIsDropdown &#x3D; false;</span><br><span class="line"></span><br><span class="line">        final WindowManager.LayoutParams p &#x3D; createPopupLayoutParams(token);</span><br><span class="line">        preparePopup(p);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Only override the default if some gravity was specified.</span><br><span class="line">        if (gravity !&#x3D; Gravity.NO_GRAVITY) &#123;</span><br><span class="line">            p.gravity &#x3D; gravity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.x &#x3D; x;</span><br><span class="line">        p.y &#x3D; y;</span><br><span class="line"></span><br><span class="line">        invokePopup(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到通过调用createPopupLayoutParams方法创造了WindowManager.LayoutParams对象，然后又调用了preparePopup方法，可以看一下preparePopup方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void preparePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line">        if (mContentView &#x3D;&#x3D; null || mContext &#x3D;&#x3D; null || mWindowManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;You must specify a valid content view by &quot;</span><br><span class="line">                    + &quot;calling setContentView() before attempting to show the popup.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The old decor view may be transitioning out. Make sure it finishes</span><br><span class="line">        &#x2F;&#x2F; and cleans up before we try to create another one.</span><br><span class="line">        if (mDecorView !&#x3D; null) &#123;</span><br><span class="line">            mDecorView.cancelTransitions();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; When a background is available, we embed the content view within</span><br><span class="line">        &#x2F;&#x2F; another view that owns the background drawable.</span><br><span class="line">        if (mBackground !&#x3D; null) &#123;</span><br><span class="line">            mBackgroundView &#x3D; createBackgroundView(mContentView);</span><br><span class="line">            mBackgroundView.setBackground(mBackground);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mBackgroundView &#x3D; mContentView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecorView &#x3D; createDecorView(mBackgroundView);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The background owner should be elevated so that it casts a shadow.</span><br><span class="line">        mBackgroundView.setElevation(mElevation);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; We may wrap that in another view, so we&#39;ll need to manually specify</span><br><span class="line">        &#x2F;&#x2F; the surface insets.</span><br><span class="line">        final int surfaceInset &#x3D; (int) Math.ceil(mBackgroundView.getZ() * 2);</span><br><span class="line">        p.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);</span><br><span class="line">        p.hasManualSurfaceInsets &#x3D; true;</span><br><span class="line"></span><br><span class="line">        mPopupViewInitialLayoutDirectionInherited &#x3D;</span><br><span class="line">                (mContentView.getRawLayoutDirection() &#x3D;&#x3D; View.LAYOUT_DIRECTION_INHERIT);</span><br><span class="line">        mPopupWidth &#x3D; p.width;</span><br><span class="line">        mPopupHeight &#x3D; p.height;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>preparePopup方法的参数是WindowManager.LayoutParams，然后设置了PopupWindow中的几个比较重要的成员变量，首先看一下mBackgroundView的初始化过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (mBackground !&#x3D; null) &#123;</span><br><span class="line">            mBackgroundView &#x3D; createBackgroundView(mContentView);</span><br><span class="line">            mBackgroundView.setBackground(mBackground);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mBackgroundView &#x3D; mContentView;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现如果我们设置了mBackground变量也就是我们在初始化的时候执行了popupWindow的setBackgound方法，那么我们这里执行的就是if分之，这里看一下createBackgourndView的具体执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private PopupBackgroundView createBackgroundView(View contentView) &#123;</span><br><span class="line">        final ViewGroup.LayoutParams layoutParams &#x3D; mContentView.getLayoutParams();</span><br><span class="line">        final int height;</span><br><span class="line">        if (layoutParams !&#x3D; null &amp;&amp; layoutParams.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PopupBackgroundView backgroundView &#x3D; new PopupBackgroundView(mContext);</span><br><span class="line">        final PopupBackgroundView.LayoutParams listParams &#x3D; new PopupBackgroundView.LayoutParams(</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT, height);</span><br><span class="line">        backgroundView.addView(contentView, listParams);</span><br><span class="line"></span><br><span class="line">        return backgroundView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，createBackgroundView的执行逻辑就是在参数contentView的外面一层包裹一层PopupBackgroundView，而这里的PopupBackgroundView值我们自定义的FrameLayout的子类，重写了其onCreateDrawableState方法。</p>
<p>继续回到我们的preparePopup方法，这里我们又调用了createDecorView方法初始化mDectorView变量，我们可以看一下createDecorView的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private PopupDecorView createDecorView(View contentView) &#123;</span><br><span class="line">        final ViewGroup.LayoutParams layoutParams &#x3D; mContentView.getLayoutParams();</span><br><span class="line">        final int height;</span><br><span class="line">        if (layoutParams !&#x3D; null &amp;&amp; layoutParams.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PopupDecorView decorView &#x3D; new PopupDecorView(mContext);</span><br><span class="line">        decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height);</span><br><span class="line">        decorView.setClipChildren(false);</span><br><span class="line">        decorView.setClipToPadding(false);</span><br><span class="line"></span><br><span class="line">        return decorView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里也是给参数contentView外面包裹了一层PopupDecorView，这里的PopupDecorView也是我们自定义的FrameLayout的子类，PopupDecorView的源码比较多，这里就不都贴出来了，这里具体看一下其onTouchEvent方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">            final int x &#x3D; (int) event.getX();</span><br><span class="line">            final int y &#x3D; (int) event.getY();</span><br><span class="line"></span><br><span class="line">            if ((event.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN)</span><br><span class="line">                    &amp;&amp; ((x &lt; 0) || (x &gt;&#x3D; getWidth()) || (y &lt; 0) || (y &gt;&#x3D; getHeight()))) &#123;</span><br><span class="line">                dismiss();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (event.getAction() &#x3D;&#x3D; MotionEvent.ACTION_OUTSIDE) &#123;</span><br><span class="line">                dismiss();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return super.onTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其重写了onTouchEvent时间，这样我们在点击popupWindow外面的时候就会执行pupopWindow的dismiss方法，取消PopupWindow。</p>
<p>好吧，继续回到我们的showAsDropDown方法，在执行完成preparePopup方法之后又调用了invokePopup方法，这里的方法应该就是具体执行PopupWindow的加载与显示逻辑了。这里我们具体看一下其实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void invokePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line">        if (mContext !&#x3D; null) &#123;</span><br><span class="line">            p.packageName &#x3D; mContext.getPackageName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PopupDecorView decorView &#x3D; mDecorView;</span><br><span class="line">        decorView.setFitsSystemWindows(mLayoutInsetDecor);</span><br><span class="line"></span><br><span class="line">        setLayoutDirectionFromAnchor();</span><br><span class="line"></span><br><span class="line">        mWindowManager.addView(decorView, p);</span><br><span class="line"></span><br><span class="line">        if (mEnterTransition !&#x3D; null) &#123;</span><br><span class="line">            decorView.requestEnterTransition(mEnterTransition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这里我们调用了mWindowManager.addView方法，看过我们前面几篇关于Dialog和Activity的加载与现实流程的同学应该知道这里的addView其实是我们布局绘制的流程，这里的mWindowManager是我们在调用PopupWIndow的构造函数的时候初始化的，其调用的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mWindowManager &#x3D;&#x3D; null &amp;&amp; mContentView !&#x3D; null) &#123;</span><br><span class="line">            mWindowManager &#x3D; (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>而这里的mContext.getSystemService是一个接口其具体的实现是在ContextImpl中实现的，所以这里我们看一下ContextImpl的getSystemService的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Object getSystemService(String name) &#123;</span><br><span class="line">        return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，在ContextImpl中的getSystemService方法又调用了SystemServiceRegister中的静态方法getSystemService，这样我们再看看一下在SystemServiceRegister是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Object getSystemService(ContextImpl ctx, String name) &#123;</span><br><span class="line">        ServiceFetcher&lt;?&gt; fetcher &#x3D; SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">        return fetcher !&#x3D; null ? fetcher.getService(ctx) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里发现服务对象的获取就是通过一个SYSTEM_SERVICE_FETCHERS的map数据结构获取的，那么这个map对象的数据是何时填充的呢？通过查看源码我们发下在SystemServiceRegister中有一段静态代码主要用于注册本地服务接口，其中关于windowManagerService本地服务的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">                new CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public WindowManager createService(ContextImpl ctx) &#123;</span><br><span class="line">                return new WindowManagerImpl(ctx.getDisplay());</span><br><span class="line">            &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>好吧，原来我们通过mContext.getSystemService获取的WindowManager其实际上是一个WindowManagerImpl对象，而我们调用的addView就是WindowManagerImpl的addView方法。</p>
<p>这样就回到了我们前几篇讲解的内容上了，通过调用WindowManagerImpl实现了布局文件的绘制流程。。。。</p>
<p>好了，经过上面的一系列的操作我们分析完了PopupWindow的加载绘制流程，其和Dialog，Activity的加载绘制流程类似，都是通过Window对象控制布局文件的加载与绘制流程。</p>
<p>总结：</p>
<ul>
<li><p>PopupWindow的界面加载绘制流程也是通过Window对象实现的；</p>
</li>
<li><p>PopupWindow内部保存的mWindowManager对象通过ContextImpl中获取，并且取得的是WindowManagerImpl对象；</p>
</li>
<li><p>PopupWindow通过为传入的View添加一层包裹的布局，并重写该布局的点击事件，实现点击PopupWindow之外的区域PopupWindow消失的效果；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/20%20Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/20%20Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">20 Dialog取消绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上几篇文章中我们分析了Dialog的加载绘制流程，也分析了Acvityi的加载绘制流程，说白了Android系统中窗口的展示都是通过Window对象控制，通过ViewRootImpl对象执行绘制操作来完成的，那么窗口的取消绘制流程是怎么样的呢？这篇文章就以Dialog为例说明Window窗口是如何取消绘制的。</p>
<p>有的同学可能会问前几篇文章介绍Activity的加载绘制流程的时候为何没有讲Activity的窗口取消流程，这里说明一下。那是因为当时说明的重点是Activity的加载与绘制流程，而取消绘制流程由于混杂在Activity的生命周期管理，可能不太明显，所以这里将Window窗口的取消绘制流程放在Dialog中，其实他们的取消绘制流程都是相似的，看完Dialog的取消绘制流程之后，再看一下Activity的取消绘制流程就很简单了。</p>
<p>还记得我们上一篇文章关于Dialog的例子么？我们通过AlertDialog.Builder创建了一个AlertDialog，并通过Activity中的按钮点击事件来显示这个AlertDialog，而在AlertDialog中定义了一个“知道了”按钮，点击这个按钮就会触发alertDialog.cancel方法，通过执行这个方法，我们的alertDialog就不在显示了，很明显的，cancel方法执行过程中就执行了取消绘制的逻辑，这里我们先看一下我们的例子核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">title.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(MainActivity.this.getApplication());</span><br><span class="line">                builder.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">                builder.setMessage(&quot;this is the content view!!!&quot;);</span><br><span class="line">                builder.setTitle(&quot;this is the title view!!!&quot;);</span><br><span class="line">                builder.setView(R.layout.activity_second);</span><br><span class="line">                builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                        alertDialog.cannel();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                alertDialog &#x3D; builder.create();</span><br><span class="line">                alertDialog.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这里的title就是我们自己的Activity中的一个TextView，通过注册这个TextView的点击事件，来显示一个AlertDialog，通过注册AlertDialog中按钮的点击事件，执行alertDialog的cancel方法。</p>
<p>好吧，看一下Dialog的cannel方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void cancel() &#123;</span><br><span class="line">        if (!mCanceled &amp;&amp; mCancelMessage !&#x3D; null) &#123;</span><br><span class="line">            mCanceled &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; Obtain a new message so this dialog can be re-used</span><br><span class="line">            Message.obtain(mCancelMessage).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">        dismiss();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，若当前Dialog没有取消，并且设置了取消message，则调用Message.obtain(mCancel).sendToTarget()，前面已经分析过这里的sendToTarget方法会回调我们注册的异步消息处理逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setOnCancelListener(final OnCancelListener listener) &#123;</span><br><span class="line">        if (mCancelAndDismissTaken !&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;OnCancelListener is already taken by &quot;</span><br><span class="line">                    + mCancelAndDismissTaken + &quot; and can not be replaced.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (listener !&#x3D; null) &#123;</span><br><span class="line">            mCancelMessage &#x3D; mListenersHandler.obtainMessage(CANCEL, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mCancelMessage &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到如果我们在初始化AlertDialog.Builder时，设置了setOnCancelListener，那么我们就会执行mListenersHandler的异步消息处理，好吧，这里看一下mListenersHandler的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static final class ListenersHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;DialogInterface&gt; mDialog;</span><br><span class="line"></span><br><span class="line">        public ListenersHandler(Dialog dialog) &#123;</span><br><span class="line">            mDialog &#x3D; new WeakReference&lt;DialogInterface&gt;(dialog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case DISMISS:</span><br><span class="line">                    ((OnDismissListener) msg.obj).onDismiss(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case CANCEL:</span><br><span class="line">                    ((OnCancelListener) msg.obj).onCancel(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case SHOW:</span><br><span class="line">                    ((OnShowListener) msg.obj).onShow(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里调用的是设置的OnCancelListener的onCancel方法，也就是说我们调用dialog.cancel方法时首先会判断dialog是否调用了setOnCancelListener若设置了，则先调用OnCancelListener的onCancel方法，然后再次执行dismiss方法，若我们没有为Dialog.Builder设置OnCancelListener那么cancel方法和dismiss方法是等效的。</p>
<p>这样，我们来看一下dismiss方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void dismiss() &#123;</span><br><span class="line">        if (Looper.myLooper() &#x3D;&#x3D; mHandler.getLooper()) &#123;</span><br><span class="line">            dismissDialog();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mHandler.post(mDismissAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里首先判断当前线程的Looper是否是主线程的Looper（由于mHandler是在主线程中创建的，所以mHandler.getLooper返回的是主线程中创建的Looper对象），若是的话，则直接执行dismissDialog()方法，否则的话，通过mHandler发送异步消息至主线程中，简单来说就是判断当前线程是否是主线程，若是主线程则执行dismissDialog方法否则发送异步消息，我们看一下mHandler对异步消息的处理机制，由于这里的mDismissAction是一个Runnable对象，所以这里直接看一下mDismissAction的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable mDismissAction &#x3D; new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            dismissDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>好吧，这里的异步消息最终也是调用的dismissDialog方法。。。。</p>
<p>所以无论我们执行的cancel方法还是dismiss方法，无论我们方法是在主线程执行还是子线程中执行，最终调用的都是dismissDialog方法，那么就看一下dismissDialog是怎么个执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void dismissDialog() &#123;</span><br><span class="line">        if (mDecor &#x3D;&#x3D; null || !mShowing) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mWindow.isDestroyed()) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog&#39;s window was already destroyed!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            mWindowManager.removeViewImmediate(mDecor);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (mActionMode !&#x3D; null) &#123;</span><br><span class="line">                mActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor &#x3D; null;</span><br><span class="line">            mWindow.closeAllPanels();</span><br><span class="line">            onStop();</span><br><span class="line">            mShowing &#x3D; false;</span><br><span class="line"></span><br><span class="line">            sendDismissMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，看样子代码还不是特别多，方法体中，首先判断当前的mDector是否为空，或者当前Dialog是否在显示，若为空或者没有在显示，则直接return掉，也就是说当前我们的dialog已经不再显示了，则我们不需要往下在执行。</p>
<p>然后我们调用了mWindow.isDestroyed()方法，判断Window对象是否已经被销毁，若已经被销毁，则直接return，并打印错误日志。</p>
<p>然后我们调用了mWindowManager.removeViewImmediate(mDector)，这里的mDector是我们Dialog窗口的根布局，看这个方法的名字应该就是Dialog去除根布局的操作了，可以看一下这个方法的具体实现。前几篇文章中我们已经分析过了这里的mWindowManager其实是WindowManagerImpl的实例，所以这里的removeViewImmediate方法应该是WindowManagerImpl中的方法，我们看一下它的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void removeViewImmediate(View view) &#123;</span><br><span class="line">        mGlobal.removeView(view, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里它调用了mGlobal.removeView方法，而这里的mGlobal是WindowManagerGlobal的实例，所以我们再看一下WIndowManagerGlobal中removeView的实现逻辑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void removeView(View view, boolean immediate) &#123;</span><br><span class="line">        if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            int index &#x3D; findViewLocked(view, true);</span><br><span class="line">            View curView &#x3D; mRoots.get(index).getView();</span><br><span class="line">            removeViewLocked(index, immediate);</span><br><span class="line">            if (curView &#x3D;&#x3D; view) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw new IllegalStateException(&quot;Calling with view &quot; + view</span><br><span class="line">                    + &quot; but the ViewAncestor is attached to &quot; + curView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里在获取了保存的mDector组件之后，又调用了removeViewLocked方法，我们在看一下这个方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void removeViewLocked(int index, boolean immediate) &#123;</span><br><span class="line">        ViewRootImpl root &#x3D; mRoots.get(index);</span><br><span class="line">        View view &#x3D; root.getView();</span><br><span class="line"></span><br><span class="line">        if (view !&#x3D; null) &#123;</span><br><span class="line">            InputMethodManager imm &#x3D; InputMethodManager.getInstance();</span><br><span class="line">            if (imm !&#x3D; null) &#123;</span><br><span class="line">                imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean deferred &#x3D; root.die(immediate);</span><br><span class="line">        if (view !&#x3D; null) &#123;</span><br><span class="line">            view.assignParent(null);</span><br><span class="line">            if (deferred) &#123;</span><br><span class="line">                mDyingViews.add(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到了么，我们获取了mDector组件的ViewRootImpl，然后调用了其的die方法，通过这个方法实现Window组件的销毁流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean die(boolean immediate) &#123;</span><br><span class="line">        &#x2F;&#x2F; Make sure we do execute immediately if we are in the middle of a traversal or the damage</span><br><span class="line">        &#x2F;&#x2F; done by dispatchDetachedFromWindow will cause havoc on return.</span><br><span class="line">        if (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">            doDie();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mIsDrawing) &#123;</span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.e(TAG, &quot;Attempting to destroy the window while drawing!\n&quot; +</span><br><span class="line">                    &quot;  window&#x3D;&quot; + this + &quot;, title&#x3D;&quot; + mWindowAttributes.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中有调用了doDie方法，看名字应该就是真正执行window销毁工作的方法了，我们在看一下doDie方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void doDie() &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mRemoved) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mRemoved &#x3D; true;</span><br><span class="line">            if (mAdded) &#123;</span><br><span class="line">                dispatchDetachedFromWindow();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">                destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">                if (mView !&#x3D; null) &#123;</span><br><span class="line">                    int viewVisibility &#x3D; mView.getVisibility();</span><br><span class="line">                    boolean viewVisibilityChanged &#x3D; mViewVisibility !&#x3D; viewVisibility;</span><br><span class="line">                    if (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                        &#x2F;&#x2F; If layout params have been changed, first give them</span><br><span class="line">                        &#x2F;&#x2F; to the window manager to make sure it has the correct</span><br><span class="line">                        &#x2F;&#x2F; animation info.</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if ((relayoutWindow(mWindowAttributes, viewVisibility, false)</span><br><span class="line">                                    &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) !&#x3D; 0) &#123;</span><br><span class="line">                                mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mSurface.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAdded &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        WindowManagerGlobal.getInstance().doRemoveView(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，首先调用了checkThread方法，介绍Activity的绘制流程的时候有过介绍，判断当前执行代码的线程，若不是主线程，则抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">        if (mThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new CalledFromWrongThreadException(</span><br><span class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们顺着doDie的方法往下看，又调用了dispatchDetachedFromWindow()方法，这个方法主要是销毁Window中的各中成员变量，临时变量等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void dispatchDetachedFromWindow() &#123;</span><br><span class="line">        if (mView !&#x3D; null &amp;&amp; mView.mAttachInfo !&#x3D; null) &#123;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);</span><br><span class="line">            mView.dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAccessibilityInteractionConnectionManager.ensureNoConnection();</span><br><span class="line">        mAccessibilityManager.removeAccessibilityStateChangeListener(</span><br><span class="line">                mAccessibilityInteractionConnectionManager);</span><br><span class="line">        mAccessibilityManager.removeHighTextContrastStateChangeListener(</span><br><span class="line">                mHighContrastTextManager);</span><br><span class="line">        removeSendWindowContentChangedCallback();</span><br><span class="line"></span><br><span class="line">        destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">        setAccessibilityFocus(null, null);</span><br><span class="line"></span><br><span class="line">        mView.assignParent(null);</span><br><span class="line">        mView &#x3D; null;</span><br><span class="line">        mAttachInfo.mRootView &#x3D; null;</span><br><span class="line"></span><br><span class="line">        mSurface.release();</span><br><span class="line"></span><br><span class="line">        if (mInputQueueCallback !&#x3D; null &amp;&amp; mInputQueue !&#x3D; null) &#123;</span><br><span class="line">            mInputQueueCallback.onInputQueueDestroyed(mInputQueue);</span><br><span class="line">            mInputQueue.dispose();</span><br><span class="line">            mInputQueueCallback &#x3D; null;</span><br><span class="line">            mInputQueue &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mInputEventReceiver !&#x3D; null) &#123;</span><br><span class="line">            mInputEventReceiver.dispose();</span><br><span class="line">            mInputEventReceiver &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            mWindowSession.remove(mWindow);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Dispose the input channel after removing the window so the Window Manager</span><br><span class="line">        &#x2F;&#x2F; doesn&#39;t interpret the input channel being closed as an abnormal termination.</span><br><span class="line">        if (mInputChannel !&#x3D; null) &#123;</span><br><span class="line">            mInputChannel.dispose();</span><br><span class="line">            mInputChannel &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     mDisplayManager.unregisterDisplayListener(mDisplayListener);</span><br><span class="line"></span><br><span class="line">        unscheduleTraversals();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们在方法中调用了mView.dispatchDetachedFromWindow方法，这个方法的作用就是将mView从Window中detach出来，我们可以看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void dispatchDetachedFromWindow() &#123;</span><br><span class="line">        AttachInfo info &#x3D; mAttachInfo;</span><br><span class="line">        if (info !&#x3D; null) &#123;</span><br><span class="line">            int vis &#x3D; info.mWindowVisibility;</span><br><span class="line">            if (vis !&#x3D; GONE) &#123;</span><br><span class="line">                onWindowVisibilityChanged(GONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onDetachedFromWindow();</span><br><span class="line">        onDetachedFromWindowInternal();</span><br><span class="line"></span><br><span class="line">        InputMethodManager imm &#x3D; InputMethodManager.peekInstance();</span><br><span class="line">        if (imm !&#x3D; null) &#123;</span><br><span class="line">            imm.onViewDetachedFromWindow(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">        final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners &#x3D;</span><br><span class="line">                li !&#x3D; null ? li.mOnAttachStateChangeListeners : null;</span><br><span class="line">        if (listeners !&#x3D; null &amp;&amp; listeners.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to</span><br><span class="line">            &#x2F;&#x2F; perform the dispatching. The iterator is a safe guard against listeners that</span><br><span class="line">            &#x2F;&#x2F; could mutate the list by calling the various add&#x2F;remove methods. This prevents</span><br><span class="line">            &#x2F;&#x2F; the array from being modified while we iterate it.</span><br><span class="line">            for (OnAttachStateChangeListener listener : listeners) &#123;</span><br><span class="line">                listener.onViewDetachedFromWindow(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) !&#x3D; 0) &#123;</span><br><span class="line">            mAttachInfo.mScrollContainers.remove(this);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_SCROLL_CONTAINER_ADDED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAttachInfo &#x3D; null;</span><br><span class="line">        if (mOverlay !&#x3D; null) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中onDetachedFromWindow方法是一个空的回调方法，这里我们重点看一下onDetachedFromWindowInternal方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void onDetachedFromWindowInternal() &#123;</span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_CANCEL_NEXT_UP_EVENT;</span><br><span class="line">        mPrivateFlags3 &amp;&#x3D; ~PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">        removeUnsetPressCallback();</span><br><span class="line">        removeLongPressCallback();</span><br><span class="line">        removePerformClickCallback();</span><br><span class="line">        removeSendViewScrolledAccessibilityEventCallback();</span><br><span class="line">        stopNestedScroll();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Anything that started animating right before detach should already</span><br><span class="line">        &#x2F;&#x2F; be in its final state when re-attached.</span><br><span class="line">        jumpDrawablesToCurrentState();</span><br><span class="line"></span><br><span class="line">        destroyDrawingCache();</span><br><span class="line"></span><br><span class="line">        cleanupDraw();</span><br><span class="line">        mCurrentAnimation &#x3D; null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onDetachedFromWindowInternal方法的方法体也不是特别长，都是一些调用函数，这里看一下destropDrawingCache方法，这个方法主要是销毁View的缓存Drawing，我们来看一下具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void destroyDrawingCache() &#123;</span><br><span class="line">        if (mDrawingCache !&#x3D; null) &#123;</span><br><span class="line">            mDrawingCache.recycle();</span><br><span class="line">            mDrawingCache &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mUnscaledDrawingCache !&#x3D; null) &#123;</span><br><span class="line">            mUnscaledDrawingCache.recycle();</span><br><span class="line">            mUnscaledDrawingCache &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mDrawingCache其实就是一个Bitmap类型的成员变量，而这里调用的recycler和置空操作其实就是把View中执行draw方法之后缓存的bitmap清空。</p>
<p>这里需要说明的是，我们View组件的最终显示落实是通过draw方法实现绘制的，而我们的draw方法的参数是一个Canvas，这是一个画布的对象，通过draw方法就是操作这个对象并显示出来，而Canvas对象之所以能够实现显示的效果是因为其内部保存着一个Bitmap对象，通过操作Canvas对象实质上是操作Canvas对象内部的Bitmap对象，而View组件的显示也就是通过这里的Bitmap来实现的。</p>
<p>而我们上文中置空了bitmap对象就相当于把View组件的显示效果置空了，就是相当于我们取消了View的draw方法的执行效果，继续回到我们的dispatchDetachedFromWindow方法，在执行了mView.dispatchDetachedFromWindow()方法之后，又调用了mView = null;方法，这里设置mView为空，这样我们有取消了View的meature和layouot的执行效果。</p>
<p>这样经过一系列的操作之后我们的Dialog的取消绘制流程就结束了，现在我们来看一下Activity的取消绘制流程。还记得我们“Activity的销毁流程”么？可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51232309" target="_blank" rel="noopener">android源码解析之（十五）–&gt;Activity销毁流程</a><br>当我们调用activity的finish方法的时候回调用ActivityThread的handleDestroyActivity方法，我们来看一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void handleDestroyActivity(IBinder token, boolean finishing,</span><br><span class="line">            int configChanges, boolean getNonConfigInstance) &#123;</span><br><span class="line">        ...</span><br><span class="line">        wm.removeViewImmediate(v);</span><br><span class="line">        ...            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了这里调用了wm.removeViewImmediate方法，这个方法不就是我们刚刚分析Dialog销毁绘制流程的起始方法么？以后的逻辑都是详细的，这样我们就实现了Activity的取消绘制流程。</p>
<p>总结：</p>
<ul>
<li><p>窗口的取消绘制流程是相似的，包括Activity和Dialog等；</p>
</li>
<li><p>通过调用WindowManager.removeViewImmediate方法，开始执行Window窗口的取消绘制流程；</p>
</li>
<li><p>Window窗口的取消绘制流程，通过清空bitma撤销draw的执行效果，通过置空View撤销meature和layout的执行效果；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/19%20Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/19%20Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">19 Dialog加载绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面两篇文章，我们分析了Activity的布局文件加载、绘制流程，算是对整个Android系统中界面的显示流程有了一个大概的了解，其实Android系统中所有的显示控件（注意这里是控件，而不是组件）的加载绘制流程都是类似的，包括：Dialog的加载绘制流程，PopupWindow的加载绘制流程，Toast的显示原理等，上一篇文章中，我说在介绍了Activity界面的加载绘制流程之后，就会分析一下剩余几个控件的显示控制流程，这里我打算先分析一下Dialog的加载绘制流程。</p>
<p>可能有的同学问这里为什么没有Fragment？其实严格意义上来说Fragment并不是一个显示控件，而只是一个显示组件。为什么这么说呢？其实像我们的Activity，Dialog，PopupWindow以及Toast类的内部都管理维护着一个Window对象，这个Window对象不但是一个View组件的集合管理对象，它也实现了组件的加载与绘制流程，而我们的Fragment组件如果看过源码的话，严格意义上来说，只是一个View组件的集合并通过控制变量实现了其特定的生命周期，但是其由于并没有维护Window类型的成员变量，所以其不具备组件的加载与绘制功能，因此其不能单独的被绘制出来，这也是我把它称之为组件而不是控件的原因。（在分析完这几个控件的加载绘制流程之后，有时间的话，也会分析一下Fragment的相关源码）</p>
<p>好吧，开始我们今天关于Dialog的讲解，相信大家在平时的开发过程中经常会使用到Dialog弹窗，使用Dialog可以在Activity弹出弹窗，确认消息等。为了更好的分析Dialog的源码，我们这里暂时写一个简单的demo，看一下Dialog的使用实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">title.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">                AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(MainActivity.this);</span><br><span class="line">                builder.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">                builder.setMessage(&quot;this is the content view!!!&quot;);</span><br><span class="line">                builder.setTitle(&quot;this is the title view!!!&quot;);</span><br><span class="line">                builder.setView(R.layout.activity_second);</span><br><span class="line">                builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                        alertDialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                alertDialog &#x3D; builder.create();</span><br><span class="line">                alertDialog.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>我们在Activity中获取一个textView组件，并监听TextView的点击事件，并在点击事件中，初始化一个AlertDialog弹窗，并执行AlertDialog的show方法展示弹窗，在弹窗中定义一个按钮，并监听弹窗按钮的点击事件，若用户点击了弹窗的按钮，则执行AlertDialog的dismiss方法，取消展示AlertDialog。好吧，我们来看一下这个弹窗弹出的展示结果：<br><img src="http://img.blog.csdn.net/20160501105319191" alt="这里写图片描述"><br>可以看到我们定义的icon，title，message和button都已经显示出来了，这时候我们点击弹窗按钮知道了，这时候弹窗就会消失了。</p>
<p>一般我们使用Dialog的大概流程都是这样的，可能定制Dialog的时候有一些定制化的操作，但是基本操作流程还是这样的。</p>
<p>那么我们先来看一下AlertDialog.Builder的构造方法，这里的Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Builder(Context context) &#123;</span><br><span class="line">            this(context, resolveDialogTheme(context, 0));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里调用的是Builder的重载构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder(Context context, int themeResId) &#123;</span><br><span class="line">            P &#x3D; new AlertController.AlertParams(new ContextThemeWrapper(</span><br><span class="line">                    context, resolveDialogTheme(context, themeResId)));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>那么这里的P是AlertDialog.Builder中的一个AlertController.AlertParams类型的成员变量，可见在这里执行了P的初始化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public AlertParams(Context context) &#123;</span><br><span class="line">            mContext &#x3D; context;</span><br><span class="line">            mCancelable &#x3D; true;</span><br><span class="line">            mInflater &#x3D; (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量。这样执行了一系列操作之后我们的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(MainActivity.this);</span><br></pre></td></tr></table></figure>
<p>就已经执行完成了，然后我们调用了builder.setIcon方法，这里看一下setIcon方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setIcon(@DrawableRes int iconId) &#123;</span><br><span class="line">            P.mIconId &#x3D; iconId;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到AlertDialog的Builder的setIcon方法，这里执行的就是给类型为AlertController.AlertParams的P的mIconId赋值为传递的iconId，并且这个方法返回的类型就是Builder。</p>
<p>然后我们调用了builder.setMessage方法，可以看一下builder.setMessage方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setMessage(CharSequence message) &#123;</span><br><span class="line">            P.mMessage &#x3D; message;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里跟setIcon方法的实现逻辑类似，都是给成员变量的mMessage赋值为我们传递的Message值，且和setIcon方法类似的，这个方法返回值也是Builder。</p>
<p>再看一下builder.setTitle方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setTitle(CharSequence title) &#123;</span><br><span class="line">            P.mTitle &#x3D; title;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现builder的setIcon、setMessage、setTitle等方法都是给Builder的成员变量P的icon，message，title赋值。</p>
<p>然后我们看一下builder.setView方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Builder setView(int layoutResId) &#123;</span><br><span class="line">            P.mView &#x3D; null;</span><br><span class="line">            P.mViewLayoutResId &#x3D; layoutResId;</span><br><span class="line">            P.mViewSpacingSpecified &#x3D; false;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里的setView和setIcon，setMessage，setTitle等方法都是类似的，都是将我们传递的数据值赋值给Builder的成员变量P。</p>
<p>然后我们调用了builder.setPositiveButton方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                        alertDialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>好吧，这里我们看一下builder的setPositiveButton的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123;</span><br><span class="line">            P.mPositiveButtonText &#x3D; text;</span><br><span class="line">            P.mPositiveButtonListener &#x3D; listener;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，可以发现跟上面几个方法还是类似的，都是为Builder的成员变量P的相应成员变量赋值。。。</p>
<p>上面的几行代码我们都是调用的builder.setXXX等方法，主要就是为Builder的成员变量P的相应成员变量值赋值。并且setXX方法返回值都是Builder类型的，因此我们可以通过消息琏的方式连续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setIcon().setMessage().setTitle().setView().setPositiveButton()...</span><br></pre></td></tr></table></figure>
<p>这样代码显得比较简洁，set方法的执行顺序是没有固定模式的，这里多说一下，这种编程方式很优秀，平时我们在设计构造类工具类的时候也可以参考这种模式，构造类有不同的功能或者特性，并且都不是必须的，我们可以通过set方法设置不同的特性值并返回构造类本身。</p>
<p>然后我们调用了builder.create方法，并且这个方法返回了AlertDialog。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public AlertDialog create() &#123;</span><br><span class="line">            &#x2F;&#x2F; Context has already been wrapped with the appropriate theme.</span><br><span class="line">            final AlertDialog dialog &#x3D; new AlertDialog(P.mContext, 0, false);</span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            if (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(true);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</span><br><span class="line">            if (P.mOnKeyListener !&#x3D; null) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            return dialog;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里首先构造了一个AlertDialog，我们可以看一下这个构造方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;</span><br><span class="line">        super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0,</span><br><span class="line">                createContextThemeWrapper);</span><br><span class="line"></span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert &#x3D; new AlertController(getContext(), this, getWindow());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里首先调用了super的构造方法，而我们的AlertDialog继承于Dialog，所以这里执行的就是Dialog的构造方法，好吧，继续看一下Dialog的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;</span><br><span class="line">        if (createContextThemeWrapper) &#123;</span><br><span class="line">            if (themeResId &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                final TypedValue outValue &#x3D; new TypedValue();</span><br><span class="line">                context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true);</span><br><span class="line">                themeResId &#x3D; outValue.resourceId;</span><br><span class="line">            &#125;</span><br><span class="line">            mContext &#x3D; new ContextThemeWrapper(context, themeResId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mContext &#x3D; context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowManager &#x3D; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">        final Window w &#x3D; new PhoneWindow(mContext);</span><br><span class="line">        mWindow &#x3D; w;</span><br><span class="line">        w.setCallback(this);</span><br><span class="line">        w.setOnWindowDismissedCallback(this);</span><br><span class="line">        w.setWindowManager(mWindowManager, null, null);</span><br><span class="line">        w.setGravity(Gravity.CENTER);</span><br><span class="line"></span><br><span class="line">        mListenersHandler &#x3D; new ListenersHandler(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在Dialog的构造方法中直接直接构造了一个PhoneWindow，并赋值给Dialog的成员变量mWindow，从这里可以看出其实Dialog和Activity的显示逻辑都是类似的，都是通过对应的Window变量来实现窗口的加载与显示的。然后我们执行了一些Window对象的初始化操作，比如设置回调函数为本身，然后调用了Window类的setWindowManager方法，并传入了WindowManager，可以发现这里的WindowManager对象是通过方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager &#x3D; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br></pre></td></tr></table></figure>
<p>获取的，而我们的context传入的是Activity对象，所以这里的WindowManager对象其实和Activity获取的WindowManager对象是一致的。然后我们看一下window类的setWindowManager方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void setWindowManager(WindowManager wm, IBinder appToken, String appName,</span><br><span class="line">            boolean hardwareAccelerated) &#123;</span><br><span class="line">        mAppToken &#x3D; appToken;</span><br><span class="line">        mAppName &#x3D; appName;</span><br><span class="line">        mHardwareAccelerated &#x3D; hardwareAccelerated</span><br><span class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);</span><br><span class="line">        if (wm &#x3D;&#x3D; null) &#123;</span><br><span class="line">            wm &#x3D; (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到跟Activity的Window对象的windowManager的获取方式是相同的，都是通过new的方式创建一个新的WindowManagerImpl对象。好吧，继续回到我们的AlertDialog的构造方法中，在构造方法中，我们除了调用Dialog的构造方法之外还执行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAlert &#x3D; new AlertController(getContext(), this, getWindow());</span><br></pre></td></tr></table></figure>
<p>相当于初始化了AlertDiaog的成员变量mAlert。</p>
<p>继续回到我们的AlertDialog.Builder.create方法，在创建了一个AlertDialog之后，又执行了P.apply(dialog.mAlert)；<br>我们知道这里的P是一个AlertController.AlertParams的变量，而dialog.mAlert是我们刚刚创建的AlertDialog中的一个AlertController类型的变量，我们来看一下apply方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ublic void apply(AlertController dialog) &#123;</span><br><span class="line">            if (mCustomTitleView !&#x3D; null) &#123;</span><br><span class="line">                dialog.setCustomTitle(mCustomTitleView);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mTitle !&#x3D; null) &#123;</span><br><span class="line">                    dialog.setTitle(mTitle);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mIcon !&#x3D; null) &#123;</span><br><span class="line">                    dialog.setIcon(mIcon);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mIconId !&#x3D; 0) &#123;</span><br><span class="line">                    dialog.setIcon(mIconId);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mIconAttrId !&#x3D; 0) &#123;</span><br><span class="line">                    dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mMessage !&#x3D; null) &#123;</span><br><span class="line">                dialog.setMessage(mMessage);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPositiveButtonText !&#x3D; null) &#123;</span><br><span class="line">                dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</span><br><span class="line">                        mPositiveButtonListener, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mNegativeButtonText !&#x3D; null) &#123;</span><br><span class="line">                dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</span><br><span class="line">                        mNegativeButtonListener, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mNeutralButtonText !&#x3D; null) &#123;</span><br><span class="line">                dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</span><br><span class="line">                        mNeutralButtonListener, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mForceInverseBackground) &#123;</span><br><span class="line">                dialog.setInverseBackgroundForced(true);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; For a list, the client can either supply an array of items or an</span><br><span class="line">            &#x2F;&#x2F; adapter or a cursor</span><br><span class="line">            if ((mItems !&#x3D; null) || (mCursor !&#x3D; null) || (mAdapter !&#x3D; null)) &#123;</span><br><span class="line">                createListView(dialog);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mView !&#x3D; null) &#123;</span><br><span class="line">                if (mViewSpacingSpecified) &#123;</span><br><span class="line">                    dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,</span><br><span class="line">                            mViewSpacingBottom);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dialog.setView(mView);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (mViewLayoutResId !&#x3D; 0) &#123;</span><br><span class="line">                dialog.setView(mViewLayoutResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>看到了么？就是我们在初始化AlertDialog.Builder的时候设置的icon、title、message赋值给了AlertController.AlertParams，这里就是将我们初始化时候设置的属性值赋值给我们创建的Dialog对象的mAlert成员变量。。。。</p>
<p>继续我们的AlertDialog.Builder.create方法，在执行了AlertController.AlertParams.apply方法之后又调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dialog.setCancelable(P.mCancelable);</span><br></pre></td></tr></table></figure>
<p>可以发现这个也是AertController.AlertParams的一个成员变量，我们在初始化AlertDialog.Builder的时候也可以通过设置builder.setCancelable赋值，由于该属性为成员变量，所以默认值为false，而我们并没有通过builder.setCancelable修改这个属性值，所以这里设置的dialog的cancelable的值为false。然后我们的create方法有设置了dialog的cancelListener和dismissListener并返回了我们创建的Dialog对象。这样我们就获取到了我们的Dialog对象，然后我们调用了dialog的show方法用于显示dialog，好吧，这里我们看一下show方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public void show() &#123;</span><br><span class="line">        if (mShowing) &#123;</span><br><span class="line">            if (mDecor !&#x3D; null) &#123;</span><br><span class="line">                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">                &#125;</span><br><span class="line">                mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCanceled &#x3D; false;</span><br><span class="line">        </span><br><span class="line">        if (!mCreated) &#123;</span><br><span class="line">            dispatchOnCreate(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onStart();</span><br><span class="line">        mDecor &#x3D; mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">        if (mActionBar &#x3D;&#x3D; null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">            final ApplicationInfo info &#x3D; mContext.getApplicationInfo();</span><br><span class="line">            mWindow.setDefaultIcon(info.icon);</span><br><span class="line">            mWindow.setDefaultLogo(info.logo);</span><br><span class="line">            mActionBar &#x3D; new WindowDecorActionBar(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WindowManager.LayoutParams l &#x3D; mWindow.getAttributes();</span><br><span class="line">        if ((l.softInputMode</span><br><span class="line">                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            WindowManager.LayoutParams nl &#x3D; new WindowManager.LayoutParams();</span><br><span class="line">            nl.copyFrom(l);</span><br><span class="line">            nl.softInputMode |&#x3D;</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">            l &#x3D; nl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            mWindowManager.addView(mDecor, l);</span><br><span class="line">            mShowing &#x3D; true;</span><br><span class="line">    </span><br><span class="line">            sendShowMessage();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体的内容比较多，我们慢慢看，由于一开始mShowing变量用于表示当前dialog是否正在显示，由于我们刚刚开始调用执行show方法，所以这里的mShowing变量的值为false，所以if分支的内容不会被执行，继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!mCreated) &#123;</span><br><span class="line">            dispatchOnCreate(null);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>mCreated这个控制变量控制dispatchOnCreate方法只被执行一次，由于我们是第一次执行，所以这里会执行dispatchOnCreate方法，好吧，我们看一下dispatchOnCreate方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void dispatchOnCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        if (!mCreated) &#123;</span><br><span class="line">            onCreate(savedInstanceState);</span><br><span class="line">            mCreated &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，可以看到代码的执行逻辑很简单就是回调了Dialog的onCreate方法，那么onCreate方法内部又执行了那些逻辑呢？由于我们创建的是AlertDialog对象，该对象继承于Dialog，所以我们这时候需要看一下AlertDialog的onCreate方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mAlert.installContent();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里面除了调用super.onCreate方法之外就是调用了mAlert.installContent方法，而这里的super.onCreate方法就是调用的Dialog的onCreate方法，Dialog的onCreate方法只是一个空的实现逻辑，所以我们具体来看一下mAlert.installContent的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void installContent() &#123;</span><br><span class="line">        &#x2F;* We use a custom title so never request a window title *&#x2F;</span><br><span class="line">        mWindow.requestFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        int contentView &#x3D; selectContentView();</span><br><span class="line">        mWindow.setContentView(contentView);</span><br><span class="line">        setupView();</span><br><span class="line">        setupDecor();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里实现Window窗口的页面设置布局初始化等操作，这里设置了mWindow对象为NO_TITLE，然后通过调用selectContentView设置Window对象的布局文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int selectContentView() &#123;</span><br><span class="line">        if (mButtonPanelSideLayout &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return mAlertDialogLayout;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mButtonPanelLayoutHint &#x3D;&#x3D; AlertDialog.LAYOUT_HINT_SIDE) &#123;</span><br><span class="line">            return mButtonPanelSideLayout;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; TODO: use layout hint side for long messages&#x2F;lists</span><br><span class="line">        return mAlertDialogLayout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里通过执行selectContentView方法返回布局文件的id值，这里的默认值是mAlertDialogLayout。看过Activity布局加载流程（<a href="http://blog.csdn.net/qq_23547831/article/details/51284556" target="_blank" rel="noopener">android源码解析（十七）–&gt;Activity布局加载流程</a>）的童鞋应该知道，从这个方法开始我们就把指定布局文件的内容加载到内存中的Window对象中。我们这里看一下具体的布局文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mAlertDialogLayout &#x3D; a.getResourceId(</span><br><span class="line">                R.styleable.AlertDialog_layout, R.layout.alert_dialog);</span><br></pre></td></tr></table></figure>
<p>也就是R.layout.alert_dialog的布局文件，有兴趣的同学可以看一下该布局文件的源码，O(∩_∩)O哈哈~</p>
<p>继续回到我们的installContent方法，在执行了mWindow.setContentView方法之后，又调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量，这里就不在详细的说明。</p>
<p>然后回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法，这个方法主要用于设置ActionBar，这里不做过多的说明，然后初始化WindowManager.LayoutParams对象，并最终调用我们的mWindowManager.addView()方法。</p>
<p>O(∩_∩)O哈哈~，到了这一步大家如果看了上一篇Acitivty布局绘制流程的话，就应该知道顺着这个方法整个Dialog的界面就会被绘制出来了。</p>
<p>最后我们调用了sendShowMessage方法，可以看一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void sendShowMessage() &#123;</span><br><span class="line">        if (mShowMessage !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; Obtain a new message so this dialog can be re-used</span><br><span class="line">            Message.obtain(mShowMessage).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里会发送一个Dialog已经显示的异步消息，该消息最终会在ListenersHandler中的handleMessage方法中被执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static final class ListenersHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;DialogInterface&gt; mDialog;</span><br><span class="line"></span><br><span class="line">        public ListenersHandler(Dialog dialog) &#123;</span><br><span class="line">            mDialog &#x3D; new WeakReference&lt;DialogInterface&gt;(dialog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case DISMISS:</span><br><span class="line">                    ((OnDismissListener) msg.obj).onDismiss(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case CANCEL:</span><br><span class="line">                    ((OnCancelListener) msg.obj).onCancel(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case SHOW:</span><br><span class="line">                    ((OnShowListener) msg.obj).onShow(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于我们的msg.what = SHOW,所以会执行OnShowListener.onShow方法，那么这个OnShowListener是何时赋值的呢？还记得我们构造AlertDialog.Builder么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alertDialog.setOnShowListener(new DialogInterface.OnShowListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onShow(DialogInterface dialog) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>这样就为我们的AlertDialog.Builder设置了OnShowListener，可以看一下setOnShowListener方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setOnShowListener(OnShowListener listener) &#123;</span><br><span class="line">        if (listener !&#x3D; null) &#123;</span><br><span class="line">            mShowMessage &#x3D; mListenersHandler.obtainMessage(SHOW, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mShowMessage &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样就为我们的Dialog中的mListenersHandler构造了Message对象，并且当我们在Dialog中发送showMessage的时候被mListenersHandler所接收。。。。</p>
<p>注：<br>这里说一下我们平时开发中若创建的Dialog使用的Context对象不是Activity，就会报出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Process: com.example.aaron.helloworld, PID: 11948                                                                         android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application</span><br><span class="line">at android.view.ViewRootImpl.setView(ViewRootImpl.java:690)</span><br><span class="line">at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:282)</span><br><span class="line">at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)</span><br><span class="line">at android.app.Dialog.show(Dialog.java:298)</span><br><span class="line">at com.example.aaron.helloworld.MainActivity$1.onClick(MainActivity.java:59)</span><br><span class="line">at android.view.View.performClick(View.java:4811)</span><br><span class="line">at android.view.View$PerformClick.run(View.java:20136)</span><br><span class="line">at android.os.Handler.handleCallback(Handler.java:815)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:104)</span><br><span class="line">at android.os.Looper.loop(Looper.java:194)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:5552)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759)</span><br></pre></td></tr></table></figure>
<p>的异常，这是由于WindowManager.addView方法最终会调用ViewRootImpl.setView方法，而这时候会有mToken的检查，若我们传入的Context对象不是Activity，这时候的mToken为空，就会出现上述问题。。。</p>
<p>总结：</p>
<ul>
<li><p>Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑；</p>
</li>
<li><p>Dialog中的Window对象与Activity中的Window对象是相似的，都对应着一个WindowManager对象；</p>
</li>
<li><p>Dialog相关的几个类：Dialog，AlertDialog，AlertDialog.Builder，AlertController，AlertController.AlertParams，其中Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑，而AlertDialog是具体的Dialog的操作实现类，AlertDialog.Builder类是AlertDialog的内部类，主要用于构造AlertDialog，AlertController是AlertDialog的控制类，AlertController.AlertParams类是控制参数类；</p>
</li>
<li><p>构造显示Dialog的一般流程，构造AlertDialog.Builder，然后设置各种属性，最后调用AlertDialog.Builder.create方法获取AlertDialog对象，并且create方法中会执行，构造AlertDialog，设置dialog各种属性的操作。最后我们调用Dialog.show方法展示窗口，初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，并最终将Dialog显示出来；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
