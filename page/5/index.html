<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Volley源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:26:01 / 修改时间：11:35:52" itemprop="dateCreated datePublished" datetime="2020-05-31T11:26:01+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>本文基于Volley 1.1.1版本的源码。</p>
<p>Volley是Google官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持HttpClient、HttpUrlConnection，甚至支持OkHttp。Volley不适用于下载大量内容的操作或流式传输操作，因为在解析过程中，Volley会将所有响应存储在内存中，因此Volley不适合上传和下载大文件。</p>
<p>添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.android.volley:volley:1.1.1&#39;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue queue &#x3D; Volley.newRequestQueue(context);</span><br><span class="line">String url &#x3D;&quot;http:&#x2F;&#x2F;www.google.com&quot;;</span><br><span class="line"></span><br><span class="line">StringRequest stringRequest &#x3D; new StringRequest(Request.Method.GET, url,</span><br><span class="line">            new Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    public void onResponse(String response) &#123;</span><br><span class="line">        &#x2F;&#x2F; in UI Thread</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, new Response.ErrorListener() &#123;</span><br><span class="line">    </span><br><span class="line">    public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">        &#x2F;&#x2F; in UI Thread</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">stringRequest.setTag(TAG);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Add the request to the RequestQueue.</span><br><span class="line">queue.add(stringRequest);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; onStop</span><br><span class="line">queue.cancelAll(TAG);</span><br></pre></td></tr></table></figure>

<h5 id="创建请求队列"><a href="#创建请求队列" class="headerlink" title="创建请求队列"></a>创建请求队列</h5><p>Volley类中有多个重载的newRequestQueue静态方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Volley &#123;</span><br><span class="line">    private static final String DEFAULT_CACHE_DIR &#x3D; &quot;volley&quot;;</span><br><span class="line"></span><br><span class="line">    public static RequestQueue newRequestQueue(Context context) &#123;</span><br><span class="line">        return newRequestQueue(context, (BaseHttpStack) null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123;</span><br><span class="line">        BasicNetwork network;</span><br><span class="line">        if (stack &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;&#x3D; 9) &#123;</span><br><span class="line">                network &#x3D; new BasicNetwork(new HurlStack());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            network &#x3D; new BasicNetwork(stack);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return newRequestQueue(context, network);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static RequestQueue newRequestQueue(Context context, Network network) &#123;</span><br><span class="line">        final Context appContext &#x3D; context.getApplicationContext();</span><br><span class="line">        DiskBasedCache.FileSupplier cacheSupplier &#x3D;</span><br><span class="line">                new DiskBasedCache.FileSupplier() &#123;</span><br><span class="line">                    private File cacheDir &#x3D; null;</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                    public File get() &#123;</span><br><span class="line">                        if (cacheDir &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            cacheDir &#x3D; new File(appContext.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return cacheDir;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">        RequestQueue queue &#x3D; new RequestQueue(new DiskBasedCache(cacheSupplier), network);</span><br><span class="line">        queue.start();</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestQueue类构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class RequestQueue &#123;</span><br><span class="line">    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE &#x3D; 4;</span><br><span class="line">    private final Cache mCache;</span><br><span class="line">    private final Network mNetwork;</span><br><span class="line">    private final ResponseDelivery mDelivery;</span><br><span class="line">    private final NetworkDispatcher[] mDispatchers;</span><br><span class="line">    private CacheDispatcher mCacheDispatcher;</span><br><span class="line"></span><br><span class="line">    public RequestQueue(</span><br><span class="line">            Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) &#123;</span><br><span class="line">        mCache &#x3D; cache;</span><br><span class="line">        mNetwork &#x3D; network;</span><br><span class="line">        mDispatchers &#x3D; new NetworkDispatcher[threadPoolSize];</span><br><span class="line">        mDelivery &#x3D; delivery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</span><br><span class="line">        this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestQueue(Cache cache, Network network) &#123;</span><br><span class="line">        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestQueue#start()方法如下，可以看出就是启动了一个Cache Dispatcher和指定数目的Network Dispatcher：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Starts the dispatchers in this queue. *&#x2F;</span><br><span class="line">public void start() &#123;</span><br><span class="line">    &#x2F;&#x2F; Make sure any currently running dispatchers are stopped.</span><br><span class="line">    stop();</span><br><span class="line">    &#x2F;&#x2F; Create the cache dispatcher and start it.</span><br><span class="line">    mCacheDispatcher &#x3D; new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create network dispatchers (and corresponding threads) up to the pool size.</span><br><span class="line">    for (int i &#x3D; 0; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher &#x3D; new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] &#x3D; networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** Stops the cache and network dispatchers. *&#x2F;</span><br><span class="line">public void stop() &#123;</span><br><span class="line">    if (mCacheDispatcher !&#x3D; null) &#123;</span><br><span class="line">        mCacheDispatcher.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    for (final NetworkDispatcher mDispatcher : mDispatchers) &#123;</span><br><span class="line">        if (mDispatcher !&#x3D; null) &#123;</span><br><span class="line">            mDispatcher.quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RequestQueue事件"><a href="#RequestQueue事件" class="headerlink" title="RequestQueue事件"></a>RequestQueue事件</h5><p>在RequestQueue类中定义了一些事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public  RequestEvent &#123;</span><br><span class="line">    &#x2F;** The request was added to the queue. *&#x2F;</span><br><span class="line">    public static final int REQUEST_QUEUED &#x3D; 0;</span><br><span class="line">    &#x2F;** Cache lookup started for the request. *&#x2F;</span><br><span class="line">    public static final int REQUEST_CACHE_LOOKUP_STARTED &#x3D; 1;</span><br><span class="line">    &#x2F;** Cache lookup finished for the request and cached response is delivered or request is queued for network dispatching. *&#x2F;</span><br><span class="line">    public static final int REQUEST_CACHE_LOOKUP_FINISHED &#x3D; 2;</span><br><span class="line">    &#x2F;** Network dispatch started for the request. *&#x2F;</span><br><span class="line">    public static final int REQUEST_NETWORK_DISPATCH_STARTED &#x3D; 3;</span><br><span class="line">    &#x2F;** The network dispatch finished for the request and response (if any) is delivered. *&#x2F;</span><br><span class="line">    public static final int REQUEST_NETWORK_DISPATCH_FINISHED &#x3D; 4;</span><br><span class="line">    &#x2F;** All the work associated with the request is finished and request is removed from all the queues. *&#x2F;</span><br><span class="line">    public static final int REQUEST_FINISHED &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface RequestEventListener &#123;</span><br><span class="line">    void onRequestEvent(Request&lt;?&gt; request, @RequestEvent int event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final List&lt;RequestEventListener&gt; mEventListeners &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">可以通过下面几个方法操作这些事件：</span><br><span class="line"></span><br><span class="line">void sendRequestEvent(Request&lt;?&gt; request, @RequestEvent int event) &#123;</span><br><span class="line">    synchronized (mEventListeners) &#123;</span><br><span class="line">        for (RequestEventListener listener : mEventListeners) &#123;</span><br><span class="line">            listener.onRequestEvent(request, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addRequestEventListener(RequestEventListener listener) &#123;</span><br><span class="line">    synchronized (mEventListeners) &#123;</span><br><span class="line">        mEventListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeRequestEventListener(RequestEventListener listener) &#123;</span><br><span class="line">    synchronized (mEventListeners) &#123;</span><br><span class="line">        mEventListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h5><p>RequestQueue#add()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger mSequenceGenerator &#x3D; new AtomicInteger();</span><br><span class="line">private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue &#x3D; new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue &#x3D; new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;</span><br><span class="line">    &#x2F;&#x2F; Tag the request as belonging to this queue and add it to the set of current requests.</span><br><span class="line">    request.setRequestQueue(this);</span><br><span class="line">    synchronized (mCurrentRequests) &#123;</span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Process requests in the order they are added.</span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(&quot;add-to-queue&quot;);</span><br><span class="line">    sendRequestEvent(request, RequestEvent.REQUEST_QUEUED);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果请求不需要缓存的话，直接交给网络请求队列去执行，默认是需要缓存的</span><br><span class="line">    if (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        return request;</span><br><span class="line">    &#125;</span><br><span class="line">    mCacheQueue.add(request);</span><br><span class="line">    return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中把请求交给了缓存队列或者网络队列去处理。</p>
<h5 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h5><p>CacheDispatcher继承自Thread，在RequestQueue#start()方法中已经将其启动了，因此直接看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">public class CacheDispatcher extends Thread &#123;</span><br><span class="line">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;</span><br><span class="line">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;</span><br><span class="line">    private final Cache mCache;</span><br><span class="line">    private final ResponseDelivery mDelivery;</span><br><span class="line">    private volatile boolean mQuit &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Manage list of waiting requests and de-duplicate requests with same cache key. *&#x2F;</span><br><span class="line">    private final WaitingRequestManager mWaitingRequestManager;</span><br><span class="line"></span><br><span class="line">    public CacheDispatcher(</span><br><span class="line">            BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue,</span><br><span class="line">            BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</span><br><span class="line">            Cache cache,</span><br><span class="line">            ResponseDelivery delivery) &#123;</span><br><span class="line">        mCacheQueue &#x3D; cacheQueue;</span><br><span class="line">        mNetworkQueue &#x3D; networkQueue;</span><br><span class="line">        mCache &#x3D; cache;</span><br><span class="line">        mDelivery &#x3D; delivery;</span><br><span class="line">        mWaitingRequestManager &#x3D; new WaitingRequestManager(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void quit() &#123;</span><br><span class="line">        mQuit &#x3D; true;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Make a blocking call to initialize the cache.</span><br><span class="line">        mCache.initialize();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                processRequest();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; We may have been interrupted because it was time to quit.</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                VolleyLog.e(&quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot; + &quot;use quit() to terminate it&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processRequest() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 阻塞式队列</span><br><span class="line">        final Request&lt;?&gt; request &#x3D; mCacheQueue.take();</span><br><span class="line">        processRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123;</span><br><span class="line">        request.addMarker(&quot;cache-queue-take&quot;);</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; If the request has been canceled, don&#39;t bother dispatching it.</span><br><span class="line">            if (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(&quot;cache-discard-canceled&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Attempt to retrieve this item from cache.</span><br><span class="line">            Cache.Entry entry &#x3D; mCache.get(request.getCacheKey());</span><br><span class="line">            if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">                request.addMarker(&quot;cache-miss&quot;);</span><br><span class="line">                &#x2F;&#x2F; Cache miss; send off to the network dispatcher.</span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If it is completely expired, just send it to the network.</span><br><span class="line">            if (entry.isExpired()) &#123;</span><br><span class="line">                request.addMarker(&quot;cache-hit-expired&quot;);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; We have a cache hit; parse its data for delivery back to the request.</span><br><span class="line">            request.addMarker(&quot;cache-hit&quot;);</span><br><span class="line">            Response&lt;?&gt; response &#x3D; request.parseNetworkResponse(new NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">            request.addMarker(&quot;cache-hit-parsed&quot;);</span><br><span class="line"></span><br><span class="line">            if (!response.isSuccess()) &#123;</span><br><span class="line">                request.addMarker(&quot;cache-parsing-failed&quot;);</span><br><span class="line">                mCache.invalidate(request.getCacheKey(), true);</span><br><span class="line">                request.setCacheEntry(null);</span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!entry.refreshNeeded()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 缓存不需要刷新，直接交给ResponseDelivery去处理</span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 软过期的缓存命中，可以分发缓存的response，但是我们还需要将请求发送到网络以进行刷新。</span><br><span class="line">                request.addMarker(&quot;cache-hit-refresh-needed&quot;);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                &#x2F;&#x2F; Mark the response as intermediate.</span><br><span class="line">                response.intermediate &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将intermediate响应发回给用户，然后将请求转发到网络。</span><br><span class="line">                    mDelivery.postResponse(</span><br><span class="line">                            request,</span><br><span class="line">                            response,</span><br><span class="line">                            new Runnable() &#123;</span><br><span class="line">                                </span><br><span class="line">                                public void run() &#123;</span><br><span class="line">                                    try &#123;</span><br><span class="line">                                        &#x2F;&#x2F; 如果缓存需要刷新，这个地方还需要再重新请求网络</span><br><span class="line">                                        mNetworkQueue.put(request);</span><br><span class="line">                                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                                        &#x2F;&#x2F; Restore the interrupted status</span><br><span class="line">                                        Thread.currentThread().interrupt();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 该请求已添加到等待请求的列表中，以便在第一个请求返回时从第一个请求接收网络响应。</span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有缓存，就取出来去处理，没有或者过期等，就加入到网络请求队列中去请求，需要网络请求的有几个地方：</p>
<ul>
<li>请求不需要缓存</li>
<li>请求在缓存中没有找到</li>
<li>请求的缓存过期</li>
<li>请求的缓存需要刷新</li>
</ul>
<h5 id="NetworkDispatcher"><a href="#NetworkDispatcher" class="headerlink" title="NetworkDispatcher"></a>NetworkDispatcher</h5><p>NetworkDispatcher<br>NetworkDispatcher也继承自Thread，它们在RequestQueue#start()方法中已经被启动了，因此直接看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public class NetworkDispatcher extends Thread &#123;</span><br><span class="line">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue;</span><br><span class="line">    private final Network mNetwork;</span><br><span class="line">    private final Cache mCache;</span><br><span class="line">    private final ResponseDelivery mDelivery;</span><br><span class="line">    private volatile boolean mQuit &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public NetworkDispatcher(</span><br><span class="line">            BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span><br><span class="line">            Network network,</span><br><span class="line">            Cache cache,</span><br><span class="line">            ResponseDelivery delivery) &#123;</span><br><span class="line">        mQueue &#x3D; queue;</span><br><span class="line">        mNetwork &#x3D; network;</span><br><span class="line">        mCache &#x3D; cache;</span><br><span class="line">        mDelivery &#x3D; delivery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void quit() &#123;</span><br><span class="line">        mQuit &#x3D; true;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                processRequest();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; We may have been interrupted because it was time to quit.</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                VolleyLog.e(&quot;Ignoring spurious interrupt of NetworkDispatcher thread; &quot; + &quot;use quit() to terminate it&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processRequest() throws InterruptedException &#123;</span><br><span class="line">        Request&lt;?&gt; request &#x3D; mQueue.take();</span><br><span class="line">        processRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void processRequest(Request&lt;?&gt; request) &#123;</span><br><span class="line">        long startTimeMs &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED);</span><br><span class="line">        try &#123;</span><br><span class="line">            request.addMarker(&quot;network-queue-take&quot;);</span><br><span class="line"></span><br><span class="line">            if (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class="line">                request.notifyListenerResponseNotUsable();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 执行网络请求</span><br><span class="line">            NetworkResponse networkResponse &#x3D; mNetwork.performRequest(request);</span><br><span class="line">            request.addMarker(&quot;network-http-complete&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the server returned 304 AND we delivered a response already,</span><br><span class="line">            &#x2F;&#x2F; we&#39;re done -- don&#39;t deliver a second identical response.</span><br><span class="line">            if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                request.finish(&quot;not-modified&quot;);</span><br><span class="line">                request.notifyListenerResponseNotUsable();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Parse the response here on the worker thread.</span><br><span class="line">            Response&lt;?&gt; response &#x3D; request.parseNetworkResponse(networkResponse);</span><br><span class="line">            request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Write to cache if applicable.</span><br><span class="line">            &#x2F;&#x2F; TODO: Only update cache metadata instead of entire record for 304s.</span><br><span class="line">            if (request.shouldCache() &amp;&amp; response.cacheEntry !&#x3D; null) &#123;</span><br><span class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Post the response back.</span><br><span class="line">            request.markDelivered();</span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">            request.notifyListenerResponseReceived(response);</span><br><span class="line">        &#125; catch (VolleyError volleyError) &#123;</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</span><br><span class="line">            VolleyError volleyError &#x3D; new VolleyError(e);</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            mDelivery.postError(request, volleyError);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在NetworkDispatcher中，最主要的就是调用了mNetwork.performRequest(request)执行网络请求，而在Network是个接口，具体实现类是BasicNetwork。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">BasicNetwork</span><br><span class="line">public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</span><br><span class="line">    long requestStart &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            httpResponse &#x3D; mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            &#x2F;&#x2F; return NetworkResponse</span><br><span class="line">        &#125; catch (SocketTimeoutException e) &#123;</span><br><span class="line">            attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            int statusCode;</span><br><span class="line">            if (httpResponse !&#x3D; null) &#123;</span><br><span class="line">                statusCode &#x3D; httpResponse.getStatusCode();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new NoConnectionError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</span><br><span class="line">            NetworkResponse networkResponse;</span><br><span class="line">            if (responseContents !&#x3D; null) &#123;</span><br><span class="line">                networkResponse &#x3D;</span><br><span class="line">                        new NetworkResponse(</span><br><span class="line">                                statusCode,</span><br><span class="line">                                responseContents,</span><br><span class="line">                                &#x2F;* notModified&#x3D; *&#x2F; false,</span><br><span class="line">                                SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                                responseHeaders);</span><br><span class="line">                if (statusCode &#x3D;&#x3D; HttpURLConnection.HTTP_UNAUTHORIZED</span><br><span class="line">                        || statusCode &#x3D;&#x3D; HttpURLConnection.HTTP_FORBIDDEN) &#123;</span><br><span class="line">                    attemptRetryOnException(</span><br><span class="line">                            &quot;auth&quot;, request, new AuthFailureError(networkResponse));</span><br><span class="line">                &#125; else if (statusCode &gt;&#x3D; 400 &amp;&amp; statusCode &lt;&#x3D; 499) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t retry other client errors.</span><br><span class="line">                    throw new ClientError(networkResponse);</span><br><span class="line">                &#125; else if (statusCode &gt;&#x3D; 500 &amp;&amp; statusCode &lt;&#x3D; 599) &#123;</span><br><span class="line">                    if (request.shouldRetryServerErrors()) &#123;</span><br><span class="line">                        attemptRetryOnException(</span><br><span class="line">                                &quot;server&quot;, request, new ServerError(networkResponse));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new ServerError(networkResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 3xx? No reason to retry.</span><br><span class="line">                    throw new ServerError(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                attemptRetryOnException(&quot;network&quot;, request, new NetworkError());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请求重试</span><br><span class="line">private static void attemptRetryOnException(</span><br><span class="line">        String logPrefix, Request&lt;?&gt; request, VolleyError exception) throws VolleyError &#123;</span><br><span class="line">    RetryPolicy retryPolicy &#x3D; request.getRetryPolicy();</span><br><span class="line">    int oldTimeout &#x3D; request.getTimeoutMs();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        retryPolicy.retry(exception);</span><br><span class="line">    &#125; catch (VolleyError e) &#123;</span><br><span class="line">        request.addMarker(String.format(&quot;%s-timeout-giveup [timeout&#x3D;%s]&quot;, logPrefix, oldTimeout));</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    request.addMarker(String.format(&quot;%s-retry [timeout&#x3D;%s]&quot;, logPrefix, oldTimeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DefaultRetryPolicy implements RetryPolicy &#123;</span><br><span class="line">    </span><br><span class="line">    public void retry(VolleyError error) throws VolleyError &#123;</span><br><span class="line">        mCurrentRetryCount++;</span><br><span class="line">        mCurrentTimeoutMs +&#x3D; (int) (mCurrentTimeoutMs * mBackoffMultiplier);</span><br><span class="line">        if (!hasAttemptRemaining()) &#123;</span><br><span class="line">            throw error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Returns true if this policy has attempts remaining, false otherwise. *&#x2F;</span><br><span class="line">    protected boolean hasAttemptRemaining() &#123;</span><br><span class="line">        return mCurrentRetryCount &lt;&#x3D; mMaxNumRetries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在BasicNetwork#performRequest()中调用了httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);，这里的mBaseHttpStack就是前面创建RequestQueue时新建的HurlStack和HttpClientStack(@Deprecated，上面RequestQueue的构造函数中还有个新建了HttpClientStack对象的方法，不过已经废弃了，不做解析)。因此在 HttpStack的executeRequest()中就是具体的网络请求。</p>
<p>HurlStack</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HurlStack extends BaseHttpStack &#123;</span><br><span class="line">    </span><br><span class="line">    public HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span><br><span class="line">            throws IOException, AuthFailureError &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个类是使用HttpURLConnection来实现真的的网络请求，可以自定义</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ResponseDelivery"><a href="#ResponseDelivery" class="headerlink" title="ResponseDelivery"></a>ResponseDelivery</h5><p>ResponseDelivery是一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public interface ResponseDelivery &#123;</span><br><span class="line">    &#x2F;** Parses a response from the network or cache and delivers it. *&#x2F;</span><br><span class="line">    void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Parses a response from the network or cache and delivers it. The provided Runnable will be</span><br><span class="line">     * executed after delivery.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable);</span><br><span class="line"></span><br><span class="line">    &#x2F;** Posts an error for the given request. *&#x2F;</span><br><span class="line">    void postError(Request&lt;?&gt; request, VolleyError error);</span><br><span class="line">&#125;</span><br><span class="line">具体实现类是ExecutorDelivery，它保证了客户端调用的回调运行在UI线程：</span><br><span class="line"></span><br><span class="line">public class ExecutorDelivery implements ResponseDelivery &#123;</span><br><span class="line">    private final Executor mResponsePoster;</span><br><span class="line">    &#x2F;&#x2F; 在上面的分析中可以看到这里的handle &#x3D; new Handler(Looper.getMainLooper())</span><br><span class="line">    public ExecutorDelivery(final Handler handler) &#123;</span><br><span class="line">        mResponsePoster &#x3D; new Executor() &#123;</span><br><span class="line">                </span><br><span class="line">                public void execute(Runnable command) &#123;</span><br><span class="line">                    handler.post(command);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ExecutorDelivery(Executor executor) &#123;</span><br><span class="line">        mResponsePoster &#x3D; executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123;</span><br><span class="line">        postResponse(request, response, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(&quot;post-response&quot;);</span><br><span class="line">        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void postError(Request&lt;?&gt; request, VolleyError error) &#123;</span><br><span class="line">        request.addMarker(&quot;post-error&quot;);</span><br><span class="line">        Response&lt;?&gt; response &#x3D; Response.error(error);</span><br><span class="line">        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ResponseDeliveryRunnable implements Runnable &#123;</span><br><span class="line">        private final Request mRequest;</span><br><span class="line">        private final Response mResponse;</span><br><span class="line">        private final Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) &#123;</span><br><span class="line">            mRequest &#x3D; request;</span><br><span class="line">            mResponse &#x3D; response;</span><br><span class="line">            mRunnable &#x3D; runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (&quot;unchecked&quot;)</span><br><span class="line">        </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(&quot;canceled-at-delivery&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这里会调用在创建Request时传入的回调</span><br><span class="line">            if (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(&quot;intermediate-response&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mRequest.finish(&quot;done&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果有需要执行的任务，如前面缓存需要刷新等，就会在这个地方进行调用</span><br><span class="line">            if (mRunnable !&#x3D; null) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Volley中主要的类有这些：</p>
<ul>
<li>Volley: 提供了构建RequestQueue的统一方法，我们也可以不通过Volley类而是自己构建RequestQueue；</li>
<li>RequestQueue: 负责分发请求到不同的请求队列中；</li>
<li>CacheDispatcher: 处理缓存请求；</li>
<li>NetworkDispatcher: 处理网络请求；</li>
<li>ResponseDelivery: 获取请求后进行处理，具体实现类为ExecutorDelivery；</li>
<li>Cache: 缓存接口，具体实现类有DiskBasedCache；</li>
<li>Network: 网络接口，具体实现类有BasicNetwork；</li>
<li>HttpStack: 真正执行请求，具体实现类有HttpClientStack(已废弃)，BaseHttpStack(子类有HurlStack，AdaptedHttpStack等)；</li>
<li>Request: 封装请求信息并处理回调，具体实现类有StringRequest，JsonRequest，ImageRequest等；</li>
<li>NetworkResponse：请求网络时的返回的response；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Kotlin 实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:19:43 / 修改时间：11:21:15" itemprop="dateCreated datePublished" datetime="2020-05-31T11:19:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Kotlin-引入-Android-项目"><a href="#Kotlin-引入-Android-项目" class="headerlink" title="Kotlin 引入 Android 项目"></a>Kotlin 引入 Android 项目</h4><p>Kotlin是基于JVM新的编程语言，由 JetBrains 开发，可以编译成java字节码，也可以编译成JavaScript。而JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，也在 Apache 许可下已经开源其Kotlin 编程语言。</p>
<h5 id="一、导入依赖库"><a href="#一、导入依赖库" class="headerlink" title="一、导入依赖库"></a>一、导入依赖库</h5><ul>
<li><p>在工程根目录bulid.grade文件添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version &#x3D; &#39;1.3.21&#39;</span><br><span class="line">    </span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>app或者module工程， bulid.grade文件添加一下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;kotlin-android&#39;</span><br><span class="line">apply plugin: &#39;kotlin-android-extensions&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h5><ul>
<li>Activity 中使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    </span><br><span class="line">    private var mRecyclerView: RecyclerView? &#x3D; null</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 定义静态方法</span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val KEY_FROM: String &#x3D; &quot;key_from&quot;</span><br><span class="line">        const val KEY_SHOW_OPEN_VIEW &#x3D; &quot;key_show_open_view&quot;</span><br><span class="line">        </span><br><span class="line">        fun startActivity(context: Context, from: String, showOpen: Boolean) &#123;</span><br><span class="line">            var intent &#x3D; Intent(context, MainActivity::class.java)</span><br><span class="line">            intent.putExtra(KEY_FROM, from)</span><br><span class="line">            intent.putExtra(KEY_SHOW_OPEN_VIEW, showOpen)</span><br><span class="line">            if (context !is Activity) &#123;</span><br><span class="line">               intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class="line">            &#125;</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        handlerIntent()</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun handlerIntent() &#123;</span><br><span class="line">        if (intent !&#x3D; null) &#123;</span><br><span class="line">            mFrom &#x3D; intent.getStringExtra(KEY_FROM)</span><br><span class="line">            mShowOpenView &#x3D; intent.getBooleanExtra(KEY_SHOW_OPEN_VIEW, false)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun initView() &#123;</span><br><span class="line">        mRecyclerView &#x3D; findViewById(R.id.recycler_view)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、常用设计模式-Kotlin代码示例"><a href="#三、常用设计模式-Kotlin代码示例" class="headerlink" title="三、常用设计模式 Kotlin代码示例"></a>三、常用设计模式 Kotlin代码示例</h5><h6 id="3-1-单例模式"><a href="#3-1-单例模式" class="headerlink" title="3.1 单例模式"></a>3.1 单例模式</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoRewardHelper</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mInstance = SingletonHolder.mInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> SingletonHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> mInstance = VideoRewardHelper()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-基于RxJava实现观察者模式"><a href="#3-2-基于RxJava实现观察者模式" class="headerlink" title="3.2 基于RxJava实现观察者模式"></a>3.2 基于RxJava实现观察者模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.Observable;</span><br><span class="line">import io.reactivex.subjects.PublishSubject;</span><br><span class="line">import io.reactivex.subjects.Subject;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 基于RxJava的事总线</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 单例模式 &amp; 门面模式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RxBus&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private volatile Subject&lt;T&gt; mSubject;</span><br><span class="line"></span><br><span class="line">    private RxBus() &#123;</span><br><span class="line">        mSubject &#x3D; PublishSubject.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Singleton &#123;</span><br><span class="line">        public static RxBus mInstance &#x3D; new RxBus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RxBus getInstance() &#123;</span><br><span class="line">        return Singleton.mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sendPost(T t) &#123;</span><br><span class="line">        mSubject.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sendComplete() &#123;</span><br><span class="line">        mSubject.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Observable&lt;T&gt; getObservable() &#123;</span><br><span class="line">        return mSubject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Disposable disposable;</span><br><span class="line"></span><br><span class="line">private Observer&lt;StatusInfo&gt; mObserver &#x3D; new Observer&lt;StatusInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        disposable &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(StatusInfo info) &#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RxBus.getInstance().getObservable().subscribeOn(AndroidSchedulers.mainThread()).subscribe(mObserver);</span><br></pre></td></tr></table></figure>

<h6 id="2-解注册"><a href="#2-解注册" class="headerlink" title="2. 解注册"></a>2. 解注册</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (disposable !&#x3D; null &amp;&amp; !disposable.isDisposed()) &#123;</span><br><span class="line">    XLLog.d(&quot;Rxjava&quot;, &quot;dispose: &quot;);</span><br><span class="line">    disposable.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-普通观察者模式"><a href="#3-3-普通观察者模式" class="headerlink" title="3.3 普通观察者模式"></a>3.3 普通观察者模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">interface CountDownObserver &#123;</span><br><span class="line">    fun onTimer(resource: PostResource)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountDownObservable : Observable&lt;CountDownObserver&gt;() &#123;</span><br><span class="line">    fun onTimer(resource: PostResource) &#123;</span><br><span class="line">        if (mObservers.isNotEmpty()) &#123;</span><br><span class="line">            val observers &#x3D; ArrayList&lt;CountDownObserver&gt;(mObservers)</span><br><span class="line">            for (observer in observers) &#123;</span><br><span class="line">                observer.onTimer(resource)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountDownManager &#123;</span><br><span class="line">    private var mCountDownObservable: CountDownObservable &#x3D; CountDownObservable()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        var TAG: String &#x3D; &quot;CountDownManager&quot;</span><br><span class="line">        val mInstance &#x3D; SingletonHolder.mInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private object SingletonHolder &#123;</span><br><span class="line">        val mInstance &#x3D; CountDownManager()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun registerCountDownObserver(observer: CountDownObserver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mCountDownObservable.registerObserver(observer)</span><br><span class="line">        &#125; catch (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun unregisterCountDownObserver(observer: CountDownObserver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mCountDownObservable.unregisterObserver(observer)</span><br><span class="line">        &#125; catch (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun notifyOnTimer(resource: PostResource) &#123;</span><br><span class="line">        mCountDownObservable.onTimer(resource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Glide 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:17:43" itemprop="dateCreated datePublished" datetime="2020-05-31T11:17:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Glide-源码剖析"><a href="#Glide-源码剖析" class="headerlink" title="Glide 源码剖析"></a>Glide 源码剖析</h4><p><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a>是Google出品的一款性能优异的图片加载框架。</p>
<p>依赖库导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">  google()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;</span><br><span class="line">  annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(myFragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .centerCrop()</span><br><span class="line">    .placeholder(R.drawable.loading_spinner)</span><br><span class="line">    .into(myImageView);</span><br></pre></td></tr></table></figure>

<h5 id="对比图片加载框架"><a href="#对比图片加载框架" class="headerlink" title="对比图片加载框架"></a>对比图片加载框架</h5><p>下面我们将会带着以下一些问题深入的剖析源码，去寻找答案。</p>
<ul>
<li>Glide的with方法是如何绑定Activity/Fragment生命周期的？</li>
<li>Glide的网络请求是怎样发出的？</li>
<li>Glide请求完成之后，图片是如何展示的？</li>
<li>Glide的缓存策略是什么样的？</li>
<li>Glide的OOM解决办法？</li>
<li>Glide自定义BitmapTransformation</li>
</ul>
<h6 id="1-with-Context-方法，返回RequestManager"><a href="#1-with-Context-方法，返回RequestManager" class="headerlink" title="1. with(Context)方法，返回RequestManager"></a>1. with(Context)方法，返回RequestManager</h6><p>Glide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Glide &#123;</span><br><span class="line"></span><br><span class="line">  public static RequestManager with(Context context) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(Activity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(android.app.Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">**with()**方法重载了5个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RequestManagerRetriever.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManagerRetriever implements Handler.Callback {<br>    private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();</p>
<pre><code>public static RequestManagerRetriever get() {
    return INSTANCE;
}

public RequestManager get(Context context) {
    if (context == null) {
        throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);
    } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {
        if (context instanceof FragmentActivity) {
            return get((FragmentActivity) context);
        } else if (context instanceof Activity) {
            return get((Activity) context);
        } else if (context instanceof ContextWrapper) {
            return get(((ContextWrapper) context).getBaseContext());
        }
    }

    return getApplicationManager(context);
}

// 生命周期和Application相关连
private RequestManager getApplicationManager(Context context) {
    if (applicationManager == null) {
        synchronized (this) {
            if (applicationManager == null) {
                applicationManager = new RequestManager(context.getApplicationContext(),
                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
            }
        }
    }
    return applicationManager;
}

// activity.getSupportFragmentManager(),会创建SupportRequestManagerFragment
public RequestManager get(FragmentActivity activity) {
    if (Util.isOnBackgroundThread()) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        FragmentManager fm = activity.getSupportFragmentManager();
        return supportFragmentGet(activity, fm);
    }
}

RequestManager supportFragmentGet(Context context, FragmentManager fm) {
    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);
    // 内部新建ActivityFragmentLifecycle对象
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        // 将SupportRequestManagerFragment的LifeCycle注入到RequestManager
        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
     // 将current.getLifecycle()与 requestManager进行了绑定
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) {
    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        current = pendingSupportRequestManagerFragments.get(fm);
        if (current == null) {
            current = new SupportRequestManagerFragment();
            pendingSupportRequestManagerFragments.put(fm, current);
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}

// activity.getFragmentManager会创建RequestManagerFragment
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public RequestManager get(Activity activity) {
    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        android.app.FragmentManager fm = activity.getFragmentManager();
        return fragmentGet(activity, fm);
    }
}

@TargetApi(Build.VERSION_CODES.HONEYCOMB)
RequestManager fragmentGet(Context context, android.app.FragmentManager fm) {
    RequestManagerFragment current = getRequestManagerFragment(fm);
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {
    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        current = pendingRequestManagerFragments.get(fm);
        if (current == null) {
            current = new RequestManagerFragment();
            pendingRequestManagerFragments.put(fm, current);
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断如果是Application则创建RequestManager绑定Application，否则创建SupportRequestManagerFragment、RequestManagerFragment并将RequestManager与之绑定</span><br><span class="line"></span><br><span class="line">SupportRequestManagerFragment.java</span><br></pre></td></tr></table></figure>
<p>public class SupportRequestManagerFragment extends Fragment {<br>    private RequestManager requestManager;<br>    private final ActivityFragmentLifecycle lifecycle;</p>
<p>  @Override<br>    public void onStart() {<br>        super.onStart();<br>        lifecycle.onStart();<br>    }</p>
<pre><code>@Override
public void onStop() {
    super.onStop();
    lifecycle.onStop();
}

@Override
public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这样SupportRequestManagerFragment就和ActivityFragmentLifecycle进行了绑定管理者Fragment的生命周期</span><br><span class="line">在RequestManager的构造函数中会调用lifecycle.addListener(RequestManager.this);进行绑定。至此整个生命周期的传递过程就形成了。</span><br><span class="line">SupportRequestManagerFragment -&gt; ActivityFragmentLifecycle -&gt; RequestManager -&gt; requestTracker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 2. load()方法,返回DrawableTypeRequest</span><br><span class="line"></span><br><span class="line">RequestManager.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManager implements LifecycleListener {<br>  private final Lifecycle lifecycle;<br>  private final RequestTracker requestTracker;</p>
<pre><code>RequestManager(Context context, final Lifecycle lifecycle, ...) {
    ...
    if (Util.isOnBackgroundThread()) {
        new Handler(Looper.getMainLooper()).post(new Runnable() {
            @Override
            public void run() {
                lifecycle.addListener(RequestManager.this);
            }
        });
    } else {
        lifecycle.addListener(this);
    }
    ...
}

public DrawableTypeRequest&lt;String&gt; load(String string) {
    return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);
}

public DrawableTypeRequest&lt;String&gt; fromString() {
    return loadGeneric(String.class);
}

private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) {
    ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =
            Glide.buildFileDescriptorModelLoader(modelClass, context);
    if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
        throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot;
                + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot;
                + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;);
    }

    return optionsApplier.apply(
            new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
                    glide, requestTracker, lifecycle, optionsApplier));
}

@Override
public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) {
    super.load(model);
    return this;
}

@Override
public void onStart() {
    resumeRequests();
}

@Override
public void onStop() {
    pauseRequests();
}

@Override
public void onDestroy() {
    requestTracker.clearRequests();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DrawableTypeRequest.java</span><br></pre></td></tr></table></figure>
<p>public class DrawableTypeRequest<ModelType> extends DrawableRequestBuilder<ModelType> implements DownloadOptions {<br>    private final ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader;<br>    private final ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader;<br>    private final RequestManager.OptionsApplier optionsApplier;</p>
<pre><code>private static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide,
        ModelLoader&lt;A, InputStream&gt; streamModelLoader,
        ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass,
        Class&lt;R&gt; transcodedClass,
        ResourceTranscoder&lt;Z, R&gt; transcoder) {
    if (streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
        return null;
    }

    if (transcoder == null) {
        transcoder = glide.buildTranscoder(resourceClass, transcodedClass);
    }
    DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,
            resourceClass);
    ImageVideoModelLoader&lt;A&gt; modelLoader = new ImageVideoModelLoader&lt;A&gt;(streamModelLoader,
            fileDescriptorModelLoader);
    return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);
}

DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader,
        ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide,
        RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) {
    super(context, modelClass,
            buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,
                    GlideDrawable.class, null),
            glide, requestTracker, lifecycle);
    this.streamModelLoader = streamModelLoader;
    this.fileDescriptorModelLoader = fileDescriptorModelLoader;
    this.optionsApplier = optionsApplier;
}

public BitmapTypeRequest&lt;ModelType&gt; asBitmap() {
    return optionsApplier.apply(new BitmapTypeRequest&lt;ModelType&gt;(this, streamModelLoader,
            fileDescriptorModelLoader, optionsApplier));
}

public GifTypeRequest&lt;ModelType&gt; asGif() {
    return optionsApplier.apply(new GifTypeRequest&lt;ModelType&gt;(this, streamModelLoader, optionsApplier));
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DrawableRequestBuilder.java</span><br></pre></td></tr></table></figure>
<p>public class DrawableRequestBuilder<ModelType><br>        extends GenericRequestBuilder&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt;<br>        implements BitmapOptions, DrawableOptions {</p>
<pre><code>@Override
public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) {
    super.load(model); //调用其父类GenericRequestBuilder的load函数赋值model变量
    return this;
}

@Override
public Target&lt;GlideDrawable&gt; into(ImageView view) {
    return super.into(view);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">into()方法,返回Target对象</span><br><span class="line"></span><br><span class="line">GenericRequestBuilder.java</span><br></pre></td></tr></table></figure>
<p>public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable {<br>    protected final Glide glide;<br>    protected final Class<TranscodeType> transcodeClass;<br>    protected final RequestTracker requestTracker;<br>    protected final Lifecycle lifecycle;<br>    private GenericRequestBuilder&lt;?, ?, ?, TranscodeType&gt; thumbnailRequestBuilder;</p>
<pre><code>@Override
public Target&lt;GlideDrawable&gt; into(ImageView view) {
    return super.into(view);
}

/**
 * into ImageView 之后，才会去从缓存LruCache&lt;Key, Resource&lt;?&gt;&gt;、弱引用Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;、磁盘缓存diskCacheService、
 */

public Target&lt;TranscodeType&gt; into(ImageView view) {
    Util.assertMainThread();
    if (view == null) {
        throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;);
    }

    if (!isTransformationSet &amp;&amp; view.getScaleType() != null) {
        switch (view.getScaleType()) {
            case CENTER_CROP:
                applyCenterCrop();
                break;
            case FIT_CENTER:
            case FIT_START:
            case FIT_END:
                applyFitCenter();
                break;
            //$CASES-OMITTED$
            default:
                // Do nothing.
        }
    }

    return into(glide.buildImageViewTarget(view, transcodeClass));
}    

public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) {
    Util.assertMainThread();
    if (target == null) {
        throw new IllegalArgumentException(&quot;You must pass in a non null Target&quot;);
    }
    if (!isModelSet) {
        throw new IllegalArgumentException(&quot;You must first set a model (try #load())&quot;);
    }

    Request previous = target.getRequest();

    if (previous != null) {
        previous.clear();
        requestTracker.removeRequest(previous);
        previous.recycle();
    }

    Request request = buildRequest(target);
    target.setRequest(request);
    lifecycle.addListener(target);
    requestTracker.runRequest(request);

    return target;
}

// 根据是缩略图划分，返回ThumbnailRequestCoordinator、GenericRequest
private Request buildRequest(Target&lt;TranscodeType&gt; target) {
    if (priority == null) {
        priority = Priority.NORMAL;
    }
    return buildRequestRecursive(target, null);
}

private Request buildRequestRecursive(Target&lt;TranscodeType&gt; target, ThumbnailRequestCoordinator parentCoordinator) {
    if (thumbnailRequestBuilder != null) {
        if (isThumbnailBuilt) {
            throw new IllegalStateException(&quot;You cannot use a request as both the main request and a thumbnail, &quot;
                    + &quot;consider using clone() on the request(s) passed to thumbnail()&quot;);
        }
        // Recursive case: contains a potentially recursive thumbnail request builder.
        if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
            thumbnailRequestBuilder.animationFactory = animationFactory;
        }

        if (thumbnailRequestBuilder.priority == null) {
            thumbnailRequestBuilder.priority = getThumbnailPriority();
        }

        if (Util.isValidDimensions(overrideWidth, overrideHeight)
                &amp;&amp; !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                        thumbnailRequestBuilder.overrideHeight)) {
          thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
        }

        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
        // Guard against infinite recursion.
        isThumbnailBuilt = true;
        // Recursively generate thumbnail requests.
        Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
        isThumbnailBuilt = false;
        coordinator.setRequests(fullRequest, thumbRequest);
        return coordinator;
    } else if (thumbSizeMultiplier != null) {
        // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
        Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
        coordinator.setRequests(fullRequest, thumbnailRequest);
        return coordinator;
    } else {
        // Base case: no thumbnail.
        return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
    }
}

private Request obtainRequest(Target&lt;TranscodeType&gt; target, float sizeMultiplier, Priority priority,
        RequestCoordinator requestCoordinator) {
    return GenericRequest.obtain(
            loadProvider,
            model,
            signature,
            context,
            priority,
            target,
            sizeMultiplier,
            placeholderDrawable,
            placeholderId,
            errorPlaceholder,
            errorId,
            fallbackDrawable,
            fallbackResource,
            requestListener,
            requestCoordinator,
            glide.getEngine(),
            transformation,
            transcodeClass,
            isCacheable,
            animationFactory,
            overrideWidth,
            overrideHeight,
            diskCacheStrategy);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">网络请求</span><br><span class="line"></span><br><span class="line">RequestTracker.java (Request集合, 负责Request的执行，暂停，取消等等关于图片请求的操作)</span><br></pre></td></tr></table></figure>
<p>public class RequestTracker {<br>    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap&lt;Request, Boolean&gt;());<br>    private final List<Request> pendingRequests = new ArrayList<Request>();<br>    private boolean isPaused;</p>
<pre><code>public void runRequest(Request request) {
    requests.add(request);
    if (!isPaused) {
        request.begin();
    } else {
        pendingRequests.add(request);
    }
}

public void pauseRequests() {
    isPaused = true;
    for (Request request : Util.getSnapshot(requests)) {
        if (request.isRunning()) {
            request.pause();
            pendingRequests.add(request);
        }
    }
}

public void resumeRequests() {
    isPaused = false;
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled() &amp;&amp; !request.isRunning()) {
            request.begin();
        }
    }
    pendingRequests.clear();
}

public void restartRequests() {
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled()) {
            // Ensure the request will be restarted in onResume.
            request.pause();
            if (!isPaused) {
                request.begin();
            } else {
                pendingRequests.add(request);
            }
        }
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GenericRequest.java</span><br></pre></td></tr></table></figure>
<p>public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback,<br>        ResourceCallback {</p>
<pre><code>@Override
public void begin() {
    startTime = LogTime.getLogTime();
    if (model == null) {
        onException(null);
        return;
    }

    status = Status.WAITING_FOR_SIZE;
    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
        onSizeReady(overrideWidth, overrideHeight);
    } else {
        target.getSize(this);
    }

    if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) {
        // 设置Placeholder图片
        target.onLoadStarted(getPlaceholderDrawable());
        // 最终调用view.setImageDrawable(Drawable drawable)
    }
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));
    }
}    

@Override
public void onSizeReady(int width, int height) {
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));
    }
    if (status != Status.WAITING_FOR_SIZE) {
        return;
    }
    status = Status.RUNNING;

    width = Math.round(sizeMultiplier * width);
    height = Math.round(sizeMultiplier * height);

    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();
    final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);

    if (dataFetcher == null) {
        onException(new Exception(&quot;Failed to load model: \&apos;&quot; + model + &quot;\&apos;&quot;));
        return;
    }
    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));
    }
    loadedFromMemoryCache = true;
    // 开始网络加载图片
    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
            priority, isMemoryCacheable, diskCacheStrategy, this);
    loadedFromMemoryCache = resource != null;
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Engine.java</span><br></pre></td></tr></table></figure>
<p>public class Engine implements EngineJobListener,<br>        MemoryCache.ResourceRemovedListener,<br>        EngineResource.ResourceListener {</p>
<pre><code>public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher,
        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,
        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {
    Util.assertMainThread();
    long startTime = LogTime.getLogTime();

    final String id = fetcher.getId();
    // 根据请求key以及width、height一起构成了一个EngineKey, 如果width、height改变了，
    // 则会认为是一个新的Key，会重新缓存。
    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),
            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),
            transcoder, loadProvider.getSourceEncoder());

    // 1.从内存中获取，isMemoryCacheable：是否允许内存缓存策略
    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
        cb.onResourceReady(cached);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);
        }
        return null;
    }

    //2.从activeResources中获取 isMemoryCacheable：是否允许内存缓存策略
    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
        cb.onResourceReady(active);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);
        }
        return null;
    }


    EngineJob current = jobs.get(key);
    if (current != null) {
        current.addCallback(cb);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);
        }
        return new LoadStatus(cb, current);
    }

    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);
    DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,
            transcoder, diskCacheProvider, diskCacheStrategy, priority);
    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);
    jobs.put(key, engineJob);
    engineJob.addCallback(cb);
    engineJob.start(runnable);

    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);
    }
    return new LoadStatus(cb, engineJob);
}    </code></pre><p>}            </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EngineJob.java</span><br></pre></td></tr></table></figure>
<p>class EngineJob implements EngineRunnable.EngineRunnableManager {</p>
<pre><code>@Override
public void run() {
    if (isCancelled) {
        return;
    }

    Exception exception = null;
    Resource&lt;?&gt; resource = null;
    try {
        resource = decode();
    } catch (OutOfMemoryError e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, &quot;Out Of Memory Error decoding&quot;, e);
        }
        exception = new ErrorWrappingGlideException(e);
    } catch (Exception e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, &quot;Exception decoding&quot;, e);
        }
        exception = e;
    }

    if (isCancelled) {
        if (resource != null) {
            resource.recycle();
        }
        return;
    }

    if (resource == null) {
        onLoadFailed(exception);
    } else {
        onLoadComplete(resource);
    }
}

/**
 * 优先从磁盘缓存中寻找
 */
private Resource&lt;?&gt; decode() throws Exception {
    if (isDecodingFromCache()) {
        return decodeFromCache();
    } else {
        return decodeFromSource();
    }
}

// 进行网路请求
private Resource&lt;?&gt; decodeFromSource() throws Exception {
    return decodeJob.decodeFromSource();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**DecodeJob.java**</span><br></pre></td></tr></table></figure>
<p>class DecodeJob&lt;A, T, Z&gt; {</p>
<pre><code>public Resource&lt;Z&gt; decodeFromSource() throws Exception {
    // 网络请求
    Resource&lt;T&gt; decoded = decodeSource();
    // 对返回结果进行Encode编码
    return transformEncodeAndTranscode(decoded);
}

private Resource&lt;T&gt; decodeSource() throws Exception {
    Resource&lt;T&gt; decoded = null;
    try {
        // 最终会走到HttpUrlFetcher.loadData返回InputStream
        final A data = fetcher.loadData(priority);
        decoded = decodeFromSourceData(data);
    } finally {
        fetcher.cleanup();
    }
    return decoded;
}

// 此处最终会走到StreamBitmapDecoder的decode方法
// 计算sampleSize、
// Bitmap result = BitmapFactory.decodeStream(is, null, options);
private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException {
    final Resource&lt;T&gt; decoded;
    decoded = loadProvider.getSourceDecoder().decode(data, width, height);
    return decoded;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**HttpUrlFetcher**</span><br></pre></td></tr></table></figure>
<p>public class HttpUrlFetcher implements DataFetcher<InputStream> {</p>
<pre><code>private HttpURLConnection urlConnection;
private InputStream stream;

@Override
public InputStream loadData(Priority priority) throws Exception {
    return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
}

private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers)
        throws IOException {
    ...
    urlConnection = connectionFactory.build(url);
    for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(2500);
    urlConnection.setReadTimeout(2500);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) { // 200 OK
        return getStreamForSuccessfulRequest(urlConnection);
    } else if (statusCode / 100 == 3) { // 3XX 重定向
        String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);
        if (TextUtils.isEmpty(redirectUrlString)) {
            throw new IOException(&quot;Received empty or null redirect url&quot;);
        }
        URL redirectUrl = new URL(url, redirectUrlString);
        return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    }
    ...
}

private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection) throws IOException {
    ...
    stream = urlConnection.getInputStream();
    return stream;
}    </code></pre><p>}</p>
<p>```</p>
<p><img src="https://img-blog.csdn.net/20170515074139121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRXRoYW5Dbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Glide 执行过程"></p>
<h4 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h4><p><a href="https://blog.csdn.net/u011733020/article/details/52446902" target="_blank" rel="noopener">1. Glide（图片异步加载缓存库）发起request获取resource</a></p>
<p><a href="https://juejin.im/post/5e2109e25188254c257c40c6#heading-42" target="_blank" rel="noopener">2. Android主流三方库源码分析（三、深入理解Glide源码）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Picasso 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:16:36" itemprop="dateCreated datePublished" datetime="2020-05-31T11:16:36+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="Picasso简介"><a href="#Picasso简介" class="headerlink" title="Picasso简介"></a>Picasso简介</h5><p>Picasso是鼎鼎有名的Square公司的一个开源项目，该公司同时开源了许多知名的项目，比如Okhttp，Retrofit，Otto等。Picasso继承了Okhttp的链式调用风格，使得它使用起来非常简单和方便，并且它的设计和实现也很轻量简单，使得整个库的接口数量和体积都很小，因此被很多开发者使用在项目中。下面我们来看一下Picasso的总体设计：</p>
<p><img src="https://img-blog.csdnimg.cn/20190126151924568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rZ2F5cw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>Picasso是通过服务器来实现的本地缓存并且都是原图，因此如果能根据图片尺寸来控制缓存图片的大小可以进一步降低本地储存的空间和图片处理的开销。(Glide 就是根据不同的图片尺寸来缓存不同的图片)</p>
<h5 id="Picasso-源码剖析"><a href="#Picasso-源码剖析" class="headerlink" title="Picasso 源码剖析"></a>Picasso 源码剖析</h5><h6 id="get、load、with-函数"><a href="#get、load、with-函数" class="headerlink" title="get、load、with 函数"></a>get、load、with 函数</h6><p>Picasso.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">public class Picasso &#123;</span><br><span class="line">  static volatile Picasso singleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单例模式</span><br><span class="line">  public static Picasso get() &#123;</span><br><span class="line">    if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized (Picasso.class) &#123;</span><br><span class="line">        if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">          if (PicassoProvider.context &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;context &#x3D;&#x3D; null&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          singleton &#x3D; new Builder(PicassoProvider.context).build();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 构建模式，初始化Picasso关键成员变量</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    public Picasso build() &#123;</span><br><span class="line">      Context context &#x3D; this.context;</span><br><span class="line"></span><br><span class="line">      if (downloader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 图片下载</span><br><span class="line">        downloader &#x3D; new OkHttp3Downloader(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (cache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 内存缓存</span><br><span class="line">        cache &#x3D; new LruCache(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (service &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池 (默认开启3个线程, 根据网络WiFi-&gt;4 、4G-&gt;3、 3G-&gt;2, 2G-&gt;1)</span><br><span class="line">        service &#x3D; new PicassoExecutorService();</span><br><span class="line">      &#125;</span><br><span class="line">      if (transformer &#x3D;&#x3D; null) &#123;</span><br><span class="line">        transformer &#x3D; RequestTransformer.IDENTITY;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 记录缓存命中次数、丢失次数等</span><br><span class="line">      Stats stats &#x3D; new Stats(cache);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 分发器</span><br><span class="line">      Dispatcher dispatcher &#x3D; new Dispatcher(context, service, HANDLER, downloader, cache, stats);</span><br><span class="line"></span><br><span class="line">      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</span><br><span class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static final Handler HANDLER &#x3D; new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    @Override public void handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case HUNTER_BATCH_COMPLETE: &#123;</span><br><span class="line">          &#x2F;&#x2F; 更新UI界面</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;BitmapHunter&gt; batch &#x3D; (List&lt;BitmapHunter&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            BitmapHunter hunter &#x3D; batch.get(i);</span><br><span class="line">            hunter.picasso.complete(hunter); </span><br><span class="line">            &#x2F;&#x2F; 最终会调用action.complete(result, from);显示图片</span><br><span class="line">            &#x2F;&#x2F; 最终会调到这里：target.setImageDrawable(drawable)</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_GCED: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), &quot;target got garbage collected&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          action.picasso.cancelExistingRequest(action.getTarget());</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_BATCH_RESUME:</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;Action&gt; batch &#x3D; (List&lt;Action&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            Action action &#x3D; batch.get(i);</span><br><span class="line">            action.picasso.resumeAction(action);</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; load URL,会创建RequestCreator对象</span><br><span class="line">  public RequestCreator load(@Nullable String path) &#123;</span><br><span class="line">    if (path &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return new RequestCreator(this, null, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (path.trim().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return load(Uri.parse(path));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator load(@Nullable Uri uri) &#123;</span><br><span class="line">    return new RequestCreator(this, uri, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; RequestCreator会在into(ImageView)方法的时候，封装ImageViewAction extends Action</span><br><span class="line">  void enqueueAndSubmit(Action action) &#123;</span><br><span class="line">    Object target &#x3D; action.getTarget();</span><br><span class="line">    if (target !&#x3D; null &amp;&amp; targetToAction.get(target) !&#x3D; action) &#123;</span><br><span class="line">      &#x2F;&#x2F; This will also check we are on the main thread.</span><br><span class="line">      cancelExistingRequest(target);</span><br><span class="line">      targetToAction.put(target, action);</span><br><span class="line">    &#125;</span><br><span class="line">    submit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void submit(Action action) &#123;</span><br><span class="line">    dispatcher.dispatchSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Picasso 的get()方法采用双重检验锁形式获取Picasso单例，在<strong>new Picasso()</strong> 的时候采用Builder构造模式初始化Picasso关键成员变量。主要有<strong>PicassoExecutorService</strong>、<strong>OkHttp3Downloader</strong>、<strong>LruCache</strong>、<strong>Dispatcher</strong>。值得关注的是<strong>PicassoProvider</strong>这个内容提供者，<strong>onCreate</strong>方法的调用是ActivityThread的启动的时候就已经调用了，比Application的初始化要早。像这种获取Context对象黑技术在Leakcanary里面也是一样的。</p>
<p><strong>RequestCreator.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">public class RequestCreator &#123;</span><br><span class="line">  private final Picasso picasso;</span><br><span class="line">  private final Request.Builder data;</span><br><span class="line">  private boolean deferred;</span><br><span class="line"></span><br><span class="line">  RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123;</span><br><span class="line">    this.picasso &#x3D; picasso;</span><br><span class="line">    this.data &#x3D; new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator fit() &#123;</span><br><span class="line">    deferred &#x3D; true;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator placeholder(@NonNull Drawable placeholderDrawable) &#123;</span><br><span class="line">    this.placeholderDrawable &#x3D; placeholderDrawable;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static boolean isMain() &#123;</span><br><span class="line">    return Looper.getMainLooper().getThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void checkMain() &#123;</span><br><span class="line">    if (!isMain()) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Method call should happen from the main thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target) &#123;</span><br><span class="line">    into(target, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target, Callback callback) &#123;</span><br><span class="line">    long started &#x3D; System.nanoTime();</span><br><span class="line">    checkMain();</span><br><span class="line">    &#x2F;&#x2F; 检查Uri 或者 resourceId是否为空</span><br><span class="line">    if (!data.hasImage()) &#123;  &#x2F;&#x2F; -&gt; uri !&#x3D; null || resourceId !&#x3D; 0</span><br><span class="line">      picasso.cancelRequest(target);</span><br><span class="line">      if (setPlaceholder) &#123;</span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (deferred) &#123;</span><br><span class="line">      if (data.hasSize()) &#123;  &#x2F;&#x2F; -&gt; targetWidth !&#x3D; 0 || targetHeight !&#x3D; 0</span><br><span class="line">        throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      int width &#x3D; target.getWidth();</span><br><span class="line">      int height &#x3D; target.getHeight();</span><br><span class="line">      if (width &#x3D;&#x3D; 0 || height &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (setPlaceholder) &#123;</span><br><span class="line">          setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">        &#125;</span><br><span class="line">        picasso.defer(target, new DeferredRequestCreator(this, target, callback));</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      data.resize(width, height);  &#x2F;&#x2F; -&gt; this.targetWidth &#x3D; targetWidth; this.targetHeight &#x3D; targetHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; createRequest(started);</span><br><span class="line">    String requestKey &#x3D; createKey(request);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 缓存中存在，则从缓存中获取, 取消请求，返回缓存值</span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      Bitmap bitmap &#x3D; picasso.quickMemoryCacheCheck(requestKey);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        picasso.cancelRequest(target);</span><br><span class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (callback !&#x3D; null) &#123;</span><br><span class="line">          callback.onSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置placeholder</span><br><span class="line">    if (setPlaceholder) &#123;</span><br><span class="line">      setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建Action用于网络请求</span><br><span class="line">    Action action &#x3D;</span><br><span class="line">        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</span><br><span class="line">            errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line"></span><br><span class="line">    picasso.enqueueAndSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Request createRequest(long started) &#123;</span><br><span class="line">    int id &#x3D; nextId.getAndIncrement();</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; data.build();</span><br><span class="line">    request.id &#x3D; id;</span><br><span class="line">    request.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">    boolean loggingEnabled &#x3D; picasso.loggingEnabled;</span><br><span class="line">    if (loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request transformed &#x3D; picasso.transformRequest(request);</span><br><span class="line">    if (transformed !&#x3D; request) &#123;</span><br><span class="line">      &#x2F;&#x2F; If the request was changed, copy over the id and timestamp from the original.</span><br><span class="line">      transformed.id &#x3D; id;</span><br><span class="line">      transformed.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">      if (loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), &quot;into &quot; + transformed);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return transformed;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RequestCreator</strong>, 在into(ImageView)的时候会进行必要的参数校验，创建Request请求对象，从LruCache缓存中检测是否有已经请求的返回结果，如果有的则直接返回，否则创建ImageViewAction对象后面进行网络请求。<strong>picasso.enqueueAndSubmit(action)</strong> 最终会调到<strong>dispatcher.dispatchSubmit(action);</strong></p>
<p><strong>Dispatcher.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">class Dispatcher &#123;</span><br><span class="line">  final Map&lt;String, BitmapHunter&gt; hunterMap;</span><br><span class="line">  final Map&lt;Object, Action&gt; failedActions;</span><br><span class="line">  final Map&lt;Object, Action&gt; pausedActions;</span><br><span class="line"></span><br><span class="line">  private static class DispatcherHandler extends Handler &#123;</span><br><span class="line">    private final Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">    DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123;</span><br><span class="line">      super(looper);</span><br><span class="line">      this.dispatcher &#x3D; dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void handleMessage(final Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case REQUEST_SUBMIT: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performSubmit(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_CANCEL: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performCancel(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_PAUSE: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performPauseTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_RESUME: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performResumeTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，会回调到此处</span><br><span class="line">        case HUNTER_COMPLETE: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performComplete(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_RETRY: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performRetry(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DECODE_FAILED: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performError(hunter, false);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DELAY_NEXT_BATCH: &#123;</span><br><span class="line">          dispatcher.performBatchComplete();</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case NETWORK_STATE_CHANGE: &#123;</span><br><span class="line">          NetworkInfo info &#x3D; (NetworkInfo) msg.obj;</span><br><span class="line">          dispatcher.performNetworkStateChange(info);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case AIRPLANE_MODE_CHANGE: &#123;</span><br><span class="line">          dispatcher.performAirplaneModeChange(msg.arg1 &#x3D;&#x3D; AIRPLANE_MODE_ON);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">          Picasso.HANDLER.post(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 通过handler发送REQUEST_SUBMIT消息，最终会走到performSubmit(action)</span><br><span class="line">  void dispatchSubmit(Action action) &#123;</span><br><span class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void performSubmit(Action action) &#123;</span><br><span class="line">    performSubmit(action, true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * performSubmit执行过程：</span><br><span class="line">   * 1. 检查action 是否在pausedTags集合中，如果存在则直接替换覆盖</span><br><span class="line">   * 2. 如果action 存在hunterMap中， 则直接attach</span><br><span class="line">   * 3. 创建BitmapHunter，添加到PicassoExecutorService线程池</span><br><span class="line">   *&#x2F;</span><br><span class="line">  void performSubmit(Action action, boolean dismissFailed) &#123;</span><br><span class="line">    if (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">      pausedActions.put(action.getTarget(), action);</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</span><br><span class="line">            &quot;because tag &#39;&quot; + action.getTag() + &quot;&#39; is paused&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BitmapHunter hunter &#x3D; hunterMap.get(action.getKey());</span><br><span class="line">    if (hunter !&#x3D; null) &#123;</span><br><span class="line">      hunter.attach(action);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (service.isShutdown()) &#123;</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hunter &#x3D; forRequest(action.getPicasso(), this, cache, stats, action);</span><br><span class="line">    hunter.future &#x3D; service.submit(hunter);</span><br><span class="line">    hunterMap.put(action.getKey(), hunter);</span><br><span class="line">    if (dismissFailed) &#123;</span><br><span class="line">      failedActions.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 创建BitmapHunter对象</span><br><span class="line">   * 1. picasso.getRequestHandlers() 类似于拦截器作用，依次从ResourceRequestHandler、</span><br><span class="line">   * ContactsPhotoRequestHandler、MediaStoreRequestHandler、ContentStreamRequestHandler、</span><br><span class="line">   * AssetRequestHandler、FileRequestHandler、NetworkRequestHandler 调用canHandleRequest方法，判断交给那个Handler处理， 一般的网络图片就是NetworkRequestHandler</span><br><span class="line">   * </span><br><span class="line">   *&#x2F;</span><br><span class="line">  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span><br><span class="line">      Action action) &#123;</span><br><span class="line">    Request request &#x3D; action.getRequest();</span><br><span class="line">    List&lt;RequestHandler&gt; requestHandlers &#x3D; picasso.getRequestHandlers();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Index-based loop to avoid allocating an iterator.</span><br><span class="line">    &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">    for (int i &#x3D; 0, count &#x3D; requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">      RequestHandler requestHandler &#x3D; requestHandlers.get(i);</span><br><span class="line">      if (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">        return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 网络请求成功会回调到performComplete</span><br><span class="line">  void performComplete(BitmapHunter hunter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加到Cache缓存</span><br><span class="line">    if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">      cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    hunterMap.remove(hunter.getKey());</span><br><span class="line">    batch(hunter);</span><br><span class="line">    if (hunter.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), &quot;for completion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 网络返回结果，将hunter添加到batch之中，延迟200ms发送HUNTER_DELAY_NEXT_BATCH</span><br><span class="line">  private void batch(BitmapHunter hunter) &#123;</span><br><span class="line">    if (hunter.isCancelled()) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hunter.result !&#x3D; null) &#123;</span><br><span class="line">      hunter.result.prepareToDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    batch.add(hunter);</span><br><span class="line">    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知主线程更新UI界面</span><br><span class="line">  void performBatchComplete() &#123;</span><br><span class="line">    List&lt;BitmapHunter&gt; copy &#x3D; new ArrayList&lt;&gt;(batch);</span><br><span class="line">    batch.clear();</span><br><span class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</span><br><span class="line">    logBatch(copy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Dispatcher</strong>分发器的作用就是：调度网络请求，回调返回结果</p>
<p><strong>BitmapHunter.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class BitmapHunter implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void run() &#123;</span><br><span class="line">      ...</span><br><span class="line">      result &#x3D; hunt();</span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        dispatcher.dispatchFailed(this);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，回调到Dispatcher</span><br><span class="line">        dispatcher.dispatchComplete(this);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Bitmap hunt() throws IOException &#123;</span><br><span class="line">    Bitmap bitmap &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      bitmap &#x3D; cache.get(key);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        stats.dispatchCacheHit();</span><br><span class="line">        loadedFrom &#x3D; MEMORY;</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), &quot;from cache&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    networkPolicy &#x3D; retryCount &#x3D;&#x3D; 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">    RequestHandler.Result result &#x3D; requestHandler.load(data, networkPolicy);</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      loadedFrom &#x3D; result.getLoadedFrom();</span><br><span class="line">      exifOrientation &#x3D; result.getExifOrientation();</span><br><span class="line">      bitmap &#x3D; result.getBitmap();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If there was no Bitmap then we need to decode it from the stream.</span><br><span class="line">      if (bitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        Source source &#x3D; result.getSource();</span><br><span class="line">        try &#123;</span><br><span class="line">          bitmap &#x3D; decodeStream(source, data);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            &#x2F;&#x2F;noinspection ConstantConditions If bitmap is null then source is guranteed non-null.</span><br><span class="line">            source.close();</span><br><span class="line">          &#125; catch (IOException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bitmap !&#x3D; null) &#123;</span><br><span class="line">      if (picasso.loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</span><br><span class="line">      &#125;</span><br><span class="line">      stats.dispatchBitmapDecoded(bitmap);</span><br><span class="line">      if (data.needsTransformation() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">        synchronized (DECODE_LOCK) &#123;</span><br><span class="line">          if (data.needsMatrixTransform() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">            bitmap &#x3D; transformResult(data, bitmap, exifOrientation);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (data.hasCustomTransformations()) &#123;</span><br><span class="line">            bitmap &#x3D; applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), &quot;from custom transformations&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap !&#x3D; null) &#123;</span><br><span class="line">          stats.dispatchBitmapTransformed(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BitmapHunter</strong> 的run方法就是利用OKHttpClient进行网络请求</p>
<p>NetworkRequestHandler.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NetworkRequestHandler extends RequestHandler &#123;</span><br><span class="line"></span><br><span class="line">  @Override public Result load(Request request, int networkPolicy) throws IOException &#123;</span><br><span class="line">    okhttp3.Request downloaderRequest &#x3D; createRequest(request, networkPolicy);</span><br><span class="line">    Response response &#x3D; downloader.load(downloaderRequest);</span><br><span class="line">    ResponseBody body &#x3D; response.body();</span><br><span class="line"></span><br><span class="line">    if (!response.isSuccessful()) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ResponseException(response.code(), request.networkPolicy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache response is only null when the response comes fully from the network. Both completely</span><br><span class="line">    &#x2F;&#x2F; cached and conditionally cached responses will have a non-null cache response.</span><br><span class="line">    Picasso.LoadedFrom loadedFrom &#x3D; response.cacheResponse() &#x3D;&#x3D; null ? NETWORK : DISK;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Sometimes response content length is zero when requests are being replayed. Haven&#39;t found</span><br><span class="line">    &#x2F;&#x2F; root cause to this but retrying the request seems safe to do so.</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; DISK &amp;&amp; body.contentLength() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ContentLengthException(&quot;Received response with 0 content-length header.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; NETWORK &amp;&amp; body.contentLength() &gt; 0) &#123;</span><br><span class="line">      stats.dispatchDownloadFinished(body.contentLength());</span><br><span class="line">    &#125;</span><br><span class="line">    return new Result(body.source(), loadedFrom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OkHttp3Downloader.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class OkHttp3Downloader implements Downloader &#123;</span><br><span class="line">  @VisibleForTesting final Call.Factory client;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建磁盘缓存目录</span><br><span class="line">  public OkHttp3Downloader(final Context context) &#123;</span><br><span class="line">    this(Utils.createDefaultCacheDir(context));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull @Override public Response load(@NonNull Request request) throws IOException &#123;</span><br><span class="line">    return client.newCall(request).execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Picasso 缓存策略： 首先从内存缓存 -&gt; OkHttp磁盘缓存 -&gt; 网络请求</strong></p>
<h5 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h5><p><a href="https://www.jianshu.com/p/a5a79d861787" target="_blank" rel="noopener">1. picasso详解及其源码简析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:15:34 / 修改时间：11:15:54" itemprop="dateCreated datePublished" datetime="2020-05-31T11:15:34+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、OkHttp-简介"><a href="#一、OkHttp-简介" class="headerlink" title="一、OkHttp 简介"></a>一、OkHttp 简介</h5><p>HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：</p>
<ul>
<li>支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接</li>
<li>连接池减少请求延时</li>
<li>透明的GZIP压缩减少响应数据的大小</li>
<li>缓存响应内容，避免一些完全重复的请求</li>
</ul>
<p>当网络出现问题的时候OkHttp依然坚守自己的职责，它会自动恢复一般的连接问题，如果你的服务有多个IP地址，当第一个IP请求失败时，OkHttp会交替尝试你配置的其他IP，OkHttp使用现代TLS技术(SNI, ALPN)初始化新的连接，当握手失败时会回退到TLS 1.0。</p>
<p>官网链接地址：<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">https://square.github.io/okhttp/</a></p>
<h5 id="二、OkHttp-使用"><a href="#二、OkHttp-使用" class="headerlink" title="二、OkHttp 使用"></a>二、OkHttp 使用</h5><h5 id="2-1-同步请求"><a href="#2-1-同步请求" class="headerlink" title="2.1 同步请求"></a>2.1 同步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line">     </span><br><span class="line">Response response = okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>

<h5 id="2-2-异步请求"><a href="#2-2-异步请求" class="headerlink" title="2.2 异步请求"></a>2.2 异步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line"></span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="三、OkHttp-原理剖析"><a href="#三、OkHttp-原理剖析" class="headerlink" title="三、OkHttp 原理剖析"></a>三、OkHttp 原理剖析</h5><p><img src="https://upload-images.jianshu.io/upload_images/692087-b2db5588ceb9d9c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="OkHttp 结构图"></p>
<h6 id="3-1-OkHttpClient-构建"><a href="#3-1-OkHttpClient-构建" class="headerlink" title="3.1 OkHttpClient 构建"></a>3.1 OkHttpClient 构建</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> dispatcher: Dispatcher = builder.dispatcher</span><br><span class="line">    <span class="keyword">val</span> connectionPool: ConnectionPool = builder.connectionPool</span><br><span class="line">    <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; = builder.interceptors.toImmutableList()</span><br><span class="line">    <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; = builder.networkInterceptors.toImmutableList()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(Builder())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">newBuilder</span><span class="params">()</span></span>: Builder = Builder(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> dispatcher: Dispatcher = Dispatcher()</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectionPool: ConnectionPool = ConnectionPool()</span><br><span class="line">        <span class="comment">// 用户定义应用层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">        <span class="comment">// 用户自定义网络层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()    </span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> readTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> writeTimeout = <span class="number">10_000</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">writeTimeout</span><span class="params">(duration: <span class="type">Duration</span>)</span></span> = apply &#123;</span><br><span class="line">            writeTimeout = checkDuration(<span class="string">"timeout"</span>, duration.toMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: OkHttpClient = OkHttpClient(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpClient内部采用构建模式，定义了连接池、分发器、拦截器</p>
<h6 id="3-2-Call-对象"><a href="#3-2-Call-对象" class="headerlink" title="3.2 Call 对象"></a>3.2 Call 对象</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> transmitter: Transmitter</span><br><span class="line">  <span class="keyword">var</span> executed: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      originalRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      forWebSocket: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: RealCall &#123;</span><br><span class="line">      <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">        transmitter = Transmitter(client, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 同步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter()</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        transmitter.noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">"OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">        transmitter.timeoutEnter()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback = <span class="literal">true</span></span><br><span class="line">          responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.<span class="keyword">get</span>().log(INFO, <span class="string">"Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>"</span>, e)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += (client.cache)</span><br><span class="line">    interceptors += ConnectICacheInterceptornterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="keyword">this</span>,</span><br><span class="line">        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分发器：<strong><em>Dispatcher.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line">    <span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> idleCallback: Runnable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()    </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">      runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call)</span><br><span class="line">        <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">          <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">          <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line">      <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">      <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">          <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">          <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">          i.remove()</span><br><span class="line">          asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">          executableCalls.add(asyncCall)</span><br><span class="line">          runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isRunning</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">        finished(runningSyncCalls, call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>)</span><br><span class="line">          idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">          idleCallback.run()</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-拦截器链"><a href="#3-3-拦截器链" class="headerlink" title="3.3 拦截器链"></a>3.3 拦截器链</h6><p><img src="https://upload-images.jianshu.io/upload_images/10259072-269cd57a864d7f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/613/format/webp" alt="拦截器链"><br><strong><em>RealInterceptorChain.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> transmitter: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> exchange: Exchange?,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> connectTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> readTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> writeTimeout: <span class="built_in">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> calls: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>, transmitter: <span class="type">Transmitter</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line">    calls++</span><br><span class="line">    <span class="keyword">val</span> next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(<span class="string">"interceptor <span class="variable">$interceptor</span> returned null"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> response  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.1 RetryAndFollowUpInterceptor 失败重试及重定向</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">var</span> request = chain.request()</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      transmitter.prepareToConnect(request)</span><br><span class="line">      <span class="comment">// 检查当前请求是否被取消，如果这时请求被取消了，则会释放连接，并抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> response: Response</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = realChain.proceed(request, transmitter, <span class="literal">null</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, transmitter, <span class="literal">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">val</span> requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// The network call threw an exception. Release any resources.</span></span><br><span class="line">        <span class="comment">// 在请求过程中，只要发生异常，就会将连接释放掉</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          transmitter.exchangeDoneDueToException()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = response.exchange</span><br><span class="line">      <span class="keyword">val</span> route = exchange?.connection()?.route()</span><br><span class="line">      <span class="comment">// 响应response来执行followUpRequest方法，来检查是否需要进行重定向操作</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, route)</span><br><span class="line">      <span class="comment">// 不需要重定向，则断开链接，返回response，交给下一个拦截器</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          transmitter.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        exchange?.detachWithViolence()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重定向次数大于阈值</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">"Too many follow-up requests: <span class="variable">$followUpCount</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, route: <span class="type">Route</span>?)</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">    <span class="comment">// 我们知道，在Http响应码中，处于3XX的，都需要进行请求重定向处理</span></span><br><span class="line">    <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">      HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">        <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line"></span><br><span class="line">      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -&gt; &#123;</span><br><span class="line">        <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">        <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="string">"GET"</span> &amp;&amp; method != <span class="string">"HEAD"</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">        <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></span><br><span class="line">        <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></span><br><span class="line">        <span class="comment">// repeat the request (even non-idempotent ones.)</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">          <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">        <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userResponse.request</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// specifically received an instruction to retry without delay</span></span><br><span class="line">          <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据响应获取到位置location，然后根据location，得到重定向的url</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildRedirectRequest</span><span class="params">(userResponse: <span class="type">Response</span>, method: <span class="type">String</span>)</span></span>: Request? &#123;</span><br><span class="line">    <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">    <span class="keyword">if</span> (!client.followRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> location = userResponse.header(<span class="string">"Location"</span>) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">    <span class="keyword">val</span> url = userResponse.request.url.resolve(location) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">    <span class="keyword">val</span> sameScheme = url.scheme == userResponse.request.url.scheme</span><br><span class="line">    <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Most redirects don't include a request body.</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userResponse.request.newBuilder()</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">      <span class="keyword">val</span> maintainBody = HttpMethod.redirectsWithBody(method)</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">        requestBuilder.method(<span class="string">"GET"</span>, <span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> requestBody = <span class="keyword">if</span> (maintainBody) userResponse.request.body <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        requestBuilder.method(method, requestBody)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Type"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">    <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">    <span class="comment">// way to retain them.</span></span><br><span class="line">    <span class="keyword">if</span> (!userResponse.request.url.canReuseConnectionFor(url)) &#123;</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Authorization"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.url(url).build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取请求的response ，判断请求是否异常（释放连接），如果response正常,判断重定向条件</strong></p>
<ul>
<li>3.3.2 BridgeInterceptor 用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="literal">true</span></span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">        <span class="string">"gzip"</span>.equals(networkResponse.header(<span class="string">"Content-Encoding"</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">      <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">            .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">"Content-Type"</span>)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完善请求头和响应头</strong></p>
<ul>
<li>3.3.3 CacheInterceptor 缓存拦截器</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">//如果配置了缓存：优先从缓存中读取Response</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="comment">// 如果缓存不为空，但是策略器得到的结果是不能用缓存，也就是 cacheResponse 为 null，这种情况就是将 cacheCandidate.body() 进行 close 操作</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// //如果根据缓存策略strategy禁止使用网络，并且缓存无效，直接返回空的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 如果根据缓存策略strategy禁止使用网络，且有缓存则直接使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 本地有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 并且服务器返回304状态码（说明缓存还没过期或服务器资源没修改）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="comment">// 使用缓存数据 </span></span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="comment">// 返回缓存</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果网络资源已经修改：使用网络响应返回的最新数据</span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将最新的数据缓存起来</span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.4 ConnectInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">val</span> doExtensiveHealthChecks = request.method != <span class="string">"GET"</span></span><br><span class="line">    <span class="keyword">val</span> exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.5 CallServerInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange()</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向服务器发送请求</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> responseHeadersStarted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 检测是否有请求body</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">      <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return</span></span><br><span class="line">      <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">      <span class="comment">// 询问Server使用愿意接受数据 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equals(request.header(<span class="string">"Expect"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseHeadersStarted = <span class="literal">true</span></span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">          <span class="comment">// 向服务器发送requesyBody</span></span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">      exchange.responseHeadersStart()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建response对象</span></span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">      <span class="comment">// try again to read the actual response</span></span><br><span class="line">      response = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回空的即无效的响应</span></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equals(response.request.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">"close"</span>.equals(response.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="四、连接"><a href="#四、连接" class="headerlink" title="四、连接"></a>四、连接</h6><p><strong><em>Transmitter.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Transmitter(</span><br><span class="line">  private val client: OkHttpClient,</span><br><span class="line">  private val call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  private val connectionPool: RealConnectionPool &#x3D; client.connectionPool.delegate</span><br><span class="line">  private var exchangeFinder: ExchangeFinder? &#x3D; null</span><br><span class="line">    </span><br><span class="line">  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange &#123;</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      check(!noMoreExchanges) &#123; &quot;released&quot; &#125;</span><br><span class="line">      check(exchange &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &quot;cannot make a new request because the previous response is still open: &quot; +</span><br><span class="line">            &quot;please call response.close()&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    val codec &#x3D; exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)</span><br><span class="line">    val result &#x3D; Exchange(this, call, eventListener, exchangeFinder!!, codec)</span><br><span class="line"></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      this.exchange &#x3D; result</span><br><span class="line">      this.exchangeRequestDone &#x3D; false</span><br><span class="line">      this.exchangeResponseDone &#x3D; false</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ExchangeFinder.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">class ExchangeFinder(</span><br><span class="line">  private val transmitter: Transmitter,</span><br><span class="line">  private val connectionPool: RealConnectionPool,</span><br><span class="line">  private val address: Address,</span><br><span class="line">  private val call: Call,</span><br><span class="line">  private val eventListener: EventListener</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  fun find(</span><br><span class="line">    client: OkHttpClient,</span><br><span class="line">    chain: Interceptor.Chain,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): ExchangeCodec &#123;</span><br><span class="line">    val connectTimeout &#x3D; chain.connectTimeoutMillis()</span><br><span class="line">    val readTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">    val writeTimeout &#x3D; chain.writeTimeoutMillis()</span><br><span class="line">    val pingIntervalMillis &#x3D; client.pingIntervalMillis</span><br><span class="line">    val connectionRetryEnabled &#x3D; client.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">      val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled,</span><br><span class="line">          doExtensiveHealthChecks &#x3D; doExtensiveHealthChecks</span><br><span class="line">      )</span><br><span class="line">      return resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw e</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findHealthyConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环调用，直到得到一个健康的RealConnection </span><br><span class="line">    while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 查找连接</span><br><span class="line">      val candidate &#x3D; findConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If this is a brand new connection, we can skip the extensive health checks.</span><br><span class="line">      &#x2F;&#x2F; 如果是一个全新的连接直接拿去使用不需要检查</span><br><span class="line">      synchronized(connectionPool) &#123;</span><br><span class="line">        if (candidate.successCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          return candidate</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br><span class="line">      &#x2F;&#x2F; isn&#39;t, take it out of the pool and start again.</span><br><span class="line">      &#x2F;&#x2F; 检查这个连接是否是健康可用的，如果不是把它移除连接池</span><br><span class="line">      if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        candidate.noNewExchanges()</span><br><span class="line">        continue</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return candidate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    var foundPooledConnection &#x3D; false</span><br><span class="line">    var result: RealConnection? &#x3D; null</span><br><span class="line">    var selectedRoute: Route? &#x3D; null</span><br><span class="line">    var releasedConnection: RealConnection?</span><br><span class="line">    val toClose: Socket?</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">      hasStreamFailure &#x3D; false &#x2F;&#x2F; This is a fresh attempt.</span><br><span class="line">      &#x2F;&#x2F; 优先返回一个已经分配的连接，假如这个连接不为空，并且这个连接上面还可以建立新的stream</span><br><span class="line">      releasedConnection &#x3D; transmitter.connection</span><br><span class="line">      toClose &#x3D; if (transmitter.connection !&#x3D; null &amp;&amp; transmitter.connection!!.noNewExchanges) &#123;</span><br><span class="line">        transmitter.releaseConnectionNoEvents()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (transmitter.connection !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">        releasedConnection &#x3D; null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Attempt to get a connection from the pool.</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">          nextRouteToTry &#x3D; null</span><br><span class="line">        &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">          selectedRoute &#x3D; transmitter.connection!!.route()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done.</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we need a route selection, make one. This is a blocking operation.</span><br><span class="line">    var newRouteSelection &#x3D; false</span><br><span class="line">    if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">      newRouteSelection &#x3D; true</span><br><span class="line">      routeSelection &#x3D; routeSelector.next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">      if (newRouteSelection) &#123;</span><br><span class="line">        &#x2F;&#x2F; Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br><span class="line">        &#x2F;&#x2F; the pool. This could match due to connection coalescing.</span><br><span class="line">        routes &#x3D; routeSelection!!.routes</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">                address, transmitter, routes, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!foundPooledConnection) &#123;</span><br><span class="line">        if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">        &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do.</span><br><span class="line">        result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">        connectingConnection &#x3D; result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we found a pooled connection on the 2nd time around, we&#39;re done.</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">    &#x2F;&#x2F; 执行TCP + TLS握手</span><br><span class="line">    result!!.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">    connectionPool.routeDatabase.connected(result!!.route())</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建socket链接</span><br><span class="line">    var socket: Socket? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      connectingConnection &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br><span class="line">      &#x2F;&#x2F; concurrent connections to the same host.</span><br><span class="line">      &#x2F;&#x2F; 如果有另一个具有相同IP地址的连接被同时创建，那么把这个连接释放，去用另外一个</span><br><span class="line">      &#x2F;&#x2F;这种情况只有Http2的时候才会去执行</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection.</span><br><span class="line">        result!!.noNewExchanges &#x3D; true</span><br><span class="line">        socket &#x3D; result!!.socket()</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新建的连接放入连接池</span><br><span class="line">        connectionPool.put(result!!)</span><br><span class="line">        transmitter.acquireConnectionNoEvents(result!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>Exchange.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Exchange(</span><br><span class="line">  internal val transmitter: Transmitter,</span><br><span class="line">  internal val call: Call,</span><br><span class="line">  internal val eventListener: EventListener,</span><br><span class="line">  private val finder: ExchangeFinder,</span><br><span class="line">  private val codec: ExchangeCodec</span><br><span class="line">) &#123;</span><br><span class="line">  fun connection(): RealConnection? &#x3D; codec.connection()</span><br><span class="line">  </span><br><span class="line">  fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      eventListener.requestHeadersStart(call)</span><br><span class="line">      codec.writeRequestHeaders(request)</span><br><span class="line">      eventListener.requestHeadersEnd(call, request)</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      eventListener.requestFailed(call, e)</span><br><span class="line">      trackFailure(e)</span><br><span class="line">      throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ExchangeCodec.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface ExchangeCodec &#123;</span><br><span class="line">  fun connection(): RealConnection?</span><br><span class="line">  fun createRequestBody(request: Request, contentLength: Long): Sink</span><br><span class="line">  fun writeRequestHeaders(request: Request)</span><br><span class="line">  fun flushRequest()</span><br><span class="line">  fun finishRequest()</span><br><span class="line">  fun readResponseHeaders(expectContinue: Boolean): Response.Builder?</span><br><span class="line">  fun openResponseBodySource(response: Response): Source</span><br><span class="line">  fun cancel()</span><br><span class="line">  companion object &#123;</span><br><span class="line">    const val DISCARD_STREAM_TIMEOUT_MILLIS &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>RealConnectionPool.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class RealConnectionPool(</span><br><span class="line">  &#x2F;** The maximum number of idle connections for each address. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 最大的空闲socket连接数</span><br><span class="line">  private val maxIdleConnections: Int,</span><br><span class="line">  &#x2F;&#x2F; socket的keepAlive时间</span><br><span class="line">  keepAliveDuration: Long,</span><br><span class="line">  timeUnit: TimeUnit</span><br><span class="line">) &#123;</span><br><span class="line">  private val keepAliveDurationNs: Long &#x3D; timeUnit.toNanos(keepAliveDuration)</span><br><span class="line"></span><br><span class="line">  private val cleanupRunnable &#x3D; object : Runnable &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        val waitNanos &#x3D; cleanup(System.nanoTime())</span><br><span class="line">        if (waitNanos &#x3D;&#x3D; -1L) return</span><br><span class="line">        try &#123;</span><br><span class="line">          this@RealConnectionPool.lockAndWaitNanos(waitNanos)</span><br><span class="line">        &#125; catch (_: InterruptedException) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private val connections &#x3D; ArrayDeque&lt;RealConnection&gt;()</span><br><span class="line">  &#x2F;&#x2F; 用来记录连接失败的路线名单</span><br><span class="line">  val routeDatabase &#x3D; RouteDatabase()</span><br><span class="line">  var cleanupRunning: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  init &#123;</span><br><span class="line">    &#x2F;&#x2F; Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span><br><span class="line">    require(keepAliveDuration &gt; 0L) &#123; &quot;keepAliveDuration &lt;&#x3D; 0: $keepAliveDuration&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  companion object &#123;</span><br><span class="line">    private val executor &#x3D; ThreadPoolExecutor(</span><br><span class="line">        0, &#x2F;&#x2F; corePoolSize.</span><br><span class="line">        Int.MAX_VALUE, &#x2F;&#x2F; maximumPoolSize.</span><br><span class="line">        60L, TimeUnit.SECONDS, &#x2F;&#x2F; keepAliveTime.</span><br><span class="line">        SynchronousQueue(),</span><br><span class="line">        threadFactory(&quot;OkHttp ConnectionPool&quot;, true)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fun get(connectionPool: ConnectionPool): RealConnectionPool &#x3D; connectionPool.delegate</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="五、更多阅读"><a href="#五、更多阅读" class="headerlink" title="五、更多阅读"></a>五、更多阅读</h6><p><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="noopener">1. OKHttp源码解析</a></p>
<p><a href="https://www.cnblogs.com/zhangqie/p/8681308.html" target="_blank" rel="noopener">2. Android开源框架源码分析：Okhttp</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Retrofit2 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:14:46 / 修改时间：11:15:06" itemprop="dateCreated datePublished" datetime="2020-05-31T11:14:46+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、Retrofit2-简介"><a href="#一、Retrofit2-简介" class="headerlink" title="一、Retrofit2 简介"></a>一、Retrofit2 简介</h5><p>Retrofit是一个遵循RESTful设计的进行HTTP网络请求框架，底层网络请求基于OkHttp框架</p>
<h6 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"> </span><br><span class="line">GitHubService service = retrofit.create(GitHubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">service.listRepos(<span class="string">"test"</span>).enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="1-2-RxJava、GSON"><a href="#1-2-RxJava、GSON" class="headerlink" title="1.2 RxJava、GSON"></a>1.2 RxJava、GSON</h6><h5 id="二、原理剖析"><a href="#二、原理剖析" class="headerlink" title="二、原理剖析"></a>二、原理剖析</h5><h6 id="2-1-Retrofit的创建"><a href="#2-1-Retrofit的创建" class="headerlink" title="2.1 Retrofit的创建"></a>2.1 Retrofit的创建</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">    <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>(Platform.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">          <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">          &#125;</span><br><span class="line">          Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">          <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">          <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">          <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">          converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">          converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">          converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-create-动态代理"><a href="#2-2-create-动态代理" class="headerlink" title="2.2 create 动态代理"></a>2.2 create 动态代理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回service的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">              @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>HttpServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">        ...   </span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">        Type responseType = callAdapter.responseType();</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line">        okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">          continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);  </span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">        <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">        CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">            <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">            <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendForBody</span>&lt;<span class="title">ResponseT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isNullable;</span><br><span class="line"></span><br><span class="line">    SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter, <span class="keyword">boolean</span> isNullable) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">      <span class="keyword">this</span>.isNullable = isNullable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Object <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      call = callAdapter.adapt(call);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class="line">      Continuation&lt;ResponseT&gt; continuation = (Continuation&lt;ResponseT&gt;) args[args.length - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span> isNullable</span><br><span class="line">          ? KotlinExtensions.awaitNullable(call, continuation)</span><br><span class="line">          : KotlinExtensions.await(call, continuation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>DefaultCallAdapterFactory.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        ? <span class="title">null</span></span></span><br><span class="line">        : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span></span><br><span class="line">            ? call</span><br><span class="line">            : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      delegate.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.request();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="四、更多阅读"><a href="#四、更多阅读" class="headerlink" title="四、更多阅读"></a>四、更多阅读</h6><p><a href="https://www.jianshu.com/p/0b4c41d5d354" target="_blank" rel="noopener">1. 【Android源码伴读】Retrofit源码探秘</a></p>
<p><a href="https://www.jianshu.com/p/097947afddaf" target="_blank" rel="noopener">2. Retrofit源码分析（超详细）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">EventBus 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:13:30 / 修改时间：11:13:57" itemprop="dateCreated datePublished" datetime="2020-05-31T11:13:30+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>EventBus是一个Android端优化的publish／subscribe消息总线，简化了应用程序内各组件内、组件与后台线程间的通信，比如请求网络，等网络返回时，通过Handler、Broadcast更新UI等。它有很多优点：简化应用组件间的通信；解耦事件的发送者和接收者。<br><img src="https://upload-images.jianshu.io/upload_images/2169292-9d0c216714804720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EventBus-Publish-Subscribe.png"></p>
<h5 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h5><p>注册： EventBus.getDefault().register(this);<br>解注册：EventBus.getDefault().unregister(this);<br>事件Event： 事件可以是任意普通的Java对象，没有任何特殊的要求<br>发送消息： EventBus.getDefault().post(new MessageEvent(“Hello EventBus!”));</p>
<h5 id="三、线程模式"><a href="#三、线程模式" class="headerlink" title="三、线程模式"></a>三、线程模式</h5><p>EventBus支持订阅者方法在不同于发布事件所在线程的线程中被调用。你可以使用线程模式来指定调用订阅者方法的线程。EventBus总共支持5种线程模式：</p>
<ul>
<li><p>ThreadMode.POSTING 订阅者方法将在发布事件所在的线程中被调用。这是 默认的线程模式。事件的传递是同步的，一旦发布事件，所有该模式的订阅者方法都将被调用。这种线程模式意味着最少的性能开销，因为它避免了线程的切换。因此，对于不要求是主线程并且耗时很短的简单任务推荐使用该模式。使用该模式的订阅者方法应该快速返回，以避免阻塞发布事件的线程，这可能是主线程。</p>
</li>
<li><p>ThreadMode.MAIN 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.MAIN_ORDERED 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。事件将先进入队列然后才发送给订阅者，所以发布事件的调用将立即返回。这使得事件的处理保持严格的串行顺序。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.BACKGROUND 订阅者方法将在后台线程中被调用。如果发布事件的线程不是主线程，那么订阅者方法将直接在该线程中被调用。如果发布事件的线程是主线程，那么将使用一个单独的后台线程，该线程将按顺序发送所有的事件。使用该模式的订阅者方法应该快速返回，以避免阻塞后台线程。</p>
</li>
<li><p>ThreadMode.ASYNC 订阅者方法将在一个单独的线程中被调用。因此，发布事件的调用将立即返回。如果订阅者方法的执行需要一些时间，例如网络访问，那么就应该使用该模式。避免触发大量的长时间运行的订阅者方法，以限制并发线程的数量。EventBus使用了一个线程池来有效地重用已经完成调用订阅者方法的线程。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.POSTING)</span><br><span class="line">    public void onMessageEventPosting(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventPosting(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN)</span><br><span class="line">public void onMessageEventMain(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMain(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN_ORDERED)</span><br><span class="line">public void onMessageEventMainOrdered(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMainOrdered(), current thread is &quot;</span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.BACKGROUND)</span><br><span class="line">public void onMessageEventBackground(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventBackground(), current thread is &quot; </span><br><span class="line">         + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.ASYNC)</span><br><span class="line">public void onMessageEventAsync(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventAsync(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、粘性事件"><a href="#四、粘性事件" class="headerlink" title="四、粘性事件"></a>四、粘性事件</h5><p>发布一个粘性事件之后，EventBus将在内存中缓存该粘性事件。当有订阅者订阅了该粘性事件，订阅者将接收到该事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发布粘性事件</span><br><span class="line">EventBus.getDefault().postSticky(new MessageEvent(&quot;Hello EventBus!&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅粘性事件</span><br><span class="line">@Subscribe(sticky &#x3D; true)</span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、源码解析"><a href="#五、源码解析" class="headerlink" title="五、源码解析"></a>五、源码解析</h5><ol>
<li>从EventBus.getDefault()方法开始说起。主要是获取EventBus对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 典型的双重校验锁的单例模式</span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">    if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                defaultInstance &#x3D; new EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public EventBus() &#123;</span><br><span class="line">    this(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; key 为订阅事件类型，value为订阅该事件的所有订阅者集合</span><br><span class="line">&#x2F;&#x2F; Subscription则是一个封装了订阅者和方法体的一个类</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; </span><br><span class="line">subscriptionsByEventType;</span><br><span class="line">&#x2F;&#x2F; key为订阅者，value为订阅者的所有订阅方法</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化成员变量</span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadPoster &#x3D; new HandlerPoster(this, Looper.getMainLooper(), 10);</span><br><span class="line">    backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">    asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">    &#x2F;&#x2F;一系列的builder赋值</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">2. 消息注册register(this)函数</span><br></pre></td></tr></table></figure>
public void register(Object subscriber) {<br> Class&lt;?&gt; subscriberClass = subscriber.getClass();<br> // 从订阅类中获取所有的订阅方法信息<br> List<SubscriberMethod> subscriberMethods = subscriberMethodFinder<pre><code>.findSubscriberMethods(subscriberClass);</code></pre> synchronized (this) {<pre><code>for (SubscriberMethod subscriberMethod : subscriberMethods) {
    subscribe(subscriber, subscriberMethod);
}</code></pre> }<br>}</li>
</ol>
<p>List<SubscriberMethod> findSubscriberMethods(Class&lt;?&gt; subscriberClass) {<br>    // 首先从缓存中读取<br>    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);<br>    if (subscriberMethods != null) {<br>        return subscriberMethods;<br>    }<br>    // 默认是false<br>    if (ignoreGeneratedIndex) {<br>        // 利用反射来获取订阅方法中的信息<br>        subscriberMethods = findUsingReflection(subscriberClass);<br>    } else {<br>        // 从注解器获取的类中获得订阅方法信息<br>        subscriberMethods = findUsingInfo(subscriberClass);<br>    }<br>    if (subscriberMethods.isEmpty()) {<br>        throw new EventBusException(“Subscriber “ + subscriberClass<br>                + “ and its super classes have no public methods with “<br>                +” the @Subscribe annotation”);<br>    } else {<br>        // 保存在缓存中<br>        METHOD_CACHE.put(subscriberClass, subscriberMethods);<br>        return subscriberMethods;<br>    }<br>}</p>
<p>private List<SubscriberMethod> findUsingInfo(Class&lt;?&gt; subscriberClass) {<br>    // 准备一个FindState，该FindState保存了订阅者类的信息<br>    FindState findState = prepareFindState();<br>    //对FindState初始化<br>    findState.initForSubscriber(subscriberClass);<br>    while (findState.clazz != null) {<br>        findState.subscriberInfo = getSubscriberInfo(findState);<br>        //获得订阅者的信息，一开始会返回null<br>        if (findState.subscriberInfo != null) {<br>            SubscriberMethod[] array = findState.subscriberInfo<br>                                       .getSubscriberMethods();<br>            for (SubscriberMethod subscriberMethod : array) {<br>                if (findState.checkAdd(subscriberMethod.method<br>                    , subscriberMethod.eventType)) {<br>                    findState.subscriberMethods.add(subscriberMethod);<br>                }<br>            }<br>        } else {<br>            findUsingReflectionInSingleClass(findState);<br>        }<br>        findState.moveToSuperclass();<br>    }<br>return getMethodsAndRelease(findState);<br>}</p>
<p>private void findUsingReflectionInSingleClass(FindState findState) {<br>    Method[] methods;<br>    try {<br>        // This is faster than getMethods, especially when subscribers are<br>       // fat classes like Activities<br>        methods = findState.clazz.getDeclaredMethods();<br>    } catch (Throwable th) {<br>        // Workaround for java.lang.NoClassDefFoundError,<br>        // see <a href="https://github.com/greenrobot/EventBus/issues/149" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus/issues/149</a><br>        methods = findState.clazz.getMethods();<br>        findState.skipSuperClasses = true;<br>    }<br>    for (Method method : methods) {<br>        int modifiers = method.getModifiers();<br>        if ((modifiers &amp; Modifier.PUBLIC) != 0<br>            &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {<br>            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method
                                               .getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    Class<?> eventType = parameterTypes[0];<br>                    if (findState.checkAdd(method, eventType)) {<br>                        ThreadMode threadMode = subscribeAnnotation.threadMode();<br>                        findState.subscriberMethods.add(new SubscriberMethod(method<br>                        , eventType, threadMode,subscribeAnnotation.priority()<br>                        , subscribeAnnotation.sticky()));<br>                    }<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>                   String methodName = method.getDeclaringClass().getName()<br>                                    + “.” + method.getName();<br>                    throw new EventBusException(“@Subscribe method “ + methodName +<br>                 “must have exactly 1 parameter but has “ + parameterTypes.length);<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>            String methodName = method.getDeclaringClass().getName() + “.”<br>                                + method.getName();<br>            throw new EventBusException(methodName +<br>                        “ is a illegal @Subscribe method: must be public “<br>                        + “, non-static, and non-abstract”);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 发送消息源码</span><br></pre></td></tr></table></figure>
<p>public void post(Object event) {<br>    PostingThreadState postingState = currentPostingThreadState.get();<br>    List<Object> eventQueue = postingState.eventQueue;<br>    eventQueue.add(event);<br>    // 如果没有正在发送，则发送消息<br>    if (!postingState.isPosting) {<br>        postingState.isMainThread = isMainThread();<br>        postingState.isPosting = true;<br>        if (postingState.canceled) {<br>          throw new EventBusException(“Internal error. Abort state was not reset”);<br>        }<br>        try {<br>            while (!eventQueue.isEmpty()) {<br>                // 发送消息<br>                postSingleEvent(eventQueue.remove(0), postingState);<br>             }<br>        } finally {<br>            postingState.isPosting = false;<br>            postingState.isMainThread = false;<br>        }<br>    }<br>}</p>
<p>private void postSingleEvent(Object event, PostingThreadState postingState)<br>throws Error {<br>    Class<?> eventClass = event.getClass();
    boolean subscriptionFound = false;
    if (eventInheritance) {
        List<Class<?>&gt; eventTypes = lookupAllEventTypes(eventClass);<br>        int countTypes = eventTypes.size();<br>        for (int h = 0; h &lt; countTypes; h++) {<br>            Class&lt;?&gt; clazz = eventTypes.get(h);<br>            subscriptionFound |= postSingleEventForEventType(event<br>                                 , postingState, clazz);<br>        }<br>     } else {<br>        subscriptionFound = postSingleEventForEventType(event, postingState<br>                                                        , eventClass);<br>     }<br>     if (!subscriptionFound) {<br>        if (logNoSubscriberMessages) {<br>            logger.log(Level.FINE, “No subscribers registered for event “<br>                       + eventClass);<br>        }<br>        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class<br>            &amp;&amp; eventClass != SubscriberExceptionEvent.class) {<br>            post(new NoSubscriberEvent(this, event));<br>        }<br>    }<br>}</p>
<p>private boolean postSingleEventForEventType(Object event<br>                          , PostingThreadState postingState, Class&lt;?&gt; eventClass) {<br>    CopyOnWriteArrayList<Subscription> subscriptions;<br>    synchronized (this) {<br>        // 根据事件类型获取所有的订者<br>        subscriptions = subscriptionsByEventType.get(eventClass);<br>    }<br>    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {<br>        for (Subscription subscription : subscriptions) {<br>            postingState.event = event;<br>            postingState.subscription = subscription;<br>            boolean aborted = false;<br>            try {<br>                postToSubscription(subscription, event, postingState.isMainThread);<br>                aborted = postingState.canceled;<br>            } finally {<br>                postingState.event = null;<br>                postingState.subscription = null;<br>                postingState.canceled = false;<br>            }<br>            if (aborted) {<br>                break;<br>            }<br>        }<br>        return true;<br>    }<br>    return false;<br>}</p>
<p>private void postToSubscription(Subscription subscription, Object event<br>                                , boolean isMainThread) {<br>    switch (subscription.subscriberMethod.threadMode) {<br>        case POSTING:<br>            invokeSubscriber(subscription, event);<br>            break;<br>        case MAIN:<br>            if (isMainThread) {<br>                invokeSubscriber(subscription, event);<br>            } else {<br>                mainThreadPoster.enqueue(subscription, event);<br>            }<br>            break;<br>        case MAIN_ORDERED:<br>            if (mainThreadPoster != null) {<br>                mainThreadPoster.enqueue(subscription, event);<br>            } else {<br>                // temporary: technically not correct as poster not decoupled<br>                // from subscriber<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case BACKGROUND:<br>            if (isMainThread) {<br>                backgroundPoster.enqueue(subscription, event);<br>            } else {<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case ASYNC:<br>            asyncPoster.enqueue(subscription, event);<br>            break;<br>        default:<br>            throw new IllegalStateException(“Unknown thread mode: “<br>                                       + subscription.subscriberMethod.threadMode);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 取消注册源码分析</span><br></pre></td></tr></table></figure>
<p>public synchronized void unregister(Object subscriber) {<br>    List&lt;Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class<?> eventType : subscribedTypes) {<br>            unsubscribeByEventType(subscriber, eventType);<br>        }<br>        typesBySubscriber.remove(subscriber);<br>    } else {<br>        logger.log(Level.WARNING, “Subscriber to unregister was not<br>                   “+registered before: “ + subscriber.getClass());<br>    }<br>}</p>
<p>private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {<br>    // 获取事件类型的所有订阅者<br>    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);<br>    if (subscriptions != null) {<br>        int size = subscriptions.size();<br>        // 遍历订阅者集合将解除的订阅者移除<br>        for (int i = 0; i &lt; size; i++) {<br>            Subscription subscription = subscriptions.get(i);<br>            if (subscription.subscriber == subscriber) {<br>                subscription.active = false;<br>                subscriptions.remove(i);<br>                i–;<br>                size–;<br>            }<br>        }<br>    }<br>}</p>
<pre><code>简单的进行总结一下，主要就是注册和发送过程比较重要。

注册：

1. 通过反射或者注解获取所有的订阅方法 
2. 将当前订阅者添加到EventBus总的事件订阅者集合中subscriptionsByEventType 
3. 将当前订阅者所有订阅的事件类型添加到typesBySubscriber，方便解注册

发送：
1. 得到要发送的事件类型 
2. 根据事件类型获取订阅者，并循环向每个订阅者发送

解注册：
1. 通过typesBySubscriber获取当前订阅者所有的订阅事件类型
2. 循环遍历每一个事件类型，并删除当前订阅者的订阅的方法</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">RxJava 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:10:57 / 修改时间：11:13:00" itemprop="dateCreated datePublished" datetime="2020-05-31T11:10:57+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、RxJava-简介"><a href="#一、RxJava-简介" class="headerlink" title="一、RxJava 简介"></a>一、RxJava 简介</h5><p>RxJava是一种基于观察者模式的响应式编程框架，其定义的角色有Observable事件流、ObservableOnSubscribe事件源头、Observer是事件订阅者。</p>
<h5 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="string">"Android"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"Kotlin"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"Java"</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(<span class="keyword">new</span> Function&lt;String, Strinsg&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I Love "</span>+ s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"test"</span>, <span class="string">"onNext: "</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"test"</span>, <span class="string">"[onComplete]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test: onNext: I Love Android</span><br><span class="line">test: onNext: I Love Kotlin</span><br><span class="line">test: onNext: I Love Java</span><br><span class="line">test: [onComplete]</span><br></pre></td></tr></table></figure>

<h5 id="三、原理剖析"><a href="#三、原理剖析" class="headerlink" title="三、原理剖析"></a>三、原理剖析</h5><h6 id="3-1-Observable、Observer订阅原理"><a href="#3-1-Observable、Observer订阅原理" class="headerlink" title="3.1 Observable、Observer订阅原理"></a>3.1 Observable、Observer订阅原理</h6><p><strong><em>ObservableSource.java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ObservableSource&lt;T&gt; &#123;</span><br><span class="line">    void subscribe(@NonNull Observer&lt;? super T&gt; observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>Observable.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="comment">// 创建事件源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅相关</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    	subscribeActual(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>create方法创建事件源,其参数ObservableOnSubscribe 接口定义如下：<br><strong><em>ObservableOnSubscribe.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObservableEmitter可以理解为事件发射器，继承Emitter里卖弄的基本发射方法，同时关连Disposable<br><strong><em>Emitter.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable error)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ObservableEmitter.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(@Nullable Disposable d)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCancellable</span><span class="params">(@Nullable Cancellable c)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ObservableEmitter&lt;T&gt; <span class="title">serialize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(@NonNull Throwable t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observable.create方法最终会返回ObservableCreate<T>对象，ObservableCreate类包含了ObservableOnSubscribe对象引用，且实现了subscribeActual订阅方法</p>
<p><strong><em>ObservableCreate.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅的时候会执行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1 创建 CreateEmitter，也是一个适配器，可以将 Observer -&gt; Disposable，CreateEmitter 中主要持有 observer 对象的引用，并且维护了 dispose 变量。</span></span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        <span class="comment">//2 onSubscribe（）参数是 Disposable。还有一点要注意的是 onSubscribe() 是在我们执行 subscribe() 这句代码的那个线程回调的，并不受线程调度影响。</span></span><br><span class="line">        <span class="comment">// 给 observer 的一个回调，告诉它是否 dispose</span></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//3 将 ObservableOnSubscribe（源头）与 CreateEmitter（Observer，终点）联系起来，即完成订阅，此时 ObservableOnSubscribe 会向 observer 传送事件</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有被 dispose，会调用 Observer 的 onNext()方法</span></span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                observer.onNext(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">                RxJavaPlugins.onError(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> NullPointerException(<span class="string">"onError called with null. Null values are generally not allowed in 2.x operators and sources."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onError(t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// onComplete() 和 onError() 互斥只能执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onComplete();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Observer订阅者定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-2-map操作符原理"><a href="#3-2-map操作符原理" class="headerlink" title="3.2 map操作符原理"></a>3.2 map操作符原理</h6><p>map函数的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ObservableMap.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super()将上游的Observable保存起来 ，用于subscribeActual()中用。</span></span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="comment">// 将function变换函数类保存起来</span></span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用 MapObserver 订阅上游 Observable。</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(actual);</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// done在onError 和 onComplete以后才会是true，默认这里是false，所以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认sourceMode是0，所以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != NONE) &#123;</span><br><span class="line">                downstream.onNext(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U v;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这一步执行变换,将上游传过来的 T，利用 Function 转换成下游需要的 V</span></span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                fail(ex);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 变换后传递给下游Observer</span></span><br><span class="line">            downstream.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transitiveBoundaryFusion(mode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> U <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            T t = qd.poll();</span><br><span class="line">            <span class="keyword">return</span> t != <span class="keyword">null</span> ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-subscribeOn-线程调度"><a href="#3-3-subscribeOn-线程调度" class="headerlink" title="3.3 subscribeOn 线程调度"></a>3.3 subscribeOn 线程调度</h6><p>subscribeOn 函数源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(</span><br><span class="line">        <span class="comment">// 返回Observable，传入上游this和调度器scheduler</span></span><br><span class="line">        <span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(downStream);</span><br><span class="line">        <span class="comment">// SubscribeOnObserver实现了Disposable，将其传递给下游的onSubscribe</span></span><br><span class="line">        downStream.onSubscribe(parent);</span><br><span class="line">        <span class="comment">// 把source的订阅放在Runnable中，由scheduler调度</span></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                source.subscribe(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对subscribeOn()的调用是自下向上，所以连续多次调用subscribeOn()，结果会被最上面的subscribeOn()覆盖。（生成和消费都会被覆盖）</strong></p>
<p>observeOn函数源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(</span><br><span class="line">        <span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上代码都很熟悉了，暂不赘述</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableObserveOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler; <span class="comment">// 线程调度器</span></span><br><span class="line">        <span class="keyword">this</span>.delayError = delayError; <span class="comment">// 出现错误是否立刻中断线程</span></span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;   <span class="comment">//缓冲区大小，默认128</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            <span class="comment">// 默认线程则不做线程调度，直接在当前线程中调用</span></span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">            source.subscribe(</span><br><span class="line">                <span class="comment">// 用Worker、和相关参数装饰observer，得到新的Observer注入上游</span></span><br><span class="line">                <span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.s = s;</span><br><span class="line">                <span class="comment">//省略部分代码，创建缓冲队列</span></span><br><span class="line">                queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line">                actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        queue.offer(t); <span class="comment">//上游的数据全部先入队列</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行调度</span></span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队列如果已经空了，则再次调度</span></span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Fused 熔断机制，默认false</span></span><br><span class="line">        <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">            drainFused();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drainNormal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该函数在Runnable所在的线程执行，从缓冲队列里拿出事件，向下游发射</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了errorDelay，则不管队列是否为空，发生了错误都会中断发射，并调用observer的onError</span></span><br><span class="line">            <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> d = done;</span><br><span class="line">                T v;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    v = q.poll();   <span class="comment">//队列中取数据</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    Exceptions.throwIfFatal(ex);</span><br><span class="line">                    s.dispose();</span><br><span class="line">                    q.clear();</span><br><span class="line">                    a.onError(ex);</span><br><span class="line">                    worker.dispose();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向下游发射数据</span></span><br><span class="line">                a.onNext(v);</span><br><span class="line">            &#125;</span><br><span class="line">            missed = addAndGet(-missed);</span><br><span class="line">            <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>observeOn()的工作原理是把消费结果先缓存，再切换到新线程上让原始消费者消费，它和生产者是没有一点关系的，就算subscribeOn()调用了，也只是改变observeOn()这个消费者所在的线程，和OperatorObserveOn中存储的原始消费者一点关系都没有，它还是由observeOn()控制。</strong></p>
<h6 id="四、更多阅读"><a href="#四、更多阅读" class="headerlink" title="四、更多阅读"></a>四、更多阅读</h6><ol>
<li><a href="http://www.pianshen.com/article/4401252533/" target="_blank" rel="noopener">RxJava 原理篇</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/JDK%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20%E2%80%94%E2%80%94%20Boolean%E3%80%81Byte/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/JDK%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20%E2%80%94%E2%80%94%20Boolean%E3%80%81Byte/" class="post-title-link" itemprop="url">JDK 源码解析 —— Boolean、Byte</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 22:21:39" itemprop="dateCreated datePublished" datetime="2020-05-30T22:21:39+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先我们来简单的了解一下，基础数据类型的数值范围，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2169292-b6ade8cee55fa85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基础数据类型的数值范围"></p>
<p><strong>Boolean 类型定义如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class Boolean implements java.io.Serializable,</span><br><span class="line">                                      Comparable&lt;Boolean&gt; &#123;</span><br><span class="line">    public static final Boolean TRUE &#x3D; new Boolean(true);</span><br><span class="line">    public static final Boolean FALSE &#x3D; new Boolean(false);</span><br><span class="line">    public static final Class&lt;Boolean&gt; TYPE &#x3D; </span><br><span class="line">                                (Class&lt;Boolean&gt;)Class.getPrimitiveClass(&quot;boolean&quot;);</span><br><span class="line">    private final boolean value;</span><br><span class="line"></span><br><span class="line">    public Boolean(boolean value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean parseBoolean(String s) &#123;</span><br><span class="line">        return ((s !&#x3D; null) &amp;&amp; s.equalsIgnoreCase(&quot;true&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">        return (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java的基本数据类型中，boolean只有两种状态，默认值为false.取值范围是{true,false}，理论上占1bit，实际上：</p>
<ul>
<li><p>1.单个的boolean 类型变量在编译的时候是使用的int 类型。</p>
<blockquote>
<p>boolean a=true;//这个a在JVM中占4个字节即：32位。</p>
</blockquote>
</li>
<li><p>2.boolean 类型的数组时，在编译的时候是作为byte array来编译的所以boolean 数组里面的每一个元件占一个字节，</p>
<blockquote>
<p>boolean[] b = new boolean[10];//数组时，每一个boolean在JVM中占一个字节。</p>
</blockquote>
</li>
</ul>
<p><strong>Byte定义如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class Byte extends Number implements Comparable&lt;Byte&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static final byte   MIN_VALUE &#x3D; -128;</span><br><span class="line">    public static final byte   MAX_VALUE &#x3D; 127;</span><br><span class="line"></span><br><span class="line">    public static String toString(byte b) &#123;</span><br><span class="line">        return Integer.toString((int)b, 10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ByteCache &#123;</span><br><span class="line">        private ByteCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        static final Byte cache[] &#x3D; new Byte[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; cache.length; I++)</span><br><span class="line">                cache[i] &#x3D; new Byte((byte)(i - 128));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Byte valueOf(byte b) &#123;</span><br><span class="line">        final int offset &#x3D; 128;</span><br><span class="line">        return ByteCache.cache[(int)b + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Byte对象中也有一个private final的byte的属性。byte的取值范围为-128-127.在Byte中有一个内部类是ByteCache,用来缓存byte的数据,所以对于byte类型赋值,JVM不会再开辟空间，如果byte类型采用new关键字创建对象JVM会在堆区产生对象,byte可以转换成short,int,long,float,double,toString.其中有parseByte(String),parseByte(String,radix)方法，可以将其他进制的字符串,转换成十进制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/29%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/29%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">29 应用程序返回按键执行流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。<br>android系统的事件分发流程分为很多部分：</p>
<ul>
<li>Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层</li>
</ul>
<p>所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。</p>
<p><strong>在Native层android系统的事件流程：</strong></p>
<ul>
<li><p>Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。</p>
</li>
<li><p>在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。</p>
</li>
<li><p>将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。</p>
</li>
<li><p>Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。</p>
</li>
<li><p>Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。</p>
</li>
</ul>
<p>可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。</p>
<p><strong>在ViewRootImpl层android系统的事件流程</strong></p>
<p>在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">        onInputEventFinished(seq, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final class ImeInputEventSender extends InputEventSender &#123;</span><br><span class="line">        public ImeInputEventSender(InputChannel inputChannel, Looper looper) &#123;</span><br><span class="line">            super(inputChannel, looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">            finishedInputEvent(seq, handled, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void finishedInputEvent(int seq, boolean handled, boolean timeout) &#123;</span><br><span class="line">        final PendingEvent p;</span><br><span class="line">        synchronized (mH) &#123;</span><br><span class="line">            int index &#x3D; mPendingEvents.indexOfKey(seq);</span><br><span class="line">            if (index &lt; 0) &#123;</span><br><span class="line">                return; &#x2F;&#x2F; spurious, event already finished or timed out</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p &#x3D; mPendingEvents.valueAt(index);</span><br><span class="line">            mPendingEvents.removeAt(index);</span><br><span class="line">            Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size());</span><br><span class="line"></span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Timeout waiting for IME to handle input event after &quot;</span><br><span class="line">                        + INPUT_METHOD_NOT_RESPONDING_TIMEOUT + &quot; ms: &quot; + p.mInputMethodId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mH.removeMessages(MSG_TIMEOUT_INPUT_EVENT, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invokeFinishedInputEventCallback(p, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法finishedInputEvent中，经过一系列的处理之后最终调用的是invokeFinishedInputEventCallback方法，所以我们继续看一下invokeFinishedInputEventCallback方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void invokeFinishedInputEventCallback(PendingEvent p, boolean handled) &#123;</span><br><span class="line">        p.mHandled &#x3D; handled;</span><br><span class="line">        if (p.mHandler.getLooper().isCurrentThread()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Already running on the callback handler thread so we can send the</span><br><span class="line">            &#x2F;&#x2F; callback immediately.</span><br><span class="line">            p.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Post the event to the callback handler thread.</span><br><span class="line">            &#x2F;&#x2F; In this case, the callback will be responsible for recycling the event.</span><br><span class="line">            Message msg &#x3D; Message.obtain(p.mHandler, p);</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">            msg.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里我们首先判断PendingEvent的mHandler所在的线程是否是当前线程，若是的话则直接调用p.run方法，若不是的话则发送一个异步消息，而异步消息最终也是执行的p.run方法，所以我们继续看一下PendingEvent的run方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            mCallback.onFinishedInputEvent(mToken, mHandled);</span><br><span class="line"></span><br><span class="line">            synchronized (mH) &#123;</span><br><span class="line">                recyclePendingEventLocked(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在run方法中我们调用了mCallback的onFinishedInputEvent方法，需要说明的是这里的mCallback就是我们ViewRootImpl中的ImeInputStage类对象，而这里的ViewRootImpl对象就是我们的系统当前界面，前面我们分析Activity的加载绘制流程的时候知道Activity中保存了一个Window对象用于表示窗口信息，而Window对象内部就是通过ViewRootImpl对象实现窗口的加载绘制，所以这里的mCallback对象就是我们当前的App获取焦点的窗口的ViewRootImpl中的ImeInputStage对象，然后我们看一下该对象的onFinishedInputEvent方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final class ImeInputStage extends AsyncInputStage</span><br><span class="line">            implements InputMethodManager.FinishedInputEventCallback &#123;</span><br><span class="line">        ...</span><br><span class="line">        @Override</span><br><span class="line">        public void onFinishedInputEvent(Object token, boolean handled) &#123;</span><br><span class="line">            QueuedInputEvent q &#x3D; (QueuedInputEvent)token;</span><br><span class="line">            if (handled) &#123;</span><br><span class="line">                finish(q, true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            forward(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样经过一系列的调用之后我们消息的处理逻辑上传至了ViewRootImpl中，而在ViewRootImpl中经过一些列的调用之后我们ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4152)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4114)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3807)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3864)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3840)</span><br><span class="line">at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4006)</span><br><span class="line">at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2272)</span><br><span class="line">at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1893)</span><br><span class="line">at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1884)</span><br><span class="line">at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2249)</span><br><span class="line">at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141)</span><br></pre></td></tr></table></figure>
<p>这是通过异常信息打印的堆栈信息，从中我们可以看到在ViewRootImpl中我们经过一系列的调用之后最终执行的是：ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法，这样我们继续看一下processKeyEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int processKeyEvent(QueuedInputEvent q) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; Deliver the key to the view hierarchy.</span><br><span class="line">            if (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">                return FINISH_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">			...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了mView的dispatchKeyEvent方法，而我们分析过Activity窗口加载绘制流程，从中我们知道ViewRootImpl中的mView对象就是我们PhoneWindow中的mDecorView对象（DecorView），所以经过层层调用我们最终执行到了DecorView层。</p>
<p><strong>在DecorView层android系统的事件流程</strong></p>
<p>从上面我们知道在ViewRootImpl中我们最终调用了mView.dispatchKeyEvent方法，即执行的是PhoneWindow%DecorView.dispatchKeyEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int action &#x3D; event.getAction();</span><br><span class="line">            final boolean isDown &#x3D; action &#x3D;&#x3D; KeyEvent.ACTION_DOWN;</span><br><span class="line"></span><br><span class="line">            if (isDown &amp;&amp; (event.getRepeatCount() &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">                &#x2F;&#x2F; First handle chording of panel key: if a panel key is held</span><br><span class="line">                &#x2F;&#x2F; but not released, try to execute a shortcut in it.</span><br><span class="line">                if ((mPanelChordingKey &gt; 0) &amp;&amp; (mPanelChordingKey !&#x3D; keyCode)) &#123;</span><br><span class="line">                    boolean handled &#x3D; dispatchKeyShortcutEvent(event);</span><br><span class="line">                    if (handled) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; If a panel is open, perform a shortcut on it without the</span><br><span class="line">                &#x2F;&#x2F; chorded panel key</span><br><span class="line">                if ((mPreparedPanel !&#x3D; null) &amp;&amp; mPreparedPanel.isOpen) &#123;</span><br><span class="line">                    if (performPanelShortcut(mPreparedPanel, keyCode, event, 0)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!isDestroyed()) &#123;</span><br><span class="line">                final Callback cb &#x3D; getCallback();</span><br><span class="line">                final boolean handled &#x3D; cb !&#x3D; null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event)</span><br><span class="line">                        : super.dispatchKeyEvent(event);</span><br><span class="line">                if (handled) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">                    : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从中我们可以看到如果当前的PhoneWindow不是destroy庄则，则执行cb.dispatchKeyEvent方法，而这里的callback对象就是我们的Activity对象，所以这里最终会执行到Activity的dispatchKeyEvent方法。。。</p>
<p><strong>在Activity层android系统的事件流程</strong></p>
<p>所以我们这里继续看一下Actiivty中的dispatchKeyEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Let action bars open menus in response to the menu key prioritized over</span><br><span class="line">        &#x2F;&#x2F; the window handling it</span><br><span class="line">        if (event.getKeyCode() &#x3D;&#x3D; KeyEvent.KEYCODE_MENU &amp;&amp;</span><br><span class="line">                mActionBar !&#x3D; null &amp;&amp; mActionBar.onMenuKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Window win &#x3D; getWindow();</span><br><span class="line">        if (win.superDispatchKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        View decor &#x3D; mDecor;</span><br><span class="line">        if (decor &#x3D;&#x3D; null) decor &#x3D; win.getDecorView();</span><br><span class="line">        return event.dispatch(this, decor !&#x3D; null</span><br><span class="line">                ? decor.getKeyDispatcherState() : null, this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从中我们可以看到我们首先调用了Activity的window对象的superDispatchKeyEvent方法，而这个方法就是将处理方法下发带Activity中的View，而这里我们分析的是返回按键，显然的View层是无法处理这里的返回按键的，所以win.superDispatchKeyEvent方法返回的是false，所以最终我们执行的是event.dispatch方法。这样我们继续看一下event.dispatch方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final boolean dispatch(Callback receiver, DispatcherState state,</span><br><span class="line">            Object target) &#123;</span><br><span class="line">        switch (mAction) &#123;</span><br><span class="line">            ...</span><br><span class="line">            case ACTION_UP:</span><br><span class="line">                if (DEBUG) Log.v(TAG, &quot;Key up to &quot; + target + &quot; in &quot; + state</span><br><span class="line">                        + &quot;: &quot; + this);</span><br><span class="line">                if (state !&#x3D; null) &#123;</span><br><span class="line">                    state.handleUpEvent(this);</span><br><span class="line">                &#125;</span><br><span class="line">                return receiver.onKeyUp(mKeyCode, this);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们暂时分析一下ACTION_UP事件，可以发现这里最终调用的是receiver.onKeyUp方法，而这里的receiver就是我们的Actiivty，所以这里又回到了Activity并且执行其onKeyUp方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean onKeyUp(int keyCode, KeyEvent event) &#123;</span><br><span class="line">        if (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;&#x3D; Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">            if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking()</span><br><span class="line">                    &amp;&amp; !event.isCanceled()) &#123;</span><br><span class="line">                onBackPressed();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看onKeyUp方法，我们可以发现当我们按的是返回按键时，其回调了onBackPressed方法，所以我们继续看一下onBackPressed方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onBackPressed() &#123;</span><br><span class="line">        if (mActionBar !&#x3D; null &amp;&amp; mActionBar.collapseActionView()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mFragments.getFragmentManager().popBackStackImmediate()) &#123;</span><br><span class="line">            finishAfterTransition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在onBackPressed方法中，我们最终调用的是finishAfterTransition方法，所以继续看一下这个方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void finishAfterTransition() &#123;</span><br><span class="line">        if (!mActivityTransitionState.startExitBackTransition(this)) &#123;</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，原来finish方法是在这里调用的，这样我们按下返回按键并抬起之后，经过层层的调用之后最终调用了我们的finish方法，而这个方法就是finish掉Activity的方法，也就解释了我们在App中默认按下返回按键之后Acitivty会被销毁了。</p>
<p>总结：</p>
<ul>
<li><p>本文中由于是分析的返回按键的处理流程，所以事件的分发流程没有做说明，下面的文章中会着重介绍Android的事件分发流程；</p>
</li>
<li><p>事件分发流程从Native –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层都是类似的，无论是按键分发流程还是触摸事件分发流程</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
