<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/24%20onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/24%20onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/" class="post-title-link" itemprop="url">24 onSaveInstanceState执行时机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。<br>可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍：</p>
<blockquote>
<p>This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state.  For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}.</p>
</blockquote>
<p>可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。</p>
<p>通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。</p>
<p>Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考:<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener"> android源码解析之（十四）–&gt;Activity启动流程</a>，文章中有对Activity生命周期的详细讲解。</p>
<p>好吧，先具体看一下ActivityThread.handlePauseActivity的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;Slog.v(TAG, &quot;userLeaving&#x3D;&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        return r !&#x3D; null ? performPauseActivity(r, finished, saveState) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(ActivityClientRecord r, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">            callCallActivityOnSaveInstanceState(r);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里调用了callCallActivityOnSaveInstanceState方法，看名称可以发现这里应该回调的是Activity的onSaveInstanceState方法，但是这里执行之前有一个条件判断，首先会判断这里的Activity是否被finish？应为这时候刚刚执行onPause方法所以这里的mFinished变量为false，所以判断执行callCallActivityOnSaveInstanceState方法只要需要通过saveState变量来判断了，而这里的saveState方法是performPauseActivity方法传递过来的。。。。好吧，我们来看一下调用performPauseActivity方法时saveState变量是如何赋值的。回到我们的handlePauseActivity方法，看一下performPauseActivity方法是如何调用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performPauseActivity(token, finished, r.isPreHoneycomb());</span><br></pre></td></tr></table></figure>
<p>可以发现saveState boolean变量是通过r.isPreHoneycomb方法赋值的，这里我们看一下IsPreHoneycomb方法是如何实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPreHoneycomb() &#123;</span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                return activity.getApplicationInfo().targetSdkVersion</span><br><span class="line">                        &lt; android.os.Build.VERSION_CODES.HONEYCOMB;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现当我们的App设置的targetSdk版本号小于android versionCode 11也就是android3.0的时候返回为true，其他的时候返回为false，也就是说当我们App设置的targetVersion大于android3.0的时候才会执行callCallActivityOnSaveInstanceState方法，好吧，继续看一下callCallActivityOnSaveInstanceState方法是如何实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123;</span><br><span class="line">        r.state &#x3D; new Bundle();</span><br><span class="line">        r.state.setAllowFds(false);</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">            r.persistentState &#x3D; new PersistableBundle();</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现方法体主要调用了mInstrumentation的callActivityOnSaveInstanceState方法，既然这样，我们再来看一下callActivityOnSaveInstanceState方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnSaveInstanceState(Activity activity, Bundle outState,</span><br><span class="line">            PersistableBundle outPersistentState) &#123;</span><br><span class="line">        activity.performSaveInstanceState(outState, outPersistentState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里方法体中又回调了Activity的performSaveInstanceState方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void performSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">        onSaveInstanceState(outState);</span><br><span class="line">        saveManagedDialogs(outState);</span><br><span class="line">        mActivityTransitionState.saveState(outState);</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里回调了Activity的onSaveInstanceState方法，这样经过一系列的方法回调之后我们就执行了onSaveInstanceState方法。</p>
<p>这样我们当只执行onPause方法的时候一般通过设置targetVersion控制是否执行onSaveInstanceState方法，当设置的targetVersionCode大于android3.0的时候默认不会执行onSaveInstanceState方法。</p>
<p>然后我们看一下当Activity执行onStop方法的时候是否会执行onSaveInstanceState方法，通过之前分析的Activity的启动流程，我们知道Actvitiy执行onStop方法会回调ActivityThread的handleStopActivity，这样我们先看一下handleStopActivity方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopActivity(IBinder token, boolean show, int configChanges) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line"></span><br><span class="line">        StopInfo info &#x3D; new StopInfo();</span><br><span class="line">        performStopActivityInner(r, info, show, true);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">            TAG, &quot;Finishing stop of &quot; + r + &quot;: show&#x3D;&quot; + show</span><br><span class="line">            + &quot; win&#x3D;&quot; + r.window);</span><br><span class="line"></span><br><span class="line">        updateVisibility(r, show);</span><br><span class="line"></span><br><span class="line">        info.activity &#x3D; r;</span><br><span class="line">        info.state &#x3D; r.state;</span><br><span class="line">        info.persistentState &#x3D; r.persistentState;</span><br><span class="line">        mH.post(info);</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们发现在方法performStopActivity方法中调用了performStopActivityInner方法，我们继续看一下performStopActivityInner方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void performStopActivityInner(ActivityClientRecord r,</span><br><span class="line">            StopInfo info, boolean keepShown, boolean saveState) &#123;</span><br><span class="line">        ...</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">                if (r.state &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    callCallActivityOnSaveInstanceState(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现还是通过saveState变量来控制是否调用onSaveInstanceState，而这里的saveState变量是在performStopActivityInner方法调用的时候传递的，回到我们的handleStopActivity方法中关于performStopActivityInner调用的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performStopActivityInner(r, info, show, true);</span><br></pre></td></tr></table></figure>
<p>好吧，这里直接传值为true，这样我们执行Activity的stop方法一定执行onSaveInstanceState方法。</p>
<p>总结</p>
<ul>
<li><p>onSaveInstanceState方法是Activity的生命周期方法，主要用于在Activity销毁时保存一些信息。</p>
</li>
<li><p>当Activity只执行onPause方法时（Activity a打开一个透明Activity b）这时候如果App设置的targetVersion大于android3.0则不会执行onSaveInstanceState方法。</p>
</li>
<li><p>当Activity执行onStop方法时，通过分析源码我们知道调用onSaveInstanceState的方法直接传值为true，所以都会执行onSaveInstanceState方法。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/23%20Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/23%20Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">23 Android异常处理流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面的几篇文章都是讲解的android中的窗口显示机制，包括Activity窗口加载绘制流程，Dialog窗口加载绘制流程，PopupWindow窗口加载绘制流程，Toast窗口加载绘制流程等等。整个Android的界面显示的原理都是类似的，都是通过Window对象控制View组件，实现加载与绘制流程。</p>
<p>这篇文章休息一下，不在讲解Android的窗口绘制机制，穿插的讲解一下Android系统的异常处理流程。O(∩_∩)O哈哈~</p>
<p>开发过android项目的童鞋对android系统中错误弹窗，force close应该不陌生了，当我们的App异常崩溃时，就会弹出一个force close的弹窗，告诉我们App崩溃，以及一下简易的错误信息：<br><img src="http://img.blog.csdn.net/20160512110851449" alt="这里写图片描述"></p>
<p>那么这里的force close弹窗是如何弹出的呢？</p>
<p>还有我们在开发App的过程中，经常会自定义Application，自定义UncaughtExceptionHandler实现App的全局异常处理，那么这里的UncaughtExceptionHandler是如何实现对异常的全局处理的呢？（可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/41725069" target="_blank" rel="noopener"> 在Android中自定义捕获Application全局异常</a>）</p>
<p>带着这两个问题，我们开始今天的异常流程分析。</p>
<p>在android应用进程的启动流程中我们在经过一系列的操作之后会调用RuntimeInit.zygoteInit方法（可参考：<a href="http://blog.csdn.net/luoshengyang/article/details/6747696" target="_blank" rel="noopener">Android应用程序进程启动过程的源代码分析</a>）</p>
<p>而我们也是从这里开始分析我们的Android系统异常处理流程，好了，让我们先来看一下zygoteInit方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;);</span><br><span class="line">        redirectLogStreams();</span><br><span class="line"></span><br><span class="line">        commonInit();</span><br><span class="line">        nativeZygoteInit();</span><br><span class="line">        applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中我们调用了commonInit方法，这个方法是用于初始化操作的，继续看一下commonInit方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final void commonInit() &#123;</span><br><span class="line">        ...</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在这里我们调用了Thread.setDefaultUncaughtExceptionHandler方法，这样当我们的进程出现异常的时候，异常信息就会被我们新创建的UncaughtHandler所捕获。</p>
<p>看过我们前面写过的关于Android全局异常处理文章的童鞋应该知道，我们实现对Android异常全局处理的操作也是通过设置Thread.setDefaultUncaughtExceptionHandler来实现的，具体可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/41725069" target="_blank" rel="noopener"> 在Android中自定义捕获Application全局异常</a><br>所以Android系统默认的异常信息都会被这里的UncaughtHandler所捕获并被其uncaughtException方法回调，所以若我们不重写Thread.setDefaultUncaughtExceptionHandler方法，那么这里的UncaughtHandler就是我们默认的异常处理操作 这样我们看一下UncaughtHandler的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static class UncaughtHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">        public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t re-enter -- avoid infinite loops if crash-reporting crashes.</span><br><span class="line">                if (mCrashing) return;</span><br><span class="line">                mCrashing &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (mApplicationObject &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    Clog_e(TAG, &quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot; + t.getName(), e);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    StringBuilder message &#x3D; new StringBuilder();</span><br><span class="line">                    message.append(&quot;FATAL EXCEPTION: &quot;).append(t.getName()).append(&quot;\n&quot;);</span><br><span class="line">                    final String processName &#x3D; ActivityThread.currentProcessName();</span><br><span class="line">                    if (processName !&#x3D; null) &#123;</span><br><span class="line">                        message.append(&quot;Process: &quot;).append(processName).append(&quot;, &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    message.append(&quot;PID: &quot;).append(Process.myPid());</span><br><span class="line">                    Clog_e(TAG, message.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Bring up crash dialog, wait for it to be dismissed</span><br><span class="line">                ActivityManagerNative.getDefault().handleApplicationCrash(</span><br><span class="line">                        mApplicationObject, new ApplicationErrorReport.CrashInfo(e));</span><br><span class="line">            &#125; catch (Throwable t2) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Clog_e(TAG, &quot;Error reporting crash&quot;, t2);</span><br><span class="line">                &#125; catch (Throwable t3) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Even Clog_e() fails!  Oh well.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; Try everything to make sure this process goes away.</span><br><span class="line">                Process.killProcess(Process.myPid());</span><br><span class="line">                System.exit(10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里uncaughtException方法最终会被执行异常信息的处理，我们看一下在这里我们调用了ActivityManagerNative.getDefault().handleApplicationCrash方法，看过我们前面Activity启动流程的童鞋应该知道这里的ActivityManagerNative其实是ActivityManagerService的Binder客户端，而这里的handleApplicationCrash方法最终会调用的是ActivityManagerService的handleApplicationCrash方法。最后在finally分之中，我们调用了Process.killProcess(Process.myPid)和System.exit(10)，这样我们的应用进程就会退出了。</p>
<p>然后我们在这里先简单的分析一下Binder的数据传输过程，看一下handleApplicationCrash方法具体做了哪些事，首先看一下ActivityManagerNative的getDefault方法是如何实现的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">        return gDefault.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，其是一个静态方法，并执行了gDefault.get方法，我们在看一下gDefault.get方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        protected IActivityManager create() &#123;</span><br><span class="line">            IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder &#x3D; &quot; + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am &#x3D; asInterface(b);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service &#x3D; &quot; + am);</span><br><span class="line">            &#125;</span><br><span class="line">            return am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现这里返回一个IActivityManager类型的am对象，而这个am对象是通过调用asInterface方法创建的，我们再来看一下这个asInterface方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager in &#x3D;</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现该方法最终返回的是一个ActivityManagerProxy对象，所以ActivityManagerNative.getDefault()方法最终返回的是一个ActivityManagerProxy对象，我们再来看一下ActivityManagerProxy的handleApplicationCrash方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void handleApplicationCrash(IBinder app,</span><br><span class="line">            ApplicationErrorReport.CrashInfo crashInfo) throws RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(app);</span><br><span class="line">        crashInfo.writeToParcel(data, 0);</span><br><span class="line">        mRemote.transact(HANDLE_APPLICATION_CRASH_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.readException();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是具体的Binder传输数据的逻辑了，这里ActivityManagerNative最为Binder的clent端，而我们的ActivityManagerService同样是继承与ActivityManagerNative，最为Binder的server端，通过传输最终ActivityManagerService的handleApplicationCrash方法会被执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        ProcessRecord r &#x3D; findAppProcess(app, &quot;Crash&quot;);</span><br><span class="line">        final String processName &#x3D; app &#x3D;&#x3D; null ? &quot;system_server&quot;</span><br><span class="line">                : (r &#x3D;&#x3D; null ? &quot;unknown&quot; : r.processName);</span><br><span class="line"></span><br><span class="line">        handleApplicationCrashInner(&quot;crash&quot;, r, processName, crashInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ActivityManagerService的handleApplicationCrash方法中我们调用了handleApplicationCreashInner方法，这样我们继续看一下handleApplicationCrashInner方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName,</span><br><span class="line">            ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(),</span><br><span class="line">                UserHandle.getUserId(Binder.getCallingUid()), processName,</span><br><span class="line">                r &#x3D;&#x3D; null ? -1 : r.info.flags,</span><br><span class="line">                crashInfo.exceptionClassName,</span><br><span class="line">                crashInfo.exceptionMessage,</span><br><span class="line">                crashInfo.throwFileName,</span><br><span class="line">                crashInfo.throwLineNumber);</span><br><span class="line"></span><br><span class="line">        addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);</span><br><span class="line"></span><br><span class="line">        crashApplication(r, crashInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在handleApplicationCrashInner方法中主要调用了两个方法addErrorToDropBox和crashApplication，我们首先看一下addErrorToDropBox方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">public void addErrorToDropBox(String eventType,</span><br><span class="line">            ProcessRecord process, String processName, ActivityRecord activity,</span><br><span class="line">            ActivityRecord parent, String subject,</span><br><span class="line">            final String report, final File logFile,</span><br><span class="line">            final ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        &#x2F;&#x2F; NOTE -- this must never acquire the ActivityManagerService lock,</span><br><span class="line">        &#x2F;&#x2F; otherwise the watchdog may be prevented from resetting the system.</span><br><span class="line"></span><br><span class="line">        final String dropboxTag &#x3D; processClass(process) + &quot;_&quot; + eventType;</span><br><span class="line">        final DropBoxManager dbox &#x3D; (DropBoxManager)</span><br><span class="line">                mContext.getSystemService(Context.DROPBOX_SERVICE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Exit early if the dropbox isn&#39;t configured to accept this report type.</span><br><span class="line">        if (dbox &#x3D;&#x3D; null || !dbox.isTagEnabled(dropboxTag)) return;</span><br><span class="line"></span><br><span class="line">        final StringBuilder sb &#x3D; new StringBuilder(1024);</span><br><span class="line">        appendDropBoxProcessHeaders(process, processName, sb);</span><br><span class="line">        if (activity !&#x3D; null) &#123;</span><br><span class="line">            sb.append(&quot;Activity: &quot;).append(activity.shortComponentName).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent !&#x3D; null &amp;&amp; parent.app !&#x3D; null &amp;&amp; parent.app.pid !&#x3D; process.pid) &#123;</span><br><span class="line">            sb.append(&quot;Parent-Process: &quot;).append(parent.app.processName).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent !&#x3D; null &amp;&amp; parent !&#x3D; activity) &#123;</span><br><span class="line">            sb.append(&quot;Parent-Activity: &quot;).append(parent.shortComponentName).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subject !&#x3D; null) &#123;</span><br><span class="line">            sb.append(&quot;Subject: &quot;).append(subject).append(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;Build: &quot;).append(Build.FINGERPRINT).append(&quot;\n&quot;);</span><br><span class="line">        if (Debug.isDebuggerConnected()) &#123;</span><br><span class="line">            sb.append(&quot;Debugger: Connected\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Do the rest in a worker thread to avoid blocking the caller on I&#x2F;O</span><br><span class="line">        &#x2F;&#x2F; (After this point, we shouldn&#39;t access AMS internal data structures.)</span><br><span class="line">        Thread worker &#x3D; new Thread(&quot;Error dump: &quot; + dropboxTag) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if (report !&#x3D; null) &#123;</span><br><span class="line">                    sb.append(report);</span><br><span class="line">                &#125;</span><br><span class="line">                if (logFile !&#x3D; null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        sb.append(FileUtils.readTextFile(logFile, DROPBOX_MAX_SIZE,</span><br><span class="line">                                    &quot;\n\n[[TRUNCATED]]&quot;));</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        Slog.e(TAG, &quot;Error reading &quot; + logFile, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (crashInfo !&#x3D; null &amp;&amp; crashInfo.stackTrace !&#x3D; null) &#123;</span><br><span class="line">                    sb.append(crashInfo.stackTrace);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String setting &#x3D; Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag;</span><br><span class="line">                int lines &#x3D; Settings.Global.getInt(mContext.getContentResolver(), setting, 0);</span><br><span class="line">                if (lines &gt; 0) &#123;</span><br><span class="line">                    sb.append(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Merge several logcat streams, and take the last N lines</span><br><span class="line">                    InputStreamReader input &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        java.lang.Process logcat &#x3D; new ProcessBuilder(&quot;&#x2F;system&#x2F;bin&#x2F;logcat&quot;,</span><br><span class="line">                                &quot;-v&quot;, &quot;time&quot;, &quot;-b&quot;, &quot;events&quot;, &quot;-b&quot;, &quot;system&quot;, &quot;-b&quot;, &quot;main&quot;,</span><br><span class="line">                                &quot;-b&quot;, &quot;crash&quot;,</span><br><span class="line">                                &quot;-t&quot;, String.valueOf(lines)).redirectErrorStream(true).start();</span><br><span class="line"></span><br><span class="line">                        try &#123; logcat.getOutputStream().close(); &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">                        try &#123; logcat.getErrorStream().close(); &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">                        input &#x3D; new InputStreamReader(logcat.getInputStream());</span><br><span class="line"></span><br><span class="line">                        int num;</span><br><span class="line">                        char[] buf &#x3D; new char[8192];</span><br><span class="line">                        while ((num &#x3D; input.read(buf)) &gt; 0) sb.append(buf, 0, num);</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        Slog.e(TAG, &quot;Error running logcat&quot;, e);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        if (input !&#x3D; null) try &#123; input.close(); &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dbox.addText(dropboxTag, sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (process &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; If process is null, we are being called from some internal code</span><br><span class="line">            &#x2F;&#x2F; and may be about to die -- run this synchronously.</span><br><span class="line">            worker.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体很长，但是逻辑比较简单，在方法体最后通过判断应用进程是否为空（是否被销毁）来执行worker.run方法或者是worker.start方法，这里的worker是一个Thread对象，而在我们的worker对象的run方法中主要的执行逻辑就是将崩溃信息写入系统log中，所以addErrorToDropBox方法的主要执行逻辑就是讲App的崩溃信息写入系统log中。。。。</p>
<p>继续回到我们的handleApplicationCrashInner方法中，看一下crashApplication方法是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">private void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) &#123;</span><br><span class="line">        long timeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">        String shortMsg &#x3D; crashInfo.exceptionClassName;</span><br><span class="line">        String longMsg &#x3D; crashInfo.exceptionMessage;</span><br><span class="line">        String stackTrace &#x3D; crashInfo.stackTrace;</span><br><span class="line">        if (shortMsg !&#x3D; null &amp;&amp; longMsg !&#x3D; null) &#123;</span><br><span class="line">            longMsg &#x3D; shortMsg + &quot;: &quot; + longMsg;</span><br><span class="line">        &#125; else if (shortMsg !&#x3D; null) &#123;</span><br><span class="line">            longMsg &#x3D; shortMsg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AppErrorResult result &#x3D; new AppErrorResult();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mController !&#x3D; null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    String name &#x3D; r !&#x3D; null ? r.processName : null;</span><br><span class="line">                    int pid &#x3D; r !&#x3D; null ? r.pid : Binder.getCallingPid();</span><br><span class="line">                    int uid &#x3D; r !&#x3D; null ? r.info.uid : Binder.getCallingUid();</span><br><span class="line">                    if (!mController.appCrashed(name, pid,</span><br><span class="line">                            shortMsg, longMsg, timeMillis, crashInfo.stackTrace)) &#123;</span><br><span class="line">                        if (&quot;1&quot;.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, &quot;0&quot;))</span><br><span class="line">                                &amp;&amp; &quot;Native crash&quot;.equals(crashInfo.exceptionClassName)) &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Skip killing native crashed app &quot; + name</span><br><span class="line">                                    + &quot;(&quot; + pid + &quot;) during testing&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Force-killing crashed app &quot; + name</span><br><span class="line">                                    + &quot; at watcher&#39;s request&quot;);</span><br><span class="line">                            if (r !&#x3D; null) &#123;</span><br><span class="line">                                r.kill(&quot;crash&quot;, true);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                &#x2F;&#x2F; Huh.</span><br><span class="line">                                Process.killProcess(pid);</span><br><span class="line">                                killProcessGroup(uid, pid);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    mController &#x3D; null;</span><br><span class="line">                    Watchdog.getInstance().setActivityController(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If this process is running instrumentation, finish it.</span><br><span class="line">            if (r !&#x3D; null &amp;&amp; r.instrumentationClass !&#x3D; null) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Error in app &quot; + r.processName</span><br><span class="line">                      + &quot; running instrumentation &quot; + r.instrumentationClass + &quot;:&quot;);</span><br><span class="line">                if (shortMsg !&#x3D; null) Slog.w(TAG, &quot;  &quot; + shortMsg);</span><br><span class="line">                if (longMsg !&#x3D; null) Slog.w(TAG, &quot;  &quot; + longMsg);</span><br><span class="line">                Bundle info &#x3D; new Bundle();</span><br><span class="line">                info.putString(&quot;shortMsg&quot;, shortMsg);</span><br><span class="line">                info.putString(&quot;longMsg&quot;, longMsg);</span><br><span class="line">                finishInstrumentationLocked(r, Activity.RESULT_CANCELED, info);</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Log crash in battery stats.</span><br><span class="line">            if (r !&#x3D; null) &#123;</span><br><span class="line">                mBatteryStatsService.noteProcessCrash(r.processName, r.uid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If we can&#39;t identify the process or it&#39;s already exceeded its crash quota,</span><br><span class="line">            &#x2F;&#x2F; quit right away without showing a crash dialog.</span><br><span class="line">            if (r &#x3D;&#x3D; null || !makeAppCrashingLocked(r, shortMsg, longMsg, stackTrace)) &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Message msg &#x3D; Message.obtain();</span><br><span class="line">            msg.what &#x3D; SHOW_ERROR_MSG;</span><br><span class="line">            HashMap data &#x3D; new HashMap();</span><br><span class="line">            data.put(&quot;result&quot;, result);</span><br><span class="line">            data.put(&quot;app&quot;, r);</span><br><span class="line">            msg.obj &#x3D; data;</span><br><span class="line">            mUiHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int res &#x3D; result.get();</span><br><span class="line"></span><br><span class="line">        Intent appErrorIntent &#x3D; null;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (r !&#x3D; null &amp;&amp; !r.isolated) &#123;</span><br><span class="line">                &#x2F;&#x2F; XXX Can&#39;t keep track of crash time for isolated processes,</span><br><span class="line">                &#x2F;&#x2F; since they don&#39;t have a persistent identity.</span><br><span class="line">                mProcessCrashTimes.put(r.info.processName, r.uid,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            if (res &#x3D;&#x3D; AppErrorDialog.FORCE_QUIT_AND_REPORT) &#123;</span><br><span class="line">                appErrorIntent &#x3D; createAppErrorIntentLocked(r, timeMillis, crashInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (appErrorIntent !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mContext.startActivityAsUser(appErrorIntent, new UserHandle(r.userId));</span><br><span class="line">            &#125; catch (ActivityNotFoundException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;bug report receiver dissappeared&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在方法体中我们调用了mUiHandler.sendMessage(msg)，其中mUiHandler是一个在主线程中创建的Handler对象，而这里的msg是一个what值为SHOW_ERROR_MSG的消息，这句话的本质就是向Ui线程中发送一个异步消息。我们来看一下mUiHander的处理逻辑。</p>
<p>在mUiHandler的handeMessage方法中，根据what值得不同，执行了如下逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">case SHOW_ERROR_MSG: &#123;</span><br><span class="line">                HashMap&lt;String, Object&gt; data &#x3D; (HashMap&lt;String, Object&gt;) msg.obj;</span><br><span class="line">                boolean showBackground &#x3D; Settings.Secure.getInt(mContext.getContentResolver(),</span><br><span class="line">                        Settings.Secure.ANR_SHOW_BACKGROUND, 0) !&#x3D; 0;</span><br><span class="line">                synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                    ProcessRecord proc &#x3D; (ProcessRecord)data.get(&quot;app&quot;);</span><br><span class="line">                    AppErrorResult res &#x3D; (AppErrorResult) data.get(&quot;result&quot;);</span><br><span class="line">                    if (proc !&#x3D; null &amp;&amp; proc.crashDialog !&#x3D; null) &#123;</span><br><span class="line">                        Slog.e(TAG, &quot;App already has crash dialog: &quot; + proc);</span><br><span class="line">                        if (res !&#x3D; null) &#123;</span><br><span class="line">                            res.set(0);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    boolean isBackground &#x3D; (UserHandle.getAppId(proc.uid)</span><br><span class="line">                            &gt;&#x3D; Process.FIRST_APPLICATION_UID</span><br><span class="line">                            &amp;&amp; proc.pid !&#x3D; MY_PID);</span><br><span class="line">                    for (int userId : mCurrentProfileIds) &#123;</span><br><span class="line">                        isBackground &amp;&#x3D; (proc.userId !&#x3D; userId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (isBackground &amp;&amp; !showBackground) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Skipping crash dialog of &quot; + proc + &quot;: background&quot;);</span><br><span class="line">                        if (res !&#x3D; null) &#123;</span><br><span class="line">                            res.set(0);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (mShowDialogs &amp;&amp; !mSleeping &amp;&amp; !mShuttingDown) &#123;</span><br><span class="line">                        Dialog d &#x3D; new AppErrorDialog(mContext,</span><br><span class="line">                                ActivityManagerService.this, res, proc);</span><br><span class="line">                        d.show();</span><br><span class="line">                        proc.crashDialog &#x3D; d;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; The device is asleep, so just pretend that the user</span><br><span class="line">                        &#x2F;&#x2F; saw a crash dialog and hit &quot;force quit&quot;.</span><br><span class="line">                        if (res !&#x3D; null) &#123;</span><br><span class="line">                            res.set(0);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ensureBootCompleted();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中我们创建了一个AppErrorDialog对象，并执行了show方法，这样该Dialog就会被显示出来。而这里的Dialog的显示内容就是：App already has crash dialog: ….</p>
<p>O(∩_∩)O哈哈~，原来我们App崩溃的时候弹出昂的异常提示框就是在这里弹出来的。这里对AppErrorDialog不做过多的介绍，在其的构造方法中，调用了如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; After the timeout, pretend the user clicked the quit button</span><br><span class="line">        mHandler.sendMessageDelayed(</span><br><span class="line">                mHandler.obtainMessage(FORCE_QUIT),</span><br><span class="line">                DISMISS_TIMEOUT);</span><br></pre></td></tr></table></figure>
<p>这里的常量DISMISS_TIME = 5 * 60 * 1000，也就是五分钟，相当于这里发送了一个延时异步消息五分钟之后取消崩溃弹窗的显示。所以我们的App若果崩溃之后不主动取消弹窗，崩溃弹窗也会默认在五分钟之后取消。</p>
<p>好吧，文章开头我们所提到的两个问题我们已经解决掉一个了，force close弹窗是如何弹出来的，相信大家已经有所了解了，其实第二个问题也已经说明了，我们知道系统默认的App异常处理流程就是从Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());开始的，并创建了自己的UncaughtHandler对象，那么我们接管系统默认的异常处理逻辑其实也就是从Thread.setDefaultUncaughtExceptionHandler开始的，并重写其uncaughtException方法，那么App异常信息就会被我们自定义的UncaughtHandler所捕获，捕获之后奔溃信息的记录与上报就可以做定制了。。。</p>
<p>这样我们就大概分析完成了Android系统的异常处理流程。O(∩_∩)O哈哈~</p>
<p>总结：</p>
<ul>
<li><p>App应用进程启动时会经过一系列的调用，执行Thread.setDefaultUncaughtExceptionHandler方法，创建默认的UncaughtHandler异常处理对象。</p>
</li>
<li><p>默认的UncaughtHandler异常处理对象，在其回调方法uncaughtException方法中会执行弹窗异常弹窗的操作，这也就是我们原生的force close弹窗，并且弹窗如果不主动取消的话，会在五分钟内默认取消。</p>
</li>
<li><p>自定义App的全局异常处理逻辑，需要接管UncaughtHandler，也就是创建自身的UncaughtHandler对象，并调用Thread.setDefaultUncaughtExceptionHandler方法，接管默认的异常处理逻辑。</p>
</li>
<li><p>force close弹窗，弹窗的时候App应用可能已经退出，该弹窗的弹窗是SystemServer进程中的ActivityManagerService服务控制的。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/22%20Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/22%20Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">22 Toast加载绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面我们分析了Activity、Dialog、PopupWindow的加载绘制流程，相信大家对整个Android系统中的窗口绘制流程已经有了一个比较清晰的认识了，这里最后再给大家介绍一下Toast的加载绘制流程。</p>
<p>其实Toast窗口和Activity、Dialog、PopupWindow有一个不太一样的地方，就是Toast窗口是属于系统级别的窗口，他和输入框等类似的，不属于某一个应用，即不属于某一个进程，所以自然而然的，一旦涉及到Toast的加载绘制流程就会涉及到进程间通讯，看过前面系列文章的同学应该知道，Android间的进程间通讯采用的是Android特有的Binder机制，所以Toast的加载绘制流程也会涉及到Binder进程间通讯。</p>
<p>Toast的显示流程其实内部还是通过Window的窗口机制实现加载绘制的，只不过由于是系统级别的窗口，在显示过程中涉及到了进程间通讯等机制。</p>
<p>下面我们来具体看一下Toast窗口的简单使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(context, msg, Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure>
<p>上面的代码是Toast的典型使用方式，通过makeText方法创建出一个Toast对象，然后调用show方法将Toast窗口显示出来。</p>
<p>下面我们来看一下makeText方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Toast makeText(Context context, CharSequence text, @Duration int duration) &#123;</span><br><span class="line">        Toast result &#x3D; new Toast(context);</span><br><span class="line"></span><br><span class="line">        LayoutInflater inflate &#x3D; (LayoutInflater)</span><br><span class="line">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        View v &#x3D; inflate.inflate(com.android.internal.R.layout.transient_notification, null);</span><br><span class="line">        TextView tv &#x3D; (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">        tv.setText(text);</span><br><span class="line">        </span><br><span class="line">        result.mNextView &#x3D; v;</span><br><span class="line">        result.mDuration &#x3D; duration;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体不是很长，在makeText方法中，我们首先通过Toast对象的构造方法，创建了一个新的Toast对象，这样我们就先来看一下Toast的构造方法做了哪些事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Toast(Context context) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mTN &#x3D; new TN();</span><br><span class="line">        mTN.mY &#x3D; context.getResources().getDimensionPixelSize(</span><br><span class="line">                com.android.internal.R.dimen.toast_y_offset);</span><br><span class="line">        mTN.mGravity &#x3D; context.getResources().getInteger(</span><br><span class="line">                com.android.internal.R.integer.config_toastDefaultGravity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里初始化了Toast对象的成员变量mContext和mTN，这里的mContext是一个Context类型的成员变量，那mTN是什么东西呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static class TN extends ITransientNotification.Stub</span><br></pre></td></tr></table></figure>
<p>从类的源码定义来看，我们知道TN是一个继承自ITransientNotification.Stub的类，这里我们暂时只用知道他的继承关系就好了，知道其是一个Binder对象，可以用于进程间通讯，然后回到我们的makeText方法，在调用了Toast的构造方法创建了Toast对象之后，我们又通过context.getSystemService方法获取到LayoutInflater，然后通过调用LayoutInflater的inflate方法加载到了Toast的布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflate &#x3D; (LayoutInflater)</span><br><span class="line">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        View v &#x3D; inflate.inflate(com.android.internal.R.layout.transient_notification, null);</span><br></pre></td></tr></table></figure>
<p>这里我们可以看一下布局文件的具体代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">    android:background&#x3D;&quot;?android:attr&#x2F;toastFrameBackground&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@android:id&#x2F;message&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">        android:layout_gravity&#x3D;&quot;center_horizontal&quot;</span><br><span class="line">        android:textAppearance&#x3D;&quot;@style&#x2F;TextAppearance.Toast&quot;</span><br><span class="line">        android:textColor&#x3D;&quot;@color&#x2F;bright_foreground_dark&quot;</span><br><span class="line">        android:shadowColor&#x3D;&quot;#BB000000&quot;</span><br><span class="line">        android:shadowRadius&#x3D;&quot;2.75&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现Toast加载的布局文件只有一个LinearLayout布局，并且只包含一个TextView组件。。。。</p>
<p>然后我们通过调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextView tv &#x3D; (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class="line">        tv.setText(text);</span><br><span class="line">        </span><br><span class="line">        result.mNextView &#x3D; v;</span><br><span class="line">        result.mDuration &#x3D; duration;</span><br><span class="line"></span><br><span class="line">        return result;</span><br></pre></td></tr></table></figure>
<p>初始化了布局文件，Toast的mNextView和mDuration成员变量并返回Toast类型的result对象。这样我们的Toast对象就构造完成了。</p>
<p>然后我们回到我们的Toast.show方法，调用完这个方法之后就准备开始显示Toast窗口了，我们来具体看一下show方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void show() &#123;</span><br><span class="line">        if (mNextView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;setView must have been called&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        INotificationManager service &#x3D; getService();</span><br><span class="line">        String pkg &#x3D; mContext.getOpPackageName();</span><br><span class="line">        TN tn &#x3D; mTN;</span><br><span class="line">        tn.mNextView &#x3D; mNextView;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            service.enqueueToast(pkg, tn, mDuration);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; Empty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断我们的mNextView是否为空，为空的话，显示逻辑就无法进行了，所以这里判断如果mNextView为空的话，就直接抛出异常，不在往下执行。。。。</p>
<p>然后我们执行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INotificationManager service &#x3D; getService();</span><br></pre></td></tr></table></figure>
<p>这里的INotificationManager是服务器端NotificationManagerService的Binder客户端，我们可以看一下getService方法的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static private INotificationManager getService() &#123;</span><br><span class="line">        if (sService !&#x3D; null) &#123;</span><br><span class="line">            return sService;</span><br><span class="line">        &#125;</span><br><span class="line">        sService &#x3D; INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;));</span><br><span class="line">        return sService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里获取了INotificationManager对象，然后我们调用了service.enqueueToast方法，并传递了package，TN对象，duration等参数，这里实际执行的是NotificationManagerService的内部类的INotificationManager.Stub的enqueueToast方法，而我们的NoticationManagerService是在SystemServer进程中执行的，这里的底层其实是通过Binder机制传输数据的，具体的Binder机制相关知识可自行学习。。</p>
<p>好吧，我们在看一下INotificationManager.Stub的enqueueToast方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void enqueueToast(String pkg, ITransientNotification callback, int duration)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            synchronized (mToastQueue) &#123;</span><br><span class="line">                int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">                long callingId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">                try &#123;</span><br><span class="line">                    ToastRecord record;</span><br><span class="line">                    int index &#x3D; indexOfToastLocked(pkg, callback);</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s already in the queue, we update it in place, we don&#39;t</span><br><span class="line">                    &#x2F;&#x2F; move it to the end of the queue.</span><br><span class="line">                    if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                        record &#x3D; mToastQueue.get(index);</span><br><span class="line">                        record.update(duration);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; Limit the number of toasts that any given package except the android</span><br><span class="line">                        &#x2F;&#x2F; package can enqueue.  Prevents DOS attacks and deals with leaks.</span><br><span class="line">                        if (!isSystemToast) &#123;</span><br><span class="line">                            int count &#x3D; 0;</span><br><span class="line">                            final int N &#x3D; mToastQueue.size();</span><br><span class="line">                            for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                                 final ToastRecord r &#x3D; mToastQueue.get(i);</span><br><span class="line">                                 if (r.pkg.equals(pkg)) &#123;</span><br><span class="line">                                     count++;</span><br><span class="line">                                     if (count &gt;&#x3D; MAX_PACKAGE_NOTIFICATIONS) &#123;</span><br><span class="line">                                         Slog.e(TAG, &quot;Package has already posted &quot; + count</span><br><span class="line">                                                + &quot; toasts. Not showing more. Package&#x3D;&quot; + pkg);</span><br><span class="line">                                         return;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        record &#x3D; new ToastRecord(callingPid, pkg, callback, duration);</span><br><span class="line">                        mToastQueue.add(record);</span><br><span class="line">                        index &#x3D; mToastQueue.size() - 1;</span><br><span class="line">                        keepProcessAliveLocked(callingPid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; If it&#39;s at index 0, it&#39;s the current toast.  It doesn&#39;t matter if it&#39;s</span><br><span class="line">                    &#x2F;&#x2F; new or just been updated.  Call back and tell it to show itself.</span><br><span class="line">                    &#x2F;&#x2F; If the callback fails, this will remove it from the list, so don&#39;t</span><br><span class="line">                    &#x2F;&#x2F; assume that it&#39;s valid after this.</span><br><span class="line">                    if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        showNextToastLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(callingId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们首先将我们的ToastRecord（Toast对象在server端的对象）保存到一个List列表mToastQueue中，然后调用了showNextToastLocked方法，这样我们在看一下showNextToastLocked方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void showNextToastLocked() &#123;</span><br><span class="line">        ToastRecord record &#x3D; mToastQueue.get(0);</span><br><span class="line">        while (record !&#x3D; null) &#123;</span><br><span class="line">            if (DBG) Slog.d(TAG, &quot;Show pkg&#x3D;&quot; + record.pkg + &quot; callback&#x3D;&quot; + record.callback);</span><br><span class="line">            try &#123;</span><br><span class="line">                record.callback.show();</span><br><span class="line">                scheduleTimeoutLocked(record);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback</span><br><span class="line">                        + &quot; in package &quot; + record.pkg);</span><br><span class="line">                &#x2F;&#x2F; remove it from the list and let the process die</span><br><span class="line">                int index &#x3D; mToastQueue.indexOf(record);</span><br><span class="line">                if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                    mToastQueue.remove(index);</span><br><span class="line">                &#125;</span><br><span class="line">                keepProcessAliveLocked(record.pid);</span><br><span class="line">                if (mToastQueue.size() &gt; 0) &#123;</span><br><span class="line">                    record &#x3D; mToastQueue.get(0);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    record &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要执行了record.callback.show方法，而这里的callback对象就是我们创建Toast对象的时候传递的TN对象，显然的，这了的show方法就是我们的Toast内部类TN的show方法，然后我们调用了scheduleTimeoutLocked方法，这里先看一下scheduleTimeoutLocked方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void scheduleTimeoutLocked(ToastRecord r)</span><br><span class="line">    &#123;</span><br><span class="line">        mHandler.removeCallbacksAndMessages(r);</span><br><span class="line">        Message m &#x3D; Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</span><br><span class="line">        long delay &#x3D; r.duration &#x3D;&#x3D; Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;</span><br><span class="line">        mHandler.sendMessageDelayed(m, delay);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里发送了一个异步消息，并且这里的异步消息是在duration时间之后发送的，也就是说我们在Toast端传递的duration参数就是这里的message消息delay发送的时间，而我们发送MESSAGE_TIMEOUT异步消息之后最终会被方法handleTimeout执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void handleTimeout(ToastRecord record)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DBG) Slog.d(TAG, &quot;Timeout pkg&#x3D;&quot; + record.pkg + &quot; callback&#x3D;&quot; + record.callback);</span><br><span class="line">        synchronized (mToastQueue) &#123;</span><br><span class="line">            int index &#x3D; indexOfToastLocked(record.pkg, record.callback);</span><br><span class="line">            if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                cancelToastLocked(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体里面又调用了cancelToastLocked方法，然后我们看一下cancelToastLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void cancelToastLocked(int index) &#123;</span><br><span class="line">        ToastRecord record &#x3D; mToastQueue.get(index);</span><br><span class="line">        try &#123;</span><br><span class="line">            record.callback.hide();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback</span><br><span class="line">                    + &quot; in package &quot; + record.pkg);</span><br><span class="line">            &#x2F;&#x2F; don&#39;t worry about this, we&#39;re about to remove it from</span><br><span class="line">            &#x2F;&#x2F; the list anyway</span><br><span class="line">        &#125;</span><br><span class="line">        mToastQueue.remove(index);</span><br><span class="line">        keepProcessAliveLocked(record.pid);</span><br><span class="line">        if (mToastQueue.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Show the next one. If the callback fails, this will remove</span><br><span class="line">            &#x2F;&#x2F; it from the list, so don&#39;t assume that the list hasn&#39;t changed</span><br><span class="line">            &#x2F;&#x2F; after this point.</span><br><span class="line">            showNextToastLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里又是调用了record.callback.hide方法，显然的这里的hide方法和刚刚的show方法是相似的，都是调用的Toast内部类TN的hide方法，所以这里可以看出Toast的显示与隐藏操作都是在Toast内部类TN的show和hide方法实现的，然后我们调用了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mToastQueue.remove(index);</span><br></pre></td></tr></table></figure>
<p>清除这个Toast对象，并继续执行showNextToastLocked方法，直到mToastQueue的大小为0。。。</p>
<p>这样关于Toast窗口的显示与隐藏操作都是在Toast内部类TN的show方法和hide方法中，我们先看一下TN内部类的show方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void show() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);</span><br><span class="line">            mHandler.post(mShow);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里也是发送一个异步消息，我们看一下Runnable类型的mShow的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final Runnable mShow &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                handleShow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到再其run方法中调用了handleShow方法，继续看handleShow方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public void handleShow() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView&#x3D;&quot; + mView</span><br><span class="line">                    + &quot; mNextView&#x3D;&quot; + mNextView);</span><br><span class="line">            if (mView !&#x3D; mNextView) &#123;</span><br><span class="line">                &#x2F;&#x2F; remove the old view if necessary</span><br><span class="line">                handleHide();</span><br><span class="line">                mView &#x3D; mNextView;</span><br><span class="line">                Context context &#x3D; mView.getContext().getApplicationContext();</span><br><span class="line">                String packageName &#x3D; mView.getContext().getOpPackageName();</span><br><span class="line">                if (context &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    context &#x3D; mView.getContext();</span><br><span class="line">                &#125;</span><br><span class="line">                mWM &#x3D; (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">                &#x2F;&#x2F; We can resolve the Gravity here by using the Locale for getting</span><br><span class="line">                &#x2F;&#x2F; the layout direction</span><br><span class="line">                final Configuration config &#x3D; mView.getContext().getResources().getConfiguration();</span><br><span class="line">                final int gravity &#x3D; Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());</span><br><span class="line">                mParams.gravity &#x3D; gravity;</span><br><span class="line">                if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#x3D;&#x3D; Gravity.FILL_HORIZONTAL) &#123;</span><br><span class="line">                    mParams.horizontalWeight &#x3D; 1.0f;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) &#x3D;&#x3D; Gravity.FILL_VERTICAL) &#123;</span><br><span class="line">                    mParams.verticalWeight &#x3D; 1.0f;</span><br><span class="line">                &#125;</span><br><span class="line">                mParams.x &#x3D; mX;</span><br><span class="line">                mParams.y &#x3D; mY;</span><br><span class="line">                mParams.verticalMargin &#x3D; mVerticalMargin;</span><br><span class="line">                mParams.horizontalMargin &#x3D; mHorizontalMargin;</span><br><span class="line">                mParams.packageName &#x3D; packageName;</span><br><span class="line">                if (mView.getParent() !&#x3D; null) &#123;</span><br><span class="line">                    if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);</span><br><span class="line">                    mWM.removeView(mView);</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this);</span><br><span class="line">                mWM.addView(mView, mParams);</span><br><span class="line">                trySendAccessibilityEvent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，在handleShow方法中经过一系列的初始化操作，初始化mWN对象，初始化mView对象，初始化了mParams对象，然后调用了mWM的addView方法，到了这里大家应该就很熟悉了（不熟悉的同学可以看一下Activity的加载绘制流程等文章<br><a href="http://blog.csdn.net/qq_23547831/article/details/51285804" target="_blank" rel="noopener"> android源码解析（十八）–&gt;Activity布局绘制流程</a>&nbsp;&nbsp;<br><a href="http://blog.csdn.net/qq_23547831/article/details/51284556" target="_blank" rel="noopener"> android源码解析（十七）–&gt;Activity布局加载流程</a>）通过这个方法就实现了Toast窗口的显示逻辑。</p>
<p>继续看一下TN的hide方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void hide() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this);</span><br><span class="line">            mHandler.post(mHide);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，和show方法类似，也是发送了一个异步消息，这里看一下Runnable类型的mHide对象的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Runnable mHide &#x3D; new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                handleHide();</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t do this in handleHide() because it is also invoked by handleShow()</span><br><span class="line">                mNextView &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现在其run方法中调用了handleHide方法，显然的，与show方法类似，这里的handleHide方法也是执行Toast窗口销毁的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void handleHide() &#123;</span><br><span class="line">            if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView&#x3D;&quot; + mView);</span><br><span class="line">            if (mView !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; note: checking parent() just to make sure the view has</span><br><span class="line">                &#x2F;&#x2F; been added...  i have seen cases where we get here when</span><br><span class="line">                &#x2F;&#x2F; the view isn&#39;t yet added, so let&#39;s try not to crash.</span><br><span class="line">                if (mView.getParent() !&#x3D; null) &#123;</span><br><span class="line">                    if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this);</span><br><span class="line">                    mWM.removeView(mView);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mView &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，在方法体重调用了mWM.removeView(mView),又是熟悉的代码，通过执行这里的removeView方法，我们可以实现Toast窗口的销毁流程，至此我们就分析完了Toast窗口的显示与销毁流程。</p>
<p>总结：</p>
<ul>
<li><p>Toast是一个系统窗口，Toast在显示与销毁流程设计到进程间通讯（Binder机制实现）</p>
</li>
<li><p>Toast的show方法首先会初始化一个Toast对象，然后将内部对象TN与duration传递给NotificationManagerService，并在NotificationManagerService端维护一个Toast对象列表。</p>
</li>
<li><p>NotificationManagerService接收到Toast的show请求之后，保存Toast对象并回调Toast.TN的show方法具体实现Toast窗口的显示逻辑。</p>
</li>
<li><p>Toast窗口的显示与销毁机制与Activity、Dialog、PopupWIndow都是类似的，都是通过WIndow对象实现的。</p>
</li>
<li><p>NotificationManagerService端在执行show方法执行会发送一个异步消息用于销毁Toast窗口，这个异步消息会在duration时间段之后发出，这样，在设置Toast显示的时间就会被传递到NotificationManagerService端，并在这段时间之后发送异步消息销毁Toast窗口。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/21%20PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/21%20PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">21 PopupWindow加载绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在前面的几篇文章中我们分析了Activity与Dialog的加载绘制流程，取消绘制流程，相信大家对Android系统的窗口绘制机制有了一个感性的认识了，这篇文章我们将继续分析一下PopupWindow加载绘制流程。</p>
<p>在分析PopupWindow之前，我们将首先说一下什么是PopupWindow？理解一个类最好的方式就是看一下这个类的定义，这里我们摘要了一下Android系统中PopupWindow的类的说明：</p>
<blockquote>
<p>A popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current<br> activity.</p>
</blockquote>
<p>一个PopupWindow能够被用于展示任意的View，PopupWindow是一个悬浮的容易展示在当前Activity的上面。<br>简单来说PopupWindow就是一个悬浮在Activity之上的窗口，可以用展示任意布局文件。</p>
<p>在说明PopupWindow的加载绘制机制之前，我们还是先写一个简单的例子用于说明一下PopupWindow的简单用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static View showPopupWindowMenu(Activity mContext, View anchorView, int layoutId) &#123;</span><br><span class="line">        LayoutInflater inflater &#x3D; (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        View view &#x3D; inflater.inflate(layoutId, null);</span><br><span class="line">        popupWindow &#x3D; new PopupWindow(view, DisplayUtil.dip2px(mContext, 148), WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">        popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_bg));</span><br><span class="line">        popupWindow.setFocusable(true);</span><br><span class="line">        popupWindow.setOutsideTouchable(true);</span><br><span class="line"></span><br><span class="line">        int[] location &#x3D; new int[2];</span><br><span class="line">        anchorView.getLocationOnScreen(location);</span><br><span class="line">        popupWindow.setAnimationStyle(R.style.popwin_anim_style);</span><br><span class="line">        popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY,</span><br><span class="line">                location[0] - popupWindow.getWidth() + anchorView.getWidth() - DisplayUtil.dip2px(mContext, 12),</span><br><span class="line">                location[1] + anchorView.getHeight() - DisplayUtil.dip2px(mContext, 10));</span><br><span class="line"></span><br><span class="line">        popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onDismiss() &#123;</span><br><span class="line">                popupWindow &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们首先通过LayoutInflater对象将布局文件解析到内存中View对象，然后创建了一个PopupWindow对象，可以看到传递了三个参数，一个是View对象，一个是PopupWindow的宽度和高度。</p>
<p>这里就是PopupWindow的初始化流程的开始了，好吧，我们来看一下PopupWindow的构造方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow(View contentView, int width, int height) &#123;</span><br><span class="line">        this(contentView, width, height, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了PopupWindow的重载构造方法，好吧，继续看一下这个重载构造方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public PopupWindow(View contentView, int width, int height, boolean focusable) &#123;</span><br><span class="line">        if (contentView !&#x3D; null) &#123;</span><br><span class="line">            mContext &#x3D; contentView.getContext();</span><br><span class="line">            mWindowManager &#x3D; (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setContentView(contentView);</span><br><span class="line">        setWidth(width);</span><br><span class="line">        setHeight(height);</span><br><span class="line">        setFocusable(focusable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里首先根据传入的View是否为空做了一下判断，若不为空，则初始化成员变量,Context和mWindowManager，可以发现这里的mContext对象就是传入的View组件中保留的Context对象，这里的mWindowManager是应用进程创建的时候注册的服务本地接口。然后调用了setContentView方法，这里就是为PopupWindow的contentView赋值。然后后面调用的setWidth、setHeight、setFocusable方法都是为PopupWindow的成员变量，width，height，focusable等赋值，这样PopupWindow的构造方法就执行完成了。</p>
<p>我们继续回到我们的例子代码中，在后续的代码中我们调用了：popupWindow.setBackgroundDrawable、popupWindow.setFocusable、PopupWindow.setOutsideTouchable、<br>PopupWindow.setAnimationStyle等方法，初始化了PopupWindow中的相关成员变量，最后我们调用了popupWindow.showAtLocation方法用于展示PopupWindow，这里我们具体看一下showAtLocation的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void showAtLocation(View parent, int gravity, int x, int y) &#123;</span><br><span class="line">        showAtLocation(parent.getWindowToken(), gravity, x, y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里调用了showAtLocation的重载函数，这样我们继续看一下这个重载函数的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void showAtLocation(IBinder token, int gravity, int x, int y) &#123;</span><br><span class="line">        if (isShowing() || mContentView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TransitionManager.endTransitions(mDecorView);</span><br><span class="line"></span><br><span class="line">        unregisterForScrollChanged();</span><br><span class="line"></span><br><span class="line">        mIsShowing &#x3D; true;</span><br><span class="line">        mIsDropdown &#x3D; false;</span><br><span class="line"></span><br><span class="line">        final WindowManager.LayoutParams p &#x3D; createPopupLayoutParams(token);</span><br><span class="line">        preparePopup(p);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Only override the default if some gravity was specified.</span><br><span class="line">        if (gravity !&#x3D; Gravity.NO_GRAVITY) &#123;</span><br><span class="line">            p.gravity &#x3D; gravity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.x &#x3D; x;</span><br><span class="line">        p.y &#x3D; y;</span><br><span class="line"></span><br><span class="line">        invokePopup(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到通过调用createPopupLayoutParams方法创造了WindowManager.LayoutParams对象，然后又调用了preparePopup方法，可以看一下preparePopup方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void preparePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line">        if (mContentView &#x3D;&#x3D; null || mContext &#x3D;&#x3D; null || mWindowManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;You must specify a valid content view by &quot;</span><br><span class="line">                    + &quot;calling setContentView() before attempting to show the popup.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The old decor view may be transitioning out. Make sure it finishes</span><br><span class="line">        &#x2F;&#x2F; and cleans up before we try to create another one.</span><br><span class="line">        if (mDecorView !&#x3D; null) &#123;</span><br><span class="line">            mDecorView.cancelTransitions();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; When a background is available, we embed the content view within</span><br><span class="line">        &#x2F;&#x2F; another view that owns the background drawable.</span><br><span class="line">        if (mBackground !&#x3D; null) &#123;</span><br><span class="line">            mBackgroundView &#x3D; createBackgroundView(mContentView);</span><br><span class="line">            mBackgroundView.setBackground(mBackground);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mBackgroundView &#x3D; mContentView;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecorView &#x3D; createDecorView(mBackgroundView);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The background owner should be elevated so that it casts a shadow.</span><br><span class="line">        mBackgroundView.setElevation(mElevation);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; We may wrap that in another view, so we&#39;ll need to manually specify</span><br><span class="line">        &#x2F;&#x2F; the surface insets.</span><br><span class="line">        final int surfaceInset &#x3D; (int) Math.ceil(mBackgroundView.getZ() * 2);</span><br><span class="line">        p.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);</span><br><span class="line">        p.hasManualSurfaceInsets &#x3D; true;</span><br><span class="line"></span><br><span class="line">        mPopupViewInitialLayoutDirectionInherited &#x3D;</span><br><span class="line">                (mContentView.getRawLayoutDirection() &#x3D;&#x3D; View.LAYOUT_DIRECTION_INHERIT);</span><br><span class="line">        mPopupWidth &#x3D; p.width;</span><br><span class="line">        mPopupHeight &#x3D; p.height;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>preparePopup方法的参数是WindowManager.LayoutParams，然后设置了PopupWindow中的几个比较重要的成员变量，首先看一下mBackgroundView的初始化过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (mBackground !&#x3D; null) &#123;</span><br><span class="line">            mBackgroundView &#x3D; createBackgroundView(mContentView);</span><br><span class="line">            mBackgroundView.setBackground(mBackground);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mBackgroundView &#x3D; mContentView;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现如果我们设置了mBackground变量也就是我们在初始化的时候执行了popupWindow的setBackgound方法，那么我们这里执行的就是if分之，这里看一下createBackgourndView的具体执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private PopupBackgroundView createBackgroundView(View contentView) &#123;</span><br><span class="line">        final ViewGroup.LayoutParams layoutParams &#x3D; mContentView.getLayoutParams();</span><br><span class="line">        final int height;</span><br><span class="line">        if (layoutParams !&#x3D; null &amp;&amp; layoutParams.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PopupBackgroundView backgroundView &#x3D; new PopupBackgroundView(mContext);</span><br><span class="line">        final PopupBackgroundView.LayoutParams listParams &#x3D; new PopupBackgroundView.LayoutParams(</span><br><span class="line">                ViewGroup.LayoutParams.MATCH_PARENT, height);</span><br><span class="line">        backgroundView.addView(contentView, listParams);</span><br><span class="line"></span><br><span class="line">        return backgroundView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，createBackgroundView的执行逻辑就是在参数contentView的外面一层包裹一层PopupBackgroundView，而这里的PopupBackgroundView值我们自定义的FrameLayout的子类，重写了其onCreateDrawableState方法。</p>
<p>继续回到我们的preparePopup方法，这里我们又调用了createDecorView方法初始化mDectorView变量，我们可以看一下createDecorView的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private PopupDecorView createDecorView(View contentView) &#123;</span><br><span class="line">        final ViewGroup.LayoutParams layoutParams &#x3D; mContentView.getLayoutParams();</span><br><span class="line">        final int height;</span><br><span class="line">        if (layoutParams !&#x3D; null &amp;&amp; layoutParams.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.WRAP_CONTENT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            height &#x3D; ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PopupDecorView decorView &#x3D; new PopupDecorView(mContext);</span><br><span class="line">        decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height);</span><br><span class="line">        decorView.setClipChildren(false);</span><br><span class="line">        decorView.setClipToPadding(false);</span><br><span class="line"></span><br><span class="line">        return decorView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里也是给参数contentView外面包裹了一层PopupDecorView，这里的PopupDecorView也是我们自定义的FrameLayout的子类，PopupDecorView的源码比较多，这里就不都贴出来了，这里具体看一下其onTouchEvent方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">            final int x &#x3D; (int) event.getX();</span><br><span class="line">            final int y &#x3D; (int) event.getY();</span><br><span class="line"></span><br><span class="line">            if ((event.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN)</span><br><span class="line">                    &amp;&amp; ((x &lt; 0) || (x &gt;&#x3D; getWidth()) || (y &lt; 0) || (y &gt;&#x3D; getHeight()))) &#123;</span><br><span class="line">                dismiss();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (event.getAction() &#x3D;&#x3D; MotionEvent.ACTION_OUTSIDE) &#123;</span><br><span class="line">                dismiss();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return super.onTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其重写了onTouchEvent时间，这样我们在点击popupWindow外面的时候就会执行pupopWindow的dismiss方法，取消PopupWindow。</p>
<p>好吧，继续回到我们的showAsDropDown方法，在执行完成preparePopup方法之后又调用了invokePopup方法，这里的方法应该就是具体执行PopupWindow的加载与显示逻辑了。这里我们具体看一下其实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void invokePopup(WindowManager.LayoutParams p) &#123;</span><br><span class="line">        if (mContext !&#x3D; null) &#123;</span><br><span class="line">            p.packageName &#x3D; mContext.getPackageName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PopupDecorView decorView &#x3D; mDecorView;</span><br><span class="line">        decorView.setFitsSystemWindows(mLayoutInsetDecor);</span><br><span class="line"></span><br><span class="line">        setLayoutDirectionFromAnchor();</span><br><span class="line"></span><br><span class="line">        mWindowManager.addView(decorView, p);</span><br><span class="line"></span><br><span class="line">        if (mEnterTransition !&#x3D; null) &#123;</span><br><span class="line">            decorView.requestEnterTransition(mEnterTransition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这里我们调用了mWindowManager.addView方法，看过我们前面几篇关于Dialog和Activity的加载与现实流程的同学应该知道这里的addView其实是我们布局绘制的流程，这里的mWindowManager是我们在调用PopupWIndow的构造函数的时候初始化的，其调用的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mWindowManager &#x3D;&#x3D; null &amp;&amp; mContentView !&#x3D; null) &#123;</span><br><span class="line">            mWindowManager &#x3D; (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>而这里的mContext.getSystemService是一个接口其具体的实现是在ContextImpl中实现的，所以这里我们看一下ContextImpl的getSystemService的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Object getSystemService(String name) &#123;</span><br><span class="line">        return SystemServiceRegistry.getSystemService(this, name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，在ContextImpl中的getSystemService方法又调用了SystemServiceRegister中的静态方法getSystemService，这样我们再看看一下在SystemServiceRegister是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Object getSystemService(ContextImpl ctx, String name) &#123;</span><br><span class="line">        ServiceFetcher&lt;?&gt; fetcher &#x3D; SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">        return fetcher !&#x3D; null ? fetcher.getService(ctx) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里发现服务对象的获取就是通过一个SYSTEM_SERVICE_FETCHERS的map数据结构获取的，那么这个map对象的数据是何时填充的呢？通过查看源码我们发下在SystemServiceRegister中有一段静态代码主要用于注册本地服务接口，其中关于windowManagerService本地服务的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">                new CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public WindowManager createService(ContextImpl ctx) &#123;</span><br><span class="line">                return new WindowManagerImpl(ctx.getDisplay());</span><br><span class="line">            &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>好吧，原来我们通过mContext.getSystemService获取的WindowManager其实际上是一个WindowManagerImpl对象，而我们调用的addView就是WindowManagerImpl的addView方法。</p>
<p>这样就回到了我们前几篇讲解的内容上了，通过调用WindowManagerImpl实现了布局文件的绘制流程。。。。</p>
<p>好了，经过上面的一系列的操作我们分析完了PopupWindow的加载绘制流程，其和Dialog，Activity的加载绘制流程类似，都是通过Window对象控制布局文件的加载与绘制流程。</p>
<p>总结：</p>
<ul>
<li><p>PopupWindow的界面加载绘制流程也是通过Window对象实现的；</p>
</li>
<li><p>PopupWindow内部保存的mWindowManager对象通过ContextImpl中获取，并且取得的是WindowManagerImpl对象；</p>
</li>
<li><p>PopupWindow通过为传入的View添加一层包裹的布局，并重写该布局的点击事件，实现点击PopupWindow之外的区域PopupWindow消失的效果；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/20%20Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/20%20Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">20 Dialog取消绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上几篇文章中我们分析了Dialog的加载绘制流程，也分析了Acvityi的加载绘制流程，说白了Android系统中窗口的展示都是通过Window对象控制，通过ViewRootImpl对象执行绘制操作来完成的，那么窗口的取消绘制流程是怎么样的呢？这篇文章就以Dialog为例说明Window窗口是如何取消绘制的。</p>
<p>有的同学可能会问前几篇文章介绍Activity的加载绘制流程的时候为何没有讲Activity的窗口取消流程，这里说明一下。那是因为当时说明的重点是Activity的加载与绘制流程，而取消绘制流程由于混杂在Activity的生命周期管理，可能不太明显，所以这里将Window窗口的取消绘制流程放在Dialog中，其实他们的取消绘制流程都是相似的，看完Dialog的取消绘制流程之后，再看一下Activity的取消绘制流程就很简单了。</p>
<p>还记得我们上一篇文章关于Dialog的例子么？我们通过AlertDialog.Builder创建了一个AlertDialog，并通过Activity中的按钮点击事件来显示这个AlertDialog，而在AlertDialog中定义了一个“知道了”按钮，点击这个按钮就会触发alertDialog.cancel方法，通过执行这个方法，我们的alertDialog就不在显示了，很明显的，cancel方法执行过程中就执行了取消绘制的逻辑，这里我们先看一下我们的例子核心代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">title.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(MainActivity.this.getApplication());</span><br><span class="line">                builder.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">                builder.setMessage(&quot;this is the content view!!!&quot;);</span><br><span class="line">                builder.setTitle(&quot;this is the title view!!!&quot;);</span><br><span class="line">                builder.setView(R.layout.activity_second);</span><br><span class="line">                builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                        alertDialog.cannel();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                alertDialog &#x3D; builder.create();</span><br><span class="line">                alertDialog.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这里的title就是我们自己的Activity中的一个TextView，通过注册这个TextView的点击事件，来显示一个AlertDialog，通过注册AlertDialog中按钮的点击事件，执行alertDialog的cancel方法。</p>
<p>好吧，看一下Dialog的cannel方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void cancel() &#123;</span><br><span class="line">        if (!mCanceled &amp;&amp; mCancelMessage !&#x3D; null) &#123;</span><br><span class="line">            mCanceled &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; Obtain a new message so this dialog can be re-used</span><br><span class="line">            Message.obtain(mCancelMessage).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">        dismiss();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，若当前Dialog没有取消，并且设置了取消message，则调用Message.obtain(mCancel).sendToTarget()，前面已经分析过这里的sendToTarget方法会回调我们注册的异步消息处理逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setOnCancelListener(final OnCancelListener listener) &#123;</span><br><span class="line">        if (mCancelAndDismissTaken !&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;OnCancelListener is already taken by &quot;</span><br><span class="line">                    + mCancelAndDismissTaken + &quot; and can not be replaced.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (listener !&#x3D; null) &#123;</span><br><span class="line">            mCancelMessage &#x3D; mListenersHandler.obtainMessage(CANCEL, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mCancelMessage &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到如果我们在初始化AlertDialog.Builder时，设置了setOnCancelListener，那么我们就会执行mListenersHandler的异步消息处理，好吧，这里看一下mListenersHandler的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static final class ListenersHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;DialogInterface&gt; mDialog;</span><br><span class="line"></span><br><span class="line">        public ListenersHandler(Dialog dialog) &#123;</span><br><span class="line">            mDialog &#x3D; new WeakReference&lt;DialogInterface&gt;(dialog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case DISMISS:</span><br><span class="line">                    ((OnDismissListener) msg.obj).onDismiss(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case CANCEL:</span><br><span class="line">                    ((OnCancelListener) msg.obj).onCancel(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case SHOW:</span><br><span class="line">                    ((OnShowListener) msg.obj).onShow(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里调用的是设置的OnCancelListener的onCancel方法，也就是说我们调用dialog.cancel方法时首先会判断dialog是否调用了setOnCancelListener若设置了，则先调用OnCancelListener的onCancel方法，然后再次执行dismiss方法，若我们没有为Dialog.Builder设置OnCancelListener那么cancel方法和dismiss方法是等效的。</p>
<p>这样，我们来看一下dismiss方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void dismiss() &#123;</span><br><span class="line">        if (Looper.myLooper() &#x3D;&#x3D; mHandler.getLooper()) &#123;</span><br><span class="line">            dismissDialog();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mHandler.post(mDismissAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里首先判断当前线程的Looper是否是主线程的Looper（由于mHandler是在主线程中创建的，所以mHandler.getLooper返回的是主线程中创建的Looper对象），若是的话，则直接执行dismissDialog()方法，否则的话，通过mHandler发送异步消息至主线程中，简单来说就是判断当前线程是否是主线程，若是主线程则执行dismissDialog方法否则发送异步消息，我们看一下mHandler对异步消息的处理机制，由于这里的mDismissAction是一个Runnable对象，所以这里直接看一下mDismissAction的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable mDismissAction &#x3D; new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            dismissDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>好吧，这里的异步消息最终也是调用的dismissDialog方法。。。。</p>
<p>所以无论我们执行的cancel方法还是dismiss方法，无论我们方法是在主线程执行还是子线程中执行，最终调用的都是dismissDialog方法，那么就看一下dismissDialog是怎么个执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void dismissDialog() &#123;</span><br><span class="line">        if (mDecor &#x3D;&#x3D; null || !mShowing) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mWindow.isDestroyed()) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog&#39;s window was already destroyed!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            mWindowManager.removeViewImmediate(mDecor);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (mActionMode !&#x3D; null) &#123;</span><br><span class="line">                mActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor &#x3D; null;</span><br><span class="line">            mWindow.closeAllPanels();</span><br><span class="line">            onStop();</span><br><span class="line">            mShowing &#x3D; false;</span><br><span class="line"></span><br><span class="line">            sendDismissMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，看样子代码还不是特别多，方法体中，首先判断当前的mDector是否为空，或者当前Dialog是否在显示，若为空或者没有在显示，则直接return掉，也就是说当前我们的dialog已经不再显示了，则我们不需要往下在执行。</p>
<p>然后我们调用了mWindow.isDestroyed()方法，判断Window对象是否已经被销毁，若已经被销毁，则直接return，并打印错误日志。</p>
<p>然后我们调用了mWindowManager.removeViewImmediate(mDector)，这里的mDector是我们Dialog窗口的根布局，看这个方法的名字应该就是Dialog去除根布局的操作了，可以看一下这个方法的具体实现。前几篇文章中我们已经分析过了这里的mWindowManager其实是WindowManagerImpl的实例，所以这里的removeViewImmediate方法应该是WindowManagerImpl中的方法，我们看一下它的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void removeViewImmediate(View view) &#123;</span><br><span class="line">        mGlobal.removeView(view, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里它调用了mGlobal.removeView方法，而这里的mGlobal是WindowManagerGlobal的实例，所以我们再看一下WIndowManagerGlobal中removeView的实现逻辑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void removeView(View view, boolean immediate) &#123;</span><br><span class="line">        if (view &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;view must not be null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            int index &#x3D; findViewLocked(view, true);</span><br><span class="line">            View curView &#x3D; mRoots.get(index).getView();</span><br><span class="line">            removeViewLocked(index, immediate);</span><br><span class="line">            if (curView &#x3D;&#x3D; view) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw new IllegalStateException(&quot;Calling with view &quot; + view</span><br><span class="line">                    + &quot; but the ViewAncestor is attached to &quot; + curView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，这里在获取了保存的mDector组件之后，又调用了removeViewLocked方法，我们在看一下这个方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void removeViewLocked(int index, boolean immediate) &#123;</span><br><span class="line">        ViewRootImpl root &#x3D; mRoots.get(index);</span><br><span class="line">        View view &#x3D; root.getView();</span><br><span class="line"></span><br><span class="line">        if (view !&#x3D; null) &#123;</span><br><span class="line">            InputMethodManager imm &#x3D; InputMethodManager.getInstance();</span><br><span class="line">            if (imm !&#x3D; null) &#123;</span><br><span class="line">                imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean deferred &#x3D; root.die(immediate);</span><br><span class="line">        if (view !&#x3D; null) &#123;</span><br><span class="line">            view.assignParent(null);</span><br><span class="line">            if (deferred) &#123;</span><br><span class="line">                mDyingViews.add(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到了么，我们获取了mDector组件的ViewRootImpl，然后调用了其的die方法，通过这个方法实现Window组件的销毁流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean die(boolean immediate) &#123;</span><br><span class="line">        &#x2F;&#x2F; Make sure we do execute immediately if we are in the middle of a traversal or the damage</span><br><span class="line">        &#x2F;&#x2F; done by dispatchDetachedFromWindow will cause havoc on return.</span><br><span class="line">        if (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">            doDie();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mIsDrawing) &#123;</span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.e(TAG, &quot;Attempting to destroy the window while drawing!\n&quot; +</span><br><span class="line">                    &quot;  window&#x3D;&quot; + this + &quot;, title&#x3D;&quot; + mWindowAttributes.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中有调用了doDie方法，看名字应该就是真正执行window销毁工作的方法了，我们在看一下doDie方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void doDie() &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface);</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mRemoved) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mRemoved &#x3D; true;</span><br><span class="line">            if (mAdded) &#123;</span><br><span class="line">                dispatchDetachedFromWindow();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">                destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">                if (mView !&#x3D; null) &#123;</span><br><span class="line">                    int viewVisibility &#x3D; mView.getVisibility();</span><br><span class="line">                    boolean viewVisibilityChanged &#x3D; mViewVisibility !&#x3D; viewVisibility;</span><br><span class="line">                    if (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                        &#x2F;&#x2F; If layout params have been changed, first give them</span><br><span class="line">                        &#x2F;&#x2F; to the window manager to make sure it has the correct</span><br><span class="line">                        &#x2F;&#x2F; animation info.</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if ((relayoutWindow(mWindowAttributes, viewVisibility, false)</span><br><span class="line">                                    &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) !&#x3D; 0) &#123;</span><br><span class="line">                                mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mSurface.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAdded &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        WindowManagerGlobal.getInstance().doRemoveView(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，首先调用了checkThread方法，介绍Activity的绘制流程的时候有过介绍，判断当前执行代码的线程，若不是主线程，则抛出异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">        if (mThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new CalledFromWrongThreadException(</span><br><span class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们顺着doDie的方法往下看，又调用了dispatchDetachedFromWindow()方法，这个方法主要是销毁Window中的各中成员变量，临时变量等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void dispatchDetachedFromWindow() &#123;</span><br><span class="line">        if (mView !&#x3D; null &amp;&amp; mView.mAttachInfo !&#x3D; null) &#123;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);</span><br><span class="line">            mView.dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAccessibilityInteractionConnectionManager.ensureNoConnection();</span><br><span class="line">        mAccessibilityManager.removeAccessibilityStateChangeListener(</span><br><span class="line">                mAccessibilityInteractionConnectionManager);</span><br><span class="line">        mAccessibilityManager.removeHighTextContrastStateChangeListener(</span><br><span class="line">                mHighContrastTextManager);</span><br><span class="line">        removeSendWindowContentChangedCallback();</span><br><span class="line"></span><br><span class="line">        destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">        setAccessibilityFocus(null, null);</span><br><span class="line"></span><br><span class="line">        mView.assignParent(null);</span><br><span class="line">        mView &#x3D; null;</span><br><span class="line">        mAttachInfo.mRootView &#x3D; null;</span><br><span class="line"></span><br><span class="line">        mSurface.release();</span><br><span class="line"></span><br><span class="line">        if (mInputQueueCallback !&#x3D; null &amp;&amp; mInputQueue !&#x3D; null) &#123;</span><br><span class="line">            mInputQueueCallback.onInputQueueDestroyed(mInputQueue);</span><br><span class="line">            mInputQueue.dispose();</span><br><span class="line">            mInputQueueCallback &#x3D; null;</span><br><span class="line">            mInputQueue &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mInputEventReceiver !&#x3D; null) &#123;</span><br><span class="line">            mInputEventReceiver.dispose();</span><br><span class="line">            mInputEventReceiver &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            mWindowSession.remove(mWindow);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Dispose the input channel after removing the window so the Window Manager</span><br><span class="line">        &#x2F;&#x2F; doesn&#39;t interpret the input channel being closed as an abnormal termination.</span><br><span class="line">        if (mInputChannel !&#x3D; null) &#123;</span><br><span class="line">            mInputChannel.dispose();</span><br><span class="line">            mInputChannel &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     mDisplayManager.unregisterDisplayListener(mDisplayListener);</span><br><span class="line"></span><br><span class="line">        unscheduleTraversals();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们在方法中调用了mView.dispatchDetachedFromWindow方法，这个方法的作用就是将mView从Window中detach出来，我们可以看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void dispatchDetachedFromWindow() &#123;</span><br><span class="line">        AttachInfo info &#x3D; mAttachInfo;</span><br><span class="line">        if (info !&#x3D; null) &#123;</span><br><span class="line">            int vis &#x3D; info.mWindowVisibility;</span><br><span class="line">            if (vis !&#x3D; GONE) &#123;</span><br><span class="line">                onWindowVisibilityChanged(GONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onDetachedFromWindow();</span><br><span class="line">        onDetachedFromWindowInternal();</span><br><span class="line"></span><br><span class="line">        InputMethodManager imm &#x3D; InputMethodManager.peekInstance();</span><br><span class="line">        if (imm !&#x3D; null) &#123;</span><br><span class="line">            imm.onViewDetachedFromWindow(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">        final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners &#x3D;</span><br><span class="line">                li !&#x3D; null ? li.mOnAttachStateChangeListeners : null;</span><br><span class="line">        if (listeners !&#x3D; null &amp;&amp; listeners.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to</span><br><span class="line">            &#x2F;&#x2F; perform the dispatching. The iterator is a safe guard against listeners that</span><br><span class="line">            &#x2F;&#x2F; could mutate the list by calling the various add&#x2F;remove methods. This prevents</span><br><span class="line">            &#x2F;&#x2F; the array from being modified while we iterate it.</span><br><span class="line">            for (OnAttachStateChangeListener listener : listeners) &#123;</span><br><span class="line">                listener.onViewDetachedFromWindow(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) !&#x3D; 0) &#123;</span><br><span class="line">            mAttachInfo.mScrollContainers.remove(this);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_SCROLL_CONTAINER_ADDED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAttachInfo &#x3D; null;</span><br><span class="line">        if (mOverlay !&#x3D; null) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中onDetachedFromWindow方法是一个空的回调方法，这里我们重点看一下onDetachedFromWindowInternal方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected void onDetachedFromWindowInternal() &#123;</span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_CANCEL_NEXT_UP_EVENT;</span><br><span class="line">        mPrivateFlags3 &amp;&#x3D; ~PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">        removeUnsetPressCallback();</span><br><span class="line">        removeLongPressCallback();</span><br><span class="line">        removePerformClickCallback();</span><br><span class="line">        removeSendViewScrolledAccessibilityEventCallback();</span><br><span class="line">        stopNestedScroll();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Anything that started animating right before detach should already</span><br><span class="line">        &#x2F;&#x2F; be in its final state when re-attached.</span><br><span class="line">        jumpDrawablesToCurrentState();</span><br><span class="line"></span><br><span class="line">        destroyDrawingCache();</span><br><span class="line"></span><br><span class="line">        cleanupDraw();</span><br><span class="line">        mCurrentAnimation &#x3D; null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onDetachedFromWindowInternal方法的方法体也不是特别长，都是一些调用函数，这里看一下destropDrawingCache方法，这个方法主要是销毁View的缓存Drawing，我们来看一下具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void destroyDrawingCache() &#123;</span><br><span class="line">        if (mDrawingCache !&#x3D; null) &#123;</span><br><span class="line">            mDrawingCache.recycle();</span><br><span class="line">            mDrawingCache &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mUnscaledDrawingCache !&#x3D; null) &#123;</span><br><span class="line">            mUnscaledDrawingCache.recycle();</span><br><span class="line">            mUnscaledDrawingCache &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mDrawingCache其实就是一个Bitmap类型的成员变量，而这里调用的recycler和置空操作其实就是把View中执行draw方法之后缓存的bitmap清空。</p>
<p>这里需要说明的是，我们View组件的最终显示落实是通过draw方法实现绘制的，而我们的draw方法的参数是一个Canvas，这是一个画布的对象，通过draw方法就是操作这个对象并显示出来，而Canvas对象之所以能够实现显示的效果是因为其内部保存着一个Bitmap对象，通过操作Canvas对象实质上是操作Canvas对象内部的Bitmap对象，而View组件的显示也就是通过这里的Bitmap来实现的。</p>
<p>而我们上文中置空了bitmap对象就相当于把View组件的显示效果置空了，就是相当于我们取消了View的draw方法的执行效果，继续回到我们的dispatchDetachedFromWindow方法，在执行了mView.dispatchDetachedFromWindow()方法之后，又调用了mView = null;方法，这里设置mView为空，这样我们有取消了View的meature和layouot的执行效果。</p>
<p>这样经过一系列的操作之后我们的Dialog的取消绘制流程就结束了，现在我们来看一下Activity的取消绘制流程。还记得我们“Activity的销毁流程”么？可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51232309" target="_blank" rel="noopener">android源码解析之（十五）–&gt;Activity销毁流程</a><br>当我们调用activity的finish方法的时候回调用ActivityThread的handleDestroyActivity方法，我们来看一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void handleDestroyActivity(IBinder token, boolean finishing,</span><br><span class="line">            int configChanges, boolean getNonConfigInstance) &#123;</span><br><span class="line">        ...</span><br><span class="line">        wm.removeViewImmediate(v);</span><br><span class="line">        ...            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了这里调用了wm.removeViewImmediate方法，这个方法不就是我们刚刚分析Dialog销毁绘制流程的起始方法么？以后的逻辑都是详细的，这样我们就实现了Activity的取消绘制流程。</p>
<p>总结：</p>
<ul>
<li><p>窗口的取消绘制流程是相似的，包括Activity和Dialog等；</p>
</li>
<li><p>通过调用WindowManager.removeViewImmediate方法，开始执行Window窗口的取消绘制流程；</p>
</li>
<li><p>Window窗口的取消绘制流程，通过清空bitma撤销draw的执行效果，通过置空View撤销meature和layout的执行效果；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/19%20Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/19%20Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">19 Dialog加载绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面两篇文章，我们分析了Activity的布局文件加载、绘制流程，算是对整个Android系统中界面的显示流程有了一个大概的了解，其实Android系统中所有的显示控件（注意这里是控件，而不是组件）的加载绘制流程都是类似的，包括：Dialog的加载绘制流程，PopupWindow的加载绘制流程，Toast的显示原理等，上一篇文章中，我说在介绍了Activity界面的加载绘制流程之后，就会分析一下剩余几个控件的显示控制流程，这里我打算先分析一下Dialog的加载绘制流程。</p>
<p>可能有的同学问这里为什么没有Fragment？其实严格意义上来说Fragment并不是一个显示控件，而只是一个显示组件。为什么这么说呢？其实像我们的Activity，Dialog，PopupWindow以及Toast类的内部都管理维护着一个Window对象，这个Window对象不但是一个View组件的集合管理对象，它也实现了组件的加载与绘制流程，而我们的Fragment组件如果看过源码的话，严格意义上来说，只是一个View组件的集合并通过控制变量实现了其特定的生命周期，但是其由于并没有维护Window类型的成员变量，所以其不具备组件的加载与绘制功能，因此其不能单独的被绘制出来，这也是我把它称之为组件而不是控件的原因。（在分析完这几个控件的加载绘制流程之后，有时间的话，也会分析一下Fragment的相关源码）</p>
<p>好吧，开始我们今天关于Dialog的讲解，相信大家在平时的开发过程中经常会使用到Dialog弹窗，使用Dialog可以在Activity弹出弹窗，确认消息等。为了更好的分析Dialog的源码，我们这里暂时写一个简单的demo，看一下Dialog的使用实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">title.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line"></span><br><span class="line">                AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(MainActivity.this);</span><br><span class="line">                builder.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">                builder.setMessage(&quot;this is the content view!!!&quot;);</span><br><span class="line">                builder.setTitle(&quot;this is the title view!!!&quot;);</span><br><span class="line">                builder.setView(R.layout.activity_second);</span><br><span class="line">                builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                        alertDialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                alertDialog &#x3D; builder.create();</span><br><span class="line">                alertDialog.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>我们在Activity中获取一个textView组件，并监听TextView的点击事件，并在点击事件中，初始化一个AlertDialog弹窗，并执行AlertDialog的show方法展示弹窗，在弹窗中定义一个按钮，并监听弹窗按钮的点击事件，若用户点击了弹窗的按钮，则执行AlertDialog的dismiss方法，取消展示AlertDialog。好吧，我们来看一下这个弹窗弹出的展示结果：<br><img src="http://img.blog.csdn.net/20160501105319191" alt="这里写图片描述"><br>可以看到我们定义的icon，title，message和button都已经显示出来了，这时候我们点击弹窗按钮知道了，这时候弹窗就会消失了。</p>
<p>一般我们使用Dialog的大概流程都是这样的，可能定制Dialog的时候有一些定制化的操作，但是基本操作流程还是这样的。</p>
<p>那么我们先来看一下AlertDialog.Builder的构造方法，这里的Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Builder(Context context) &#123;</span><br><span class="line">            this(context, resolveDialogTheme(context, 0));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里调用的是Builder的重载构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder(Context context, int themeResId) &#123;</span><br><span class="line">            P &#x3D; new AlertController.AlertParams(new ContextThemeWrapper(</span><br><span class="line">                    context, resolveDialogTheme(context, themeResId)));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>那么这里的P是AlertDialog.Builder中的一个AlertController.AlertParams类型的成员变量，可见在这里执行了P的初始化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public AlertParams(Context context) &#123;</span><br><span class="line">            mContext &#x3D; context;</span><br><span class="line">            mCancelable &#x3D; true;</span><br><span class="line">            mInflater &#x3D; (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量。这样执行了一系列操作之后我们的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog.Builder builder &#x3D; new AlertDialog.Builder(MainActivity.this);</span><br></pre></td></tr></table></figure>
<p>就已经执行完成了，然后我们调用了builder.setIcon方法，这里看一下setIcon方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setIcon(@DrawableRes int iconId) &#123;</span><br><span class="line">            P.mIconId &#x3D; iconId;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到AlertDialog的Builder的setIcon方法，这里执行的就是给类型为AlertController.AlertParams的P的mIconId赋值为传递的iconId，并且这个方法返回的类型就是Builder。</p>
<p>然后我们调用了builder.setMessage方法，可以看一下builder.setMessage方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setMessage(CharSequence message) &#123;</span><br><span class="line">            P.mMessage &#x3D; message;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里跟setIcon方法的实现逻辑类似，都是给成员变量的mMessage赋值为我们传递的Message值，且和setIcon方法类似的，这个方法返回值也是Builder。</p>
<p>再看一下builder.setTitle方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Builder setTitle(CharSequence title) &#123;</span><br><span class="line">            P.mTitle &#x3D; title;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现builder的setIcon、setMessage、setTitle等方法都是给Builder的成员变量P的icon，message，title赋值。</p>
<p>然后我们看一下builder.setView方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Builder setView(int layoutResId) &#123;</span><br><span class="line">            P.mView &#x3D; null;</span><br><span class="line">            P.mViewLayoutResId &#x3D; layoutResId;</span><br><span class="line">            P.mViewSpacingSpecified &#x3D; false;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里的setView和setIcon，setMessage，setTitle等方法都是类似的，都是将我们传递的数据值赋值给Builder的成员变量P。</p>
<p>然后我们调用了builder.setPositiveButton方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                        alertDialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>好吧，这里我们看一下builder的setPositiveButton的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123;</span><br><span class="line">            P.mPositiveButtonText &#x3D; text;</span><br><span class="line">            P.mPositiveButtonListener &#x3D; listener;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，可以发现跟上面几个方法还是类似的，都是为Builder的成员变量P的相应成员变量赋值。。。</p>
<p>上面的几行代码我们都是调用的builder.setXXX等方法，主要就是为Builder的成员变量P的相应成员变量值赋值。并且setXX方法返回值都是Builder类型的，因此我们可以通过消息琏的方式连续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.setIcon().setMessage().setTitle().setView().setPositiveButton()...</span><br></pre></td></tr></table></figure>
<p>这样代码显得比较简洁，set方法的执行顺序是没有固定模式的，这里多说一下，这种编程方式很优秀，平时我们在设计构造类工具类的时候也可以参考这种模式，构造类有不同的功能或者特性，并且都不是必须的，我们可以通过set方法设置不同的特性值并返回构造类本身。</p>
<p>然后我们调用了builder.create方法，并且这个方法返回了AlertDialog。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public AlertDialog create() &#123;</span><br><span class="line">            &#x2F;&#x2F; Context has already been wrapped with the appropriate theme.</span><br><span class="line">            final AlertDialog dialog &#x3D; new AlertDialog(P.mContext, 0, false);</span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            if (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(true);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</span><br><span class="line">            if (P.mOnKeyListener !&#x3D; null) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            return dialog;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里首先构造了一个AlertDialog，我们可以看一下这个构造方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;</span><br><span class="line">        super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0,</span><br><span class="line">                createContextThemeWrapper);</span><br><span class="line"></span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert &#x3D; new AlertController(getContext(), this, getWindow());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里首先调用了super的构造方法，而我们的AlertDialog继承于Dialog，所以这里执行的就是Dialog的构造方法，好吧，继续看一下Dialog的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123;</span><br><span class="line">        if (createContextThemeWrapper) &#123;</span><br><span class="line">            if (themeResId &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                final TypedValue outValue &#x3D; new TypedValue();</span><br><span class="line">                context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true);</span><br><span class="line">                themeResId &#x3D; outValue.resourceId;</span><br><span class="line">            &#125;</span><br><span class="line">            mContext &#x3D; new ContextThemeWrapper(context, themeResId);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mContext &#x3D; context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowManager &#x3D; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">        final Window w &#x3D; new PhoneWindow(mContext);</span><br><span class="line">        mWindow &#x3D; w;</span><br><span class="line">        w.setCallback(this);</span><br><span class="line">        w.setOnWindowDismissedCallback(this);</span><br><span class="line">        w.setWindowManager(mWindowManager, null, null);</span><br><span class="line">        w.setGravity(Gravity.CENTER);</span><br><span class="line"></span><br><span class="line">        mListenersHandler &#x3D; new ListenersHandler(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在Dialog的构造方法中直接直接构造了一个PhoneWindow，并赋值给Dialog的成员变量mWindow，从这里可以看出其实Dialog和Activity的显示逻辑都是类似的，都是通过对应的Window变量来实现窗口的加载与显示的。然后我们执行了一些Window对象的初始化操作，比如设置回调函数为本身，然后调用了Window类的setWindowManager方法，并传入了WindowManager，可以发现这里的WindowManager对象是通过方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager &#x3D; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br></pre></td></tr></table></figure>
<p>获取的，而我们的context传入的是Activity对象，所以这里的WindowManager对象其实和Activity获取的WindowManager对象是一致的。然后我们看一下window类的setWindowManager方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void setWindowManager(WindowManager wm, IBinder appToken, String appName,</span><br><span class="line">            boolean hardwareAccelerated) &#123;</span><br><span class="line">        mAppToken &#x3D; appToken;</span><br><span class="line">        mAppName &#x3D; appName;</span><br><span class="line">        mHardwareAccelerated &#x3D; hardwareAccelerated</span><br><span class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);</span><br><span class="line">        if (wm &#x3D;&#x3D; null) &#123;</span><br><span class="line">            wm &#x3D; (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到跟Activity的Window对象的windowManager的获取方式是相同的，都是通过new的方式创建一个新的WindowManagerImpl对象。好吧，继续回到我们的AlertDialog的构造方法中，在构造方法中，我们除了调用Dialog的构造方法之外还执行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAlert &#x3D; new AlertController(getContext(), this, getWindow());</span><br></pre></td></tr></table></figure>
<p>相当于初始化了AlertDiaog的成员变量mAlert。</p>
<p>继续回到我们的AlertDialog.Builder.create方法，在创建了一个AlertDialog之后，又执行了P.apply(dialog.mAlert)；<br>我们知道这里的P是一个AlertController.AlertParams的变量，而dialog.mAlert是我们刚刚创建的AlertDialog中的一个AlertController类型的变量，我们来看一下apply方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ublic void apply(AlertController dialog) &#123;</span><br><span class="line">            if (mCustomTitleView !&#x3D; null) &#123;</span><br><span class="line">                dialog.setCustomTitle(mCustomTitleView);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mTitle !&#x3D; null) &#123;</span><br><span class="line">                    dialog.setTitle(mTitle);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mIcon !&#x3D; null) &#123;</span><br><span class="line">                    dialog.setIcon(mIcon);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mIconId !&#x3D; 0) &#123;</span><br><span class="line">                    dialog.setIcon(mIconId);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mIconAttrId !&#x3D; 0) &#123;</span><br><span class="line">                    dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mMessage !&#x3D; null) &#123;</span><br><span class="line">                dialog.setMessage(mMessage);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPositiveButtonText !&#x3D; null) &#123;</span><br><span class="line">                dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</span><br><span class="line">                        mPositiveButtonListener, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mNegativeButtonText !&#x3D; null) &#123;</span><br><span class="line">                dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</span><br><span class="line">                        mNegativeButtonListener, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mNeutralButtonText !&#x3D; null) &#123;</span><br><span class="line">                dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</span><br><span class="line">                        mNeutralButtonListener, null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mForceInverseBackground) &#123;</span><br><span class="line">                dialog.setInverseBackgroundForced(true);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; For a list, the client can either supply an array of items or an</span><br><span class="line">            &#x2F;&#x2F; adapter or a cursor</span><br><span class="line">            if ((mItems !&#x3D; null) || (mCursor !&#x3D; null) || (mAdapter !&#x3D; null)) &#123;</span><br><span class="line">                createListView(dialog);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mView !&#x3D; null) &#123;</span><br><span class="line">                if (mViewSpacingSpecified) &#123;</span><br><span class="line">                    dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,</span><br><span class="line">                            mViewSpacingBottom);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dialog.setView(mView);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (mViewLayoutResId !&#x3D; 0) &#123;</span><br><span class="line">                dialog.setView(mViewLayoutResId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>看到了么？就是我们在初始化AlertDialog.Builder的时候设置的icon、title、message赋值给了AlertController.AlertParams，这里就是将我们初始化时候设置的属性值赋值给我们创建的Dialog对象的mAlert成员变量。。。。</p>
<p>继续我们的AlertDialog.Builder.create方法，在执行了AlertController.AlertParams.apply方法之后又调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dialog.setCancelable(P.mCancelable);</span><br></pre></td></tr></table></figure>
<p>可以发现这个也是AertController.AlertParams的一个成员变量，我们在初始化AlertDialog.Builder的时候也可以通过设置builder.setCancelable赋值，由于该属性为成员变量，所以默认值为false，而我们并没有通过builder.setCancelable修改这个属性值，所以这里设置的dialog的cancelable的值为false。然后我们的create方法有设置了dialog的cancelListener和dismissListener并返回了我们创建的Dialog对象。这样我们就获取到了我们的Dialog对象，然后我们调用了dialog的show方法用于显示dialog，好吧，这里我们看一下show方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public void show() &#123;</span><br><span class="line">        if (mShowing) &#123;</span><br><span class="line">            if (mDecor !&#x3D; null) &#123;</span><br><span class="line">                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">                &#125;</span><br><span class="line">                mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCanceled &#x3D; false;</span><br><span class="line">        </span><br><span class="line">        if (!mCreated) &#123;</span><br><span class="line">            dispatchOnCreate(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onStart();</span><br><span class="line">        mDecor &#x3D; mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">        if (mActionBar &#x3D;&#x3D; null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">            final ApplicationInfo info &#x3D; mContext.getApplicationInfo();</span><br><span class="line">            mWindow.setDefaultIcon(info.icon);</span><br><span class="line">            mWindow.setDefaultLogo(info.logo);</span><br><span class="line">            mActionBar &#x3D; new WindowDecorActionBar(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WindowManager.LayoutParams l &#x3D; mWindow.getAttributes();</span><br><span class="line">        if ((l.softInputMode</span><br><span class="line">                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            WindowManager.LayoutParams nl &#x3D; new WindowManager.LayoutParams();</span><br><span class="line">            nl.copyFrom(l);</span><br><span class="line">            nl.softInputMode |&#x3D;</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">            l &#x3D; nl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            mWindowManager.addView(mDecor, l);</span><br><span class="line">            mShowing &#x3D; true;</span><br><span class="line">    </span><br><span class="line">            sendShowMessage();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体的内容比较多，我们慢慢看，由于一开始mShowing变量用于表示当前dialog是否正在显示，由于我们刚刚开始调用执行show方法，所以这里的mShowing变量的值为false，所以if分支的内容不会被执行，继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!mCreated) &#123;</span><br><span class="line">            dispatchOnCreate(null);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>mCreated这个控制变量控制dispatchOnCreate方法只被执行一次，由于我们是第一次执行，所以这里会执行dispatchOnCreate方法，好吧，我们看一下dispatchOnCreate方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void dispatchOnCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        if (!mCreated) &#123;</span><br><span class="line">            onCreate(savedInstanceState);</span><br><span class="line">            mCreated &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，可以看到代码的执行逻辑很简单就是回调了Dialog的onCreate方法，那么onCreate方法内部又执行了那些逻辑呢？由于我们创建的是AlertDialog对象，该对象继承于Dialog，所以我们这时候需要看一下AlertDialog的onCreate方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mAlert.installContent();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里面除了调用super.onCreate方法之外就是调用了mAlert.installContent方法，而这里的super.onCreate方法就是调用的Dialog的onCreate方法，Dialog的onCreate方法只是一个空的实现逻辑，所以我们具体来看一下mAlert.installContent的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void installContent() &#123;</span><br><span class="line">        &#x2F;* We use a custom title so never request a window title *&#x2F;</span><br><span class="line">        mWindow.requestFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        int contentView &#x3D; selectContentView();</span><br><span class="line">        mWindow.setContentView(contentView);</span><br><span class="line">        setupView();</span><br><span class="line">        setupDecor();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里实现Window窗口的页面设置布局初始化等操作，这里设置了mWindow对象为NO_TITLE，然后通过调用selectContentView设置Window对象的布局文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int selectContentView() &#123;</span><br><span class="line">        if (mButtonPanelSideLayout &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return mAlertDialogLayout;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mButtonPanelLayoutHint &#x3D;&#x3D; AlertDialog.LAYOUT_HINT_SIDE) &#123;</span><br><span class="line">            return mButtonPanelSideLayout;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; TODO: use layout hint side for long messages&#x2F;lists</span><br><span class="line">        return mAlertDialogLayout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里通过执行selectContentView方法返回布局文件的id值，这里的默认值是mAlertDialogLayout。看过Activity布局加载流程（<a href="http://blog.csdn.net/qq_23547831/article/details/51284556" target="_blank" rel="noopener">android源码解析（十七）–&gt;Activity布局加载流程</a>）的童鞋应该知道，从这个方法开始我们就把指定布局文件的内容加载到内存中的Window对象中。我们这里看一下具体的布局文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mAlertDialogLayout &#x3D; a.getResourceId(</span><br><span class="line">                R.styleable.AlertDialog_layout, R.layout.alert_dialog);</span><br></pre></td></tr></table></figure>
<p>也就是R.layout.alert_dialog的布局文件，有兴趣的同学可以看一下该布局文件的源码，O(∩_∩)O哈哈~</p>
<p>继续回到我们的installContent方法，在执行了mWindow.setContentView方法之后，又调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量，这里就不在详细的说明。</p>
<p>然后回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法，这个方法主要用于设置ActionBar，这里不做过多的说明，然后初始化WindowManager.LayoutParams对象，并最终调用我们的mWindowManager.addView()方法。</p>
<p>O(∩_∩)O哈哈~，到了这一步大家如果看了上一篇Acitivty布局绘制流程的话，就应该知道顺着这个方法整个Dialog的界面就会被绘制出来了。</p>
<p>最后我们调用了sendShowMessage方法，可以看一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void sendShowMessage() &#123;</span><br><span class="line">        if (mShowMessage !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; Obtain a new message so this dialog can be re-used</span><br><span class="line">            Message.obtain(mShowMessage).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里会发送一个Dialog已经显示的异步消息，该消息最终会在ListenersHandler中的handleMessage方法中被执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static final class ListenersHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;DialogInterface&gt; mDialog;</span><br><span class="line"></span><br><span class="line">        public ListenersHandler(Dialog dialog) &#123;</span><br><span class="line">            mDialog &#x3D; new WeakReference&lt;DialogInterface&gt;(dialog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case DISMISS:</span><br><span class="line">                    ((OnDismissListener) msg.obj).onDismiss(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case CANCEL:</span><br><span class="line">                    ((OnCancelListener) msg.obj).onCancel(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">                case SHOW:</span><br><span class="line">                    ((OnShowListener) msg.obj).onShow(mDialog.get());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于我们的msg.what = SHOW,所以会执行OnShowListener.onShow方法，那么这个OnShowListener是何时赋值的呢？还记得我们构造AlertDialog.Builder么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alertDialog.setOnShowListener(new DialogInterface.OnShowListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onShow(DialogInterface dialog) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>这样就为我们的AlertDialog.Builder设置了OnShowListener，可以看一下setOnShowListener方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setOnShowListener(OnShowListener listener) &#123;</span><br><span class="line">        if (listener !&#x3D; null) &#123;</span><br><span class="line">            mShowMessage &#x3D; mListenersHandler.obtainMessage(SHOW, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mShowMessage &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样就为我们的Dialog中的mListenersHandler构造了Message对象，并且当我们在Dialog中发送showMessage的时候被mListenersHandler所接收。。。。</p>
<p>注：<br>这里说一下我们平时开发中若创建的Dialog使用的Context对象不是Activity，就会报出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Process: com.example.aaron.helloworld, PID: 11948                                                                         android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an application</span><br><span class="line">at android.view.ViewRootImpl.setView(ViewRootImpl.java:690)</span><br><span class="line">at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:282)</span><br><span class="line">at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)</span><br><span class="line">at android.app.Dialog.show(Dialog.java:298)</span><br><span class="line">at com.example.aaron.helloworld.MainActivity$1.onClick(MainActivity.java:59)</span><br><span class="line">at android.view.View.performClick(View.java:4811)</span><br><span class="line">at android.view.View$PerformClick.run(View.java:20136)</span><br><span class="line">at android.os.Handler.handleCallback(Handler.java:815)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:104)</span><br><span class="line">at android.os.Looper.loop(Looper.java:194)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:5552)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759)</span><br></pre></td></tr></table></figure>
<p>的异常，这是由于WindowManager.addView方法最终会调用ViewRootImpl.setView方法，而这时候会有mToken的检查，若我们传入的Context对象不是Activity，这时候的mToken为空，就会出现上述问题。。。</p>
<p>总结：</p>
<ul>
<li><p>Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑；</p>
</li>
<li><p>Dialog中的Window对象与Activity中的Window对象是相似的，都对应着一个WindowManager对象；</p>
</li>
<li><p>Dialog相关的几个类：Dialog，AlertDialog，AlertDialog.Builder，AlertController，AlertController.AlertParams，其中Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑，而AlertDialog是具体的Dialog的操作实现类，AlertDialog.Builder类是AlertDialog的内部类，主要用于构造AlertDialog，AlertController是AlertDialog的控制类，AlertController.AlertParams类是控制参数类；</p>
</li>
<li><p>构造显示Dialog的一般流程，构造AlertDialog.Builder，然后设置各种属性，最后调用AlertDialog.Builder.create方法获取AlertDialog对象，并且create方法中会执行，构造AlertDialog，设置dialog各种属性的操作。最后我们调用Dialog.show方法展示窗口，初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，并最终将Dialog显示出来；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/18%20Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/18%20Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">18 Activity布局绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是承接上一篇文章(Android布局加载流程：<a href="http://blog.csdn.net/qq_23547831/article/details/51284556" target="_blank" rel="noopener">android源码解析（十七）–&gt;Activity布局加载流程</a>)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Activity对象也就可以说是一个窗口对象，而Window只是控制着界面布局文件的加载过程，那么界面布局文件的绘制流程是如何的呢？这篇文章主要就是顺着上篇文章的思路，看一下在android系统中Activity的布局文件是如何绘制的。</p>
<p>顺便在这里多说几句，android中所有能显示的东西都是通过Window对象实现了，无论Activity，Dialog，PopupWindow，Toast等。后期我可能也会讲一下Dialog，PopupWindow，Toast等组件的显示过程。</p>
<p>前面有一篇文章中我们介绍过Activity的启动流程，可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">android源码解析之（十四）–&gt;Activity启动流程</a><br>在执行ActivityThread的handleLauncherActivity方法中通过Window对象控制了布局文件的加载流程，而Android体系在执行Activity的onResume方法之前会回调ActivityThread的handleResumeActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide, boolean isForward, boolean reallyResume) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window &#x3D; r.activity.getWindow();</span><br><span class="line">                View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                a.mDecor &#x3D; decor;</span><br><span class="line">                l.type &#x3D; WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |&#x3D; forwardBit;</span><br><span class="line">                if (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded &#x3D; true;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the window has already been added, but during resume</span><br><span class="line">            &#x2F;&#x2F; we started another activity, then don&#39;t yet make the</span><br><span class="line">            &#x2F;&#x2F; window visible.</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; The window is now visible if it has been added, we are not</span><br><span class="line">            &#x2F;&#x2F; simply finishing, and we are not starting another activity.</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor !&#x3D; null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                if (r.newConfig !&#x3D; null) &#123;</span><br><span class="line">                    r.tmpConfig.setTo(r.newConfig);</span><br><span class="line">                    if (r.overrideConfig !&#x3D; null) &#123;</span><br><span class="line">                        r.tmpConfig.updateFrom(r.overrideConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                            + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);</span><br><span class="line">                    performConfigurationChanged(r.activity, r.tmpConfig);</span><br><span class="line">                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</span><br><span class="line">                    r.newConfig &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward&#x3D;&quot;</span><br><span class="line">                        + isForward);</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                if ((l.softInputMode</span><br><span class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                        !&#x3D; forwardBit) &#123;</span><br><span class="line">                    l.softInputMode &#x3D; (l.softInputMode</span><br><span class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                            | forwardBit;</span><br><span class="line">                    if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                        ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                        View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                        wm.updateViewLayout(decor, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mVisibleFromServer &#x3D; true;</span><br><span class="line">                mNumVisibleActivities++;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!r.onlyLocalRequest) &#123;</span><br><span class="line">                r.nextIdle &#x3D; mNewActivities;</span><br><span class="line">                mNewActivities &#x3D; r;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">                Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">            &#125;</span><br><span class="line">            r.onlyLocalRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have resumed.</span><br><span class="line">            if (reallyResume) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在在获取了Activity的Window相关参数之后执行了r.activity.makeVisible()方法，看样子这个就是Activity的显示方法，这里我们来具体看一下makeVisible方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void makeVisible() &#123;</span><br><span class="line">        if (!mWindowAdded) &#123;</span><br><span class="line">            ViewManager wm &#x3D; getWindowManager();</span><br><span class="line">            wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">            mWindowAdded &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断成员变量mWindowAdded是否为true，可以发现mWindowAdded成员变量只有在执行之后才能赋值为true，所以这里的代码的主要逻辑是该if分支只能执行一次。</p>
<p>这里的ViewManager对象是通过getWindowManager()方法获取的，我们来看一下getWindowManager()方法的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManager getWindowManager() &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，原来就是返回的Activity的mWindowManager的成员变量，那么这个mWindowManager的成员变量是什么时候赋值的呢？上一篇文章我们在Activity的attach方法方法中初始化了Activity的相关成员变量，这里也包括了mWindowManager，我们来看一下mWindowManager的赋值过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager &#x3D; mWindow.getWindowManager();</span><br></pre></td></tr></table></figure>
<p>好吧，这里的Window.getWindowManager()方法是具体如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManager getWindowManager() &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么这里的Window对象的mWindowManager成员变量是具体如何赋值的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void setWindowManager(WindowManager wm, IBinder appToken, String appName,</span><br><span class="line">            boolean hardwareAccelerated) &#123;</span><br><span class="line">        mAppToken &#x3D; appToken;</span><br><span class="line">        mAppName &#x3D; appName;</span><br><span class="line">        mHardwareAccelerated &#x3D; hardwareAccelerated</span><br><span class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);</span><br><span class="line">        if (wm &#x3D;&#x3D; null) &#123;</span><br><span class="line">            wm &#x3D; (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，可以发现mWindowManager = ((WindowManagerImpl)vm).createLocalWindowManager(this)原来是在这里赋值的，所以一个Activity对应这一个新的Window，而这个Window对象内部会对应着一个新的WindowManager对象，我们接着往下看，那么createLoclWindowManager方法是如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123;</span><br><span class="line">        return new WindowManagerImpl(mDisplay, parentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，原来是new出了一个WindowManagerImpl对象，所以回到我们的Activity的makeVisible方法，ViewManager获取的是一个WindowManagerImpl对象，所以Window对象内部的WindowManager对象其实都是一个WindowManagerImpl的实例，都是而且从继承关系上可以看到：</p>
<p>WindowManagerImpl –&gt; WindowManager –&gt; ViewManager;</p>
<p>继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wm.addView(mDecor, getWindow().getAttributes());</span><br></pre></td></tr></table></figure>
<p>这里的mDector成员变量，通过上一篇文章的介绍，我们知道，它是Activity的界面根View，而getWindow.getAttrbutes方法是windowManager中定义的Params内部类，该内部类定义了许多的Window类型，由于这里的vm是WindowManagerImpl的实例，我们来看一下这里的addView的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们具体看一下mGlobal.addView方法，这里的mGlobal是一个WindowManagerGlobal的单例对象，WindowManagerGlobal是Window处理的工具类，那么WindowManagerGlobal的addView具体是如何实现的呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        View panelParentView &#x3D; null;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            &#x2F;&#x2F; Start watching for system property changes.</span><br><span class="line">            if (mSystemPropertyUpdater &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mSystemPropertyUpdater &#x3D; new Runnable() &#123;</span><br><span class="line">                    @Override public void run() &#123;</span><br><span class="line">                        synchronized (mLock) &#123;</span><br><span class="line">                            for (int i &#x3D; mRoots.size() - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">                                mRoots.get(i).loadSystemProperties();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int index &#x3D; findViewLocked(view, false);</span><br><span class="line">            if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                if (mDyingViews.contains(view)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue.</span><br><span class="line">                    mRoots.get(index).doDie();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;View &quot; + view</span><br><span class="line">                            + &quot; has already been added to the window manager.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; The previous removeView() had not completed executing. Now it has.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If this is a panel window, then find the window it is being</span><br><span class="line">            &#x2F;&#x2F; attached to for future reference.</span><br><span class="line">            if (wparams.type &gt;&#x3D; WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                    wparams.type &lt;&#x3D; WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">                final int count &#x3D; mViews.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">                    if (mRoots.get(i).mWindow.asBinder() &#x3D;&#x3D; wparams.token) &#123;</span><br><span class="line">                        panelParentView &#x3D; mViews.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root &#x3D; new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; do this last because it fires off messages to start doing things</span><br><span class="line">        try &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">            synchronized (mLock) &#123;</span><br><span class="line">                final int index &#x3D; findViewLocked(view, false);</span><br><span class="line">                if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                    removeViewLocked(index, true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在WindowManagerGlobal中存在着三个数据列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;View&gt; mViews &#x3D; new ArrayList&lt;View&gt;();</span><br><span class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots &#x3D; new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams &#x3D;</span><br><span class="line">            new ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br></pre></td></tr></table></figure>
<p>其中mViews主要用于保存Activity的mDector也就是Activity的根View，而mRoots主要用于保存ViewRootImpl，mParams主要用于保存Window的LayoutParams，WindowManagerGlobal主要作为WindowManagerImpl的辅助方法类，用于操作View组件。</p>
<p>最后我们调用了root.setView方法，这个方法很重要我们就是在这里实现了我们的root与ViewRootImpl的关联的，除了实现了mDector与ViewRootImpl的相互关联，我们还调用了requestLayout方法，这里我们看一下setView方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        ...</span><br><span class="line">        requestLayout();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在方法体中又调用了requestLayout方法，这个方法其实就是调用执行重绘的请求，我们来看一下这个requestLayout方法具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void requestLayout() &#123;</span><br><span class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested &#x3D; true;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里有一个checkThread方法，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">        if (mThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new CalledFromWrongThreadException(</span><br><span class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相信大家平时在编程的过程中肯定会遇到过这个错误，ViewRootImpl是具体更新View的管理类，所有关于View的更新操作都是在这里执行的，自然而然的对于更新线程的检测是在这个类中添加的，一般在更新UI的时候都会调用这个方法用于检测当前执行更新UI的线程是否是UI线程，否则就会抛出这个异常。</p>
<p>继续回到我们的requestLayout方法，这里又调用了scheduleTraversales方法，我们来看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">        if (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; true;</span><br><span class="line">            mTraversalBarrier &#x3D; mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">            if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里mChoreographer.postCallback，内部会调用一个异步消息，用于执行mTraversalRunnable的run方法，这个mTraversalRunnable是一个Runnable对象，我们来看一下mTraversalRunnable类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在TraversalRunnable类的run方法中调用了doTraversal方法，我们来看一下这个方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void doTraversal() &#123;</span><br><span class="line">        if (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; false;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            if (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(&quot;ViewAncestor&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            if (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，其内部又回调了方法performTraversals方法，这个方法就是整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作之后就可以展示在界面中了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 执行View组件的onMeasure方法，主要用于测量View</span><br><span class="line">            if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">                boolean focusChangedDueToTouchMode &#x3D; ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) !&#x3D; 0);</span><br><span class="line">                if (focusChangedDueToTouchMode || mWidth !&#x3D; host.getMeasuredWidth()</span><br><span class="line">                        || mHeight !&#x3D; host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">                    int childWidthMeasureSpec &#x3D; getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    int childHeightMeasureSpec &#x3D; getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed!  mWidth&#x3D;&quot;</span><br><span class="line">                            + mWidth + &quot; measuredWidth&#x3D;&quot; + host.getMeasuredWidth()</span><br><span class="line">                            + &quot; mHeight&#x3D;&quot; + mHeight</span><br><span class="line">                            + &quot; measuredHeight&#x3D;&quot; + host.getMeasuredHeight()</span><br><span class="line">                            + &quot; coveredInsetsChanged&#x3D;&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                     &#x2F;&#x2F; Ask host how big it wants to be</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Implementation of weights from WindowManager.LayoutParams</span><br><span class="line">                    &#x2F;&#x2F; We just grow the dimensions as needed and re-measure if</span><br><span class="line">                    &#x2F;&#x2F; needs be</span><br><span class="line">                    int width &#x3D; host.getMeasuredWidth();</span><br><span class="line">                    int height &#x3D; host.getMeasuredHeight();</span><br><span class="line">                    boolean measureAgain &#x3D; false;</span><br><span class="line"></span><br><span class="line">                    if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        width +&#x3D; (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                        childWidthMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        height +&#x3D; (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                        childHeightMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (measureAgain) &#123;</span><br><span class="line">                        if (DEBUG_LAYOUT) Log.v(TAG,</span><br><span class="line">                                &quot;And hey let&#39;s measure once more: width&#x3D;&quot; + width</span><br><span class="line">                                + &quot; height&#x3D;&quot; + height);</span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">		&#x2F;&#x2F; 主要用于测量View组件的位置</span><br><span class="line">		...</span><br><span class="line">        final boolean didLayout &#x3D; layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener &#x3D; didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">            performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; By this point all views have been sized and positioned</span><br><span class="line">            &#x2F;&#x2F; We can compute the transparent area</span><br><span class="line"></span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; start out transparent</span><br><span class="line">                &#x2F;&#x2F; TODO: AVOID THAT CALL BY CACHING THE RESULT?</span><br><span class="line">                host.getLocationInWindow(mTmpLocation);</span><br><span class="line">                mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                        mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                        mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">                host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">                if (mTranslator !&#x3D; null) &#123;</span><br><span class="line">                    mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                    mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                    mFullRedrawNeeded &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; reconfigure window manager</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DBG) &#123;</span><br><span class="line">                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">                System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">                host.debug();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 主要用于View的绘制过程</span><br><span class="line">        ...</span><br><span class="line">        if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            if (!skipDraw || mReportNextDraw) &#123;</span><br><span class="line">                if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                        mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingTransitions.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                performDraw();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (viewVisibility &#x3D;&#x3D; View.VISIBLE) &#123;</span><br><span class="line">                &#x2F;&#x2F; Try again</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">            &#125; else if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsInTraversal &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法performTraversals方法，我们调用了performMeasure，performLayout，performDraw三个方法，这几个方法主要用于测量View组件的大小，测量View组件的位置，绘制View组件；</p>
<p>即：测量大小 –&gt; 测量位置 –&gt; 绘制组件</p>
<p>好吧，这里我们调用了performMeasure方法，我们先看一下performMeasure方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在performMeasure方法中我们又调用了mView的measure方法，这里的mView就是我们一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        ...</span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在View的measure方法中，又调用了onMeasure方法，由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">        final boolean measureMatchParentChildren &#x3D;</span><br><span class="line">                MeasureSpec.getMode(widthMeasureSpec) !&#x3D; MeasureSpec.EXACTLY ||</span><br><span class="line">                MeasureSpec.getMode(heightMeasureSpec) !&#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">        mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">        int maxHeight &#x3D; 0;</span><br><span class="line">        int maxWidth &#x3D; 0;</span><br><span class="line">        int childState &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child &#x3D; getChildAt(i);</span><br><span class="line">            if (mMeasureAllChildren || child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">                final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line">                maxWidth &#x3D; Math.max(maxWidth,</span><br><span class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">                maxHeight &#x3D; Math.max(maxHeight,</span><br><span class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                childState &#x3D; combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">                if (measureMatchParentChildren) &#123;</span><br><span class="line">                    if (lp.width &#x3D;&#x3D; LayoutParams.MATCH_PARENT ||</span><br><span class="line">                            lp.height &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                        mMatchParentChildren.add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Account for padding too</span><br><span class="line">        maxWidth +&#x3D; getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">        maxHeight +&#x3D; getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check against our minimum height and width</span><br><span class="line">        maxHeight &#x3D; Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">        maxWidth &#x3D; Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check against our foreground&#39;s minimum height and width</span><br><span class="line">        final Drawable drawable &#x3D; getForeground();</span><br><span class="line">        if (drawable !&#x3D; null) &#123;</span><br><span class="line">            maxHeight &#x3D; Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">            maxWidth &#x3D; Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">        count &#x3D; mMatchParentChildren.size();</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">                final View child &#x3D; mMatchParentChildren.get(i);</span><br><span class="line">                final MarginLayoutParams lp &#x3D; (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                final int childWidthMeasureSpec;</span><br><span class="line">                if (lp.width &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    final int width &#x3D; Math.max(0, getMeasuredWidth()</span><br><span class="line">                            - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                            - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                    childWidthMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            width, MeasureSpec.EXACTLY);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    childWidthMeasureSpec &#x3D; getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                            lp.leftMargin + lp.rightMargin,</span><br><span class="line">                            lp.width);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeightMeasureSpec;</span><br><span class="line">                if (lp.height &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    final int height &#x3D; Math.max(0, getMeasuredHeight()</span><br><span class="line">                            - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                            - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                    childHeightMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            height, MeasureSpec.EXACTLY);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    childHeightMeasureSpec &#x3D; getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                            getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                            lp.topMargin + lp.bottomMargin,</span><br><span class="line">                            lp.height);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法，这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法，我们来看一下View的onMeasure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法中调用了setMeasuredDimension方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        boolean optical &#x3D; isLayoutModeOptical(this);</span><br><span class="line">        if (optical !&#x3D; isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets &#x3D; getOpticalInsets();</span><br><span class="line">            int opticalWidth  &#x3D; insets.left + insets.right;</span><br><span class="line">            int opticalHeight &#x3D; insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">            measuredWidth  +&#x3D; optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">            measuredHeight +&#x3D; optical ? opticalHeight : -opticalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体里面又调用了setMeasuredDimensionRaw方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        mMeasuredWidth &#x3D; measuredWidth;</span><br><span class="line">        mMeasuredHeight &#x3D; measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |&#x3D; PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中。</p>
<p>继续回到我们的performTransles方法，然后我们继续看performLayout方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">            int desiredWindowHeight) &#123;</span><br><span class="line">        mLayoutRequested &#x3D; false;</span><br><span class="line">        mScrollMayChange &#x3D; true;</span><br><span class="line">        mInLayout &#x3D; true;</span><br><span class="line"></span><br><span class="line">        final View host &#x3D; mView;</span><br><span class="line">        if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">            Log.v(TAG, &quot;Laying out &quot; + host + &quot; to (&quot; +</span><br><span class="line">                    host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">            mInLayout &#x3D; false;</span><br><span class="line">            int numViewsRequestingLayout &#x3D; mLayoutRequesters.size();</span><br><span class="line">            if (numViewsRequestingLayout &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; requestLayout() was called during layout.</span><br><span class="line">                &#x2F;&#x2F; If no layout-request flags are set on the requesting views, there is no problem.</span><br><span class="line">                &#x2F;&#x2F; If some requests are still pending, then we need to clear those flags and do</span><br><span class="line">                &#x2F;&#x2F; a full request&#x2F;measure&#x2F;layout pass to handle this situation.</span><br><span class="line">                ArrayList&lt;View&gt; validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        false);</span><br><span class="line">                if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Set this flag to indicate that any further requests are happening during</span><br><span class="line">                    &#x2F;&#x2F; the second pass, which may result in posting those requests to the next</span><br><span class="line">                    &#x2F;&#x2F; frame instead</span><br><span class="line">                    mHandlingLayoutInLayoutRequest &#x3D; true;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Process fresh layout requests, then measure and layout</span><br><span class="line">                    int numValidRequests &#x3D; validLayoutRequesters.size();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                        final View view &#x3D; validLayoutRequesters.get(i);</span><br><span class="line">                        Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                                &quot; during layout: running second layout pass&quot;);</span><br><span class="line">                        view.requestLayout();</span><br><span class="line">                    &#125;</span><br><span class="line">                    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                    mInLayout &#x3D; true;</span><br><span class="line">                    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                    mHandlingLayoutInLayoutRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Check the valid requests again, this time without checking&#x2F;clearing the</span><br><span class="line">                    &#x2F;&#x2F; layout flags, since requests happening during the second pass get noop&#39;d</span><br><span class="line">                    validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters, true);</span><br><span class="line">                    if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                        final ArrayList&lt;View&gt; finalRequesters &#x3D; validLayoutRequesters;</span><br><span class="line">                        &#x2F;&#x2F; Post second-pass requests to the next frame</span><br><span class="line">                        getRunQueue().post(new Runnable() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void run() &#123;</span><br><span class="line">                                int numValidRequests &#x3D; finalRequesters.size();</span><br><span class="line">                                for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                    final View view &#x3D; finalRequesters.get(i);</span><br><span class="line">                                    Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                                            &quot; during second layout pass: posting in next frame&quot;);</span><br><span class="line">                                    view.requestLayout();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        mInLayout &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中，我们看到该方法执行了layout方法，我们看一下该layout方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL &#x3D; mLeft;</span><br><span class="line">        int oldT &#x3D; mTop;</span><br><span class="line">        int oldB &#x3D; mBottom;</span><br><span class="line">        int oldR &#x3D; mRight;</span><br><span class="line"></span><br><span class="line">        boolean changed &#x3D; isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">            if (li !&#x3D; null &amp;&amp; li.mOnLayoutChangeListeners !&#x3D; null) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy &#x3D;</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners &#x3D; listenersCopy.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |&#x3D; PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法体中执行了onLayout方法，这个方法就是具体执行测量位置的方法了，由于我们的mDector是一个FrameLayout，所以跟measure类似的，我们看一下FrameLayout的onLayout方法的实现：</p>
<p>我们看到我们定义了一个循环逻辑，获取所有的validLayoutRequesters也就是需要执行Layout方法的View的集合，通过循环执行view的requestLayout方法。这里我们来看一下requestLayout方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, false &#x2F;* no force left gravity *&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了layoutChildren方法，让我们来看一下layoutChildren方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom,</span><br><span class="line">                                  boolean forceLeftGravity) &#123;</span><br><span class="line">        final int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">        final int parentLeft &#x3D; getPaddingLeftWithForeground();</span><br><span class="line">        final int parentRight &#x3D; right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        final int parentTop &#x3D; getPaddingTopWithForeground();</span><br><span class="line">        final int parentBottom &#x3D; bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child &#x3D; getChildAt(i);</span><br><span class="line">            if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">                final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">                final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                int childLeft;</span><br><span class="line">                int childTop;</span><br><span class="line"></span><br><span class="line">                int gravity &#x3D; lp.gravity;</span><br><span class="line">                if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                    gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">                final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.RIGHT:</span><br><span class="line">                        if (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    case Gravity.LEFT:</span><br><span class="line">                    default:</span><br><span class="line">                        childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                switch (verticalGravity) &#123;</span><br><span class="line">                    case Gravity.TOP:</span><br><span class="line">                        childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.BOTTOM:</span><br><span class="line">                        childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跟measure类似的，这里也是遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法，好吧，我们看一下View的layout的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL &#x3D; mLeft;</span><br><span class="line">        int oldT &#x3D; mTop;</span><br><span class="line">        int oldB &#x3D; mBottom;</span><br><span class="line">        int oldR &#x3D; mRight;</span><br><span class="line"></span><br><span class="line">        boolean changed &#x3D; isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">            if (li !&#x3D; null &amp;&amp; li.mOnLayoutChangeListeners !&#x3D; null) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy &#x3D;</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners &#x3D; listenersCopy.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |&#x3D; PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中。</p>
<p>好吧，经过了测量大小与测量位置的逻辑之后，我们最后看一下performTraversals方法中的performDraw方法，这个方法的作用就是执行View组件的绘制逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void performDraw() &#123;</span><br><span class="line">        ...</span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了ViewRootImpl的draw方法，然后我们看一下draw方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">			...</span><br><span class="line">            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">               return;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里又调用了drawSoftware方法，看名字这里应该就是调用执行绘制的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">            boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        ...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了mView的draw方法，这里的mView是我们的mDector，好吧，看一下draw方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">        final int privateFlags &#x3D; mPrivateFlags;</span><br><span class="line">        final boolean dirtyOpaque &#x3D; (privateFlags &amp; PFLAG_DIRTY_MASK) &#x3D;&#x3D; PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo &#x3D;&#x3D; null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        mPrivateFlags &#x3D; (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">         * in the appropriate order:</span><br><span class="line">         *</span><br><span class="line">         *      1. Draw the background</span><br><span class="line">         *      2. If necessary, save the canvas&#39; layers to prepare for fading</span><br><span class="line">         *      3. Draw view&#39;s content</span><br><span class="line">         *      4. Draw children</span><br><span class="line">         *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">         *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 1, draw the background, if needed</span><br><span class="line">        int saveCount;</span><br><span class="line"></span><br><span class="line">        if (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">        final int viewFlags &#x3D; mViewFlags;</span><br><span class="line">        boolean horizontalEdges &#x3D; (viewFlags &amp; FADING_EDGE_HORIZONTAL) !&#x3D; 0;</span><br><span class="line">        boolean verticalEdges &#x3D; (viewFlags &amp; FADING_EDGE_VERTICAL) !&#x3D; 0;</span><br><span class="line">        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            &#x2F;&#x2F; Step 3, draw the content</span><br><span class="line">            if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Step 4, draw the children</span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Overlay is part of the content and draws beneath Foreground</span><br><span class="line">            if (mOverlay !&#x3D; null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; we&#39;re done...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Here we do the full fledged routine...</span><br><span class="line">         * (this is an uncommon case where speed matters less,</span><br><span class="line">         * this is why we repeat some of the tests that have been</span><br><span class="line">         * done above)</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        boolean drawTop &#x3D; false;</span><br><span class="line">        boolean drawBottom &#x3D; false;</span><br><span class="line">        boolean drawLeft &#x3D; false;</span><br><span class="line">        boolean drawRight &#x3D; false;</span><br><span class="line"></span><br><span class="line">        float topFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float bottomFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float leftFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float rightFadeStrength &#x3D; 0.0f;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 2, save the canvas&#39; layers</span><br><span class="line">        int paddingLeft &#x3D; mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        final boolean offsetRequired &#x3D; isPaddingOffsetRequired();</span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            paddingLeft +&#x3D; getLeftPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left &#x3D; mScrollX + paddingLeft;</span><br><span class="line">        int right &#x3D; left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">        int top &#x3D; mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">        int bottom &#x3D; top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            right +&#x3D; getRightPaddingOffset();</span><br><span class="line">            bottom +&#x3D; getBottomPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ScrollabilityCache scrollabilityCache &#x3D; mScrollCache;</span><br><span class="line">        final float fadeHeight &#x3D; scrollabilityCache.fadingEdgeLength;</span><br><span class="line">        int length &#x3D; (int) fadeHeight;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; clip the fade length if top and bottom fades overlap</span><br><span class="line">        &#x2F;&#x2F; overlapping fades produce odd-looking artifacts</span><br><span class="line">        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">            length &#x3D; (bottom - top) &#x2F; 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; also clip horizontal fades if necessary</span><br><span class="line">        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">            length &#x3D; (right - left) &#x2F; 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (verticalEdges) &#123;</span><br><span class="line">            topFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</span><br><span class="line">            drawTop &#x3D; topFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            bottomFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</span><br><span class="line">            drawBottom &#x3D; bottomFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (horizontalEdges) &#123;</span><br><span class="line">            leftFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</span><br><span class="line">            drawLeft &#x3D; leftFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            rightFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</span><br><span class="line">            drawRight &#x3D; rightFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        saveCount &#x3D; canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">        int solidColor &#x3D; getSolidColor();</span><br><span class="line">        if (solidColor &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final int flags &#x3D; Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">            if (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawBottom) &#123;</span><br><span class="line">                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawLeft) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, left + length, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawRight) &#123;</span><br><span class="line">                canvas.saveLayer(right - length, top, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 3, draw the content</span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 5, draw the fade effect and restore layers</span><br><span class="line">        final Paint p &#x3D; scrollabilityCache.paint;</span><br><span class="line">        final Matrix matrix &#x3D; scrollabilityCache.matrix;</span><br><span class="line">        final Shader fade &#x3D; scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">        if (drawTop) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * topFadeStrength);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawBottom) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * bottomFadeStrength);</span><br><span class="line">            matrix.postRotate(180);</span><br><span class="line">            matrix.postTranslate(left, bottom);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawLeft) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * leftFadeStrength);</span><br><span class="line">            matrix.postRotate(-90);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawRight) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * rightFadeStrength);</span><br><span class="line">            matrix.postRotate(90);</span><br><span class="line">            matrix.postTranslate(right, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Overlay is part of the content and draws beneath Foreground</span><br><span class="line">        if (mOverlay !&#x3D; null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整个View的绘制流程还是比较清楚的，整个执行逻辑还有相应的注释，一共大概需要六步，并且在执行draw方法的过程中，如果包含子View，那么也会执行子View的draw方法，好吧，经过这样一系列的执行逻辑之后，mDector以及子View就被绘制出来了。</p>
<p>总结：</p>
<ul>
<li><p>Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。</p>
</li>
<li><p>View的绘制流程包含了测量大小，测量位置，绘制三个流程；</p>
</li>
<li><p>Activty的界面绘制是从mDector即根View开始的，也就是从mDector的测量大小，测量位置，绘制三个流程；</p>
</li>
<li><p>View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的；</p>
</li>
<li><p>View的测量大小流程:performMeasure –&gt; measure –&gt; onMeasure等方法;</p>
</li>
<li><p>View的测量位置流程：performLayout –&gt; layout –&gt; onLayout等方法；</p>
</li>
<li><p>View的绘制流程：onDraw等方法；</p>
</li>
<li><p>View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑；</p>
</li>
<li><p>Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/17%20Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/17%20Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">17 Activity布局加载流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好吧，终于要开始讲讲Activity的布局加载流程了，大家都知道在Android体系中Activity扮演了一个界面展示的角色，这也是它与android中另外一个很重要的组件Service最大的不同，但是这个展示的界面的功能是Activity直接控制的么？界面的布局文件是如何加载到内存并被Activity管理的？android中的View是一个怎样的概念？加载到内存中的布局文件是如何绘制出来的？</p>
<p>要想回答这些问题，我们就需要对android的界面加载与绘制流程有所了解，这里我们先来学习一下Activity的布局加载的流程。而至于Acitivty的布局绘制流程我们在下一篇中在做介绍。</p>
<p>其实Activity对界面布局的管理是都是通过Window对象来实现的，Window对象，顾名思义就是一个窗口对象，而Activity从用户角度就是一个个的窗口实例，因此不难想象每个Activity中都对应着一个Window对象，而这个Window对象就是负责加载显示界面的。至于window对象是如何展示不同的界面的，那是通过定义不同的View组件实现不同的界面展示。</p>
<p>废话不多说了，不知道大家是否还记得我们讲过的Activity的启动流程么？不熟悉的童鞋可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener"> android源码解析之（十四）–&gt;Activity启动流程</a> ，在文章中我们介绍到当ActivityManagerService接收到启动Activity的请求之后会通过IApplicationThread进程间通讯告知ApplicationThread并执行handleLauncherActivity方法，这里我们可以下其具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        &#x2F;&#x2F; If we are getting ready to gc after going to the background, well</span><br><span class="line">        &#x2F;&#x2F; we are back active so skip it.</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line"></span><br><span class="line">        if (r.profilerInfo !&#x3D; null) &#123;</span><br><span class="line">            mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">            mProfiler.startProfiling();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Make sure we are running with the most recent config.</span><br><span class="line">        handleConfigurationChanged(null, null);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">            TAG, &quot;Handling launch of &quot; + r);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initialize before creating the activity</span><br><span class="line">        WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">        Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">        if (a !&#x3D; null) &#123;</span><br><span class="line">            r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState &#x3D; r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line"></span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">                &#x2F;&#x2F; The activity manager actually wants this one to start out</span><br><span class="line">                &#x2F;&#x2F; paused, because it needs to be visible but isn&#39;t in the</span><br><span class="line">                &#x2F;&#x2F; foreground.  We accomplish this by going through the</span><br><span class="line">                &#x2F;&#x2F; normal startup (because activities expect to go through</span><br><span class="line">                &#x2F;&#x2F; onResume() the first time they run, before their window</span><br><span class="line">                &#x2F;&#x2F; is displayed), and then pausing it.  However, in this case</span><br><span class="line">                &#x2F;&#x2F; we do -not- need to do the full pause cycle (of freezing</span><br><span class="line">                &#x2F;&#x2F; and such) because the activity manager assumes it can just</span><br><span class="line">                &#x2F;&#x2F; retain the current state it has.</span><br><span class="line">                try &#123;</span><br><span class="line">                    r.activity.mCalled &#x3D; false;</span><br><span class="line">                    mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">                    &#x2F;&#x2F; We need to keep around the original state, in case</span><br><span class="line">                    &#x2F;&#x2F; we need to be created again.  But we only do this</span><br><span class="line">                    &#x2F;&#x2F; for pre-Honeycomb apps, which always save their state</span><br><span class="line">                    &#x2F;&#x2F; when pausing, so we can not have them save their state</span><br><span class="line">                    &#x2F;&#x2F; when restarting from a paused state.  For HC and later,</span><br><span class="line">                    &#x2F;&#x2F; we want to (and can) let the state be saved as the normal</span><br><span class="line">                    &#x2F;&#x2F; part of stopping the activity.</span><br><span class="line">                    if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                        r.state &#x3D; oldState;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!r.activity.mCalled) &#123;</span><br><span class="line">                        throw new SuperNotCalledException(</span><br><span class="line">                            &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                            &quot; did not call through to super.onPause()&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">                    throw e;</span><br><span class="line"></span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                        throw new RuntimeException(</span><br><span class="line">                                &quot;Unable to pause activity &quot;</span><br><span class="line">                                + r.intent.getComponent().toShortString()</span><br><span class="line">                                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.paused &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If there was an error, for any reason, tell the activity</span><br><span class="line">            &#x2F;&#x2F; manager to stop us.</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null, false);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里的handleLauncherActivity方法内部调用了performLaunchActivity方法，这个方法也是具体启动Activity的方法，我们来看一下它的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity activity &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();</span><br><span class="line">            activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state !&#x3D; null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		...</span><br><span class="line">            Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, r + &quot;: app&#x3D;&quot; + app</span><br><span class="line">                    + &quot;, appName&#x3D;&quot; + app.getPackageName()</span><br><span class="line">                    + &quot;, pkg&#x3D;&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                    + &quot;, comp&#x3D;&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                    + &quot;, dir&#x3D;&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                Context appContext &#x3D; createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title &#x3D; r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config &#x3D; new Configuration(mCompatConfiguration);</span><br><span class="line">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                        + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到这里是通过反射的机制创建的Activity，并调用了Activity的attach方法，那么这里的attach方法是做什么的呢？我们继续来看一下attach方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">            Instrumentation instr, IBinder token, int ident,</span><br><span class="line">            Application application, Intent intent, ActivityInfo info,</span><br><span class="line">            CharSequence title, Activity parent, String id,</span><br><span class="line">            NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">            Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">        mFragments.attachHost(null &#x2F;*parent*&#x2F;);</span><br><span class="line"></span><br><span class="line">        mWindow &#x3D; new PhoneWindow(this);</span><br><span class="line">        mWindow.setCallback(this);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">        mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">        if (info.softInputMode !&#x3D; WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">            mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">        &#125;</span><br><span class="line">        if (info.uiOptions !&#x3D; 0) &#123;</span><br><span class="line">            mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        mUiThread &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        mMainThread &#x3D; aThread;</span><br><span class="line">        mInstrumentation &#x3D; instr;</span><br><span class="line">        mToken &#x3D; token;</span><br><span class="line">        mIdent &#x3D; ident;</span><br><span class="line">        mApplication &#x3D; application;</span><br><span class="line">        mIntent &#x3D; intent;</span><br><span class="line">        mReferrer &#x3D; referrer;</span><br><span class="line">        mComponent &#x3D; intent.getComponent();</span><br><span class="line">        mActivityInfo &#x3D; info;</span><br><span class="line">        mTitle &#x3D; title;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">        mEmbeddedID &#x3D; id;</span><br><span class="line">        mLastNonConfigurationInstances &#x3D; lastNonConfigurationInstances;</span><br><span class="line">        if (voiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            if (lastNonConfigurationInstances !&#x3D; null) &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) !&#x3D; 0);</span><br><span class="line">        if (mParent !&#x3D; null) &#123;</span><br><span class="line">            mWindow.setContainer(mParent.getWindow());</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; mWindow.getWindowManager();</span><br><span class="line">        mCurrentConfig &#x3D; config;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在attach方法这里初始化了一些Activity的成员变量，主要是mWindow对象，并且mWindow的成员实例是PhoneWindow实例，这样也从侧面说明了一个Activity对应着一个Window对象。除了window对象还初始化了一些Activity的其他成员变量，这里不再做讨论，继续回到我们的performLaunchActivity方法，在调用了Activity的attach方法之后又调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInstrumentation.callActivityOnCreate(activity, r.state);</span><br></pre></td></tr></table></figure>
<p>这里的mInstrumentation是类Instrumentation，每个应用进程对应着一个Instrumentation和一个ActivityThread，Instrumentation就是具体操作Activity回调其生命周期方法的，我们这里看一下它的callActivityOnCreate方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里代码比较简洁，preOerformCreate方法和postPerformCreate方法我们这里暂时不管，主要的执行逻辑是调用了activity.performCreate方法，我们来看一下Activity的performCreate方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line">        performCreateCommon();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>原来onCreate的生命周期方法是在这里回调的，其实这里的逻辑在前面几篇文章中有讲述，也可以参考前面的文章。</p>
<p>至此我们就回调到了我们Activity的onCreate方法，大家平时在重写onCreate方法的时候，怎么加载布局文件的呢？这里看一下我们的onCreate方法的典型写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>无论我们怎么变化，我们的onCreate方法一般都是会调用这两句话的吧？那么这里的两段代码分辨是什么含义呢？我们首先看一下super.onCreate方法的实现逻辑，由于我们的Activity类继承与Activity，所以这里的super.onCreate方法，就是调用的Activity.onCreate方法，好吧，既然这样我们来看一下Activity的onCreate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line">        if (mLastNonConfigurationInstances !&#x3D; null) &#123;</span><br><span class="line">            mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mActivityInfo.parentActivityName !&#x3D; null) &#123;</span><br><span class="line">            if (mActionBar &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mEnableDefaultActionBarUp &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mActionBar.setDefaultDisplayHomeAsUpEnabled(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (savedInstanceState !&#x3D; null) &#123;</span><br><span class="line">            Parcelable p &#x3D; savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">            mFragments.restoreAllState(p, mLastNonConfigurationInstances !&#x3D; null</span><br><span class="line">                    ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">        &#125;</span><br><span class="line">        mFragments.dispatchCreate();</span><br><span class="line">        getApplication().dispatchActivityCreated(this, savedInstanceState);</span><br><span class="line">        if (mVoiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            mVoiceInteractor.attachActivity(this);</span><br><span class="line">        &#125;</span><br><span class="line">        mCalled &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，Activity的onCreate方法主要是做了一些Acitivty的初始化操作，那么如果我们不在自己的Activity调用super.onCreate方法呢？好吧，尝试之后，AndroidStudio在打开的Acitivty的onCreate方法中如果不调用super.onCreate方法的话，会报错。。。有木有搞错。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FATAL EXCEPTION: main                                                              Process: com.example.aaron.helloworld, PID: 18001                                                                 android.util.SuperNotCalledException: Activity &#123;com.example.aaron.helloworld&#x2F;com.example.aaron.helloworld.SecondActivity&#125; did not call through to super.onCreate()                                                                    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2422)                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2528)                                                                               at android.app.ActivityThread.access$800(ActivityThread.java:169)                                                                              at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421)                                                                             at android.os.Handler.dispatchMessage(Handler.java:111)                                                                            at android.os.Looper.loop(Looper.java:194)                                                                           at android.app.ActivityThread.main(ActivityThread.java:5552)                                                                        at java.lang.reflect.Method.invoke(Native Method)                                                                        at java.lang.reflect.Method.invoke(Method.java:372)                                                                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)                                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759)</span><br></pre></td></tr></table></figure>
<p>可以看到如果不调用super.onCreate方法的话，会在Activity的performLaunchActivity中报错，我们知道这里的performLaunchActivity方法就是我们启动Activity的时候回回调的方法，我们找找方法体实现中throws的Exception。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">activity.mCalled &#x3D; false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>在Activity的performLaunchActivity方法中，我们在调用了Activity的onCreate方法之后会执行一个判断逻辑，若Activity的mCalled为false，则会抛出我们刚刚捕获的异常，那么这个mCalled成员变量是在什么时候被赋值的呢？好吧，就是在Activity的onCreate方法赋值的，所以我们在实现自己的Activity的时候只有调用了super.onCreate方法才不会抛出这个异常，反过来说，我们实现自己的Actiivty，那么一定要在onCreate方法中调用super.onCreate方法。</p>
<p>然后我们在看一下onCreate中的setContentView方法，这里的参数就是一个Layout布局文件，可以发现这里的setContentView方法就是Acitivty中的setContentView，好吧我们来看一下Activity中setContentView的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">        getWindow().setContentView(layoutResID);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的getWindow方法就是获取Acitivty的mWindow成员变量，从刚刚我们在Activity.attach方法我们知道这里的mWindow的实例是PhoneWindow，所以这里调用的其实是PhoneWindow的setConentView方法，然后我们看一下PhoneWindow的setContentView是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void setContentView(int layoutResID) &#123;</span><br><span class="line">        &#x2F;&#x2F; Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">        &#x2F;&#x2F; decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">        &#x2F;&#x2F; before this happens.</span><br><span class="line">        if (mContentParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            final Scene newScene &#x3D; Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                    getContext());</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        final Callback cb &#x3D; getCallback();</span><br><span class="line">        if (cb !&#x3D; null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mContentParent对象是一个View对象，由于第一次mContentParent为空，所以执行installerDector方法，这里我们看一下installerDector方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">        if (mDecor &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mDecor &#x3D; generateDecor();</span><br><span class="line">            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">            mDecor.setIsRootNamespace(true);</span><br><span class="line">            if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures !&#x3D; 0) &#123;</span><br><span class="line">                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mDector是一个DectorView对象，而DectorView继承与FrameLayout，所以这里的mDector其实就是一个FrameLayout对象，并通过调用generateDector()方法初始化，我们继续看一下generateDector方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DecorView generateDecor() &#123;</span><br><span class="line">        return new DecorView(getContext(), -1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，就是通过new的方式创建了一个DectorView对象，然后我们继续看installDector方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (mContentParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mContentParent &#x3D; generateLayout(mDecor);</span><br></pre></td></tr></table></figure>
<p>这里初始化了mContentParent对象，这是一个View对象，我们调用了generateLayout方法，好吧，来看一下generateLayout方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Inflate the window decor.</span><br><span class="line"></span><br><span class="line">        int layoutResource;</span><br><span class="line">        int features &#x3D; getLocalFeatures();</span><br><span class="line">        &#x2F;&#x2F; System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) !&#x3D; 0) &#123;</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_swipe_dismiss;</span><br><span class="line">        &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) !&#x3D; 0) &#123;</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res &#x3D; new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogTitleIconsDecorLayout, res, true);</span><br><span class="line">                layoutResource &#x3D; res.resourceId;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource &#x3D; R.layout.screen_title_icons;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; XXX Remove this once action bar supports these features.</span><br><span class="line">            removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Title Icons!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) !&#x3D; 0</span><br><span class="line">                &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Special case for a window with only a progress bar (and title).</span><br><span class="line">            &#x2F;&#x2F; XXX Need to have a no-title version of embedded windows.</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_progress;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Progress!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Special case for a window with a custom title.</span><br><span class="line">            &#x2F;&#x2F; If the window is floating, we need a dialog layout</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res &#x3D; new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogCustomTitleDecorLayout, res, true);</span><br><span class="line">                layoutResource &#x3D; res.resourceId;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource &#x3D; R.layout.screen_custom_title;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; XXX Remove this once action bar supports these features.</span><br><span class="line">            removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; If no other features and not embedded, only need a title.</span><br><span class="line">            &#x2F;&#x2F; If the window is floating, we need a dialog layout</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res &#x3D; new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogTitleDecorLayout, res, true);</span><br><span class="line">                layoutResource &#x3D; res.resourceId;</span><br><span class="line">            &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) !&#x3D; 0) &#123;</span><br><span class="line">                layoutResource &#x3D; a.getResourceId(</span><br><span class="line">                        R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                        R.layout.screen_action_bar);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource &#x3D; R.layout.screen_title;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Title!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) !&#x3D; 0) &#123;</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Embedded, so no decoration is needed.</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_simple;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Simple!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecor.startChanging();</span><br><span class="line"></span><br><span class="line">        View in &#x3D; mLayoutInflater.inflate(layoutResource, null);</span><br><span class="line">        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        mContentRoot &#x3D; (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">        ViewGroup contentParent &#x3D; (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">        if (contentParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Window couldn&#39;t find content container view&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) !&#x3D; 0) &#123;</span><br><span class="line">            ProgressBar progress &#x3D; getCircularProgressBar(false);</span><br><span class="line">            if (progress !&#x3D; null) &#123;</span><br><span class="line">                progress.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) !&#x3D; 0) &#123;</span><br><span class="line">            registerSwipeCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Remaining setup -- of background and title -- that only applies</span><br><span class="line">        &#x2F;&#x2F; to top-level windows.</span><br><span class="line">        if (getContainer() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            final Drawable background;</span><br><span class="line">            if (mBackgroundResource !&#x3D; 0) &#123;</span><br><span class="line">                background &#x3D; getContext().getDrawable(mBackgroundResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                background &#x3D; mBackgroundDrawable;</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setWindowBackground(background);</span><br><span class="line"></span><br><span class="line">            final Drawable frame;</span><br><span class="line">            if (mFrameResource !&#x3D; 0) &#123;</span><br><span class="line">                frame &#x3D; getContext().getDrawable(mFrameResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                frame &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setWindowFrame(frame);</span><br><span class="line"></span><br><span class="line">            mDecor.setElevation(mElevation);</span><br><span class="line">            mDecor.setClipToOutline(mClipToOutline);</span><br><span class="line"></span><br><span class="line">            if (mTitle !&#x3D; null) &#123;</span><br><span class="line">                setTitle(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mTitleColor &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                mTitleColor &#x3D; mTextColor;</span><br><span class="line">            &#125;</span><br><span class="line">            setTitleColor(mTitleColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">        return contentParent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里就是通过调用LayoutInflater.inflate方法来加载布局文件到内存中，关于LayoutInflater.inflater是如何加载布局文件的，并且，通过对代码的分析，我们发现PhoneWindow中的几个成员变量：mDector，mContentRoot，mContentParent的关系<br>mDector –&gt; mContentRoot –&gt; mContentParent（包含）<br>并且我们来看一下典型的布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:fitsSystemWindows&#x3D;&quot;true&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class="line">    &lt;ViewStub android:id&#x3D;&quot;@+id&#x2F;action_mode_bar_stub&quot;</span><br><span class="line">              android:inflatedId&#x3D;&quot;@+id&#x2F;action_mode_bar&quot;</span><br><span class="line">              android:layout&#x3D;&quot;@layout&#x2F;action_mode_bar&quot;</span><br><span class="line">              android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">              android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">              android:theme&#x3D;&quot;?attr&#x2F;actionBarTheme&quot; &#x2F;&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">         android:id&#x3D;&quot;@android:id&#x2F;content&quot;</span><br><span class="line">         android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">         android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">         android:foregroundInsidePadding&#x3D;&quot;false&quot;</span><br><span class="line">         android:foregroundGravity&#x3D;&quot;fill_horizontal|top&quot;</span><br><span class="line">         android:foreground&#x3D;&quot;?android:attr&#x2F;windowContentOverlay&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>这里就是整个Activity加载的跟布局文件：screen_simple.xml，其中ViewStub对应着Activity中的titleBar而这里的FrameLayout里面主要用于填充内容。</p>
<p>然后我们具体看一下LayoutInflater.inflater方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</span><br><span class="line">        return inflate(resource, root, root !&#x3D; null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了inflate的重载方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">        synchronized (mConstructorArgs) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">            final Context inflaterContext &#x3D; mContext;</span><br><span class="line">            final AttributeSet attrs &#x3D; Xml.asAttributeSet(parser);</span><br><span class="line">            Context lastContext &#x3D; (Context) mConstructorArgs[0];</span><br><span class="line">            mConstructorArgs[0] &#x3D; inflaterContext;</span><br><span class="line">            View result &#x3D; root;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Look for the root node.</span><br><span class="line">                int type;</span><br><span class="line">                while ((type &#x3D; parser.next()) !&#x3D; XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                        type !&#x3D; XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Empty</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (type !&#x3D; XmlPullParser.START_TAG) &#123;</span><br><span class="line">                    throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                            + &quot;: No start tag found!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final String name &#x3D; parser.getName();</span><br><span class="line">                </span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                    System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                            + name);</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                    if (root &#x3D;&#x3D; null || !attachToRoot) &#123;</span><br><span class="line">                        throw new InflateException(&quot;&lt;merge &#x2F;&gt; can be used only with a valid &quot;</span><br><span class="line">                                + &quot;ViewGroup root and attachToRoot&#x3D;true&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; Temp is the root view that was found in the xml</span><br><span class="line">                    final View temp &#x3D; createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                    ViewGroup.LayoutParams params &#x3D; null;</span><br><span class="line"></span><br><span class="line">                    if (root !&#x3D; null) &#123;</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                    root);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; Create layout params that match root, if supplied</span><br><span class="line">                        params &#x3D; root.generateLayoutParams(attrs);</span><br><span class="line">                        if (!attachToRoot) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Set the layout params for temp if we are not</span><br><span class="line">                            &#x2F;&#x2F; attaching. (If we are, we use addView, below)</span><br><span class="line">                            temp.setLayoutParams(params);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Inflate all children under temp against its context.</span><br><span class="line">                    rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; We are supposed to attach all the views we found (int temp)</span><br><span class="line">                    &#x2F;&#x2F; to root. Do that now.</span><br><span class="line">                    if (root !&#x3D; null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                        root.addView(temp, params);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Decide whether to return the root that was passed in or the</span><br><span class="line">                    &#x2F;&#x2F; top view found in xml.</span><br><span class="line">                    if (root &#x3D;&#x3D; null || !attachToRoot) &#123;</span><br><span class="line">                        result &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">                InflateException ex &#x3D; new InflateException(e.getMessage());</span><br><span class="line">                ex.initCause(e);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                InflateException ex &#x3D; new InflateException(</span><br><span class="line">                        parser.getPositionDescription()</span><br><span class="line">                                + &quot;: &quot; + e.getMessage());</span><br><span class="line">                ex.initCause(e);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t retain static reference on context.</span><br><span class="line">                mConstructorArgs[0] &#x3D; lastContext;</span><br><span class="line">                mConstructorArgs[1] &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析源码，不难发现，主要是通过循环解析xml文件并将信息解析到内存View对象，布局文件中定义的一个个组件都被顺序的解析到了内存中并被父子View的形式组织起来，这样通过给定的一个root View就可以将整个布局文件中定义的组件全部解析。分析完解析布局文件，回到我们的setContentVIew方法，在调用了installDector方法之后，又调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);</span><br></pre></td></tr></table></figure>
<p>这个方法的含义就是将我们传递的客户端的layoutId对应的布局文件作为mContentParent的子View加载到内存中，这样我们的layoutId作为mContentParent的子View，而mContentParent又是mContentRoot的子View，mContentRoot又是mDector的子View，通过LayoutInflater的inflate方法逐步加载到了内存中，而我们的Activity又持有自身的PhoneWindow的引用，这就相当于我们的Activity持有了我们定义的布局文件的引用，因而Activity的布局文件被加载到了内存中。</p>
<p>总结：</p>
<ul>
<li><p>Activity的展示界面的特性是通过Window对象来控制的；</p>
</li>
<li><p>每个Activity对象都对应这个一个Window对象，并且Window对象的初始化在启动Activity的时候完成，在执行Activity的onCreate方法之前；</p>
</li>
<li><p>每个Window对象内部都存在一个FrameLayout类型的mDector对象，它是Acitivty界面的root view；</p>
</li>
<li><p>Activity中的window对象的实例是PhoneWindow对象，PhoneWindow对象中的几个成员变量mDector，mContentRoot，mContentParent都是View组件，它们的关系是：mDector –&gt; mContentRoot –&gt; mContentParent –&gt; 自定义layoutView</p>
</li>
<li><p>LayoutInflater.inflate主要用于将布局文件加载到内存View组件中，也可以设定加载到某一个父组件中；</p>
</li>
<li><p>典型的Activity的onCreate方法中需要调用super.onCreate方法和setContentView方法，若不调用super.onCreate方法，执行启动该Activity的逻辑会报错，若不执行setContentView的方法，该Activity只会显示一个空页面。</p>
</li>
</ul>
<p>好了，关于Activity的布局加载流程我们暂时介绍这么多，下一篇文章，我们将介绍一下Activity的布局显示流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/16%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/16%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">16 应用进程Context创建流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天讲讲应用进程Context的创建流程，相信大家平时在开发过程中经常会遇到对Context对象的使用，Application是Context，Activity是Context，Service也是Context，所以有一个经典的问题是一个App中一共有多少个Context？</p>
<p>这个问题的答案是Application + N个Activity + N个Service。</p>
<p>还有就是我们平时在使用Context过程中许多时候由于使用不当，可能会造成内存泄露的情况等等，这个也是需要我们注意的。这里有篇不错的文章：<br><a href="http://blog.csdn.net/feiduclear_up/article/details/47356289" target="_blank" rel="noopener"> Android Context 是什么？</a></p>
<p>好吧，什么叫应用进程Context呢？这是指的是Application所代表的Context的创建流程，还记得我们前几篇写的应用进程创建流程么？<br><a href="http://blog.csdn.net/qq_23547831/article/details/51119333" target="_blank" rel="noopener"> android源码解析之（十一）–&gt;应用进程启动流程</a><br>最后我们得出结论，应用进程的起始方法是ActivityThread.main方法，好吧，</p>
<p>由于还未讲解Service相关知识，这里暂时讲解一下Activity与Application中Context对象的创建过程。</p>
<p>首先我们就从ActivityThread.main方法开始看一下Application的创建流程。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现在方法体中我们创建了一个ActivityThread对象并执行了attach方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">        sCurrentActivityThread &#x3D; this;</span><br><span class="line">        mSystemThread &#x3D; system;</span><br><span class="line">        if (!system) &#123;</span><br><span class="line">            ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    ensureJitEnabled();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            final IActivityManager mgr &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Watch for getting close to heap limit.</span><br><span class="line">            BinderInternal.addGcWatcher(new Runnable() &#123;</span><br><span class="line">                @Override public void run() &#123;</span><br><span class="line">                    if (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Runtime runtime &#x3D; Runtime.getRuntime();</span><br><span class="line">                    long dalvikMax &#x3D; runtime.maxMemory();</span><br><span class="line">                    long dalvikUsed &#x3D; runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                    if (dalvikUsed &gt; ((3*dalvikMax)&#x2F;4)) &#123;</span><br><span class="line">                        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max&#x3D;&quot; + (dalvikMax&#x2F;1024)</span><br><span class="line">                                + &quot; total&#x3D;&quot; + (runtime.totalMemory()&#x2F;1024)</span><br><span class="line">                                + &quot; used&#x3D;&quot; + (dalvikUsed&#x2F;1024));</span><br><span class="line">                        mSomeActivitiesChanged &#x3D; false;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          ...  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里看一下重点实现，我们可以发现在方法体中调用了ActivityManagerNative.getDefault().attachApplication(mAppThread)<br>看过我的前几篇文章的童鞋应该知道这里就是一个Binder进程间通讯，其实上执行的是ActivityManagerService.attachApplication方法，具体的可以参考前几篇文章的介绍，好吧，既然这样我们看一下ActivityManagerService.attachApplication方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后这里面又调用了attachApplicationLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread 	  thread, int pid) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat,</span><br><span class="line">getCommonServicesLocked(app.isolated),</span><br><span class="line">mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>可以看到这里面又调用了IApplication.bindApplication，从方法名称中我们可以看出这里应该是绑定Application的方法，跟上面的ActivityManangerNative类似的，前面几篇文章中我们已经做过介绍，IApplicationThread是ActivityThread中ApplicationThread binder对象的客户端，所以这里最终调用的是ApplicationThread的bindApplication方法，既然这样，我们来看一下ApplicationThread的bindApplication的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">                IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">                IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,</span><br><span class="line">                Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span><br><span class="line">                Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">            if (services !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Setup the service cache in the ServiceManager</span><br><span class="line">                ServiceManager.initServiceCache(services);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Two possible indications that this package could be</span><br><span class="line">             * sharing its runtime with other packages:</span><br><span class="line">             *</span><br><span class="line">             * 1.) the sharedUserId attribute is set in the manifest,</span><br><span class="line">             *     indicating a request to share a VM with other</span><br><span class="line">             *     packages with the same sharedUserId.</span><br><span class="line">             *</span><br><span class="line">             * 2.) the application element of the manifest has an</span><br><span class="line">             *     attribute specifying a non-default process name,</span><br><span class="line">             *     indicating the desire to run in another packages VM.</span><br><span class="line">             *</span><br><span class="line">             * If sharing is enabled we do not have a unique application</span><br><span class="line">             * in a process and therefore cannot rely on the package</span><br><span class="line">             * name inside the runtime.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            IPackageManager pm &#x3D; getPackageManager();</span><br><span class="line">            android.content.pm.PackageInfo pi &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                pi &#x3D; pm.getPackageInfo(appInfo.packageName, 0, UserHandle.myUserId());</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pi !&#x3D; null) &#123;</span><br><span class="line">                boolean sharedUserIdSet &#x3D; (pi.sharedUserId !&#x3D; null);</span><br><span class="line">                boolean processNameNotDefault &#x3D;</span><br><span class="line">                (pi.applicationInfo !&#x3D; null &amp;&amp;</span><br><span class="line">                 !appInfo.packageName.equals(pi.applicationInfo.processName));</span><br><span class="line">                boolean sharable &#x3D; (sharedUserIdSet || processNameNotDefault);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Tell the VMRuntime about the application, unless it is shared</span><br><span class="line">                &#x2F;&#x2F; inside a process.</span><br><span class="line">                if (!sharable) &#123;</span><br><span class="line">                    VMRuntime.registerAppInfo(appInfo.packageName, appInfo.dataDir,</span><br><span class="line">                                            appInfo.processName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AppBindData data &#x3D; new AppBindData();</span><br><span class="line">            data.processName &#x3D; processName;</span><br><span class="line">            data.appInfo &#x3D; appInfo;</span><br><span class="line">            data.providers &#x3D; providers;</span><br><span class="line">            data.instrumentationName &#x3D; instrumentationName;</span><br><span class="line">            data.instrumentationArgs &#x3D; instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher &#x3D; instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection &#x3D; instrumentationUiConnection;</span><br><span class="line">            data.debugMode &#x3D; debugMode;</span><br><span class="line">            data.enableOpenGlTrace &#x3D; enableOpenGlTrace;</span><br><span class="line">            data.restrictedBackupMode &#x3D; isRestrictedBackupMode;</span><br><span class="line">            data.persistent &#x3D; persistent;</span><br><span class="line">            data.config &#x3D; config;</span><br><span class="line">            data.compatInfo &#x3D; compatInfo;</span><br><span class="line">            data.initProfilerInfo &#x3D; profilerInfo;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，最后调用了ActivityThread.sendMessage()…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj) &#123;</span><br><span class="line">        sendMessage(what, obj, 0, 0, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看一下其sendMessage的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">        Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.what &#x3D; what;</span><br><span class="line">        msg.obj &#x3D; obj;</span><br><span class="line">        msg.arg1 &#x3D; arg1;</span><br><span class="line">        msg.arg2 &#x3D; arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里调用了mH的sendMessage方法，最后通过Handler的异步消息机制被mH的handleMessage方法处理，然后根据Message.what选择处理分支，最终调用了ActivityThread的handleBindApplication方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 创建Instrumentation</span><br><span class="line">        if (data.instrumentationName !&#x3D; null) &#123;</span><br><span class="line">            InstrumentationInfo ii &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                ii &#x3D; appContext.getPackageManager().</span><br><span class="line">                    getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">            &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (ii &#x3D;&#x3D; null) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find instrumentation info for: &quot;</span><br><span class="line">                    + data.instrumentationName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInstrumentationPackageName &#x3D; ii.packageName;</span><br><span class="line">            mInstrumentationAppDir &#x3D; ii.sourceDir;</span><br><span class="line">            mInstrumentationSplitAppDirs &#x3D; ii.splitSourceDirs;</span><br><span class="line">            mInstrumentationLibDir &#x3D; ii.nativeLibraryDir;</span><br><span class="line">            mInstrumentedAppDir &#x3D; data.info.getAppDir();</span><br><span class="line">            mInstrumentedSplitAppDirs &#x3D; data.info.getSplitAppDirs();</span><br><span class="line">            mInstrumentedLibDir &#x3D; data.info.getLibDir();</span><br><span class="line"></span><br><span class="line">            ApplicationInfo instrApp &#x3D; new ApplicationInfo();</span><br><span class="line">            instrApp.packageName &#x3D; ii.packageName;</span><br><span class="line">            instrApp.sourceDir &#x3D; ii.sourceDir;</span><br><span class="line">            instrApp.publicSourceDir &#x3D; ii.publicSourceDir;</span><br><span class="line">            instrApp.splitSourceDirs &#x3D; ii.splitSourceDirs;</span><br><span class="line">            instrApp.splitPublicSourceDirs &#x3D; ii.splitPublicSourceDirs;</span><br><span class="line">            instrApp.dataDir &#x3D; ii.dataDir;</span><br><span class="line">            instrApp.nativeLibraryDir &#x3D; ii.nativeLibraryDir;</span><br><span class="line">            LoadedApk pi &#x3D; getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                    appContext.getClassLoader(), false, true, false);</span><br><span class="line">            ContextImpl instrContext &#x3D; ContextImpl.createAppContext(this, pi);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                java.lang.ClassLoader cl &#x3D; instrContext.getClassLoader();</span><br><span class="line">                mInstrumentation &#x3D; (Instrumentation)</span><br><span class="line">                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                    + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInstrumentation.init(this, instrContext, appContext,</span><br><span class="line">                   new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher,</span><br><span class="line">                   data.instrumentationUiAutomationConnection);</span><br><span class="line"></span><br><span class="line">            if (mProfiler.profileFile !&#x3D; null &amp;&amp; !ii.handleProfiling</span><br><span class="line">                    &amp;&amp; mProfiler.profileFd &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mProfiler.handlingProfiling &#x3D; true;</span><br><span class="line">                File file &#x3D; new File(mProfiler.profileFile);</span><br><span class="line">                file.getParentFile().mkdirs();</span><br><span class="line">                Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		&#x2F; If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">            &#x2F;&#x2F; a restricted environment with the base application class.</span><br><span class="line">            Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">            mInitialApplication &#x3D; app;</span><br><span class="line">		...</span><br><span class="line">        try &#123;</span><br><span class="line">           mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception e) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                    + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                        + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的方法体比较长，我们挑重点的看，可以看到方法体中系统通过反射机制创建了Instrumentation对象，并执行了init方法，执行了Insrtumentation对象的初始化。然后我们调用了LockedApk.makeApplication方法创建了Application对象，我们来看一下其具体的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">            Instrumentation instrumentation) &#123;</span><br><span class="line">        if (mApplication !&#x3D; null) &#123;</span><br><span class="line">            return mApplication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Application app &#x3D; null;</span><br><span class="line"></span><br><span class="line">        String appClass &#x3D; mApplicationInfo.className;</span><br><span class="line">        if (forceDefaultAppClass || (appClass &#x3D;&#x3D; null)) &#123;</span><br><span class="line">            appClass &#x3D; &quot;android.app.Application&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; getClassLoader();</span><br><span class="line">            if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">                initializeJavaContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">            ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">            app &#x3D; mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mActivityThread.mAllApplications.add(app);</span><br><span class="line">        mApplication &#x3D; app;</span><br><span class="line"></span><br><span class="line">        if (instrumentation !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                instrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                        + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Rewrite the R &#39;constants&#39; for all library apks.</span><br><span class="line">        SparseArray&lt;String&gt; packageIdentifiers &#x3D; getAssets(mActivityThread)</span><br><span class="line">                .getAssignedPackageIdentifiers();</span><br><span class="line">        final int N &#x3D; packageIdentifiers.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            final int id &#x3D; packageIdentifiers.keyAt(i);</span><br><span class="line">            if (id &#x3D;&#x3D; 0x01 || id &#x3D;&#x3D; 0x7f) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里也是以反射的机制创建了Application对象，并创建了一个ContextImpl对象，并将Application与ContextImpl建立关联。。。</p>
<p>继续回到我们的ActivityThread的handleBindApplication方法，在创建了Application对象之后我们调用了Instrumentation的onCreate方法，然后调用了Instrumentation的callApplicationOnCreate方法，我们来看一下其具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callApplicationOnCreate(Application app) &#123;</span><br><span class="line">        app.onCreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>咋样？原来Application的onCreate生命周期方法是在这里回调滴啊。</p>
<p>这样我们整个Application的创建执行流程就讲解完了。</p>
<p>总结：</p>
<ul>
<li><p>应用进程启动 –&gt; 创建Instrumentation –&gt; 创建Application对象 –&gt; 创建Application相关的ContextImpl对象；</p>
</li>
<li><p>ActivityThread.main方法–&gt; ActivityManagerService.bindApplication方法 –&gt; ActivityThread.handleBindApplication –&gt; 创建Instrumentation，创建Application；</p>
</li>
<li><p>每个应用进程对应一个Instrumentation，对应一个Application；</p>
</li>
<li><p>Instrumentation与Application都是通过java反射机制创建；</p>
</li>
<li><p>Application创建过程中会同时创建一个ContextImpl对象，并建立关联；</p>
</li>
</ul>
<p><br><br><br><br>接下来我们来看一下Acitivty中的Context创建流程，大家都知道我们Activity的具体创建过程是在ActivityThread的performLaunchActivity,可参见：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener"> android源码解析之（十四）–&gt;Activity启动流程</a>，这里我们看一下其具体的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity activity &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();</span><br><span class="line">            activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state !&#x3D; null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">			...</span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                Context appContext &#x3D; createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title &#x3D; r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config &#x3D; new Configuration(mCompatConfiguration);</span><br><span class="line">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                        + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">                if (customIntent !&#x3D; null) &#123;</span><br><span class="line">                    activity.mIntent &#x3D; customIntent;</span><br><span class="line">                &#125;</span><br><span class="line">                r.lastNonConfigurationInstances &#x3D; null;</span><br><span class="line">                activity.mStartedActivity &#x3D; false;</span><br><span class="line">                int theme &#x3D; r.activityInfo.getThemeResource();</span><br><span class="line">                if (theme !&#x3D; 0) &#123;</span><br><span class="line">                    activity.setTheme(theme);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.mCalled &#x3D; false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity &#x3D; activity;</span><br><span class="line">                r.stopped &#x3D; true;</span><br><span class="line">                if (!r.activity.mFinished) &#123;</span><br><span class="line">                    activity.performStart();</span><br><span class="line">                    r.stopped &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!r.activity.mFinished) &#123;</span><br><span class="line">                    if (r.isPersistable()) &#123;</span><br><span class="line">                        if (r.state !&#x3D; null || r.persistentState !&#x3D; null) &#123;</span><br><span class="line">                            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                    r.persistentState);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else if (r.state !&#x3D; null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里简要说明一下，Activity也是系统通过反射机制创建的，然后我们通过LockedApk.makeApplication创建一个Application，通过查看源码我们知道若这时候LockedApk中的mApplication不为空则直接返回当前的mApplication又因为当我们创建应用进程的时候Application已经被创建，所以当创建Activity的时候这时候Application肯定不为空，所以这时候返回的就是应用进程创建的时候创建的Application，这也从侧面说明了一个应用进程对应着一个Application。然后我们通过createBaseContextForActivity创建了一个ContextImpl对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123;</span><br><span class="line">        int displayId &#x3D; Display.DEFAULT_DISPLAY;</span><br><span class="line">        try &#123;</span><br><span class="line">            displayId &#x3D; ActivityManagerNative.getDefault().getActivityDisplayId(r.token);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ContextImpl appContext &#x3D; ContextImpl.createActivityContext(</span><br><span class="line">                this, r.packageInfo, displayId, r.overrideConfig);</span><br><span class="line">        appContext.setOuterContext(activity);</span><br><span class="line">        Context baseContext &#x3D; appContext;</span><br><span class="line"></span><br><span class="line">        final DisplayManagerGlobal dm &#x3D; DisplayManagerGlobal.getInstance();</span><br><span class="line">        &#x2F;&#x2F; For debugging purposes, if the activity&#39;s package name contains the value of</span><br><span class="line">        &#x2F;&#x2F; the &quot;debug.use-second-display&quot; system property as a substring, then show</span><br><span class="line">        &#x2F;&#x2F; its content on a secondary display if there is one.</span><br><span class="line">        String pkgName &#x3D; SystemProperties.get(&quot;debug.second-display.pkg&quot;);</span><br><span class="line">        if (pkgName !&#x3D; null &amp;&amp; !pkgName.isEmpty()</span><br><span class="line">                &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) &#123;</span><br><span class="line">            for (int id : dm.getDisplayIds()) &#123;</span><br><span class="line">                if (id !&#x3D; Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                    Display display &#x3D;</span><br><span class="line">                            dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id));</span><br><span class="line">                    baseContext &#x3D; appContext.createDisplayContext(display);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return baseContext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里创建了一个ContextImpl对象，并通过ContextImpl的setOuterContext方法，让该ContextImpl持有了Activity的引用，继续往下看，我们调用了activity.attach方法，查看一下该方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">            Instrumentation instr, IBinder token, int ident,</span><br><span class="line">            Application application, Intent intent, ActivityInfo info,</span><br><span class="line">            CharSequence title, Activity parent, String id,</span><br><span class="line">            NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">            Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">        mFragments.attachHost(null &#x2F;*parent*&#x2F;);</span><br><span class="line"></span><br><span class="line">        mWindow &#x3D; new PhoneWindow(this);</span><br><span class="line">        mWindow.setCallback(this);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">        mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">        if (info.softInputMode !&#x3D; WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">            mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">        &#125;</span><br><span class="line">        if (info.uiOptions !&#x3D; 0) &#123;</span><br><span class="line">            mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        mUiThread &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        mMainThread &#x3D; aThread;</span><br><span class="line">        mInstrumentation &#x3D; instr;</span><br><span class="line">        mToken &#x3D; token;</span><br><span class="line">        mIdent &#x3D; ident;</span><br><span class="line">        mApplication &#x3D; application;</span><br><span class="line">        mIntent &#x3D; intent;</span><br><span class="line">        mReferrer &#x3D; referrer;</span><br><span class="line">        mComponent &#x3D; intent.getComponent();</span><br><span class="line">        mActivityInfo &#x3D; info;</span><br><span class="line">        mTitle &#x3D; title;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">        mEmbeddedID &#x3D; id;</span><br><span class="line">        mLastNonConfigurationInstances &#x3D; lastNonConfigurationInstances;</span><br><span class="line">        if (voiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            if (lastNonConfigurationInstances !&#x3D; null) &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) !&#x3D; 0);</span><br><span class="line">        if (mParent !&#x3D; null) &#123;</span><br><span class="line">            mWindow.setContainer(mParent.getWindow());</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; mWindow.getWindowManager();</span><br><span class="line">        mCurrentConfig &#x3D; config;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>除了一下初始化操作之外，还调用了attachBaseContext方法，让Activity持有了ContextImpl的引用，这样就相当于Activity与ContextImpl对象相互持有了对方的引用，并且Activity是继承与Context。</p>
<p>总结：</p>
<ul>
<li><p>Activity中创建ContextImpl对象的具体实现在ActivityThread的performLauncherAcitivty方法中；</p>
</li>
<li><p>Activity的创建伴随着ContextImpl的创建，二者相互持有对方的引用；</p>
</li>
<li><p>创建Activity –&gt; 创建Activity相关ContextImpl对象；</p>
</li>
<li><p>创建应用进程 –&gt; 创建Application –&gt; 创建Application相关ContextImpl对象；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/15%20activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/15%20activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">15 activity销毁流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>继续我们的源码解析，上一篇文章我们介绍了Activity的启动流程，一个典型的场景就是Activity a 启动了一个Activity b，他们的生命周期回调方法是：<br>onPause(a) –&gt; onCreate(b) –&gt; onStart(b) –&gt; onResume(b) –&gt; onStop(a)<br>而我们根据源码也验证了这样的生命周期调用序列，那么Activity的销毁流程呢？它的生命周期的调用顺序又是这样的呢？</p>
<p>这里我们我做一个简单的demo，让一个Activity a启动Activity b，然后在b中调用finish()方法，它们的生命周期执行顺序是：</p>
<blockquote>
<p>onPause(b)<br>onRestart(a)<br>onStart(a)<br>onResume(a)<br>onStop(b)<br>onDestory(b)</p>
</blockquote>
<p>好吧，根据我们测试的生命周期方法的回调过程开始对Activity销毁流程的分析，一般而言当我们需要销毁Activity的时候都会调用其自身的finish方法，所以我们的流程开始是以finish方法开始的。</p>
<p><br><strong><font size="6">一：请求销毁当前Activity</p>
<blockquote>
<font color="red">
MyActivity.finish()
Activity.finish()
ActivityManagerNative.getDefault().finishActivity()
ActivityManagerService.finishActivity()
ActivityStack.requestFinishActivityLocked()
ActivityStack.finishActivityLocked()
ActivityStack.startPausingLocked()
</font>
</blockquote>
<p>首先我们在自己的Activity调用了finish方法，它实际上调用的是Activity的finish方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void finish() &#123;</span><br><span class="line">    finish(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以发现其调用了finish方法的重载方法，并且传递了一个参数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void finish(boolean finishTask) &#123;</span><br><span class="line">        if (mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            int resultCode;</span><br><span class="line">            Intent resultData;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                resultCode &#x3D; mResultCode;</span><br><span class="line">                resultData &#x3D; mResultData;</span><br><span class="line">            &#125;</span><br><span class="line">            if (false) Log.v(TAG, &quot;Finishing self: token&#x3D;&quot; + mToken);</span><br><span class="line">            try &#123;</span><br><span class="line">                if (resultData !&#x3D; null) &#123;</span><br><span class="line">                    resultData.prepareToLeaveProcess();</span><br><span class="line">                &#125;</span><br><span class="line">                if (ActivityManagerNative.getDefault()</span><br><span class="line">                        .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;</span><br><span class="line">                    mFinished &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; Empty</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mParent.finishFromChild(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这个参数值似乎并没什么用。。。这里就不在讨论了，然后调用了ActivityManagerNative.getDefault().finishActivity方法，好吧，根据上一篇文章的介绍，我们知道了ActivityManagerNative是一个Binder对象，这里调用的方法最终会被ActivityManagerService执行，所以这了的finishActivity最终被执行的是ActivityManagerService.finishActivity方法，好吧，我们来看一下ActivityManagerService的finishActivity方法的执行逻辑。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, boolean finishTask) &#123;</span><br><span class="line">     ...</span><br><span class="line">     res &#x3D; tr.stack.requestFinishActivityLocked(token, resultCode,resultData, &quot;app-request&quot;, true);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以发现，经过一系列逻辑判断之后，最终调用了ActivityStack的requestFinishActivityLocked方法，这里应该就是执行finish Activity的逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final boolean requestFinishActivityLocked(IBinder token, int resultCode,</span><br><span class="line">            Intent resultData, String reason, boolean oomAdj) &#123;</span><br><span class="line">        ActivityRecord r &#x3D; isInStackLocked(token);</span><br><span class="line">        if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                &quot;Finishing activity token&#x3D;&quot; + token + &quot; r&#x3D;&quot;</span><br><span class="line">                + &quot;, result&#x3D;&quot; + resultCode + &quot;, data&#x3D;&quot; + resultData</span><br><span class="line">                + &quot;, reason&#x3D;&quot; + reason);</span><br><span class="line">        if (r &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finishActivityLocked(r, resultCode, resultData, reason, oomAdj);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法体里面又调用了finishActivityLocked方法，那我们继续看一下finishActivityLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,</span><br><span class="line">            String reason, boolean oomAdj) &#123;</span><br><span class="line">        ...</span><br><span class="line">        startPausingLocked(false, false, false, false);</span><br><span class="line">		...</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，在这里调用了startPausingLocked方法，看名字应该是开始要执行Activity的onPause方法请求了，然后我们看一下startPausingLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) &#123;</span><br><span class="line">       ...</span><br><span class="line">            try &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</span><br><span class="line">                        prev.userId, System.identityHashCode(prev),</span><br><span class="line">                        prev.shortComponentName);</span><br><span class="line">                mService.updateUsageStats(prev, false);</span><br><span class="line">                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                        userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore exception, if process died other code will cleanup.</span><br><span class="line">                Slog.w(TAG, &quot;Exception thrown during pause&quot;, e);</span><br><span class="line">                mPausingActivity &#x3D; null;</span><br><span class="line">                mLastPausedActivity &#x3D; null;</span><br><span class="line">                mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样从应用程序调用finish方法，ActivityManagerService接收请求并执行startPausingLocked方法。</p>
<p><br><strong><font size="6">二：执行当前Activity的onPause方法</p>
<blockquote>
<font color="red">
IApplicationThread.schedulePauseActivity()
ActivityThread.schedulePauseActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handlePauseActivity()
ActivityThread.performPauseActivity()
Instrumentation.callActivityOnPause()
Activity.performPause()
Activity.onPause()
ActivityManagerNative.getDefault().activityPaused()
ActivityManagerService.activityPaused()
ActivityStack.activityPausedLocked()
ActivityStack.completePauseLocked()
</font>
</blockquote>
<p>在方法startPausingLocked中我们调用了：prev.app.thread.schedulePauseActivity这里实际上调用的是IApplicationThread的schedulePauseActivity方法，IApplicationThread也是一个Binder对象，它是ActivityThread中ApplicationThread的Binder client端，所以最终会调用的是ApplicationThread的schedulePauseActivity方法，好吧我们看一下ActivityThread的schedulePauseActivity方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">   sendMessage(</span><br><span class="line">       finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">       token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0),</span><br><span class="line">                    configChanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了ActivityThread的sendMessage方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2) &#123;</span><br><span class="line">        sendMessage(what, obj, arg1, arg2, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后又回调了sendMessage的重载方法。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">        Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.what &#x3D; what;</span><br><span class="line">        msg.obj &#x3D; obj;</span><br><span class="line">        msg.arg1 &#x3D; arg1;</span><br><span class="line">        msg.arg2 &#x3D; arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用mH发送异步消息，然后在mH的handleMessge方法中处理异步消息并调用handlePauseActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;Slog.v(TAG, &quot;userLeaving&#x3D;&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里回调了performPauseActivity方法，上篇文章中我们已经分析过了这段代码：</p>
<blockquote>
<p>performPauseActivity()<br>Instrumentation.callActivityOnPause()<br>Activity.performPause()<br>Activity.onPause()</p>
</blockquote>
<p>这样我们就回调了第一个生命周期方法：onPause。。。</p>
<p>在handlePauseActivity方法中我们调用了ActivityManagerNative.getDefault().activityPaused(token)方法，好吧又是回调ActivityManagerService的方法，这样最终会调用ActivityManagerService的activityPaused方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityPaused(IBinder token) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                stack.activityPausedLocked(token, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们继续看一下activityPausedLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void activityPausedLocked(IBinder token, boolean timeout) &#123;</span><br><span class="line">        ...</span><br><span class="line">        completePauseLocked(true);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面又经过一系列的逻辑判断之后，开始执行completePauseLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void completePauseLocked(boolean resumeNext) &#123;</span><br><span class="line">	...                   mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null);</span><br><span class="line">	...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样栈顶Activity的onPause操作就执行完成了，接下来就就是开始执行上一个Activity的onResume操作了。。。</p>
<p></br><strong><font size="6">三：执行上一个Activity的onResume操作</font></strong><br>这样调用了ActivityStackSupervisor.resumeTopActivitiesLocked方法。。，又开始调用这个方法，通过上一篇文章的介绍，我们知道这个方法实际上是执行Activity的初始化，我们看一下其具体的调用过程：</p>
<blockquote>
<font color="red">
ActivityStack.resumeTopActivityLocked()
ActivityStack.resumeTopInnerLocked()
IApplicationThread.scheduleResumeActivity()
ActivityThread.scheduleResumeActivity()
ActivityThread.sendMessage()
ActivityTherad.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.H.handleResumeMessage()
Activity.performResume()
Activity.performRestart()
Instrumentation.callActivityOnRestart()
Activity.onRestart()
Activity.performStart()
Instrumentation.callActivityOnStart()
Activity.onStart()
Instrumentation.callActivityOnResume()
Activity.onResume()
</font>
</blockquote>
<p>好吧，这个过程其实上一篇文章中已经做了介绍，这里不做过多的分析了，通过这样调用过程我们最终执行了当前栈顶Activity上一个Activity的onRestart方法，onStart方法，onResume方法等，下面我们将调用栈顶Activity的onStop方法，onDestory方法。</p>
<p></br><strong><font size="6">四：执行栈顶Activity的销毁操作</p>
<blockquote>
<font color="red">
Looper.myQueue().addIdleHandler(new Idler())
ActivityManagerNative.getDefault().activityIdle()
ActivityManagerService.activityIdle()
ActivityStackSupervisor.activityIdleInternalLocked()
ActivityStack.destroyActivityLocked()
IApplicationThread.scheduleDestoryActivity()
ActivityThread.scheduleDestoryActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handleDestoryActivity()
ActivityThread.performDestoryActivity()
Activity.performStop()
Instrumentation.callActivityOnStop()
Activity.onStop()
Instrumentation.callActivityOnDestory()
Activity.performDestory()
Acitivity.onDestory()
ActivityManagerNative.getDefault().activityDestoryed()
ActivityManagerService.activityDestoryed()
ActivityStack.activityDestoryedLocked()
</font>
</blockquote>
<p>我们在ActivityThread.handleResumeActivity方法中调用了Looper.myQueue().addIdleHandler(new Idler())，下面看一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean queueIdle() &#123;</span><br><span class="line">            ActivityClientRecord a &#x3D; mNewActivities;</span><br><span class="line">            boolean stopProfiling &#x3D; false;</span><br><span class="line">            if (mBoundApplication !&#x3D; null &amp;&amp; mProfiler.profileFd !&#x3D; null</span><br><span class="line">                    &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">                stopProfiling &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a !&#x3D; null) &#123;</span><br><span class="line">                mNewActivities &#x3D; null;</span><br><span class="line">                IActivityManager am &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">                ActivityClientRecord prev;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (localLOGV) Slog.v(</span><br><span class="line">                        TAG, &quot;Reporting idle of &quot; + a +</span><br><span class="line">                        &quot; finished&#x3D;&quot; +</span><br><span class="line">                        (a.activity !&#x3D; null &amp;&amp; a.activity.mFinished));</span><br><span class="line">                    if (a.activity !&#x3D; null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                            a.createdConfig &#x3D; null;</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Ignore</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev &#x3D; a;</span><br><span class="line">                    a &#x3D; a.nextIdle;</span><br><span class="line">                    prev.nextIdle &#x3D; null;</span><br><span class="line">                &#125; while (a !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (stopProfiling) &#123;</span><br><span class="line">                mProfiler.stopProfiling();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>内部有一个queueIdle的回调方法，当它被添加到MessageQueue之后就会回调该方法，我们可以发现在这个方法体中调用了ActivityManagerNative.getDefault.activityIdle方法，通过上一篇文章以及上面的讲解，我们应该知道这了最终调用的是ActivityManagerService.activityIdle方法，好吧，这里看一下activityIdle方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                ActivityRecord r &#x3D;</span><br><span class="line">                        mStackSupervisor.activityIdleInternalLocked(token, false, config);</span><br><span class="line">                if (stopProfiling) &#123;</span><br><span class="line">                    if ((mProfileProc &#x3D;&#x3D; r.app) &amp;&amp; (mProfileFd !&#x3D; null)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            mProfileFd.close();</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        clearProfilerLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里又调用了ActivityStackSupervisor.activityIdleInternalLocked方法，然后我们看一下activityIdleInternalLocked方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123;</span><br><span class="line">    ....   </span><br><span class="line">    stack.destroyActivityLocked(r, true, &quot;finish-idle&quot;);</span><br><span class="line">    ....    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用ActivityStack.destroyActivityLocked方法，可以看一下其具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) &#123;</span><br><span class="line">      ...</span><br><span class="line">      r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags);</span><br><span class="line">      ...      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里又开始执行IApplicationThread.scheduleDestoryActivity方法，上文已经做了说明这里最终调用的是ActivityThread.scheduleDestroyActivity方法，好吧，看一下ActivityThread.scheduleDestryActivity方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleDestroyActivity(IBinder token, boolean finishing, int configChanges) &#123;</span><br><span class="line">    sendMessage(H.DESTROY_ACTIVITY, token, finishing ? 1 : 0,</span><br><span class="line">                    configChanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有开始执行sendMessage方法，通过一系列的调用sendMessage方法最终调用了handleDestroyActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private void handleDestroyActivity(IBinder token, boolean finishing,</span><br><span class="line">            int configChanges, boolean getNonConfigInstance) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; performDestroyActivity(token, finishing,</span><br><span class="line">                configChanges, getNonConfigInstance);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            cleanUpPendingRemoveWindows(r);</span><br><span class="line">            WindowManager wm &#x3D; r.activity.getWindowManager();</span><br><span class="line">            View v &#x3D; r.activity.mDecor;</span><br><span class="line">            if (v !&#x3D; null) &#123;</span><br><span class="line">                if (r.activity.mVisibleFromServer) &#123;</span><br><span class="line">                    mNumVisibleActivities--;</span><br><span class="line">                &#125;</span><br><span class="line">                IBinder wtoken &#x3D; v.getWindowToken();</span><br><span class="line">                if (r.activity.mWindowAdded) &#123;</span><br><span class="line">                    if (r.onlyLocalRequest) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Hold off on removing this until the new activity&#39;s</span><br><span class="line">                        &#x2F;&#x2F; window is being added.</span><br><span class="line">                        r.mPendingRemoveWindow &#x3D; v;</span><br><span class="line">                        r.mPendingRemoveWindowManager &#x3D; wm;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        wm.removeViewImmediate(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (wtoken !&#x3D; null &amp;&amp; r.mPendingRemoveWindow &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    WindowManagerGlobal.getInstance().closeAll(wtoken,</span><br><span class="line">                            r.activity.getClass().getName(), &quot;Activity&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mDecor &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r.mPendingRemoveWindow &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; If we are delaying the removal of the activity window, then</span><br><span class="line">                &#x2F;&#x2F; we can&#39;t clean up all windows here.  Note that we can&#39;t do</span><br><span class="line">                &#x2F;&#x2F; so later either, which means any windows that aren&#39;t closed</span><br><span class="line">                &#x2F;&#x2F; by the app will leak.  Well we try to warning them a lot</span><br><span class="line">                &#x2F;&#x2F; about leaking windows, because that is a bug, so if they are</span><br><span class="line">                &#x2F;&#x2F; using this recreate facility then they get to live with leaks.</span><br><span class="line">                WindowManagerGlobal.getInstance().closeAll(token,</span><br><span class="line">                        r.activity.getClass().getName(), &quot;Activity&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Mocked out contexts won&#39;t be participating in the normal</span><br><span class="line">            &#x2F;&#x2F; process lifecycle, but if we&#39;re running with a proper</span><br><span class="line">            &#x2F;&#x2F; ApplicationContext we need to have it tear down things</span><br><span class="line">            &#x2F;&#x2F; cleanly.</span><br><span class="line">            Context c &#x3D; r.activity.getBaseContext();</span><br><span class="line">            if (c instanceof ContextImpl) &#123;</span><br><span class="line">                ((ContextImpl) c).scheduleFinalCleanup(</span><br><span class="line">                        r.activity.getClass().getName(), &quot;Activity&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (finishing) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityDestroyed(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the system process has died, it&#39;s game over for everyone.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了performDestroyActivity方法，用来执行Avtivity的onDestroy方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing,</span><br><span class="line">            int configChanges, boolean getNonConfigInstance) &#123;</span><br><span class="line">       ...     </span><br><span class="line">       r.activity.performStop();</span><br><span class="line">       ...</span><br><span class="line">       mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">	   ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了Activity.performStop()方法，查看performStop方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performStop() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mInstrumentation.callActivityOnStop(this);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了Instrumentation.callActivityOnStop()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnStop(Activity activity) &#123;</span><br><span class="line">        activity.onStop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，终于调用了Activity的onStop方法。。。</p>
<p>我们继续看一下Instrumentation.callActivityOnDestroy()。。。。又是通过Instrumentation来调用Activity的onDestroy方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnDestroy(Activity activity) &#123;</span><br><span class="line">    ...</span><br><span class="line">    activity.performDestroy();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下Activity的performDestroy()方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final void performDestroy() &#123;</span><br><span class="line">        mDestroyed &#x3D; true;</span><br><span class="line">        mWindow.destroy();</span><br><span class="line">        mFragments.dispatchDestroy();</span><br><span class="line">        onDestroy();</span><br><span class="line">        mFragments.doLoaderDestroy();</span><br><span class="line">        if (mVoiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            mVoiceInteractor.detachActivity();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，终于回调了Activity的onDestroy方法。。。。</p>
<p></br></br></br><br><strong><font size="5">总结：</p>
<ul>
<li><p>Activity的销毁流程是从finish方法开始的</p>
</li>
<li><p>Activity销毁过程是：onPause –&gt; onRestart –&gt; onStart –&gt; onResume –&gt; onStop –&gt; onDestroy</p>
</li>
<li><p>Activity的销毁流程是ActivityThread与ActivityManagerService相互配合销毁的</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
