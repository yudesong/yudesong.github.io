<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Kotlin 实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:19:43 / 修改时间：11:21:15" itemprop="dateCreated datePublished" datetime="2020-05-31T11:19:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Kotlin-引入-Android-项目"><a href="#Kotlin-引入-Android-项目" class="headerlink" title="Kotlin 引入 Android 项目"></a>Kotlin 引入 Android 项目</h4><p>Kotlin是基于JVM新的编程语言，由 JetBrains 开发，可以编译成java字节码，也可以编译成JavaScript。而JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，也在 Apache 许可下已经开源其Kotlin 编程语言。</p>
<h5 id="一、导入依赖库"><a href="#一、导入依赖库" class="headerlink" title="一、导入依赖库"></a>一、导入依赖库</h5><ul>
<li><p>在工程根目录bulid.grade文件添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version &#x3D; &#39;1.3.21&#39;</span><br><span class="line">    </span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>app或者module工程， bulid.grade文件添加一下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;kotlin-android&#39;</span><br><span class="line">apply plugin: &#39;kotlin-android-extensions&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h5><ul>
<li>Activity 中使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    </span><br><span class="line">    private var mRecyclerView: RecyclerView? &#x3D; null</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 定义静态方法</span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val KEY_FROM: String &#x3D; &quot;key_from&quot;</span><br><span class="line">        const val KEY_SHOW_OPEN_VIEW &#x3D; &quot;key_show_open_view&quot;</span><br><span class="line">        </span><br><span class="line">        fun startActivity(context: Context, from: String, showOpen: Boolean) &#123;</span><br><span class="line">            var intent &#x3D; Intent(context, MainActivity::class.java)</span><br><span class="line">            intent.putExtra(KEY_FROM, from)</span><br><span class="line">            intent.putExtra(KEY_SHOW_OPEN_VIEW, showOpen)</span><br><span class="line">            if (context !is Activity) &#123;</span><br><span class="line">               intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class="line">            &#125;</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        handlerIntent()</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun handlerIntent() &#123;</span><br><span class="line">        if (intent !&#x3D; null) &#123;</span><br><span class="line">            mFrom &#x3D; intent.getStringExtra(KEY_FROM)</span><br><span class="line">            mShowOpenView &#x3D; intent.getBooleanExtra(KEY_SHOW_OPEN_VIEW, false)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun initView() &#123;</span><br><span class="line">        mRecyclerView &#x3D; findViewById(R.id.recycler_view)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、常用设计模式-Kotlin代码示例"><a href="#三、常用设计模式-Kotlin代码示例" class="headerlink" title="三、常用设计模式 Kotlin代码示例"></a>三、常用设计模式 Kotlin代码示例</h5><h6 id="3-1-单例模式"><a href="#3-1-单例模式" class="headerlink" title="3.1 单例模式"></a>3.1 单例模式</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoRewardHelper</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mInstance = SingletonHolder.mInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> SingletonHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> mInstance = VideoRewardHelper()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-基于RxJava实现观察者模式"><a href="#3-2-基于RxJava实现观察者模式" class="headerlink" title="3.2 基于RxJava实现观察者模式"></a>3.2 基于RxJava实现观察者模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.Observable;</span><br><span class="line">import io.reactivex.subjects.PublishSubject;</span><br><span class="line">import io.reactivex.subjects.Subject;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 基于RxJava的事总线</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 单例模式 &amp; 门面模式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RxBus&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private volatile Subject&lt;T&gt; mSubject;</span><br><span class="line"></span><br><span class="line">    private RxBus() &#123;</span><br><span class="line">        mSubject &#x3D; PublishSubject.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Singleton &#123;</span><br><span class="line">        public static RxBus mInstance &#x3D; new RxBus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RxBus getInstance() &#123;</span><br><span class="line">        return Singleton.mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sendPost(T t) &#123;</span><br><span class="line">        mSubject.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sendComplete() &#123;</span><br><span class="line">        mSubject.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Observable&lt;T&gt; getObservable() &#123;</span><br><span class="line">        return mSubject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Disposable disposable;</span><br><span class="line"></span><br><span class="line">private Observer&lt;StatusInfo&gt; mObserver &#x3D; new Observer&lt;StatusInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        disposable &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(StatusInfo info) &#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RxBus.getInstance().getObservable().subscribeOn(AndroidSchedulers.mainThread()).subscribe(mObserver);</span><br></pre></td></tr></table></figure>

<h6 id="2-解注册"><a href="#2-解注册" class="headerlink" title="2. 解注册"></a>2. 解注册</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (disposable !&#x3D; null &amp;&amp; !disposable.isDisposed()) &#123;</span><br><span class="line">    XLLog.d(&quot;Rxjava&quot;, &quot;dispose: &quot;);</span><br><span class="line">    disposable.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-普通观察者模式"><a href="#3-3-普通观察者模式" class="headerlink" title="3.3 普通观察者模式"></a>3.3 普通观察者模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">interface CountDownObserver &#123;</span><br><span class="line">    fun onTimer(resource: PostResource)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountDownObservable : Observable&lt;CountDownObserver&gt;() &#123;</span><br><span class="line">    fun onTimer(resource: PostResource) &#123;</span><br><span class="line">        if (mObservers.isNotEmpty()) &#123;</span><br><span class="line">            val observers &#x3D; ArrayList&lt;CountDownObserver&gt;(mObservers)</span><br><span class="line">            for (observer in observers) &#123;</span><br><span class="line">                observer.onTimer(resource)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountDownManager &#123;</span><br><span class="line">    private var mCountDownObservable: CountDownObservable &#x3D; CountDownObservable()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        var TAG: String &#x3D; &quot;CountDownManager&quot;</span><br><span class="line">        val mInstance &#x3D; SingletonHolder.mInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private object SingletonHolder &#123;</span><br><span class="line">        val mInstance &#x3D; CountDownManager()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun registerCountDownObserver(observer: CountDownObserver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mCountDownObservable.registerObserver(observer)</span><br><span class="line">        &#125; catch (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun unregisterCountDownObserver(observer: CountDownObserver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mCountDownObservable.unregisterObserver(observer)</span><br><span class="line">        &#125; catch (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun notifyOnTimer(resource: PostResource) &#123;</span><br><span class="line">        mCountDownObservable.onTimer(resource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Glide 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:17:43" itemprop="dateCreated datePublished" datetime="2020-05-31T11:17:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Glide-源码剖析"><a href="#Glide-源码剖析" class="headerlink" title="Glide 源码剖析"></a>Glide 源码剖析</h4><p><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a>是Google出品的一款性能优异的图片加载框架。</p>
<p>依赖库导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">  google()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;</span><br><span class="line">  annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(myFragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .centerCrop()</span><br><span class="line">    .placeholder(R.drawable.loading_spinner)</span><br><span class="line">    .into(myImageView);</span><br></pre></td></tr></table></figure>

<h5 id="对比图片加载框架"><a href="#对比图片加载框架" class="headerlink" title="对比图片加载框架"></a>对比图片加载框架</h5><p>下面我们将会带着以下一些问题深入的剖析源码，去寻找答案。</p>
<ul>
<li>Glide的with方法是如何绑定Activity/Fragment生命周期的？</li>
<li>Glide的网络请求是怎样发出的？</li>
<li>Glide请求完成之后，图片是如何展示的？</li>
<li>Glide的缓存策略是什么样的？</li>
<li>Glide的OOM解决办法？</li>
<li>Glide自定义BitmapTransformation</li>
</ul>
<h6 id="1-with-Context-方法，返回RequestManager"><a href="#1-with-Context-方法，返回RequestManager" class="headerlink" title="1. with(Context)方法，返回RequestManager"></a>1. with(Context)方法，返回RequestManager</h6><p>Glide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Glide &#123;</span><br><span class="line"></span><br><span class="line">  public static RequestManager with(Context context) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(Activity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(android.app.Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">**with()**方法重载了5个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RequestManagerRetriever.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManagerRetriever implements Handler.Callback {<br>    private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();</p>
<pre><code>public static RequestManagerRetriever get() {
    return INSTANCE;
}

public RequestManager get(Context context) {
    if (context == null) {
        throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);
    } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {
        if (context instanceof FragmentActivity) {
            return get((FragmentActivity) context);
        } else if (context instanceof Activity) {
            return get((Activity) context);
        } else if (context instanceof ContextWrapper) {
            return get(((ContextWrapper) context).getBaseContext());
        }
    }

    return getApplicationManager(context);
}

// 生命周期和Application相关连
private RequestManager getApplicationManager(Context context) {
    if (applicationManager == null) {
        synchronized (this) {
            if (applicationManager == null) {
                applicationManager = new RequestManager(context.getApplicationContext(),
                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
            }
        }
    }
    return applicationManager;
}

// activity.getSupportFragmentManager(),会创建SupportRequestManagerFragment
public RequestManager get(FragmentActivity activity) {
    if (Util.isOnBackgroundThread()) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        FragmentManager fm = activity.getSupportFragmentManager();
        return supportFragmentGet(activity, fm);
    }
}

RequestManager supportFragmentGet(Context context, FragmentManager fm) {
    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);
    // 内部新建ActivityFragmentLifecycle对象
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        // 将SupportRequestManagerFragment的LifeCycle注入到RequestManager
        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
     // 将current.getLifecycle()与 requestManager进行了绑定
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) {
    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        current = pendingSupportRequestManagerFragments.get(fm);
        if (current == null) {
            current = new SupportRequestManagerFragment();
            pendingSupportRequestManagerFragments.put(fm, current);
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}

// activity.getFragmentManager会创建RequestManagerFragment
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public RequestManager get(Activity activity) {
    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        android.app.FragmentManager fm = activity.getFragmentManager();
        return fragmentGet(activity, fm);
    }
}

@TargetApi(Build.VERSION_CODES.HONEYCOMB)
RequestManager fragmentGet(Context context, android.app.FragmentManager fm) {
    RequestManagerFragment current = getRequestManagerFragment(fm);
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {
    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        current = pendingRequestManagerFragments.get(fm);
        if (current == null) {
            current = new RequestManagerFragment();
            pendingRequestManagerFragments.put(fm, current);
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断如果是Application则创建RequestManager绑定Application，否则创建SupportRequestManagerFragment、RequestManagerFragment并将RequestManager与之绑定</span><br><span class="line"></span><br><span class="line">SupportRequestManagerFragment.java</span><br></pre></td></tr></table></figure>
<p>public class SupportRequestManagerFragment extends Fragment {<br>    private RequestManager requestManager;<br>    private final ActivityFragmentLifecycle lifecycle;</p>
<p>  @Override<br>    public void onStart() {<br>        super.onStart();<br>        lifecycle.onStart();<br>    }</p>
<pre><code>@Override
public void onStop() {
    super.onStop();
    lifecycle.onStop();
}

@Override
public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这样SupportRequestManagerFragment就和ActivityFragmentLifecycle进行了绑定管理者Fragment的生命周期</span><br><span class="line">在RequestManager的构造函数中会调用lifecycle.addListener(RequestManager.this);进行绑定。至此整个生命周期的传递过程就形成了。</span><br><span class="line">SupportRequestManagerFragment -&gt; ActivityFragmentLifecycle -&gt; RequestManager -&gt; requestTracker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 2. load()方法,返回DrawableTypeRequest</span><br><span class="line"></span><br><span class="line">RequestManager.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManager implements LifecycleListener {<br>  private final Lifecycle lifecycle;<br>  private final RequestTracker requestTracker;</p>
<pre><code>RequestManager(Context context, final Lifecycle lifecycle, ...) {
    ...
    if (Util.isOnBackgroundThread()) {
        new Handler(Looper.getMainLooper()).post(new Runnable() {
            @Override
            public void run() {
                lifecycle.addListener(RequestManager.this);
            }
        });
    } else {
        lifecycle.addListener(this);
    }
    ...
}

public DrawableTypeRequest&lt;String&gt; load(String string) {
    return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);
}

public DrawableTypeRequest&lt;String&gt; fromString() {
    return loadGeneric(String.class);
}

private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) {
    ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =
            Glide.buildFileDescriptorModelLoader(modelClass, context);
    if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
        throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot;
                + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot;
                + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;);
    }

    return optionsApplier.apply(
            new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
                    glide, requestTracker, lifecycle, optionsApplier));
}

@Override
public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) {
    super.load(model);
    return this;
}

@Override
public void onStart() {
    resumeRequests();
}

@Override
public void onStop() {
    pauseRequests();
}

@Override
public void onDestroy() {
    requestTracker.clearRequests();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DrawableTypeRequest.java</span><br></pre></td></tr></table></figure>
<p>public class DrawableTypeRequest<ModelType> extends DrawableRequestBuilder<ModelType> implements DownloadOptions {<br>    private final ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader;<br>    private final ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader;<br>    private final RequestManager.OptionsApplier optionsApplier;</p>
<pre><code>private static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide,
        ModelLoader&lt;A, InputStream&gt; streamModelLoader,
        ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass,
        Class&lt;R&gt; transcodedClass,
        ResourceTranscoder&lt;Z, R&gt; transcoder) {
    if (streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
        return null;
    }

    if (transcoder == null) {
        transcoder = glide.buildTranscoder(resourceClass, transcodedClass);
    }
    DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,
            resourceClass);
    ImageVideoModelLoader&lt;A&gt; modelLoader = new ImageVideoModelLoader&lt;A&gt;(streamModelLoader,
            fileDescriptorModelLoader);
    return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);
}

DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader,
        ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide,
        RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) {
    super(context, modelClass,
            buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,
                    GlideDrawable.class, null),
            glide, requestTracker, lifecycle);
    this.streamModelLoader = streamModelLoader;
    this.fileDescriptorModelLoader = fileDescriptorModelLoader;
    this.optionsApplier = optionsApplier;
}

public BitmapTypeRequest&lt;ModelType&gt; asBitmap() {
    return optionsApplier.apply(new BitmapTypeRequest&lt;ModelType&gt;(this, streamModelLoader,
            fileDescriptorModelLoader, optionsApplier));
}

public GifTypeRequest&lt;ModelType&gt; asGif() {
    return optionsApplier.apply(new GifTypeRequest&lt;ModelType&gt;(this, streamModelLoader, optionsApplier));
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DrawableRequestBuilder.java</span><br></pre></td></tr></table></figure>
<p>public class DrawableRequestBuilder<ModelType><br>        extends GenericRequestBuilder&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt;<br>        implements BitmapOptions, DrawableOptions {</p>
<pre><code>@Override
public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) {
    super.load(model); //调用其父类GenericRequestBuilder的load函数赋值model变量
    return this;
}

@Override
public Target&lt;GlideDrawable&gt; into(ImageView view) {
    return super.into(view);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">into()方法,返回Target对象</span><br><span class="line"></span><br><span class="line">GenericRequestBuilder.java</span><br></pre></td></tr></table></figure>
<p>public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable {<br>    protected final Glide glide;<br>    protected final Class<TranscodeType> transcodeClass;<br>    protected final RequestTracker requestTracker;<br>    protected final Lifecycle lifecycle;<br>    private GenericRequestBuilder&lt;?, ?, ?, TranscodeType&gt; thumbnailRequestBuilder;</p>
<pre><code>@Override
public Target&lt;GlideDrawable&gt; into(ImageView view) {
    return super.into(view);
}

/**
 * into ImageView 之后，才会去从缓存LruCache&lt;Key, Resource&lt;?&gt;&gt;、弱引用Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;、磁盘缓存diskCacheService、
 */

public Target&lt;TranscodeType&gt; into(ImageView view) {
    Util.assertMainThread();
    if (view == null) {
        throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;);
    }

    if (!isTransformationSet &amp;&amp; view.getScaleType() != null) {
        switch (view.getScaleType()) {
            case CENTER_CROP:
                applyCenterCrop();
                break;
            case FIT_CENTER:
            case FIT_START:
            case FIT_END:
                applyFitCenter();
                break;
            //$CASES-OMITTED$
            default:
                // Do nothing.
        }
    }

    return into(glide.buildImageViewTarget(view, transcodeClass));
}    

public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) {
    Util.assertMainThread();
    if (target == null) {
        throw new IllegalArgumentException(&quot;You must pass in a non null Target&quot;);
    }
    if (!isModelSet) {
        throw new IllegalArgumentException(&quot;You must first set a model (try #load())&quot;);
    }

    Request previous = target.getRequest();

    if (previous != null) {
        previous.clear();
        requestTracker.removeRequest(previous);
        previous.recycle();
    }

    Request request = buildRequest(target);
    target.setRequest(request);
    lifecycle.addListener(target);
    requestTracker.runRequest(request);

    return target;
}

// 根据是缩略图划分，返回ThumbnailRequestCoordinator、GenericRequest
private Request buildRequest(Target&lt;TranscodeType&gt; target) {
    if (priority == null) {
        priority = Priority.NORMAL;
    }
    return buildRequestRecursive(target, null);
}

private Request buildRequestRecursive(Target&lt;TranscodeType&gt; target, ThumbnailRequestCoordinator parentCoordinator) {
    if (thumbnailRequestBuilder != null) {
        if (isThumbnailBuilt) {
            throw new IllegalStateException(&quot;You cannot use a request as both the main request and a thumbnail, &quot;
                    + &quot;consider using clone() on the request(s) passed to thumbnail()&quot;);
        }
        // Recursive case: contains a potentially recursive thumbnail request builder.
        if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
            thumbnailRequestBuilder.animationFactory = animationFactory;
        }

        if (thumbnailRequestBuilder.priority == null) {
            thumbnailRequestBuilder.priority = getThumbnailPriority();
        }

        if (Util.isValidDimensions(overrideWidth, overrideHeight)
                &amp;&amp; !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                        thumbnailRequestBuilder.overrideHeight)) {
          thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
        }

        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
        // Guard against infinite recursion.
        isThumbnailBuilt = true;
        // Recursively generate thumbnail requests.
        Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
        isThumbnailBuilt = false;
        coordinator.setRequests(fullRequest, thumbRequest);
        return coordinator;
    } else if (thumbSizeMultiplier != null) {
        // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
        Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
        coordinator.setRequests(fullRequest, thumbnailRequest);
        return coordinator;
    } else {
        // Base case: no thumbnail.
        return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
    }
}

private Request obtainRequest(Target&lt;TranscodeType&gt; target, float sizeMultiplier, Priority priority,
        RequestCoordinator requestCoordinator) {
    return GenericRequest.obtain(
            loadProvider,
            model,
            signature,
            context,
            priority,
            target,
            sizeMultiplier,
            placeholderDrawable,
            placeholderId,
            errorPlaceholder,
            errorId,
            fallbackDrawable,
            fallbackResource,
            requestListener,
            requestCoordinator,
            glide.getEngine(),
            transformation,
            transcodeClass,
            isCacheable,
            animationFactory,
            overrideWidth,
            overrideHeight,
            diskCacheStrategy);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">网络请求</span><br><span class="line"></span><br><span class="line">RequestTracker.java (Request集合, 负责Request的执行，暂停，取消等等关于图片请求的操作)</span><br></pre></td></tr></table></figure>
<p>public class RequestTracker {<br>    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap&lt;Request, Boolean&gt;());<br>    private final List<Request> pendingRequests = new ArrayList<Request>();<br>    private boolean isPaused;</p>
<pre><code>public void runRequest(Request request) {
    requests.add(request);
    if (!isPaused) {
        request.begin();
    } else {
        pendingRequests.add(request);
    }
}

public void pauseRequests() {
    isPaused = true;
    for (Request request : Util.getSnapshot(requests)) {
        if (request.isRunning()) {
            request.pause();
            pendingRequests.add(request);
        }
    }
}

public void resumeRequests() {
    isPaused = false;
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled() &amp;&amp; !request.isRunning()) {
            request.begin();
        }
    }
    pendingRequests.clear();
}

public void restartRequests() {
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled()) {
            // Ensure the request will be restarted in onResume.
            request.pause();
            if (!isPaused) {
                request.begin();
            } else {
                pendingRequests.add(request);
            }
        }
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GenericRequest.java</span><br></pre></td></tr></table></figure>
<p>public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback,<br>        ResourceCallback {</p>
<pre><code>@Override
public void begin() {
    startTime = LogTime.getLogTime();
    if (model == null) {
        onException(null);
        return;
    }

    status = Status.WAITING_FOR_SIZE;
    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
        onSizeReady(overrideWidth, overrideHeight);
    } else {
        target.getSize(this);
    }

    if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) {
        // 设置Placeholder图片
        target.onLoadStarted(getPlaceholderDrawable());
        // 最终调用view.setImageDrawable(Drawable drawable)
    }
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));
    }
}    

@Override
public void onSizeReady(int width, int height) {
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));
    }
    if (status != Status.WAITING_FOR_SIZE) {
        return;
    }
    status = Status.RUNNING;

    width = Math.round(sizeMultiplier * width);
    height = Math.round(sizeMultiplier * height);

    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();
    final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);

    if (dataFetcher == null) {
        onException(new Exception(&quot;Failed to load model: \&apos;&quot; + model + &quot;\&apos;&quot;));
        return;
    }
    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));
    }
    loadedFromMemoryCache = true;
    // 开始网络加载图片
    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
            priority, isMemoryCacheable, diskCacheStrategy, this);
    loadedFromMemoryCache = resource != null;
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Engine.java</span><br></pre></td></tr></table></figure>
<p>public class Engine implements EngineJobListener,<br>        MemoryCache.ResourceRemovedListener,<br>        EngineResource.ResourceListener {</p>
<pre><code>public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher,
        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,
        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {
    Util.assertMainThread();
    long startTime = LogTime.getLogTime();

    final String id = fetcher.getId();
    // 根据请求key以及width、height一起构成了一个EngineKey, 如果width、height改变了，
    // 则会认为是一个新的Key，会重新缓存。
    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),
            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),
            transcoder, loadProvider.getSourceEncoder());

    // 1.从内存中获取，isMemoryCacheable：是否允许内存缓存策略
    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
        cb.onResourceReady(cached);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);
        }
        return null;
    }

    //2.从activeResources中获取 isMemoryCacheable：是否允许内存缓存策略
    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
        cb.onResourceReady(active);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);
        }
        return null;
    }


    EngineJob current = jobs.get(key);
    if (current != null) {
        current.addCallback(cb);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);
        }
        return new LoadStatus(cb, current);
    }

    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);
    DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,
            transcoder, diskCacheProvider, diskCacheStrategy, priority);
    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);
    jobs.put(key, engineJob);
    engineJob.addCallback(cb);
    engineJob.start(runnable);

    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);
    }
    return new LoadStatus(cb, engineJob);
}    </code></pre><p>}            </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EngineJob.java</span><br></pre></td></tr></table></figure>
<p>class EngineJob implements EngineRunnable.EngineRunnableManager {</p>
<pre><code>@Override
public void run() {
    if (isCancelled) {
        return;
    }

    Exception exception = null;
    Resource&lt;?&gt; resource = null;
    try {
        resource = decode();
    } catch (OutOfMemoryError e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, &quot;Out Of Memory Error decoding&quot;, e);
        }
        exception = new ErrorWrappingGlideException(e);
    } catch (Exception e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, &quot;Exception decoding&quot;, e);
        }
        exception = e;
    }

    if (isCancelled) {
        if (resource != null) {
            resource.recycle();
        }
        return;
    }

    if (resource == null) {
        onLoadFailed(exception);
    } else {
        onLoadComplete(resource);
    }
}

/**
 * 优先从磁盘缓存中寻找
 */
private Resource&lt;?&gt; decode() throws Exception {
    if (isDecodingFromCache()) {
        return decodeFromCache();
    } else {
        return decodeFromSource();
    }
}

// 进行网路请求
private Resource&lt;?&gt; decodeFromSource() throws Exception {
    return decodeJob.decodeFromSource();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**DecodeJob.java**</span><br></pre></td></tr></table></figure>
<p>class DecodeJob&lt;A, T, Z&gt; {</p>
<pre><code>public Resource&lt;Z&gt; decodeFromSource() throws Exception {
    // 网络请求
    Resource&lt;T&gt; decoded = decodeSource();
    // 对返回结果进行Encode编码
    return transformEncodeAndTranscode(decoded);
}

private Resource&lt;T&gt; decodeSource() throws Exception {
    Resource&lt;T&gt; decoded = null;
    try {
        // 最终会走到HttpUrlFetcher.loadData返回InputStream
        final A data = fetcher.loadData(priority);
        decoded = decodeFromSourceData(data);
    } finally {
        fetcher.cleanup();
    }
    return decoded;
}

// 此处最终会走到StreamBitmapDecoder的decode方法
// 计算sampleSize、
// Bitmap result = BitmapFactory.decodeStream(is, null, options);
private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException {
    final Resource&lt;T&gt; decoded;
    decoded = loadProvider.getSourceDecoder().decode(data, width, height);
    return decoded;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**HttpUrlFetcher**</span><br></pre></td></tr></table></figure>
<p>public class HttpUrlFetcher implements DataFetcher<InputStream> {</p>
<pre><code>private HttpURLConnection urlConnection;
private InputStream stream;

@Override
public InputStream loadData(Priority priority) throws Exception {
    return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
}

private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers)
        throws IOException {
    ...
    urlConnection = connectionFactory.build(url);
    for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(2500);
    urlConnection.setReadTimeout(2500);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) { // 200 OK
        return getStreamForSuccessfulRequest(urlConnection);
    } else if (statusCode / 100 == 3) { // 3XX 重定向
        String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);
        if (TextUtils.isEmpty(redirectUrlString)) {
            throw new IOException(&quot;Received empty or null redirect url&quot;);
        }
        URL redirectUrl = new URL(url, redirectUrlString);
        return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    }
    ...
}

private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection) throws IOException {
    ...
    stream = urlConnection.getInputStream();
    return stream;
}    </code></pre><p>}</p>
<p>```</p>
<p><img src="https://img-blog.csdn.net/20170515074139121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRXRoYW5Dbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Glide 执行过程"></p>
<h4 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h4><p><a href="https://blog.csdn.net/u011733020/article/details/52446902" target="_blank" rel="noopener">1. Glide（图片异步加载缓存库）发起request获取resource</a></p>
<p><a href="https://juejin.im/post/5e2109e25188254c257c40c6#heading-42" target="_blank" rel="noopener">2. Android主流三方库源码分析（三、深入理解Glide源码）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Picasso 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:16:36" itemprop="dateCreated datePublished" datetime="2020-05-31T11:16:36+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="Picasso简介"><a href="#Picasso简介" class="headerlink" title="Picasso简介"></a>Picasso简介</h5><p>Picasso是鼎鼎有名的Square公司的一个开源项目，该公司同时开源了许多知名的项目，比如Okhttp，Retrofit，Otto等。Picasso继承了Okhttp的链式调用风格，使得它使用起来非常简单和方便，并且它的设计和实现也很轻量简单，使得整个库的接口数量和体积都很小，因此被很多开发者使用在项目中。下面我们来看一下Picasso的总体设计：</p>
<p><img src="https://img-blog.csdnimg.cn/20190126151924568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rZ2F5cw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>Picasso是通过服务器来实现的本地缓存并且都是原图，因此如果能根据图片尺寸来控制缓存图片的大小可以进一步降低本地储存的空间和图片处理的开销。(Glide 就是根据不同的图片尺寸来缓存不同的图片)</p>
<h5 id="Picasso-源码剖析"><a href="#Picasso-源码剖析" class="headerlink" title="Picasso 源码剖析"></a>Picasso 源码剖析</h5><h6 id="get、load、with-函数"><a href="#get、load、with-函数" class="headerlink" title="get、load、with 函数"></a>get、load、with 函数</h6><p>Picasso.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">public class Picasso &#123;</span><br><span class="line">  static volatile Picasso singleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单例模式</span><br><span class="line">  public static Picasso get() &#123;</span><br><span class="line">    if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized (Picasso.class) &#123;</span><br><span class="line">        if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">          if (PicassoProvider.context &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;context &#x3D;&#x3D; null&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          singleton &#x3D; new Builder(PicassoProvider.context).build();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 构建模式，初始化Picasso关键成员变量</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    public Picasso build() &#123;</span><br><span class="line">      Context context &#x3D; this.context;</span><br><span class="line"></span><br><span class="line">      if (downloader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 图片下载</span><br><span class="line">        downloader &#x3D; new OkHttp3Downloader(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (cache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 内存缓存</span><br><span class="line">        cache &#x3D; new LruCache(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (service &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池 (默认开启3个线程, 根据网络WiFi-&gt;4 、4G-&gt;3、 3G-&gt;2, 2G-&gt;1)</span><br><span class="line">        service &#x3D; new PicassoExecutorService();</span><br><span class="line">      &#125;</span><br><span class="line">      if (transformer &#x3D;&#x3D; null) &#123;</span><br><span class="line">        transformer &#x3D; RequestTransformer.IDENTITY;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 记录缓存命中次数、丢失次数等</span><br><span class="line">      Stats stats &#x3D; new Stats(cache);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 分发器</span><br><span class="line">      Dispatcher dispatcher &#x3D; new Dispatcher(context, service, HANDLER, downloader, cache, stats);</span><br><span class="line"></span><br><span class="line">      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</span><br><span class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static final Handler HANDLER &#x3D; new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    @Override public void handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case HUNTER_BATCH_COMPLETE: &#123;</span><br><span class="line">          &#x2F;&#x2F; 更新UI界面</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;BitmapHunter&gt; batch &#x3D; (List&lt;BitmapHunter&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            BitmapHunter hunter &#x3D; batch.get(i);</span><br><span class="line">            hunter.picasso.complete(hunter); </span><br><span class="line">            &#x2F;&#x2F; 最终会调用action.complete(result, from);显示图片</span><br><span class="line">            &#x2F;&#x2F; 最终会调到这里：target.setImageDrawable(drawable)</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_GCED: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), &quot;target got garbage collected&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          action.picasso.cancelExistingRequest(action.getTarget());</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_BATCH_RESUME:</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;Action&gt; batch &#x3D; (List&lt;Action&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            Action action &#x3D; batch.get(i);</span><br><span class="line">            action.picasso.resumeAction(action);</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; load URL,会创建RequestCreator对象</span><br><span class="line">  public RequestCreator load(@Nullable String path) &#123;</span><br><span class="line">    if (path &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return new RequestCreator(this, null, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (path.trim().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return load(Uri.parse(path));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator load(@Nullable Uri uri) &#123;</span><br><span class="line">    return new RequestCreator(this, uri, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; RequestCreator会在into(ImageView)方法的时候，封装ImageViewAction extends Action</span><br><span class="line">  void enqueueAndSubmit(Action action) &#123;</span><br><span class="line">    Object target &#x3D; action.getTarget();</span><br><span class="line">    if (target !&#x3D; null &amp;&amp; targetToAction.get(target) !&#x3D; action) &#123;</span><br><span class="line">      &#x2F;&#x2F; This will also check we are on the main thread.</span><br><span class="line">      cancelExistingRequest(target);</span><br><span class="line">      targetToAction.put(target, action);</span><br><span class="line">    &#125;</span><br><span class="line">    submit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void submit(Action action) &#123;</span><br><span class="line">    dispatcher.dispatchSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Picasso 的get()方法采用双重检验锁形式获取Picasso单例，在<strong>new Picasso()</strong> 的时候采用Builder构造模式初始化Picasso关键成员变量。主要有<strong>PicassoExecutorService</strong>、<strong>OkHttp3Downloader</strong>、<strong>LruCache</strong>、<strong>Dispatcher</strong>。值得关注的是<strong>PicassoProvider</strong>这个内容提供者，<strong>onCreate</strong>方法的调用是ActivityThread的启动的时候就已经调用了，比Application的初始化要早。像这种获取Context对象黑技术在Leakcanary里面也是一样的。</p>
<p><strong>RequestCreator.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">public class RequestCreator &#123;</span><br><span class="line">  private final Picasso picasso;</span><br><span class="line">  private final Request.Builder data;</span><br><span class="line">  private boolean deferred;</span><br><span class="line"></span><br><span class="line">  RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123;</span><br><span class="line">    this.picasso &#x3D; picasso;</span><br><span class="line">    this.data &#x3D; new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator fit() &#123;</span><br><span class="line">    deferred &#x3D; true;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator placeholder(@NonNull Drawable placeholderDrawable) &#123;</span><br><span class="line">    this.placeholderDrawable &#x3D; placeholderDrawable;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static boolean isMain() &#123;</span><br><span class="line">    return Looper.getMainLooper().getThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void checkMain() &#123;</span><br><span class="line">    if (!isMain()) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Method call should happen from the main thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target) &#123;</span><br><span class="line">    into(target, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target, Callback callback) &#123;</span><br><span class="line">    long started &#x3D; System.nanoTime();</span><br><span class="line">    checkMain();</span><br><span class="line">    &#x2F;&#x2F; 检查Uri 或者 resourceId是否为空</span><br><span class="line">    if (!data.hasImage()) &#123;  &#x2F;&#x2F; -&gt; uri !&#x3D; null || resourceId !&#x3D; 0</span><br><span class="line">      picasso.cancelRequest(target);</span><br><span class="line">      if (setPlaceholder) &#123;</span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (deferred) &#123;</span><br><span class="line">      if (data.hasSize()) &#123;  &#x2F;&#x2F; -&gt; targetWidth !&#x3D; 0 || targetHeight !&#x3D; 0</span><br><span class="line">        throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      int width &#x3D; target.getWidth();</span><br><span class="line">      int height &#x3D; target.getHeight();</span><br><span class="line">      if (width &#x3D;&#x3D; 0 || height &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (setPlaceholder) &#123;</span><br><span class="line">          setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">        &#125;</span><br><span class="line">        picasso.defer(target, new DeferredRequestCreator(this, target, callback));</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      data.resize(width, height);  &#x2F;&#x2F; -&gt; this.targetWidth &#x3D; targetWidth; this.targetHeight &#x3D; targetHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; createRequest(started);</span><br><span class="line">    String requestKey &#x3D; createKey(request);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 缓存中存在，则从缓存中获取, 取消请求，返回缓存值</span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      Bitmap bitmap &#x3D; picasso.quickMemoryCacheCheck(requestKey);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        picasso.cancelRequest(target);</span><br><span class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (callback !&#x3D; null) &#123;</span><br><span class="line">          callback.onSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置placeholder</span><br><span class="line">    if (setPlaceholder) &#123;</span><br><span class="line">      setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建Action用于网络请求</span><br><span class="line">    Action action &#x3D;</span><br><span class="line">        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</span><br><span class="line">            errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line"></span><br><span class="line">    picasso.enqueueAndSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Request createRequest(long started) &#123;</span><br><span class="line">    int id &#x3D; nextId.getAndIncrement();</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; data.build();</span><br><span class="line">    request.id &#x3D; id;</span><br><span class="line">    request.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">    boolean loggingEnabled &#x3D; picasso.loggingEnabled;</span><br><span class="line">    if (loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request transformed &#x3D; picasso.transformRequest(request);</span><br><span class="line">    if (transformed !&#x3D; request) &#123;</span><br><span class="line">      &#x2F;&#x2F; If the request was changed, copy over the id and timestamp from the original.</span><br><span class="line">      transformed.id &#x3D; id;</span><br><span class="line">      transformed.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">      if (loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), &quot;into &quot; + transformed);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return transformed;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RequestCreator</strong>, 在into(ImageView)的时候会进行必要的参数校验，创建Request请求对象，从LruCache缓存中检测是否有已经请求的返回结果，如果有的则直接返回，否则创建ImageViewAction对象后面进行网络请求。<strong>picasso.enqueueAndSubmit(action)</strong> 最终会调到<strong>dispatcher.dispatchSubmit(action);</strong></p>
<p><strong>Dispatcher.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">class Dispatcher &#123;</span><br><span class="line">  final Map&lt;String, BitmapHunter&gt; hunterMap;</span><br><span class="line">  final Map&lt;Object, Action&gt; failedActions;</span><br><span class="line">  final Map&lt;Object, Action&gt; pausedActions;</span><br><span class="line"></span><br><span class="line">  private static class DispatcherHandler extends Handler &#123;</span><br><span class="line">    private final Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">    DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123;</span><br><span class="line">      super(looper);</span><br><span class="line">      this.dispatcher &#x3D; dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void handleMessage(final Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case REQUEST_SUBMIT: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performSubmit(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_CANCEL: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performCancel(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_PAUSE: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performPauseTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_RESUME: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performResumeTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，会回调到此处</span><br><span class="line">        case HUNTER_COMPLETE: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performComplete(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_RETRY: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performRetry(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DECODE_FAILED: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performError(hunter, false);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DELAY_NEXT_BATCH: &#123;</span><br><span class="line">          dispatcher.performBatchComplete();</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case NETWORK_STATE_CHANGE: &#123;</span><br><span class="line">          NetworkInfo info &#x3D; (NetworkInfo) msg.obj;</span><br><span class="line">          dispatcher.performNetworkStateChange(info);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case AIRPLANE_MODE_CHANGE: &#123;</span><br><span class="line">          dispatcher.performAirplaneModeChange(msg.arg1 &#x3D;&#x3D; AIRPLANE_MODE_ON);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">          Picasso.HANDLER.post(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 通过handler发送REQUEST_SUBMIT消息，最终会走到performSubmit(action)</span><br><span class="line">  void dispatchSubmit(Action action) &#123;</span><br><span class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void performSubmit(Action action) &#123;</span><br><span class="line">    performSubmit(action, true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * performSubmit执行过程：</span><br><span class="line">   * 1. 检查action 是否在pausedTags集合中，如果存在则直接替换覆盖</span><br><span class="line">   * 2. 如果action 存在hunterMap中， 则直接attach</span><br><span class="line">   * 3. 创建BitmapHunter，添加到PicassoExecutorService线程池</span><br><span class="line">   *&#x2F;</span><br><span class="line">  void performSubmit(Action action, boolean dismissFailed) &#123;</span><br><span class="line">    if (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">      pausedActions.put(action.getTarget(), action);</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</span><br><span class="line">            &quot;because tag &#39;&quot; + action.getTag() + &quot;&#39; is paused&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BitmapHunter hunter &#x3D; hunterMap.get(action.getKey());</span><br><span class="line">    if (hunter !&#x3D; null) &#123;</span><br><span class="line">      hunter.attach(action);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (service.isShutdown()) &#123;</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hunter &#x3D; forRequest(action.getPicasso(), this, cache, stats, action);</span><br><span class="line">    hunter.future &#x3D; service.submit(hunter);</span><br><span class="line">    hunterMap.put(action.getKey(), hunter);</span><br><span class="line">    if (dismissFailed) &#123;</span><br><span class="line">      failedActions.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 创建BitmapHunter对象</span><br><span class="line">   * 1. picasso.getRequestHandlers() 类似于拦截器作用，依次从ResourceRequestHandler、</span><br><span class="line">   * ContactsPhotoRequestHandler、MediaStoreRequestHandler、ContentStreamRequestHandler、</span><br><span class="line">   * AssetRequestHandler、FileRequestHandler、NetworkRequestHandler 调用canHandleRequest方法，判断交给那个Handler处理， 一般的网络图片就是NetworkRequestHandler</span><br><span class="line">   * </span><br><span class="line">   *&#x2F;</span><br><span class="line">  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span><br><span class="line">      Action action) &#123;</span><br><span class="line">    Request request &#x3D; action.getRequest();</span><br><span class="line">    List&lt;RequestHandler&gt; requestHandlers &#x3D; picasso.getRequestHandlers();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Index-based loop to avoid allocating an iterator.</span><br><span class="line">    &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">    for (int i &#x3D; 0, count &#x3D; requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">      RequestHandler requestHandler &#x3D; requestHandlers.get(i);</span><br><span class="line">      if (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">        return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 网络请求成功会回调到performComplete</span><br><span class="line">  void performComplete(BitmapHunter hunter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加到Cache缓存</span><br><span class="line">    if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">      cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    hunterMap.remove(hunter.getKey());</span><br><span class="line">    batch(hunter);</span><br><span class="line">    if (hunter.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), &quot;for completion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 网络返回结果，将hunter添加到batch之中，延迟200ms发送HUNTER_DELAY_NEXT_BATCH</span><br><span class="line">  private void batch(BitmapHunter hunter) &#123;</span><br><span class="line">    if (hunter.isCancelled()) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hunter.result !&#x3D; null) &#123;</span><br><span class="line">      hunter.result.prepareToDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    batch.add(hunter);</span><br><span class="line">    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知主线程更新UI界面</span><br><span class="line">  void performBatchComplete() &#123;</span><br><span class="line">    List&lt;BitmapHunter&gt; copy &#x3D; new ArrayList&lt;&gt;(batch);</span><br><span class="line">    batch.clear();</span><br><span class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</span><br><span class="line">    logBatch(copy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Dispatcher</strong>分发器的作用就是：调度网络请求，回调返回结果</p>
<p><strong>BitmapHunter.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class BitmapHunter implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void run() &#123;</span><br><span class="line">      ...</span><br><span class="line">      result &#x3D; hunt();</span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        dispatcher.dispatchFailed(this);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，回调到Dispatcher</span><br><span class="line">        dispatcher.dispatchComplete(this);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Bitmap hunt() throws IOException &#123;</span><br><span class="line">    Bitmap bitmap &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      bitmap &#x3D; cache.get(key);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        stats.dispatchCacheHit();</span><br><span class="line">        loadedFrom &#x3D; MEMORY;</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), &quot;from cache&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    networkPolicy &#x3D; retryCount &#x3D;&#x3D; 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">    RequestHandler.Result result &#x3D; requestHandler.load(data, networkPolicy);</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      loadedFrom &#x3D; result.getLoadedFrom();</span><br><span class="line">      exifOrientation &#x3D; result.getExifOrientation();</span><br><span class="line">      bitmap &#x3D; result.getBitmap();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If there was no Bitmap then we need to decode it from the stream.</span><br><span class="line">      if (bitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        Source source &#x3D; result.getSource();</span><br><span class="line">        try &#123;</span><br><span class="line">          bitmap &#x3D; decodeStream(source, data);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            &#x2F;&#x2F;noinspection ConstantConditions If bitmap is null then source is guranteed non-null.</span><br><span class="line">            source.close();</span><br><span class="line">          &#125; catch (IOException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bitmap !&#x3D; null) &#123;</span><br><span class="line">      if (picasso.loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</span><br><span class="line">      &#125;</span><br><span class="line">      stats.dispatchBitmapDecoded(bitmap);</span><br><span class="line">      if (data.needsTransformation() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">        synchronized (DECODE_LOCK) &#123;</span><br><span class="line">          if (data.needsMatrixTransform() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">            bitmap &#x3D; transformResult(data, bitmap, exifOrientation);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (data.hasCustomTransformations()) &#123;</span><br><span class="line">            bitmap &#x3D; applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), &quot;from custom transformations&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap !&#x3D; null) &#123;</span><br><span class="line">          stats.dispatchBitmapTransformed(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BitmapHunter</strong> 的run方法就是利用OKHttpClient进行网络请求</p>
<p>NetworkRequestHandler.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NetworkRequestHandler extends RequestHandler &#123;</span><br><span class="line"></span><br><span class="line">  @Override public Result load(Request request, int networkPolicy) throws IOException &#123;</span><br><span class="line">    okhttp3.Request downloaderRequest &#x3D; createRequest(request, networkPolicy);</span><br><span class="line">    Response response &#x3D; downloader.load(downloaderRequest);</span><br><span class="line">    ResponseBody body &#x3D; response.body();</span><br><span class="line"></span><br><span class="line">    if (!response.isSuccessful()) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ResponseException(response.code(), request.networkPolicy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache response is only null when the response comes fully from the network. Both completely</span><br><span class="line">    &#x2F;&#x2F; cached and conditionally cached responses will have a non-null cache response.</span><br><span class="line">    Picasso.LoadedFrom loadedFrom &#x3D; response.cacheResponse() &#x3D;&#x3D; null ? NETWORK : DISK;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Sometimes response content length is zero when requests are being replayed. Haven&#39;t found</span><br><span class="line">    &#x2F;&#x2F; root cause to this but retrying the request seems safe to do so.</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; DISK &amp;&amp; body.contentLength() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ContentLengthException(&quot;Received response with 0 content-length header.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; NETWORK &amp;&amp; body.contentLength() &gt; 0) &#123;</span><br><span class="line">      stats.dispatchDownloadFinished(body.contentLength());</span><br><span class="line">    &#125;</span><br><span class="line">    return new Result(body.source(), loadedFrom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OkHttp3Downloader.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class OkHttp3Downloader implements Downloader &#123;</span><br><span class="line">  @VisibleForTesting final Call.Factory client;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建磁盘缓存目录</span><br><span class="line">  public OkHttp3Downloader(final Context context) &#123;</span><br><span class="line">    this(Utils.createDefaultCacheDir(context));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull @Override public Response load(@NonNull Request request) throws IOException &#123;</span><br><span class="line">    return client.newCall(request).execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Picasso 缓存策略： 首先从内存缓存 -&gt; OkHttp磁盘缓存 -&gt; 网络请求</strong></p>
<h5 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h5><p><a href="https://www.jianshu.com/p/a5a79d861787" target="_blank" rel="noopener">1. picasso详解及其源码简析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:15:34" itemprop="dateCreated datePublished" datetime="2020-05-31T11:15:34+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、OkHttp-简介"><a href="#一、OkHttp-简介" class="headerlink" title="一、OkHttp 简介"></a>一、OkHttp 简介</h5><p>HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：</p>
<ul>
<li>支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接</li>
<li>连接池减少请求延时</li>
<li>透明的GZIP压缩减少响应数据的大小</li>
<li>缓存响应内容，避免一些完全重复的请求</li>
</ul>
<p>当网络出现问题的时候OkHttp依然坚守自己的职责，它会自动恢复一般的连接问题，如果你的服务有多个IP地址，当第一个IP请求失败时，OkHttp会交替尝试你配置的其他IP，OkHttp使用现代TLS技术(SNI, ALPN)初始化新的连接，当握手失败时会回退到TLS 1.0。</p>
<p>官网链接地址：<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">https://square.github.io/okhttp/</a></p>
<h5 id="二、OkHttp-使用"><a href="#二、OkHttp-使用" class="headerlink" title="二、OkHttp 使用"></a>二、OkHttp 使用</h5><h5 id="2-1-同步请求"><a href="#2-1-同步请求" class="headerlink" title="2.1 同步请求"></a>2.1 同步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line">     </span><br><span class="line">Response response = okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>

<h5 id="2-2-异步请求"><a href="#2-2-异步请求" class="headerlink" title="2.2 异步请求"></a>2.2 异步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line"></span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="三、OkHttp-原理剖析"><a href="#三、OkHttp-原理剖析" class="headerlink" title="三、OkHttp 原理剖析"></a>三、OkHttp 原理剖析</h5><p><img src="https://upload-images.jianshu.io/upload_images/692087-b2db5588ceb9d9c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="OkHttp 结构图"></p>
<h6 id="3-1-OkHttpClient-构建"><a href="#3-1-OkHttpClient-构建" class="headerlink" title="3.1 OkHttpClient 构建"></a>3.1 OkHttpClient 构建</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">    <span class="keyword">val</span> dispatcher: Dispatcher = builder.dispatcher</span><br><span class="line">    <span class="keyword">val</span> connectionPool: ConnectionPool = builder.connectionPool</span><br><span class="line">    <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; = builder.interceptors.toImmutableList()</span><br><span class="line">    <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; = builder.networkInterceptors.toImmutableList()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(Builder())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">newBuilder</span><span class="params">()</span></span>: Builder = Builder(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> dispatcher: Dispatcher = Dispatcher()</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectionPool: ConnectionPool = ConnectionPool()</span><br><span class="line">        <span class="comment">// 用户定义应用层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">        <span class="comment">// 用户自定义网络层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()    </span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> readTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> writeTimeout = <span class="number">10_000</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">writeTimeout</span><span class="params">(duration: <span class="type">Duration</span>)</span></span> = apply &#123;</span><br><span class="line">            writeTimeout = checkDuration(<span class="string">"timeout"</span>, duration.toMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: OkHttpClient = OkHttpClient(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpClient内部采用构建模式，定义了连接池、分发器、拦截器</p>
<h6 id="3-2-Call-对象"><a href="#3-2-Call-对象" class="headerlink" title="3.2 Call 对象"></a>3.2 Call 对象</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> transmitter: Transmitter</span><br><span class="line">  <span class="keyword">var</span> executed: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      originalRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      forWebSocket: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: RealCall &#123;</span><br><span class="line">      <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">        transmitter = Transmitter(client, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 同步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter()</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 把当前的RealCall添加到分发器的Deque&lt;RealCall&gt; runningSyncCalls队列中</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// 开始执行请求</span></span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 请求完成之后，将当前的RealCall从当前正在运行的同步RealCall队列中移除出去</span></span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="comment">// 将异步请求AsyncCall</span></span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        transmitter.noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">"OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">        transmitter.timeoutEnter()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback = <span class="literal">true</span></span><br><span class="line">          responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.<span class="keyword">get</span>().log(INFO, <span class="string">"Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>"</span>, e)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += (client.cache)</span><br><span class="line">    interceptors += ConnectICacheInterceptornterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="keyword">this</span>,</span><br><span class="line">        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分发器：<strong><em>Dispatcher.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line">    <span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> idleCallback: Runnable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 核心线程数为0, 所有的空闲线程运行结束之后，全部回收</span></span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()    </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">      runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 异步请求，先放到异步readyAsyncCalls队列里面</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call)</span><br><span class="line">        <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">          <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">          <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line">      <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">      <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">          <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">          <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line">          <span class="comment">// 从readyAsyncCalls队列里面移除，添加到runningAsyncCalls队列</span></span><br><span class="line">          i.remove()</span><br><span class="line">          asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">          executableCalls.add(asyncCall)</span><br><span class="line">          runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isRunning</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">        finished(runningSyncCalls, call)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经运行结束的Call，从相对应的队列中移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>)</span><br><span class="line">          idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">          idleCallback.run()</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-拦截器链"><a href="#3-3-拦截器链" class="headerlink" title="3.3 拦截器链"></a>3.3 拦截器链</h6><p><img src="https://upload-images.jianshu.io/upload_images/10259072-269cd57a864d7f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/613/format/webp" alt="拦截器链"><br><strong><em>RealInterceptorChain.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> transmitter: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> exchange: Exchange?,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> connectTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> readTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> writeTimeout: <span class="built_in">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> calls: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>, transmitter: <span class="type">Transmitter</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line">    calls++</span><br><span class="line">    <span class="keyword">val</span> next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(<span class="string">"interceptor <span class="variable">$interceptor</span> returned null"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> response  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.1 RetryAndFollowUpInterceptor 失败重试及重定向</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">var</span> request = chain.request()</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      transmitter.prepareToConnect(request)</span><br><span class="line">      <span class="comment">// 检查当前请求是否被取消，如果这时请求被取消了，则会释放连接，并抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> response: Response</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取出网络请求结果response</span></span><br><span class="line">        response = realChain.proceed(request, transmitter, <span class="literal">null</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, transmitter, <span class="literal">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">val</span> requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// The network call threw an exception. Release any resources.</span></span><br><span class="line">        <span class="comment">// 在请求过程中，只要发生异常，就会将连接释放掉</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          transmitter.exchangeDoneDueToException()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = response.exchange</span><br><span class="line">      <span class="keyword">val</span> route = exchange?.connection()?.route()</span><br><span class="line">      <span class="comment">// 响应response来执行followUpRequest方法，来检查是否需要进行重定向操作</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, route)</span><br><span class="line">      <span class="comment">// 不需要重定向，则断开链接，返回response，交给下一个拦截器</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          transmitter.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        exchange?.detachWithViolence()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重定向次数大于阈值</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">"Too many follow-up requests: <span class="variable">$followUpCount</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, route: <span class="type">Route</span>?)</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">    <span class="comment">// 我们知道，在Http响应码中，处于3XX的，都需要进行请求重定向处理</span></span><br><span class="line">    <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">      HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">        <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line"></span><br><span class="line">      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -&gt; &#123;</span><br><span class="line">        <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">        <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="string">"GET"</span> &amp;&amp; method != <span class="string">"HEAD"</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">        <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></span><br><span class="line">        <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></span><br><span class="line">        <span class="comment">// repeat the request (even non-idempotent ones.)</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">          <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">        <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userResponse.request</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// specifically received an instruction to retry without delay</span></span><br><span class="line">          <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据响应获取到位置location，然后根据location，得到重定向的url</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildRedirectRequest</span><span class="params">(userResponse: <span class="type">Response</span>, method: <span class="type">String</span>)</span></span>: Request? &#123;</span><br><span class="line">    <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">    <span class="keyword">if</span> (!client.followRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> location = userResponse.header(<span class="string">"Location"</span>) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">    <span class="keyword">val</span> url = userResponse.request.url.resolve(location) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">    <span class="keyword">val</span> sameScheme = url.scheme == userResponse.request.url.scheme</span><br><span class="line">    <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Most redirects don't include a request body.</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userResponse.request.newBuilder()</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">      <span class="keyword">val</span> maintainBody = HttpMethod.redirectsWithBody(method)</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">        requestBuilder.method(<span class="string">"GET"</span>, <span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> requestBody = <span class="keyword">if</span> (maintainBody) userResponse.request.body <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        requestBuilder.method(method, requestBody)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Type"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">    <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">    <span class="comment">// way to retain them.</span></span><br><span class="line">    <span class="keyword">if</span> (!userResponse.request.url.canReuseConnectionFor(url)) &#123;</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Authorization"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.url(url).build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取请求的response ，判断请求是否异常（释放连接），如果response正常,判断重定向条件</strong></p>
<ul>
<li>3.3.2 BridgeInterceptor 用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="literal">true</span></span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">        <span class="string">"gzip"</span>.equals(networkResponse.header(<span class="string">"Content-Encoding"</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">      <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">            .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">"Content-Type"</span>)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完善请求头和响应头</strong></p>
<ul>
<li>3.3.3 CacheInterceptor 缓存拦截器</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">//如果配置了缓存：优先从缓存中读取Response</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="comment">// 如果缓存不为空，但是策略器得到的结果是不能用缓存，也就是 cacheResponse 为 null，这种情况就是将 cacheCandidate.body() 进行 close 操作</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// //如果根据缓存策略strategy禁止使用网络，并且缓存无效，直接返回空的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 如果根据缓存策略strategy禁止使用网络，且有缓存则直接使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 本地有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 并且服务器返回304状态码（说明缓存还没过期或服务器资源没修改）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="comment">// 使用缓存数据 </span></span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="comment">// 返回缓存</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果网络资源已经修改：使用网络响应返回的最新数据</span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将最新的数据缓存起来</span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.4 ConnectInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">val</span> doExtensiveHealthChecks = request.method != <span class="string">"GET"</span></span><br><span class="line">    <span class="keyword">val</span> exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.5 CallServerInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange()</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向服务器发送请求</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> responseHeadersStarted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 检测是否有请求body</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// HTTP/1.1 协议里设计 100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP/1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。</span></span><br><span class="line">      <span class="comment">// 询问Server使用愿意接受数据 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equals(request.header(<span class="string">"Expect"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseHeadersStarted = <span class="literal">true</span></span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">          <span class="comment">// 向服务器发送requesyBody</span></span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">      exchange.responseHeadersStart()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建response对象</span></span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">      <span class="comment">// try again to read the actual response</span></span><br><span class="line">      response = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回空的即无效的响应</span></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equals(response.request.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">"close"</span>.equals(response.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="四、连接"><a href="#四、连接" class="headerlink" title="四、连接"></a>四、连接</h6><p><strong><em>Transmitter.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Transmitter(</span><br><span class="line">  private val client: OkHttpClient,</span><br><span class="line">  private val call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  private val connectionPool: RealConnectionPool &#x3D; client.connectionPool.delegate</span><br><span class="line">  private var exchangeFinder: ExchangeFinder? &#x3D; null</span><br><span class="line">    </span><br><span class="line">  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange &#123;</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      check(!noMoreExchanges) &#123; &quot;released&quot; &#125;</span><br><span class="line">      check(exchange &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &quot;cannot make a new request because the previous response is still open: &quot; +</span><br><span class="line">            &quot;please call response.close()&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    val codec &#x3D; exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)</span><br><span class="line">    val result &#x3D; Exchange(this, call, eventListener, exchangeFinder!!, codec)</span><br><span class="line"></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      this.exchange &#x3D; result</span><br><span class="line">      this.exchangeRequestDone &#x3D; false</span><br><span class="line">      this.exchangeResponseDone &#x3D; false</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ExchangeFinder.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">class ExchangeFinder(</span><br><span class="line">  private val transmitter: Transmitter,</span><br><span class="line">  private val connectionPool: RealConnectionPool,</span><br><span class="line">  private val address: Address,</span><br><span class="line">  private val call: Call,</span><br><span class="line">  private val eventListener: EventListener</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  fun find(</span><br><span class="line">    client: OkHttpClient,</span><br><span class="line">    chain: Interceptor.Chain,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): ExchangeCodec &#123;</span><br><span class="line">    val connectTimeout &#x3D; chain.connectTimeoutMillis()</span><br><span class="line">    val readTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">    val writeTimeout &#x3D; chain.writeTimeoutMillis()</span><br><span class="line">    val pingIntervalMillis &#x3D; client.pingIntervalMillis</span><br><span class="line">    val connectionRetryEnabled &#x3D; client.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">      val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled,</span><br><span class="line">          doExtensiveHealthChecks &#x3D; doExtensiveHealthChecks</span><br><span class="line">      )</span><br><span class="line">      return resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw e</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findHealthyConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环调用，直到得到一个健康的RealConnection </span><br><span class="line">    while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 查找连接</span><br><span class="line">      val candidate &#x3D; findConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If this is a brand new connection, we can skip the extensive health checks.</span><br><span class="line">      &#x2F;&#x2F; 如果是一个全新的连接直接拿去使用不需要检查</span><br><span class="line">      synchronized(connectionPool) &#123;</span><br><span class="line">        if (candidate.successCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          return candidate</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br><span class="line">      &#x2F;&#x2F; isn&#39;t, take it out of the pool and start again.</span><br><span class="line">      &#x2F;&#x2F; 检查这个连接是否是健康可用的，如果不是把它移除连接池</span><br><span class="line">      if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        candidate.noNewExchanges()</span><br><span class="line">        continue</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return candidate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    var foundPooledConnection &#x3D; false</span><br><span class="line">    var result: RealConnection? &#x3D; null</span><br><span class="line">    var selectedRoute: Route? &#x3D; null</span><br><span class="line">    var releasedConnection: RealConnection?</span><br><span class="line">    val toClose: Socket?</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">      hasStreamFailure &#x3D; false &#x2F;&#x2F; This is a fresh attempt.</span><br><span class="line">      &#x2F;&#x2F; 优先返回一个已经分配的连接，假如这个连接不为空，并且这个连接上面还可以建立新的stream</span><br><span class="line">      releasedConnection &#x3D; transmitter.connection</span><br><span class="line">      toClose &#x3D; if (transmitter.connection !&#x3D; null &amp;&amp; transmitter.connection!!.noNewExchanges) &#123;</span><br><span class="line">        transmitter.releaseConnectionNoEvents()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (transmitter.connection !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">        releasedConnection &#x3D; null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Attempt to get a connection from the pool.</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">          nextRouteToTry &#x3D; null</span><br><span class="line">        &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">          selectedRoute &#x3D; transmitter.connection!!.route()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done.</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we need a route selection, make one. This is a blocking operation.</span><br><span class="line">    var newRouteSelection &#x3D; false</span><br><span class="line">    if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">      newRouteSelection &#x3D; true</span><br><span class="line">      routeSelection &#x3D; routeSelector.next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">      if (newRouteSelection) &#123;</span><br><span class="line">        &#x2F;&#x2F; Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br><span class="line">        &#x2F;&#x2F; the pool. This could match due to connection coalescing.</span><br><span class="line">        routes &#x3D; routeSelection!!.routes</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">                address, transmitter, routes, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!foundPooledConnection) &#123;</span><br><span class="line">        if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">        &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do.</span><br><span class="line">        result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">        connectingConnection &#x3D; result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we found a pooled connection on the 2nd time around, we&#39;re done.</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">    &#x2F;&#x2F; 执行TCP + TLS握手</span><br><span class="line">    result!!.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">    connectionPool.routeDatabase.connected(result!!.route())</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建socket链接</span><br><span class="line">    var socket: Socket? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      connectingConnection &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br><span class="line">      &#x2F;&#x2F; concurrent connections to the same host.</span><br><span class="line">      &#x2F;&#x2F; 如果有另一个具有相同IP地址的连接被同时创建，那么把这个连接释放，去用另外一个</span><br><span class="line">      &#x2F;&#x2F;这种情况只有Http2的时候才会去执行</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection.</span><br><span class="line">        result!!.noNewExchanges &#x3D; true</span><br><span class="line">        socket &#x3D; result!!.socket()</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新建的连接放入连接池</span><br><span class="line">        connectionPool.put(result!!)</span><br><span class="line">        transmitter.acquireConnectionNoEvents(result!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>Exchange.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Exchange(</span><br><span class="line">  internal val transmitter: Transmitter,</span><br><span class="line">  internal val call: Call,</span><br><span class="line">  internal val eventListener: EventListener,</span><br><span class="line">  private val finder: ExchangeFinder,</span><br><span class="line">  private val codec: ExchangeCodec</span><br><span class="line">) &#123;</span><br><span class="line">  fun connection(): RealConnection? &#x3D; codec.connection()</span><br><span class="line">  </span><br><span class="line">  fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      eventListener.requestHeadersStart(call)</span><br><span class="line">      codec.writeRequestHeaders(request)</span><br><span class="line">      eventListener.requestHeadersEnd(call, request)</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      eventListener.requestFailed(call, e)</span><br><span class="line">      trackFailure(e)</span><br><span class="line">      throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ExchangeCodec.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface ExchangeCodec &#123;</span><br><span class="line">  fun connection(): RealConnection?</span><br><span class="line">  fun createRequestBody(request: Request, contentLength: Long): Sink</span><br><span class="line">  fun writeRequestHeaders(request: Request)</span><br><span class="line">  fun flushRequest()</span><br><span class="line">  fun finishRequest()</span><br><span class="line">  fun readResponseHeaders(expectContinue: Boolean): Response.Builder?</span><br><span class="line">  fun openResponseBodySource(response: Response): Source</span><br><span class="line">  fun cancel()</span><br><span class="line">  companion object &#123;</span><br><span class="line">    const val DISCARD_STREAM_TIMEOUT_MILLIS &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>RealConnectionPool.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class RealConnectionPool(</span><br><span class="line">  &#x2F;** The maximum number of idle connections for each address. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 最大的空闲socket连接数</span><br><span class="line">  private val maxIdleConnections: Int,</span><br><span class="line">  &#x2F;&#x2F; socket的keepAlive时间</span><br><span class="line">  keepAliveDuration: Long,</span><br><span class="line">  timeUnit: TimeUnit</span><br><span class="line">) &#123;</span><br><span class="line">  private val keepAliveDurationNs: Long &#x3D; timeUnit.toNanos(keepAliveDuration)</span><br><span class="line"></span><br><span class="line">  private val cleanupRunnable &#x3D; object : Runnable &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        val waitNanos &#x3D; cleanup(System.nanoTime())</span><br><span class="line">        if (waitNanos &#x3D;&#x3D; -1L) return</span><br><span class="line">        try &#123;</span><br><span class="line">          this@RealConnectionPool.lockAndWaitNanos(waitNanos)</span><br><span class="line">        &#125; catch (_: InterruptedException) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private val connections &#x3D; ArrayDeque&lt;RealConnection&gt;()</span><br><span class="line">  &#x2F;&#x2F; 用来记录连接失败的路线名单</span><br><span class="line">  val routeDatabase &#x3D; RouteDatabase()</span><br><span class="line">  var cleanupRunning: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  init &#123;</span><br><span class="line">    &#x2F;&#x2F; Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span><br><span class="line">    require(keepAliveDuration &gt; 0L) &#123; &quot;keepAliveDuration &lt;&#x3D; 0: $keepAliveDuration&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  companion object &#123;</span><br><span class="line">    private val executor &#x3D; ThreadPoolExecutor(</span><br><span class="line">        0, &#x2F;&#x2F; corePoolSize.</span><br><span class="line">        Int.MAX_VALUE, &#x2F;&#x2F; maximumPoolSize.</span><br><span class="line">        60L, TimeUnit.SECONDS, &#x2F;&#x2F; keepAliveTime.</span><br><span class="line">        SynchronousQueue(),</span><br><span class="line">        threadFactory(&quot;OkHttp ConnectionPool&quot;, true)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fun get(connectionPool: ConnectionPool): RealConnectionPool &#x3D; connectionPool.delegate</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>SynchronousQueue 原理</strong></p>
<p>在OKHttp中像异步网络请求，<strong>内部使用的线程池是采用SynchronousQueue这个特殊的阻塞队列：每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final SynchronousQueue&lt;Integer&gt; queue &#x3D; new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Thread putThread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;put thread start&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;put thread end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread takeThread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;take thread start&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;take from putThread: &quot; + queue.take());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;take thread end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        putThread.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        takeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行结果</span><br><span class="line">put thread start</span><br><span class="line">take thread start</span><br><span class="line">take from putThread: 1</span><br><span class="line">take thread end</span><br><span class="line">put thread end</span><br></pre></td></tr></table></figure>

<h6 id="五、更多阅读"><a href="#五、更多阅读" class="headerlink" title="五、更多阅读"></a>五、更多阅读</h6><p><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="noopener">1. OKHttp源码解析</a></p>
<p><a href="https://www.cnblogs.com/zhangqie/p/8681308.html" target="_blank" rel="noopener">2. Android开源框架源码分析：Okhttp</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Retrofit2 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:14:46 / 修改时间：11:15:06" itemprop="dateCreated datePublished" datetime="2020-05-31T11:14:46+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、Retrofit2-简介"><a href="#一、Retrofit2-简介" class="headerlink" title="一、Retrofit2 简介"></a>一、Retrofit2 简介</h5><p>Retrofit是一个遵循RESTful设计的进行HTTP网络请求框架，底层网络请求基于OkHttp框架</p>
<h6 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"> </span><br><span class="line">GitHubService service = retrofit.create(GitHubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">service.listRepos(<span class="string">"test"</span>).enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="1-2-RxJava、GSON"><a href="#1-2-RxJava、GSON" class="headerlink" title="1.2 RxJava、GSON"></a>1.2 RxJava、GSON</h6><h5 id="二、原理剖析"><a href="#二、原理剖析" class="headerlink" title="二、原理剖析"></a>二、原理剖析</h5><h6 id="2-1-Retrofit的创建"><a href="#2-1-Retrofit的创建" class="headerlink" title="2.1 Retrofit的创建"></a>2.1 Retrofit的创建</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">    <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>(Platform.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">          <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">          &#125;</span><br><span class="line">          Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">          <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">          <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">          <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">          converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">          converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">          converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-create-动态代理"><a href="#2-2-create-动态代理" class="headerlink" title="2.2 create 动态代理"></a>2.2 create 动态代理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回service的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">              @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>HttpServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">        ...   </span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">        Type responseType = callAdapter.responseType();</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line">        okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">          continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);  </span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">        <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">        CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">            <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">            <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendForBody</span>&lt;<span class="title">ResponseT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isNullable;</span><br><span class="line"></span><br><span class="line">    SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter, <span class="keyword">boolean</span> isNullable) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">      <span class="keyword">this</span>.isNullable = isNullable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Object <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      call = callAdapter.adapt(call);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class="line">      Continuation&lt;ResponseT&gt; continuation = (Continuation&lt;ResponseT&gt;) args[args.length - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span> isNullable</span><br><span class="line">          ? KotlinExtensions.awaitNullable(call, continuation)</span><br><span class="line">          : KotlinExtensions.await(call, continuation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>DefaultCallAdapterFactory.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        ? <span class="title">null</span></span></span><br><span class="line">        : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span></span><br><span class="line">            ? call</span><br><span class="line">            : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      delegate.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.request();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="四、更多阅读"><a href="#四、更多阅读" class="headerlink" title="四、更多阅读"></a>四、更多阅读</h6><p><a href="https://www.jianshu.com/p/0b4c41d5d354" target="_blank" rel="noopener">1. 【Android源码伴读】Retrofit源码探秘</a></p>
<p><a href="https://www.jianshu.com/p/097947afddaf" target="_blank" rel="noopener">2. Retrofit源码分析（超详细）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">EventBus 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:13:30 / 修改时间：11:13:57" itemprop="dateCreated datePublished" datetime="2020-05-31T11:13:30+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>EventBus是一个Android端优化的publish／subscribe消息总线，简化了应用程序内各组件内、组件与后台线程间的通信，比如请求网络，等网络返回时，通过Handler、Broadcast更新UI等。它有很多优点：简化应用组件间的通信；解耦事件的发送者和接收者。<br><img src="https://upload-images.jianshu.io/upload_images/2169292-9d0c216714804720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EventBus-Publish-Subscribe.png"></p>
<h5 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h5><p>注册： EventBus.getDefault().register(this);<br>解注册：EventBus.getDefault().unregister(this);<br>事件Event： 事件可以是任意普通的Java对象，没有任何特殊的要求<br>发送消息： EventBus.getDefault().post(new MessageEvent(“Hello EventBus!”));</p>
<h5 id="三、线程模式"><a href="#三、线程模式" class="headerlink" title="三、线程模式"></a>三、线程模式</h5><p>EventBus支持订阅者方法在不同于发布事件所在线程的线程中被调用。你可以使用线程模式来指定调用订阅者方法的线程。EventBus总共支持5种线程模式：</p>
<ul>
<li><p>ThreadMode.POSTING 订阅者方法将在发布事件所在的线程中被调用。这是 默认的线程模式。事件的传递是同步的，一旦发布事件，所有该模式的订阅者方法都将被调用。这种线程模式意味着最少的性能开销，因为它避免了线程的切换。因此，对于不要求是主线程并且耗时很短的简单任务推荐使用该模式。使用该模式的订阅者方法应该快速返回，以避免阻塞发布事件的线程，这可能是主线程。</p>
</li>
<li><p>ThreadMode.MAIN 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.MAIN_ORDERED 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。事件将先进入队列然后才发送给订阅者，所以发布事件的调用将立即返回。这使得事件的处理保持严格的串行顺序。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.BACKGROUND 订阅者方法将在后台线程中被调用。如果发布事件的线程不是主线程，那么订阅者方法将直接在该线程中被调用。如果发布事件的线程是主线程，那么将使用一个单独的后台线程，该线程将按顺序发送所有的事件。使用该模式的订阅者方法应该快速返回，以避免阻塞后台线程。</p>
</li>
<li><p>ThreadMode.ASYNC 订阅者方法将在一个单独的线程中被调用。因此，发布事件的调用将立即返回。如果订阅者方法的执行需要一些时间，例如网络访问，那么就应该使用该模式。避免触发大量的长时间运行的订阅者方法，以限制并发线程的数量。EventBus使用了一个线程池来有效地重用已经完成调用订阅者方法的线程。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.POSTING)</span><br><span class="line">    public void onMessageEventPosting(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventPosting(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN)</span><br><span class="line">public void onMessageEventMain(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMain(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN_ORDERED)</span><br><span class="line">public void onMessageEventMainOrdered(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMainOrdered(), current thread is &quot;</span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.BACKGROUND)</span><br><span class="line">public void onMessageEventBackground(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventBackground(), current thread is &quot; </span><br><span class="line">         + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.ASYNC)</span><br><span class="line">public void onMessageEventAsync(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventAsync(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、粘性事件"><a href="#四、粘性事件" class="headerlink" title="四、粘性事件"></a>四、粘性事件</h5><p>发布一个粘性事件之后，EventBus将在内存中缓存该粘性事件。当有订阅者订阅了该粘性事件，订阅者将接收到该事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发布粘性事件</span><br><span class="line">EventBus.getDefault().postSticky(new MessageEvent(&quot;Hello EventBus!&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅粘性事件</span><br><span class="line">@Subscribe(sticky &#x3D; true)</span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、源码解析"><a href="#五、源码解析" class="headerlink" title="五、源码解析"></a>五、源码解析</h5><ol>
<li>从EventBus.getDefault()方法开始说起。主要是获取EventBus对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 典型的双重校验锁的单例模式</span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">    if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                defaultInstance &#x3D; new EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public EventBus() &#123;</span><br><span class="line">    this(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; key 为订阅事件类型，value为订阅该事件的所有订阅者集合</span><br><span class="line">&#x2F;&#x2F; Subscription则是一个封装了订阅者和方法体的一个类</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; </span><br><span class="line">subscriptionsByEventType;</span><br><span class="line">&#x2F;&#x2F; key为订阅者，value为订阅者的所有订阅方法</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化成员变量</span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadPoster &#x3D; new HandlerPoster(this, Looper.getMainLooper(), 10);</span><br><span class="line">    backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">    asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">    &#x2F;&#x2F;一系列的builder赋值</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">2. 消息注册register(this)函数</span><br></pre></td></tr></table></figure>
public void register(Object subscriber) {<br> Class&lt;?&gt; subscriberClass = subscriber.getClass();<br> // 从订阅类中获取所有的订阅方法信息<br> List<SubscriberMethod> subscriberMethods = subscriberMethodFinder<pre><code>.findSubscriberMethods(subscriberClass);</code></pre> synchronized (this) {<pre><code>for (SubscriberMethod subscriberMethod : subscriberMethods) {
    subscribe(subscriber, subscriberMethod);
}</code></pre> }<br>}</li>
</ol>
<p>List<SubscriberMethod> findSubscriberMethods(Class&lt;?&gt; subscriberClass) {<br>    // 首先从缓存中读取<br>    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);<br>    if (subscriberMethods != null) {<br>        return subscriberMethods;<br>    }<br>    // 默认是false<br>    if (ignoreGeneratedIndex) {<br>        // 利用反射来获取订阅方法中的信息<br>        subscriberMethods = findUsingReflection(subscriberClass);<br>    } else {<br>        // 从注解器获取的类中获得订阅方法信息<br>        subscriberMethods = findUsingInfo(subscriberClass);<br>    }<br>    if (subscriberMethods.isEmpty()) {<br>        throw new EventBusException(“Subscriber “ + subscriberClass<br>                + “ and its super classes have no public methods with “<br>                +” the @Subscribe annotation”);<br>    } else {<br>        // 保存在缓存中<br>        METHOD_CACHE.put(subscriberClass, subscriberMethods);<br>        return subscriberMethods;<br>    }<br>}</p>
<p>private List<SubscriberMethod> findUsingInfo(Class&lt;?&gt; subscriberClass) {<br>    // 准备一个FindState，该FindState保存了订阅者类的信息<br>    FindState findState = prepareFindState();<br>    //对FindState初始化<br>    findState.initForSubscriber(subscriberClass);<br>    while (findState.clazz != null) {<br>        findState.subscriberInfo = getSubscriberInfo(findState);<br>        //获得订阅者的信息，一开始会返回null<br>        if (findState.subscriberInfo != null) {<br>            SubscriberMethod[] array = findState.subscriberInfo<br>                                       .getSubscriberMethods();<br>            for (SubscriberMethod subscriberMethod : array) {<br>                if (findState.checkAdd(subscriberMethod.method<br>                    , subscriberMethod.eventType)) {<br>                    findState.subscriberMethods.add(subscriberMethod);<br>                }<br>            }<br>        } else {<br>            findUsingReflectionInSingleClass(findState);<br>        }<br>        findState.moveToSuperclass();<br>    }<br>return getMethodsAndRelease(findState);<br>}</p>
<p>private void findUsingReflectionInSingleClass(FindState findState) {<br>    Method[] methods;<br>    try {<br>        // This is faster than getMethods, especially when subscribers are<br>       // fat classes like Activities<br>        methods = findState.clazz.getDeclaredMethods();<br>    } catch (Throwable th) {<br>        // Workaround for java.lang.NoClassDefFoundError,<br>        // see <a href="https://github.com/greenrobot/EventBus/issues/149" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus/issues/149</a><br>        methods = findState.clazz.getMethods();<br>        findState.skipSuperClasses = true;<br>    }<br>    for (Method method : methods) {<br>        int modifiers = method.getModifiers();<br>        if ((modifiers &amp; Modifier.PUBLIC) != 0<br>            &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {<br>            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method
                                               .getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    Class<?> eventType = parameterTypes[0];<br>                    if (findState.checkAdd(method, eventType)) {<br>                        ThreadMode threadMode = subscribeAnnotation.threadMode();<br>                        findState.subscriberMethods.add(new SubscriberMethod(method<br>                        , eventType, threadMode,subscribeAnnotation.priority()<br>                        , subscribeAnnotation.sticky()));<br>                    }<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>                   String methodName = method.getDeclaringClass().getName()<br>                                    + “.” + method.getName();<br>                    throw new EventBusException(“@Subscribe method “ + methodName +<br>                 “must have exactly 1 parameter but has “ + parameterTypes.length);<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>            String methodName = method.getDeclaringClass().getName() + “.”<br>                                + method.getName();<br>            throw new EventBusException(methodName +<br>                        “ is a illegal @Subscribe method: must be public “<br>                        + “, non-static, and non-abstract”);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 发送消息源码</span><br></pre></td></tr></table></figure>
<p>public void post(Object event) {<br>    PostingThreadState postingState = currentPostingThreadState.get();<br>    List<Object> eventQueue = postingState.eventQueue;<br>    eventQueue.add(event);<br>    // 如果没有正在发送，则发送消息<br>    if (!postingState.isPosting) {<br>        postingState.isMainThread = isMainThread();<br>        postingState.isPosting = true;<br>        if (postingState.canceled) {<br>          throw new EventBusException(“Internal error. Abort state was not reset”);<br>        }<br>        try {<br>            while (!eventQueue.isEmpty()) {<br>                // 发送消息<br>                postSingleEvent(eventQueue.remove(0), postingState);<br>             }<br>        } finally {<br>            postingState.isPosting = false;<br>            postingState.isMainThread = false;<br>        }<br>    }<br>}</p>
<p>private void postSingleEvent(Object event, PostingThreadState postingState)<br>throws Error {<br>    Class<?> eventClass = event.getClass();
    boolean subscriptionFound = false;
    if (eventInheritance) {
        List<Class<?>&gt; eventTypes = lookupAllEventTypes(eventClass);<br>        int countTypes = eventTypes.size();<br>        for (int h = 0; h &lt; countTypes; h++) {<br>            Class&lt;?&gt; clazz = eventTypes.get(h);<br>            subscriptionFound |= postSingleEventForEventType(event<br>                                 , postingState, clazz);<br>        }<br>     } else {<br>        subscriptionFound = postSingleEventForEventType(event, postingState<br>                                                        , eventClass);<br>     }<br>     if (!subscriptionFound) {<br>        if (logNoSubscriberMessages) {<br>            logger.log(Level.FINE, “No subscribers registered for event “<br>                       + eventClass);<br>        }<br>        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class<br>            &amp;&amp; eventClass != SubscriberExceptionEvent.class) {<br>            post(new NoSubscriberEvent(this, event));<br>        }<br>    }<br>}</p>
<p>private boolean postSingleEventForEventType(Object event<br>                          , PostingThreadState postingState, Class&lt;?&gt; eventClass) {<br>    CopyOnWriteArrayList<Subscription> subscriptions;<br>    synchronized (this) {<br>        // 根据事件类型获取所有的订者<br>        subscriptions = subscriptionsByEventType.get(eventClass);<br>    }<br>    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {<br>        for (Subscription subscription : subscriptions) {<br>            postingState.event = event;<br>            postingState.subscription = subscription;<br>            boolean aborted = false;<br>            try {<br>                postToSubscription(subscription, event, postingState.isMainThread);<br>                aborted = postingState.canceled;<br>            } finally {<br>                postingState.event = null;<br>                postingState.subscription = null;<br>                postingState.canceled = false;<br>            }<br>            if (aborted) {<br>                break;<br>            }<br>        }<br>        return true;<br>    }<br>    return false;<br>}</p>
<p>private void postToSubscription(Subscription subscription, Object event<br>                                , boolean isMainThread) {<br>    switch (subscription.subscriberMethod.threadMode) {<br>        case POSTING:<br>            invokeSubscriber(subscription, event);<br>            break;<br>        case MAIN:<br>            if (isMainThread) {<br>                invokeSubscriber(subscription, event);<br>            } else {<br>                mainThreadPoster.enqueue(subscription, event);<br>            }<br>            break;<br>        case MAIN_ORDERED:<br>            if (mainThreadPoster != null) {<br>                mainThreadPoster.enqueue(subscription, event);<br>            } else {<br>                // temporary: technically not correct as poster not decoupled<br>                // from subscriber<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case BACKGROUND:<br>            if (isMainThread) {<br>                backgroundPoster.enqueue(subscription, event);<br>            } else {<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case ASYNC:<br>            asyncPoster.enqueue(subscription, event);<br>            break;<br>        default:<br>            throw new IllegalStateException(“Unknown thread mode: “<br>                                       + subscription.subscriberMethod.threadMode);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 取消注册源码分析</span><br></pre></td></tr></table></figure>
<p>public synchronized void unregister(Object subscriber) {<br>    List&lt;Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class<?> eventType : subscribedTypes) {<br>            unsubscribeByEventType(subscriber, eventType);<br>        }<br>        typesBySubscriber.remove(subscriber);<br>    } else {<br>        logger.log(Level.WARNING, “Subscriber to unregister was not<br>                   “+registered before: “ + subscriber.getClass());<br>    }<br>}</p>
<p>private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {<br>    // 获取事件类型的所有订阅者<br>    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);<br>    if (subscriptions != null) {<br>        int size = subscriptions.size();<br>        // 遍历订阅者集合将解除的订阅者移除<br>        for (int i = 0; i &lt; size; i++) {<br>            Subscription subscription = subscriptions.get(i);<br>            if (subscription.subscriber == subscriber) {<br>                subscription.active = false;<br>                subscriptions.remove(i);<br>                i–;<br>                size–;<br>            }<br>        }<br>    }<br>}</p>
<pre><code>简单的进行总结一下，主要就是注册和发送过程比较重要。

注册：

1. 通过反射或者注解获取所有的订阅方法 
2. 将当前订阅者添加到EventBus总的事件订阅者集合中subscriptionsByEventType 
3. 将当前订阅者所有订阅的事件类型添加到typesBySubscriber，方便解注册

发送：
1. 得到要发送的事件类型 
2. 根据事件类型获取订阅者，并循环向每个订阅者发送

解注册：
1. 通过typesBySubscriber获取当前订阅者所有的订阅事件类型
2. 循环遍历每一个事件类型，并删除当前订阅者的订阅的方法</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">RxJava 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:10:57 / 修改时间：11:13:00" itemprop="dateCreated datePublished" datetime="2020-05-31T11:10:57+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、RxJava-简介"><a href="#一、RxJava-简介" class="headerlink" title="一、RxJava 简介"></a>一、RxJava 简介</h5><p>RxJava是一种基于观察者模式的响应式编程框架，其定义的角色有Observable事件流、ObservableOnSubscribe事件源头、Observer是事件订阅者。</p>
<h5 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="string">"Android"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"Kotlin"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"Java"</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(<span class="keyword">new</span> Function&lt;String, Strinsg&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I Love "</span>+ s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"test"</span>, <span class="string">"onNext: "</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"test"</span>, <span class="string">"[onComplete]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test: onNext: I Love Android</span><br><span class="line">test: onNext: I Love Kotlin</span><br><span class="line">test: onNext: I Love Java</span><br><span class="line">test: [onComplete]</span><br></pre></td></tr></table></figure>

<h5 id="三、原理剖析"><a href="#三、原理剖析" class="headerlink" title="三、原理剖析"></a>三、原理剖析</h5><h6 id="3-1-Observable、Observer订阅原理"><a href="#3-1-Observable、Observer订阅原理" class="headerlink" title="3.1 Observable、Observer订阅原理"></a>3.1 Observable、Observer订阅原理</h6><p><strong><em>ObservableSource.java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ObservableSource&lt;T&gt; &#123;</span><br><span class="line">    void subscribe(@NonNull Observer&lt;? super T&gt; observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>Observable.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="comment">// 创建事件源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅相关</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    	subscribeActual(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>create方法创建事件源,其参数ObservableOnSubscribe 接口定义如下：<br><strong><em>ObservableOnSubscribe.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObservableEmitter可以理解为事件发射器，继承Emitter里卖弄的基本发射方法，同时关连Disposable<br><strong><em>Emitter.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable error)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ObservableEmitter.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(@Nullable Disposable d)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCancellable</span><span class="params">(@Nullable Cancellable c)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ObservableEmitter&lt;T&gt; <span class="title">serialize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(@NonNull Throwable t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observable.create方法最终会返回ObservableCreate<T>对象，ObservableCreate类包含了ObservableOnSubscribe对象引用，且实现了subscribeActual订阅方法</p>
<p><strong><em>ObservableCreate.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅的时候会执行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1 创建 CreateEmitter，也是一个适配器，可以将 Observer -&gt; Disposable，CreateEmitter 中主要持有 observer 对象的引用，并且维护了 dispose 变量。</span></span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        <span class="comment">//2 onSubscribe（）参数是 Disposable。还有一点要注意的是 onSubscribe() 是在我们执行 subscribe() 这句代码的那个线程回调的，并不受线程调度影响。</span></span><br><span class="line">        <span class="comment">// 给 observer 的一个回调，告诉它是否 dispose</span></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//3 将 ObservableOnSubscribe（源头）与 CreateEmitter（Observer，终点）联系起来，即完成订阅，此时 ObservableOnSubscribe 会向 observer 传送事件</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有被 dispose，会调用 Observer 的 onNext()方法</span></span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                observer.onNext(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">                RxJavaPlugins.onError(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> NullPointerException(<span class="string">"onError called with null. Null values are generally not allowed in 2.x operators and sources."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onError(t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// onComplete() 和 onError() 互斥只能执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onComplete();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Observer订阅者定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-2-map操作符原理"><a href="#3-2-map操作符原理" class="headerlink" title="3.2 map操作符原理"></a>3.2 map操作符原理</h6><p>map函数的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ObservableMap.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super()将上游的Observable保存起来 ，用于subscribeActual()中用。</span></span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="comment">// 将function变换函数类保存起来</span></span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用 MapObserver 订阅上游 Observable。</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(actual);</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// done在onError 和 onComplete以后才会是true，默认这里是false，所以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认sourceMode是0，所以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != NONE) &#123;</span><br><span class="line">                downstream.onNext(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U v;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这一步执行变换,将上游传过来的 T，利用 Function 转换成下游需要的 V</span></span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                fail(ex);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 变换后传递给下游Observer</span></span><br><span class="line">            downstream.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transitiveBoundaryFusion(mode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> U <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            T t = qd.poll();</span><br><span class="line">            <span class="keyword">return</span> t != <span class="keyword">null</span> ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-subscribeOn-线程调度"><a href="#3-3-subscribeOn-线程调度" class="headerlink" title="3.3 subscribeOn 线程调度"></a>3.3 subscribeOn 线程调度</h6><p>subscribeOn 函数源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(</span><br><span class="line">        <span class="comment">// 返回Observable，传入上游this和调度器scheduler</span></span><br><span class="line">        <span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(downStream);</span><br><span class="line">        <span class="comment">// SubscribeOnObserver实现了Disposable，将其传递给下游的onSubscribe</span></span><br><span class="line">        downStream.onSubscribe(parent);</span><br><span class="line">        <span class="comment">// 把source的订阅放在Runnable中，由scheduler调度</span></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                source.subscribe(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对subscribeOn()的调用是自下向上，所以连续多次调用subscribeOn()，结果会被最上面的subscribeOn()覆盖。（生成和消费都会被覆盖）</strong></p>
<p>observeOn函数源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(</span><br><span class="line">        <span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上代码都很熟悉了，暂不赘述</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableObserveOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler; <span class="comment">// 线程调度器</span></span><br><span class="line">        <span class="keyword">this</span>.delayError = delayError; <span class="comment">// 出现错误是否立刻中断线程</span></span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;   <span class="comment">//缓冲区大小，默认128</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            <span class="comment">// 默认线程则不做线程调度，直接在当前线程中调用</span></span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">            source.subscribe(</span><br><span class="line">                <span class="comment">// 用Worker、和相关参数装饰observer，得到新的Observer注入上游</span></span><br><span class="line">                <span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.s = s;</span><br><span class="line">                <span class="comment">//省略部分代码，创建缓冲队列</span></span><br><span class="line">                queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line">                actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        queue.offer(t); <span class="comment">//上游的数据全部先入队列</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行调度</span></span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队列如果已经空了，则再次调度</span></span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Fused 熔断机制，默认false</span></span><br><span class="line">        <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">            drainFused();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drainNormal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该函数在Runnable所在的线程执行，从缓冲队列里拿出事件，向下游发射</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了errorDelay，则不管队列是否为空，发生了错误都会中断发射，并调用observer的onError</span></span><br><span class="line">            <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> d = done;</span><br><span class="line">                T v;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    v = q.poll();   <span class="comment">//队列中取数据</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    Exceptions.throwIfFatal(ex);</span><br><span class="line">                    s.dispose();</span><br><span class="line">                    q.clear();</span><br><span class="line">                    a.onError(ex);</span><br><span class="line">                    worker.dispose();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向下游发射数据</span></span><br><span class="line">                a.onNext(v);</span><br><span class="line">            &#125;</span><br><span class="line">            missed = addAndGet(-missed);</span><br><span class="line">            <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>observeOn()的工作原理是把消费结果先缓存，再切换到新线程上让原始消费者消费，它和生产者是没有一点关系的，就算subscribeOn()调用了，也只是改变observeOn()这个消费者所在的线程，和OperatorObserveOn中存储的原始消费者一点关系都没有，它还是由observeOn()控制。</strong></p>
<h6 id="四、更多阅读"><a href="#四、更多阅读" class="headerlink" title="四、更多阅读"></a>四、更多阅读</h6><ol>
<li><a href="http://www.pianshen.com/article/4401252533/" target="_blank" rel="noopener">RxJava 原理篇</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/JDK%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20%E2%80%94%E2%80%94%20Boolean%E3%80%81Byte/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/JDK%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20%E2%80%94%E2%80%94%20Boolean%E3%80%81Byte/" class="post-title-link" itemprop="url">JDK 源码解析 —— Boolean、Byte</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 22:21:39" itemprop="dateCreated datePublished" datetime="2020-05-30T22:21:39+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先我们来简单的了解一下，基础数据类型的数值范围，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2169292-b6ade8cee55fa85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基础数据类型的数值范围"></p>
<p><strong>Boolean 类型定义如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class Boolean implements java.io.Serializable,</span><br><span class="line">                                      Comparable&lt;Boolean&gt; &#123;</span><br><span class="line">    public static final Boolean TRUE &#x3D; new Boolean(true);</span><br><span class="line">    public static final Boolean FALSE &#x3D; new Boolean(false);</span><br><span class="line">    public static final Class&lt;Boolean&gt; TYPE &#x3D; </span><br><span class="line">                                (Class&lt;Boolean&gt;)Class.getPrimitiveClass(&quot;boolean&quot;);</span><br><span class="line">    private final boolean value;</span><br><span class="line"></span><br><span class="line">    public Boolean(boolean value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean parseBoolean(String s) &#123;</span><br><span class="line">        return ((s !&#x3D; null) &amp;&amp; s.equalsIgnoreCase(&quot;true&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">        return (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java的基本数据类型中，boolean只有两种状态，默认值为false.取值范围是{true,false}，理论上占1bit，实际上：</p>
<ul>
<li><p>1.单个的boolean 类型变量在编译的时候是使用的int 类型。</p>
<blockquote>
<p>boolean a=true;//这个a在JVM中占4个字节即：32位。</p>
</blockquote>
</li>
<li><p>2.boolean 类型的数组时，在编译的时候是作为byte array来编译的所以boolean 数组里面的每一个元件占一个字节，</p>
<blockquote>
<p>boolean[] b = new boolean[10];//数组时，每一个boolean在JVM中占一个字节。</p>
</blockquote>
</li>
</ul>
<p><strong>Byte定义如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class Byte extends Number implements Comparable&lt;Byte&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static final byte   MIN_VALUE &#x3D; -128;</span><br><span class="line">    public static final byte   MAX_VALUE &#x3D; 127;</span><br><span class="line"></span><br><span class="line">    public static String toString(byte b) &#123;</span><br><span class="line">        return Integer.toString((int)b, 10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ByteCache &#123;</span><br><span class="line">        private ByteCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        static final Byte cache[] &#x3D; new Byte[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; cache.length; I++)</span><br><span class="line">                cache[i] &#x3D; new Byte((byte)(i - 128));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Byte valueOf(byte b) &#123;</span><br><span class="line">        final int offset &#x3D; 128;</span><br><span class="line">        return ByteCache.cache[(int)b + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Byte对象中也有一个private final的byte的属性。byte的取值范围为-128-127.在Byte中有一个内部类是ByteCache,用来缓存byte的数据,所以对于byte类型赋值,JVM不会再开辟空间，如果byte类型采用new关键字创建对象JVM会在堆区产生对象,byte可以转换成short,int,long,float,double,toString.其中有parseByte(String),parseByte(String,radix)方法，可以将其他进制的字符串,转换成十进制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/29%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/29%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">29 应用程序返回按键执行流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。<br>android系统的事件分发流程分为很多部分：</p>
<ul>
<li>Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层</li>
</ul>
<p>所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。</p>
<p><strong>在Native层android系统的事件流程：</strong></p>
<ul>
<li><p>Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。</p>
</li>
<li><p>在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。</p>
</li>
<li><p>将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。</p>
</li>
<li><p>Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。</p>
</li>
<li><p>Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。</p>
</li>
</ul>
<p>可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。</p>
<p><strong>在ViewRootImpl层android系统的事件流程</strong></p>
<p>在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">        onInputEventFinished(seq, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final class ImeInputEventSender extends InputEventSender &#123;</span><br><span class="line">        public ImeInputEventSender(InputChannel inputChannel, Looper looper) &#123;</span><br><span class="line">            super(inputChannel, looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">            finishedInputEvent(seq, handled, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void finishedInputEvent(int seq, boolean handled, boolean timeout) &#123;</span><br><span class="line">        final PendingEvent p;</span><br><span class="line">        synchronized (mH) &#123;</span><br><span class="line">            int index &#x3D; mPendingEvents.indexOfKey(seq);</span><br><span class="line">            if (index &lt; 0) &#123;</span><br><span class="line">                return; &#x2F;&#x2F; spurious, event already finished or timed out</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p &#x3D; mPendingEvents.valueAt(index);</span><br><span class="line">            mPendingEvents.removeAt(index);</span><br><span class="line">            Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size());</span><br><span class="line"></span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Timeout waiting for IME to handle input event after &quot;</span><br><span class="line">                        + INPUT_METHOD_NOT_RESPONDING_TIMEOUT + &quot; ms: &quot; + p.mInputMethodId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mH.removeMessages(MSG_TIMEOUT_INPUT_EVENT, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invokeFinishedInputEventCallback(p, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法finishedInputEvent中，经过一系列的处理之后最终调用的是invokeFinishedInputEventCallback方法，所以我们继续看一下invokeFinishedInputEventCallback方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void invokeFinishedInputEventCallback(PendingEvent p, boolean handled) &#123;</span><br><span class="line">        p.mHandled &#x3D; handled;</span><br><span class="line">        if (p.mHandler.getLooper().isCurrentThread()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Already running on the callback handler thread so we can send the</span><br><span class="line">            &#x2F;&#x2F; callback immediately.</span><br><span class="line">            p.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Post the event to the callback handler thread.</span><br><span class="line">            &#x2F;&#x2F; In this case, the callback will be responsible for recycling the event.</span><br><span class="line">            Message msg &#x3D; Message.obtain(p.mHandler, p);</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">            msg.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里我们首先判断PendingEvent的mHandler所在的线程是否是当前线程，若是的话则直接调用p.run方法，若不是的话则发送一个异步消息，而异步消息最终也是执行的p.run方法，所以我们继续看一下PendingEvent的run方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            mCallback.onFinishedInputEvent(mToken, mHandled);</span><br><span class="line"></span><br><span class="line">            synchronized (mH) &#123;</span><br><span class="line">                recyclePendingEventLocked(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在run方法中我们调用了mCallback的onFinishedInputEvent方法，需要说明的是这里的mCallback就是我们ViewRootImpl中的ImeInputStage类对象，而这里的ViewRootImpl对象就是我们的系统当前界面，前面我们分析Activity的加载绘制流程的时候知道Activity中保存了一个Window对象用于表示窗口信息，而Window对象内部就是通过ViewRootImpl对象实现窗口的加载绘制，所以这里的mCallback对象就是我们当前的App获取焦点的窗口的ViewRootImpl中的ImeInputStage对象，然后我们看一下该对象的onFinishedInputEvent方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final class ImeInputStage extends AsyncInputStage</span><br><span class="line">            implements InputMethodManager.FinishedInputEventCallback &#123;</span><br><span class="line">        ...</span><br><span class="line">        @Override</span><br><span class="line">        public void onFinishedInputEvent(Object token, boolean handled) &#123;</span><br><span class="line">            QueuedInputEvent q &#x3D; (QueuedInputEvent)token;</span><br><span class="line">            if (handled) &#123;</span><br><span class="line">                finish(q, true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            forward(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样经过一系列的调用之后我们消息的处理逻辑上传至了ViewRootImpl中，而在ViewRootImpl中经过一些列的调用之后我们ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4152)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4114)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3807)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3864)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3840)</span><br><span class="line">at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4006)</span><br><span class="line">at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2272)</span><br><span class="line">at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1893)</span><br><span class="line">at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1884)</span><br><span class="line">at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2249)</span><br><span class="line">at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141)</span><br></pre></td></tr></table></figure>
<p>这是通过异常信息打印的堆栈信息，从中我们可以看到在ViewRootImpl中我们经过一系列的调用之后最终执行的是：ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法，这样我们继续看一下processKeyEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int processKeyEvent(QueuedInputEvent q) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; Deliver the key to the view hierarchy.</span><br><span class="line">            if (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">                return FINISH_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">			...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了mView的dispatchKeyEvent方法，而我们分析过Activity窗口加载绘制流程，从中我们知道ViewRootImpl中的mView对象就是我们PhoneWindow中的mDecorView对象（DecorView），所以经过层层调用我们最终执行到了DecorView层。</p>
<p><strong>在DecorView层android系统的事件流程</strong></p>
<p>从上面我们知道在ViewRootImpl中我们最终调用了mView.dispatchKeyEvent方法，即执行的是PhoneWindow%DecorView.dispatchKeyEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int action &#x3D; event.getAction();</span><br><span class="line">            final boolean isDown &#x3D; action &#x3D;&#x3D; KeyEvent.ACTION_DOWN;</span><br><span class="line"></span><br><span class="line">            if (isDown &amp;&amp; (event.getRepeatCount() &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">                &#x2F;&#x2F; First handle chording of panel key: if a panel key is held</span><br><span class="line">                &#x2F;&#x2F; but not released, try to execute a shortcut in it.</span><br><span class="line">                if ((mPanelChordingKey &gt; 0) &amp;&amp; (mPanelChordingKey !&#x3D; keyCode)) &#123;</span><br><span class="line">                    boolean handled &#x3D; dispatchKeyShortcutEvent(event);</span><br><span class="line">                    if (handled) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; If a panel is open, perform a shortcut on it without the</span><br><span class="line">                &#x2F;&#x2F; chorded panel key</span><br><span class="line">                if ((mPreparedPanel !&#x3D; null) &amp;&amp; mPreparedPanel.isOpen) &#123;</span><br><span class="line">                    if (performPanelShortcut(mPreparedPanel, keyCode, event, 0)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!isDestroyed()) &#123;</span><br><span class="line">                final Callback cb &#x3D; getCallback();</span><br><span class="line">                final boolean handled &#x3D; cb !&#x3D; null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event)</span><br><span class="line">                        : super.dispatchKeyEvent(event);</span><br><span class="line">                if (handled) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">                    : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从中我们可以看到如果当前的PhoneWindow不是destroy庄则，则执行cb.dispatchKeyEvent方法，而这里的callback对象就是我们的Activity对象，所以这里最终会执行到Activity的dispatchKeyEvent方法。。。</p>
<p><strong>在Activity层android系统的事件流程</strong></p>
<p>所以我们这里继续看一下Actiivty中的dispatchKeyEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Let action bars open menus in response to the menu key prioritized over</span><br><span class="line">        &#x2F;&#x2F; the window handling it</span><br><span class="line">        if (event.getKeyCode() &#x3D;&#x3D; KeyEvent.KEYCODE_MENU &amp;&amp;</span><br><span class="line">                mActionBar !&#x3D; null &amp;&amp; mActionBar.onMenuKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Window win &#x3D; getWindow();</span><br><span class="line">        if (win.superDispatchKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        View decor &#x3D; mDecor;</span><br><span class="line">        if (decor &#x3D;&#x3D; null) decor &#x3D; win.getDecorView();</span><br><span class="line">        return event.dispatch(this, decor !&#x3D; null</span><br><span class="line">                ? decor.getKeyDispatcherState() : null, this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从中我们可以看到我们首先调用了Activity的window对象的superDispatchKeyEvent方法，而这个方法就是将处理方法下发带Activity中的View，而这里我们分析的是返回按键，显然的View层是无法处理这里的返回按键的，所以win.superDispatchKeyEvent方法返回的是false，所以最终我们执行的是event.dispatch方法。这样我们继续看一下event.dispatch方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final boolean dispatch(Callback receiver, DispatcherState state,</span><br><span class="line">            Object target) &#123;</span><br><span class="line">        switch (mAction) &#123;</span><br><span class="line">            ...</span><br><span class="line">            case ACTION_UP:</span><br><span class="line">                if (DEBUG) Log.v(TAG, &quot;Key up to &quot; + target + &quot; in &quot; + state</span><br><span class="line">                        + &quot;: &quot; + this);</span><br><span class="line">                if (state !&#x3D; null) &#123;</span><br><span class="line">                    state.handleUpEvent(this);</span><br><span class="line">                &#125;</span><br><span class="line">                return receiver.onKeyUp(mKeyCode, this);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们暂时分析一下ACTION_UP事件，可以发现这里最终调用的是receiver.onKeyUp方法，而这里的receiver就是我们的Actiivty，所以这里又回到了Activity并且执行其onKeyUp方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean onKeyUp(int keyCode, KeyEvent event) &#123;</span><br><span class="line">        if (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;&#x3D; Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">            if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking()</span><br><span class="line">                    &amp;&amp; !event.isCanceled()) &#123;</span><br><span class="line">                onBackPressed();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看onKeyUp方法，我们可以发现当我们按的是返回按键时，其回调了onBackPressed方法，所以我们继续看一下onBackPressed方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onBackPressed() &#123;</span><br><span class="line">        if (mActionBar !&#x3D; null &amp;&amp; mActionBar.collapseActionView()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mFragments.getFragmentManager().popBackStackImmediate()) &#123;</span><br><span class="line">            finishAfterTransition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在onBackPressed方法中，我们最终调用的是finishAfterTransition方法，所以继续看一下这个方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void finishAfterTransition() &#123;</span><br><span class="line">        if (!mActivityTransitionState.startExitBackTransition(this)) &#123;</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，原来finish方法是在这里调用的，这样我们按下返回按键并抬起之后，经过层层的调用之后最终调用了我们的finish方法，而这个方法就是finish掉Activity的方法，也就解释了我们在App中默认按下返回按键之后Acitivty会被销毁了。</p>
<p>总结：</p>
<ul>
<li><p>本文中由于是分析的返回按键的处理流程，所以事件的分发流程没有做说明，下面的文章中会着重介绍Android的事件分发流程；</p>
</li>
<li><p>事件分发流程从Native –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层都是类似的，无论是按键分发流程还是触摸事件分发流程</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">28 电源开关机按键事件流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。</p>
<p>和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。</p>
<p>下面首先看一下dispatchUnhandledKey方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode&#x3D;&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState&#x3D;&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过前面两篇文章的分析<br>（<a href="http://blog.csdn.net/qq_23547831/article/details/51474288" target="_blank" rel="noopener"> android源码解析（二十六）–&gt;截屏事件流程</a>&nbsp;&nbsp;<br><a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）<br>我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">            case KeyEvent.KEYCODE_POWER: &#123;</span><br><span class="line">                result &amp;&#x3D; ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey &#x3D; false; &#x2F;&#x2F; wake-up will be handled separately</span><br><span class="line">                if (down) &#123;</span><br><span class="line">                    interceptPowerKeyDown(event, interactive);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    interceptPowerKeyUp(event, interactive, canceled);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private void interceptPowerKeyDown(KeyEvent event, boolean interactive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Latch power key state to detect screenshot chord.</span><br><span class="line">        if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mScreenshotChordPowerKeyTriggered &#x3D; true;</span><br><span class="line">            mScreenshotChordPowerKeyTime &#x3D; event.getDownTime();</span><br><span class="line">            interceptScreenshotChord();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Stop ringing or end call if configured to do so when power is pressed.</span><br><span class="line">        TelecomManager telecomManager &#x3D; getTelecommService();</span><br><span class="line">        boolean hungUp &#x3D; false;</span><br><span class="line">        if (telecomManager !&#x3D; null) &#123;</span><br><span class="line">            if (telecomManager.isRinging()) &#123;</span><br><span class="line">                &#x2F;&#x2F; Pressing Power while there&#39;s a ringing incoming</span><br><span class="line">                &#x2F;&#x2F; call should silence the ringer.</span><br><span class="line">                telecomManager.silenceRinger();</span><br><span class="line">            &#125; else if ((mIncallPowerBehavior</span><br><span class="line">                    &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) !&#x3D; 0</span><br><span class="line">                    &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; Otherwise, if &quot;Power button ends call&quot; is enabled,</span><br><span class="line">                &#x2F;&#x2F; the Power button will hang up any current active call.</span><br><span class="line">                hungUp &#x3D; telecomManager.endCall();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the power key has still not yet been handled, then detect short</span><br><span class="line">        &#x2F;&#x2F; press, long press, or multi press and decide what to do.</span><br><span class="line">        mPowerKeyHandled &#x3D; hungUp || mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                || mScreenshotChordVolumeUpKeyTriggered;</span><br><span class="line">        if (!mPowerKeyHandled) &#123;</span><br><span class="line">            if (interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; When interactive, we&#39;re already awake.</span><br><span class="line">                &#x2F;&#x2F; Wait for a long press or for the button to be released to decide what to do.</span><br><span class="line">                if (hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                wakeUpFromPowerKey(event.getDownTime());</span><br><span class="line"></span><br><span class="line">                if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                    mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int maxCount &#x3D; getMaxMultiPressPowerCount();</span><br><span class="line"></span><br><span class="line">                    if (maxCount &lt;&#x3D; 1) &#123;</span><br><span class="line">                        mPowerKeyHandled &#x3D; true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case MSG_POWER_LONG_PRESS:</span><br><span class="line">                    powerLongPress();</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void powerLongPress() &#123;</span><br><span class="line">        final int behavior &#x3D; getResolvedLongPressOnPowerBehavior();</span><br><span class="line">        switch (behavior) &#123;</span><br><span class="line">        case LONG_PRESS_POWER_NOTHING:</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_GLOBAL_ACTIONS:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) &#123;</span><br><span class="line">                performAuditoryFeedbackForAccessibilityIfNeed();</span><br><span class="line">            &#125;</span><br><span class="line">            showGlobalActionsInternal();</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF:</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">            mWindowManagerFuncs.shutdown(behavior &#x3D;&#x3D; LONG_PRESS_POWER_SHUT_OFF);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面：<br><img src="http://img.blog.csdn.net/20160524153125405" alt="这里写图片描述"></p>
<p>然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void showGlobalActionsInternal() &#123;</span><br><span class="line">        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">        if (mGlobalActions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mGlobalActions &#x3D; new GlobalActions(mContext, mWindowManagerFuncs);</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean keyguardShowing &#x3D; isKeyguardShowingAndNotOccluded();</span><br><span class="line">        mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned());</span><br><span class="line">        if (keyguardShowing) &#123;</span><br><span class="line">            &#x2F;&#x2F; since it took two seconds of long press to bring this up,</span><br><span class="line">            &#x2F;&#x2F; poke the wake lock so they have some time to see the dialog.</span><br><span class="line">            mPowerManager.userActivity(SystemClock.uptimeMillis(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（<a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">        mAudioManager &#x3D; (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">        mDreamManager &#x3D; IDreamManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(DreamService.DREAM_SERVICE));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; receive broadcasts</span><br><span class="line">        IntentFilter filter &#x3D; new IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);</span><br><span class="line">        context.registerReceiver(mBroadcastReceiver, filter);</span><br><span class="line"></span><br><span class="line">        ConnectivityManager cm &#x3D; (ConnectivityManager)</span><br><span class="line">                context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        mHasTelephony &#x3D; cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; get notified of phone state changes</span><br><span class="line">        TelephonyManager telephonyManager &#x3D;</span><br><span class="line">                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);</span><br><span class="line">        mContext.getContentResolver().registerContentObserver(</span><br><span class="line">                Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true,</span><br><span class="line">                mAirplaneModeObserver);</span><br><span class="line">        Vibrator vibrator &#x3D; (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">        mHasVibrator &#x3D; vibrator !&#x3D; null &amp;&amp; vibrator.hasVibrator();</span><br><span class="line"></span><br><span class="line">        mShowSilentToggle &#x3D; SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_useFixedVolume);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) &#123;</span><br><span class="line">        mKeyguardShowing &#x3D; keyguardShowing;</span><br><span class="line">        mDeviceProvisioned &#x3D; isDeviceProvisioned;</span><br><span class="line">        if (mDialog !&#x3D; null) &#123;</span><br><span class="line">            mDialog.dismiss();</span><br><span class="line">            mDialog &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; Show delayed, so that the dismiss of the previous dialog completes</span><br><span class="line">            mHandler.sendEmptyMessage(MESSAGE_SHOW);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleShow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void handleShow() &#123;</span><br><span class="line">        awakenIfNecessary();</span><br><span class="line">        mDialog &#x3D; createDialog();</span><br><span class="line">        prepareDialog();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we only have 1 item and it&#39;s a simple press action, just do this action.</span><br><span class="line">        if (mAdapter.getCount() &#x3D;&#x3D; 1</span><br><span class="line">                &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction</span><br><span class="line">                &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) &#123;</span><br><span class="line">            ((SinglePressAction) mAdapter.getItem(0)).onPress();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            WindowManager.LayoutParams attrs &#x3D; mDialog.getWindow().getAttributes();</span><br><span class="line">            attrs.setTitle(&quot;GlobalActions&quot;);</span><br><span class="line">            mDialog.getWindow().setAttributes(attrs);</span><br><span class="line">            mDialog.show();</span><br><span class="line">            mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">private GlobalActionsDialog createDialog() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mAirplaneModeOn &#x3D; new ToggleAction(</span><br><span class="line">                R.drawable.ic_lock_airplane_mode,</span><br><span class="line">                R.drawable.ic_lock_airplane_mode_off,</span><br><span class="line">                R.string.global_actions_toggle_airplane_mode,</span><br><span class="line">                R.string.global_actions_airplane_mode_on_status,</span><br><span class="line">                R.string.global_actions_airplane_mode_off_status) &#123;</span><br><span class="line"></span><br><span class="line">            void onToggle(boolean on) &#123;</span><br><span class="line">                if (mHasTelephony &amp;&amp; Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) &#123;</span><br><span class="line">                    mIsWaitingForEcmExit &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; Launch ECM exit dialog</span><br><span class="line">                    Intent ecmDialogIntent &#x3D;</span><br><span class="line">                            new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);</span><br><span class="line">                    ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                    mContext.startActivity(ecmDialogIntent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    changeAirplaneModeSystemSetting(on);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected void changeStateFromPress(boolean buttonOn) &#123;</span><br><span class="line">                if (!mHasTelephony) return;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; In ECM mode airplane state cannot be changed</span><br><span class="line">                if (!(Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) &#123;</span><br><span class="line">                    mState &#x3D; buttonOn ? State.TurningOn : State.TurningOff;</span><br><span class="line">                    mAirplaneState &#x3D; mState;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showDuringKeyguard() &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showBeforeProvisioning() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        onAirplaneModeChanged();</span><br><span class="line"></span><br><span class="line">        mItems &#x3D; new ArrayList&lt;Action&gt;();</span><br><span class="line">        String[] defaultActions &#x3D; mContext.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_globalActionsList);</span><br><span class="line"></span><br><span class="line">        ArraySet&lt;String&gt; addedKeys &#x3D; new ArraySet&lt;String&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; defaultActions.length; i++) &#123;</span><br><span class="line">            String actionKey &#x3D; defaultActions[i];</span><br><span class="line">            if (addedKeys.contains(actionKey)) &#123;</span><br><span class="line">                &#x2F;&#x2F; If we already have added this, don&#39;t add it again.</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(new PowerAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(mAirplaneModeOn);</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) &#123;</span><br><span class="line">                if (Settings.Global.getInt(mContext.getContentResolver(),</span><br><span class="line">                        Settings.Global.BUGREPORT_IN_POWER_MENU, 0) !&#x3D; 0 &amp;&amp; isCurrentUserOwner()) &#123;</span><br><span class="line">                    mItems.add(getBugReportAction());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) &#123;</span><br><span class="line">                if (mShowSilentToggle) &#123;</span><br><span class="line">                    mItems.add(mSilentModeAction);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) &#123;</span><br><span class="line">                if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) &#123;</span><br><span class="line">                    addUsersToMenu(mItems);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getSettingsAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getLockdownAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getVoiceAssistAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getAssistAction());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;Invalid global action key &quot; + actionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Add here so we don&#39;t add more than one.</span><br><span class="line">            addedKeys.add(actionKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdapter &#x3D; new MyAdapter();</span><br><span class="line"></span><br><span class="line">        AlertParams params &#x3D; new AlertParams(mContext);</span><br><span class="line">        params.mAdapter &#x3D; mAdapter;</span><br><span class="line">        params.mOnClickListener &#x3D; this;</span><br><span class="line">        params.mForceInverseBackground &#x3D; true;</span><br><span class="line"></span><br><span class="line">        GlobalActionsDialog dialog &#x3D; new GlobalActionsDialog(mContext, params);</span><br><span class="line">        dialog.setCanceledOnTouchOutside(false); &#x2F;&#x2F; Handled by the custom class.</span><br><span class="line"></span><br><span class="line">        dialog.getListView().setItemsCanFocus(true);</span><br><span class="line">        dialog.getListView().setLongClickable(true);</span><br><span class="line">        dialog.getListView().setOnItemLongClickListener(</span><br><span class="line">                new AdapterView.OnItemLongClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position,</span><br><span class="line">                            long id) &#123;</span><br><span class="line">                        final Action action &#x3D; mAdapter.getItem(position);</span><br><span class="line">                        if (action instanceof LongPressAction) &#123;</span><br><span class="line">                            return ((LongPressAction) action).onLongPress();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        dialog.setOnDismissListener(this);</span><br><span class="line"></span><br><span class="line">        return dialog;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面：<br><img src="http://img.blog.csdn.net/20160525144307466" alt="这里写图片描述"></p>
<p>好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mItems.add(new PowerAction());</span><br></pre></td></tr></table></figure>
<p>这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final class PowerAction extends SinglePressAction implements LongPressAction &#123;</span><br><span class="line">        private PowerAction() &#123;</span><br><span class="line">            super(com.android.internal.R.drawable.ic_lock_power_off,</span><br><span class="line">                R.string.global_action_power_off);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onLongPress() &#123;</span><br><span class="line">            UserManager um &#x3D; (UserManager) mContext.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) &#123;</span><br><span class="line">                mWindowManagerFuncs.rebootSafeMode(true);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showDuringKeyguard() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showBeforeProvisioning() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onPress() &#123;</span><br><span class="line">            &#x2F;&#x2F; shutdown by making sure radio and power are handled accordingly.</span><br><span class="line">            mWindowManagerFuncs.shutdown(false &#x2F;* confirm *&#x2F;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">		...</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。</p>
<p>经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initPolicy() &#123;</span><br><span class="line">        UiThread.getHandler().runWithScissors(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line"></span><br><span class="line">                mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。</p>
<p>然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false /* confirm */);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void shutdown(boolean confirm) &#123;</span><br><span class="line">        ShutdownThread.shutdown(mContext, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void shutdown(final Context context, boolean confirm) &#123;</span><br><span class="line">        mReboot &#x3D; false;</span><br><span class="line">        mRebootSafeMode &#x3D; false;</span><br><span class="line">        shutdownInner(context, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void shutdownInner(final Context context, boolean confirm) &#123;</span><br><span class="line">        &#x2F;&#x2F; ensure that only one thread is trying to power down.</span><br><span class="line">        &#x2F;&#x2F; any additional calls are just returned</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int longPressBehavior &#x3D; context.getResources().getInteger(</span><br><span class="line">                        com.android.internal.R.integer.config_longPressOnPowerBehavior);</span><br><span class="line">        final int resourceId &#x3D; mRebootSafeMode</span><br><span class="line">                ? com.android.internal.R.string.reboot_safemode_confirm</span><br><span class="line">                : (longPressBehavior &#x3D;&#x3D; 2</span><br><span class="line">                        ? com.android.internal.R.string.shutdown_confirm_question</span><br><span class="line">                        : com.android.internal.R.string.shutdown_confirm);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior&#x3D;&quot; + longPressBehavior);</span><br><span class="line"></span><br><span class="line">        if (confirm) &#123;</span><br><span class="line">            final CloseDialogReceiver closer &#x3D; new CloseDialogReceiver(context);</span><br><span class="line">            if (sConfirmDialog !&#x3D; null) &#123;</span><br><span class="line">                sConfirmDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">            sConfirmDialog &#x3D; new AlertDialog.Builder(context)</span><br><span class="line">                    .setTitle(mRebootSafeMode</span><br><span class="line">                            ? com.android.internal.R.string.reboot_safemode_title</span><br><span class="line">                            : com.android.internal.R.string.power_off)</span><br><span class="line">                    .setMessage(resourceId)</span><br><span class="line">                    .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            beginShutdownSequence(context);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(com.android.internal.R.string.no, null)</span><br><span class="line">                    .create();</span><br><span class="line">            closer.dialog &#x3D; sConfirmDialog;</span><br><span class="line">            sConfirmDialog.setOnDismissListener(closer);</span><br><span class="line">            sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line">            sConfirmDialog.show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            beginShutdownSequence(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">private static void beginShutdownSequence(Context context) &#123;</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            sIsStarted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) &#123;</span><br><span class="line">            mRebootUpdate &#x3D; new File(UNCRYPT_PACKAGE_FILE).exists();</span><br><span class="line">            if (mRebootUpdate) &#123;</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_update_prepare));</span><br><span class="line">                pd.setMax(100);</span><br><span class="line">                pd.setProgressNumberFormat(null);</span><br><span class="line">                pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">                pd.setProgress(0);</span><br><span class="line">                pd.setIndeterminate(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Factory reset path. Set the dialog message accordingly.</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pd.setTitle(context.getText(com.android.internal.R.string.power_off));</span><br><span class="line">            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));</span><br><span class="line">            pd.setIndeterminate(true);</span><br><span class="line">        &#125;</span><br><span class="line">        pd.setCancelable(false);</span><br><span class="line">        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        pd.show();</span><br><span class="line"></span><br><span class="line">        sInstance.mProgressDialog &#x3D; pd;</span><br><span class="line">        sInstance.mContext &#x3D; context;</span><br><span class="line">        sInstance.mPowerManager &#x3D; (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; make sure we never fall asleep again</span><br><span class="line">        sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                    PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;);</span><br><span class="line">            sInstance.mCpuWakeLock.setReferenceCounted(false);</span><br><span class="line">            sInstance.mCpuWakeLock.acquire();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; also make sure the screen stays on for better user experience</span><br><span class="line">        sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">        if (sInstance.mPowerManager.isScreenOn()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                        PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;);</span><br><span class="line">                sInstance.mScreenWakeLock.setReferenceCounted(false);</span><br><span class="line">                sInstance.mScreenWakeLock.acquire();</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; start the thread that initiates shutdown</span><br><span class="line">        sInstance.mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        sInstance.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。</p>
<p>总结：</p>
<ul>
<li><p>电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中；</p>
</li>
<li><p>在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等；</p>
</li>
<li><p>当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
