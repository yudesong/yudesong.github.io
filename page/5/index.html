<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Picasso 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:16:36" itemprop="dateCreated datePublished" datetime="2020-05-31T11:16:36+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="Picasso简介"><a href="#Picasso简介" class="headerlink" title="Picasso简介"></a>Picasso简介</h5><p>Picasso是鼎鼎有名的Square公司的一个开源项目，该公司同时开源了许多知名的项目，比如Okhttp，Retrofit，Otto等。Picasso继承了Okhttp的链式调用风格，使得它使用起来非常简单和方便，并且它的设计和实现也很轻量简单，使得整个库的接口数量和体积都很小，因此被很多开发者使用在项目中。下面我们来看一下Picasso的总体设计：</p>
<p><img src="https://img-blog.csdnimg.cn/20190126151924568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rZ2F5cw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>Picasso是通过服务器来实现的本地缓存并且都是原图，因此如果能根据图片尺寸来控制缓存图片的大小可以进一步降低本地储存的空间和图片处理的开销。(Glide 就是根据不同的图片尺寸来缓存不同的图片)</p>
<h5 id="Picasso-源码剖析"><a href="#Picasso-源码剖析" class="headerlink" title="Picasso 源码剖析"></a>Picasso 源码剖析</h5><h6 id="get、load、with-函数"><a href="#get、load、with-函数" class="headerlink" title="get、load、with 函数"></a>get、load、with 函数</h6><p>Picasso.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">public class Picasso &#123;</span><br><span class="line">  static volatile Picasso singleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单例模式</span><br><span class="line">  public static Picasso get() &#123;</span><br><span class="line">    if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized (Picasso.class) &#123;</span><br><span class="line">        if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">          if (PicassoProvider.context &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;context &#x3D;&#x3D; null&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          singleton &#x3D; new Builder(PicassoProvider.context).build();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 构建模式，初始化Picasso关键成员变量</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    public Picasso build() &#123;</span><br><span class="line">      Context context &#x3D; this.context;</span><br><span class="line"></span><br><span class="line">      if (downloader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 图片下载</span><br><span class="line">        downloader &#x3D; new OkHttp3Downloader(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (cache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 内存缓存</span><br><span class="line">        cache &#x3D; new LruCache(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (service &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池 (默认开启3个线程, 根据网络WiFi-&gt;4 、4G-&gt;3、 3G-&gt;2, 2G-&gt;1)</span><br><span class="line">        service &#x3D; new PicassoExecutorService();</span><br><span class="line">      &#125;</span><br><span class="line">      if (transformer &#x3D;&#x3D; null) &#123;</span><br><span class="line">        transformer &#x3D; RequestTransformer.IDENTITY;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 记录缓存命中次数、丢失次数等</span><br><span class="line">      Stats stats &#x3D; new Stats(cache);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 分发器</span><br><span class="line">      Dispatcher dispatcher &#x3D; new Dispatcher(context, service, HANDLER, downloader, cache, stats);</span><br><span class="line"></span><br><span class="line">      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</span><br><span class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static final Handler HANDLER &#x3D; new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    @Override public void handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case HUNTER_BATCH_COMPLETE: &#123;</span><br><span class="line">          &#x2F;&#x2F; 更新UI界面</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;BitmapHunter&gt; batch &#x3D; (List&lt;BitmapHunter&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            BitmapHunter hunter &#x3D; batch.get(i);</span><br><span class="line">            hunter.picasso.complete(hunter); </span><br><span class="line">            &#x2F;&#x2F; 最终会调用action.complete(result, from);显示图片</span><br><span class="line">            &#x2F;&#x2F; 最终会调到这里：target.setImageDrawable(drawable)</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_GCED: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), &quot;target got garbage collected&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          action.picasso.cancelExistingRequest(action.getTarget());</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_BATCH_RESUME:</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;Action&gt; batch &#x3D; (List&lt;Action&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            Action action &#x3D; batch.get(i);</span><br><span class="line">            action.picasso.resumeAction(action);</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; load URL,会创建RequestCreator对象</span><br><span class="line">  public RequestCreator load(@Nullable String path) &#123;</span><br><span class="line">    if (path &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return new RequestCreator(this, null, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (path.trim().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return load(Uri.parse(path));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator load(@Nullable Uri uri) &#123;</span><br><span class="line">    return new RequestCreator(this, uri, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; RequestCreator会在into(ImageView)方法的时候，封装ImageViewAction extends Action</span><br><span class="line">  void enqueueAndSubmit(Action action) &#123;</span><br><span class="line">    Object target &#x3D; action.getTarget();</span><br><span class="line">    if (target !&#x3D; null &amp;&amp; targetToAction.get(target) !&#x3D; action) &#123;</span><br><span class="line">      &#x2F;&#x2F; This will also check we are on the main thread.</span><br><span class="line">      cancelExistingRequest(target);</span><br><span class="line">      targetToAction.put(target, action);</span><br><span class="line">    &#125;</span><br><span class="line">    submit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void submit(Action action) &#123;</span><br><span class="line">    dispatcher.dispatchSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Picasso 的get()方法采用双重检验锁形式获取Picasso单例，在<strong>new Picasso()</strong> 的时候采用Builder构造模式初始化Picasso关键成员变量。主要有<strong>PicassoExecutorService</strong>、<strong>OkHttp3Downloader</strong>、<strong>LruCache</strong>、<strong>Dispatcher</strong>。值得关注的是<strong>PicassoProvider</strong>这个内容提供者，<strong>onCreate</strong>方法的调用是ActivityThread的启动的时候就已经调用了，比Application的初始化要早。像这种获取Context对象黑技术在Leakcanary里面也是一样的。</p>
<p><strong>RequestCreator.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">public class RequestCreator &#123;</span><br><span class="line">  private final Picasso picasso;</span><br><span class="line">  private final Request.Builder data;</span><br><span class="line">  private boolean deferred;</span><br><span class="line"></span><br><span class="line">  RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123;</span><br><span class="line">    this.picasso &#x3D; picasso;</span><br><span class="line">    this.data &#x3D; new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator fit() &#123;</span><br><span class="line">    deferred &#x3D; true;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator placeholder(@NonNull Drawable placeholderDrawable) &#123;</span><br><span class="line">    this.placeholderDrawable &#x3D; placeholderDrawable;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static boolean isMain() &#123;</span><br><span class="line">    return Looper.getMainLooper().getThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void checkMain() &#123;</span><br><span class="line">    if (!isMain()) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Method call should happen from the main thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target) &#123;</span><br><span class="line">    into(target, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target, Callback callback) &#123;</span><br><span class="line">    long started &#x3D; System.nanoTime();</span><br><span class="line">    checkMain();</span><br><span class="line">    &#x2F;&#x2F; 检查Uri 或者 resourceId是否为空</span><br><span class="line">    if (!data.hasImage()) &#123;  &#x2F;&#x2F; -&gt; uri !&#x3D; null || resourceId !&#x3D; 0</span><br><span class="line">      picasso.cancelRequest(target);</span><br><span class="line">      if (setPlaceholder) &#123;</span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (deferred) &#123;</span><br><span class="line">      if (data.hasSize()) &#123;  &#x2F;&#x2F; -&gt; targetWidth !&#x3D; 0 || targetHeight !&#x3D; 0</span><br><span class="line">        throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      int width &#x3D; target.getWidth();</span><br><span class="line">      int height &#x3D; target.getHeight();</span><br><span class="line">      if (width &#x3D;&#x3D; 0 || height &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (setPlaceholder) &#123;</span><br><span class="line">          setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">        &#125;</span><br><span class="line">        picasso.defer(target, new DeferredRequestCreator(this, target, callback));</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      data.resize(width, height);  &#x2F;&#x2F; -&gt; this.targetWidth &#x3D; targetWidth; this.targetHeight &#x3D; targetHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; createRequest(started);</span><br><span class="line">    String requestKey &#x3D; createKey(request);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 缓存中存在，则从缓存中获取, 取消请求，返回缓存值</span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      Bitmap bitmap &#x3D; picasso.quickMemoryCacheCheck(requestKey);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        picasso.cancelRequest(target);</span><br><span class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (callback !&#x3D; null) &#123;</span><br><span class="line">          callback.onSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置placeholder</span><br><span class="line">    if (setPlaceholder) &#123;</span><br><span class="line">      setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建Action用于网络请求</span><br><span class="line">    Action action &#x3D;</span><br><span class="line">        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</span><br><span class="line">            errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line"></span><br><span class="line">    picasso.enqueueAndSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Request createRequest(long started) &#123;</span><br><span class="line">    int id &#x3D; nextId.getAndIncrement();</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; data.build();</span><br><span class="line">    request.id &#x3D; id;</span><br><span class="line">    request.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">    boolean loggingEnabled &#x3D; picasso.loggingEnabled;</span><br><span class="line">    if (loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request transformed &#x3D; picasso.transformRequest(request);</span><br><span class="line">    if (transformed !&#x3D; request) &#123;</span><br><span class="line">      &#x2F;&#x2F; If the request was changed, copy over the id and timestamp from the original.</span><br><span class="line">      transformed.id &#x3D; id;</span><br><span class="line">      transformed.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">      if (loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), &quot;into &quot; + transformed);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return transformed;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RequestCreator</strong>, 在into(ImageView)的时候会进行必要的参数校验，创建Request请求对象，从LruCache缓存中检测是否有已经请求的返回结果，如果有的则直接返回，否则创建ImageViewAction对象后面进行网络请求。<strong>picasso.enqueueAndSubmit(action)</strong> 最终会调到<strong>dispatcher.dispatchSubmit(action);</strong></p>
<p><strong>Dispatcher.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">class Dispatcher &#123;</span><br><span class="line">  final Map&lt;String, BitmapHunter&gt; hunterMap;</span><br><span class="line">  final Map&lt;Object, Action&gt; failedActions;</span><br><span class="line">  final Map&lt;Object, Action&gt; pausedActions;</span><br><span class="line"></span><br><span class="line">  private static class DispatcherHandler extends Handler &#123;</span><br><span class="line">    private final Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">    DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123;</span><br><span class="line">      super(looper);</span><br><span class="line">      this.dispatcher &#x3D; dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void handleMessage(final Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case REQUEST_SUBMIT: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performSubmit(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_CANCEL: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performCancel(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_PAUSE: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performPauseTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_RESUME: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performResumeTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，会回调到此处</span><br><span class="line">        case HUNTER_COMPLETE: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performComplete(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_RETRY: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performRetry(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DECODE_FAILED: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performError(hunter, false);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DELAY_NEXT_BATCH: &#123;</span><br><span class="line">          dispatcher.performBatchComplete();</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case NETWORK_STATE_CHANGE: &#123;</span><br><span class="line">          NetworkInfo info &#x3D; (NetworkInfo) msg.obj;</span><br><span class="line">          dispatcher.performNetworkStateChange(info);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case AIRPLANE_MODE_CHANGE: &#123;</span><br><span class="line">          dispatcher.performAirplaneModeChange(msg.arg1 &#x3D;&#x3D; AIRPLANE_MODE_ON);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">          Picasso.HANDLER.post(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 通过handler发送REQUEST_SUBMIT消息，最终会走到performSubmit(action)</span><br><span class="line">  void dispatchSubmit(Action action) &#123;</span><br><span class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void performSubmit(Action action) &#123;</span><br><span class="line">    performSubmit(action, true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * performSubmit执行过程：</span><br><span class="line">   * 1. 检查action 是否在pausedTags集合中，如果存在则直接替换覆盖</span><br><span class="line">   * 2. 如果action 存在hunterMap中， 则直接attach</span><br><span class="line">   * 3. 创建BitmapHunter，添加到PicassoExecutorService线程池</span><br><span class="line">   *&#x2F;</span><br><span class="line">  void performSubmit(Action action, boolean dismissFailed) &#123;</span><br><span class="line">    if (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">      pausedActions.put(action.getTarget(), action);</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</span><br><span class="line">            &quot;because tag &#39;&quot; + action.getTag() + &quot;&#39; is paused&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BitmapHunter hunter &#x3D; hunterMap.get(action.getKey());</span><br><span class="line">    if (hunter !&#x3D; null) &#123;</span><br><span class="line">      hunter.attach(action);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (service.isShutdown()) &#123;</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hunter &#x3D; forRequest(action.getPicasso(), this, cache, stats, action);</span><br><span class="line">    hunter.future &#x3D; service.submit(hunter);</span><br><span class="line">    hunterMap.put(action.getKey(), hunter);</span><br><span class="line">    if (dismissFailed) &#123;</span><br><span class="line">      failedActions.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 创建BitmapHunter对象</span><br><span class="line">   * 1. picasso.getRequestHandlers() 类似于拦截器作用，依次从ResourceRequestHandler、</span><br><span class="line">   * ContactsPhotoRequestHandler、MediaStoreRequestHandler、ContentStreamRequestHandler、</span><br><span class="line">   * AssetRequestHandler、FileRequestHandler、NetworkRequestHandler 调用canHandleRequest方法，判断交给那个Handler处理， 一般的网络图片就是NetworkRequestHandler</span><br><span class="line">   * </span><br><span class="line">   *&#x2F;</span><br><span class="line">  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span><br><span class="line">      Action action) &#123;</span><br><span class="line">    Request request &#x3D; action.getRequest();</span><br><span class="line">    List&lt;RequestHandler&gt; requestHandlers &#x3D; picasso.getRequestHandlers();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Index-based loop to avoid allocating an iterator.</span><br><span class="line">    &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">    for (int i &#x3D; 0, count &#x3D; requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">      RequestHandler requestHandler &#x3D; requestHandlers.get(i);</span><br><span class="line">      if (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">        return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 网络请求成功会回调到performComplete</span><br><span class="line">  void performComplete(BitmapHunter hunter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加到Cache缓存</span><br><span class="line">    if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">      cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    hunterMap.remove(hunter.getKey());</span><br><span class="line">    batch(hunter);</span><br><span class="line">    if (hunter.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), &quot;for completion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 网络返回结果，将hunter添加到batch之中，延迟200ms发送HUNTER_DELAY_NEXT_BATCH</span><br><span class="line">  private void batch(BitmapHunter hunter) &#123;</span><br><span class="line">    if (hunter.isCancelled()) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hunter.result !&#x3D; null) &#123;</span><br><span class="line">      hunter.result.prepareToDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    batch.add(hunter);</span><br><span class="line">    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知主线程更新UI界面</span><br><span class="line">  void performBatchComplete() &#123;</span><br><span class="line">    List&lt;BitmapHunter&gt; copy &#x3D; new ArrayList&lt;&gt;(batch);</span><br><span class="line">    batch.clear();</span><br><span class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</span><br><span class="line">    logBatch(copy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Dispatcher</strong>分发器的作用就是：调度网络请求，回调返回结果</p>
<p><strong>BitmapHunter.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class BitmapHunter implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void run() &#123;</span><br><span class="line">      ...</span><br><span class="line">      result &#x3D; hunt();</span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        dispatcher.dispatchFailed(this);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，回调到Dispatcher</span><br><span class="line">        dispatcher.dispatchComplete(this);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Bitmap hunt() throws IOException &#123;</span><br><span class="line">    Bitmap bitmap &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      bitmap &#x3D; cache.get(key);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        stats.dispatchCacheHit();</span><br><span class="line">        loadedFrom &#x3D; MEMORY;</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), &quot;from cache&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    networkPolicy &#x3D; retryCount &#x3D;&#x3D; 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">    RequestHandler.Result result &#x3D; requestHandler.load(data, networkPolicy);</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      loadedFrom &#x3D; result.getLoadedFrom();</span><br><span class="line">      exifOrientation &#x3D; result.getExifOrientation();</span><br><span class="line">      bitmap &#x3D; result.getBitmap();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If there was no Bitmap then we need to decode it from the stream.</span><br><span class="line">      if (bitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        Source source &#x3D; result.getSource();</span><br><span class="line">        try &#123;</span><br><span class="line">          bitmap &#x3D; decodeStream(source, data);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            &#x2F;&#x2F;noinspection ConstantConditions If bitmap is null then source is guranteed non-null.</span><br><span class="line">            source.close();</span><br><span class="line">          &#125; catch (IOException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bitmap !&#x3D; null) &#123;</span><br><span class="line">      if (picasso.loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</span><br><span class="line">      &#125;</span><br><span class="line">      stats.dispatchBitmapDecoded(bitmap);</span><br><span class="line">      if (data.needsTransformation() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">        synchronized (DECODE_LOCK) &#123;</span><br><span class="line">          if (data.needsMatrixTransform() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">            bitmap &#x3D; transformResult(data, bitmap, exifOrientation);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (data.hasCustomTransformations()) &#123;</span><br><span class="line">            bitmap &#x3D; applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), &quot;from custom transformations&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap !&#x3D; null) &#123;</span><br><span class="line">          stats.dispatchBitmapTransformed(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BitmapHunter</strong> 的run方法就是利用OKHttpClient进行网络请求</p>
<p>NetworkRequestHandler.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NetworkRequestHandler extends RequestHandler &#123;</span><br><span class="line"></span><br><span class="line">  @Override public Result load(Request request, int networkPolicy) throws IOException &#123;</span><br><span class="line">    okhttp3.Request downloaderRequest &#x3D; createRequest(request, networkPolicy);</span><br><span class="line">    Response response &#x3D; downloader.load(downloaderRequest);</span><br><span class="line">    ResponseBody body &#x3D; response.body();</span><br><span class="line"></span><br><span class="line">    if (!response.isSuccessful()) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ResponseException(response.code(), request.networkPolicy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache response is only null when the response comes fully from the network. Both completely</span><br><span class="line">    &#x2F;&#x2F; cached and conditionally cached responses will have a non-null cache response.</span><br><span class="line">    Picasso.LoadedFrom loadedFrom &#x3D; response.cacheResponse() &#x3D;&#x3D; null ? NETWORK : DISK;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Sometimes response content length is zero when requests are being replayed. Haven&#39;t found</span><br><span class="line">    &#x2F;&#x2F; root cause to this but retrying the request seems safe to do so.</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; DISK &amp;&amp; body.contentLength() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ContentLengthException(&quot;Received response with 0 content-length header.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; NETWORK &amp;&amp; body.contentLength() &gt; 0) &#123;</span><br><span class="line">      stats.dispatchDownloadFinished(body.contentLength());</span><br><span class="line">    &#125;</span><br><span class="line">    return new Result(body.source(), loadedFrom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OkHttp3Downloader.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class OkHttp3Downloader implements Downloader &#123;</span><br><span class="line">  @VisibleForTesting final Call.Factory client;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建磁盘缓存目录</span><br><span class="line">  public OkHttp3Downloader(final Context context) &#123;</span><br><span class="line">    this(Utils.createDefaultCacheDir(context));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull @Override public Response load(@NonNull Request request) throws IOException &#123;</span><br><span class="line">    return client.newCall(request).execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Picasso 缓存策略： 首先从内存缓存 -&gt; OkHttp磁盘缓存 -&gt; 网络请求</strong></p>
<h5 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h5><p><a href="https://www.jianshu.com/p/a5a79d861787" target="_blank" rel="noopener">1. picasso详解及其源码简析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:15:34 / 修改时间：11:15:54" itemprop="dateCreated datePublished" datetime="2020-05-31T11:15:34+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、OkHttp-简介"><a href="#一、OkHttp-简介" class="headerlink" title="一、OkHttp 简介"></a>一、OkHttp 简介</h5><p>HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：</p>
<ul>
<li>支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接</li>
<li>连接池减少请求延时</li>
<li>透明的GZIP压缩减少响应数据的大小</li>
<li>缓存响应内容，避免一些完全重复的请求</li>
</ul>
<p>当网络出现问题的时候OkHttp依然坚守自己的职责，它会自动恢复一般的连接问题，如果你的服务有多个IP地址，当第一个IP请求失败时，OkHttp会交替尝试你配置的其他IP，OkHttp使用现代TLS技术(SNI, ALPN)初始化新的连接，当握手失败时会回退到TLS 1.0。</p>
<p>官网链接地址：<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">https://square.github.io/okhttp/</a></p>
<h5 id="二、OkHttp-使用"><a href="#二、OkHttp-使用" class="headerlink" title="二、OkHttp 使用"></a>二、OkHttp 使用</h5><h5 id="2-1-同步请求"><a href="#2-1-同步请求" class="headerlink" title="2.1 同步请求"></a>2.1 同步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line">     </span><br><span class="line">Response response = okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>

<h5 id="2-2-异步请求"><a href="#2-2-异步请求" class="headerlink" title="2.2 异步请求"></a>2.2 异步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line"></span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="三、OkHttp-原理剖析"><a href="#三、OkHttp-原理剖析" class="headerlink" title="三、OkHttp 原理剖析"></a>三、OkHttp 原理剖析</h5><p><img src="https://upload-images.jianshu.io/upload_images/692087-b2db5588ceb9d9c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="OkHttp 结构图"></p>
<h6 id="3-1-OkHttpClient-构建"><a href="#3-1-OkHttpClient-构建" class="headerlink" title="3.1 OkHttpClient 构建"></a>3.1 OkHttpClient 构建</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> dispatcher: Dispatcher = builder.dispatcher</span><br><span class="line">    <span class="keyword">val</span> connectionPool: ConnectionPool = builder.connectionPool</span><br><span class="line">    <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; = builder.interceptors.toImmutableList()</span><br><span class="line">    <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; = builder.networkInterceptors.toImmutableList()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(Builder())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">newBuilder</span><span class="params">()</span></span>: Builder = Builder(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> dispatcher: Dispatcher = Dispatcher()</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectionPool: ConnectionPool = ConnectionPool()</span><br><span class="line">        <span class="comment">// 用户定义应用层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">        <span class="comment">// 用户自定义网络层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()    </span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> readTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> writeTimeout = <span class="number">10_000</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">writeTimeout</span><span class="params">(duration: <span class="type">Duration</span>)</span></span> = apply &#123;</span><br><span class="line">            writeTimeout = checkDuration(<span class="string">"timeout"</span>, duration.toMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: OkHttpClient = OkHttpClient(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpClient内部采用构建模式，定义了连接池、分发器、拦截器</p>
<h6 id="3-2-Call-对象"><a href="#3-2-Call-对象" class="headerlink" title="3.2 Call 对象"></a>3.2 Call 对象</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> transmitter: Transmitter</span><br><span class="line">  <span class="keyword">var</span> executed: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      originalRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      forWebSocket: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: RealCall &#123;</span><br><span class="line">      <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">        transmitter = Transmitter(client, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 同步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter()</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        transmitter.noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">"OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">        transmitter.timeoutEnter()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback = <span class="literal">true</span></span><br><span class="line">          responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.<span class="keyword">get</span>().log(INFO, <span class="string">"Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>"</span>, e)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += (client.cache)</span><br><span class="line">    interceptors += ConnectICacheInterceptornterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="keyword">this</span>,</span><br><span class="line">        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分发器：<strong><em>Dispatcher.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line">    <span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> idleCallback: Runnable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()    </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">      runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call)</span><br><span class="line">        <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">          <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">          <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line">      <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">      <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">          <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">          <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">          i.remove()</span><br><span class="line">          asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">          executableCalls.add(asyncCall)</span><br><span class="line">          runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isRunning</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">        finished(runningSyncCalls, call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>)</span><br><span class="line">          idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">          idleCallback.run()</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-拦截器链"><a href="#3-3-拦截器链" class="headerlink" title="3.3 拦截器链"></a>3.3 拦截器链</h6><p><img src="https://upload-images.jianshu.io/upload_images/10259072-269cd57a864d7f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/613/format/webp" alt="拦截器链"><br><strong><em>RealInterceptorChain.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> transmitter: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> exchange: Exchange?,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> connectTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> readTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> writeTimeout: <span class="built_in">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> calls: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>, transmitter: <span class="type">Transmitter</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line">    calls++</span><br><span class="line">    <span class="keyword">val</span> next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(<span class="string">"interceptor <span class="variable">$interceptor</span> returned null"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> response  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.1 RetryAndFollowUpInterceptor 失败重试及重定向</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">var</span> request = chain.request()</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      transmitter.prepareToConnect(request)</span><br><span class="line">      <span class="comment">// 检查当前请求是否被取消，如果这时请求被取消了，则会释放连接，并抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> response: Response</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = realChain.proceed(request, transmitter, <span class="literal">null</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, transmitter, <span class="literal">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">val</span> requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// The network call threw an exception. Release any resources.</span></span><br><span class="line">        <span class="comment">// 在请求过程中，只要发生异常，就会将连接释放掉</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          transmitter.exchangeDoneDueToException()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = response.exchange</span><br><span class="line">      <span class="keyword">val</span> route = exchange?.connection()?.route()</span><br><span class="line">      <span class="comment">// 响应response来执行followUpRequest方法，来检查是否需要进行重定向操作</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, route)</span><br><span class="line">      <span class="comment">// 不需要重定向，则断开链接，返回response，交给下一个拦截器</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          transmitter.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        exchange?.detachWithViolence()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重定向次数大于阈值</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">"Too many follow-up requests: <span class="variable">$followUpCount</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, route: <span class="type">Route</span>?)</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">    <span class="comment">// 我们知道，在Http响应码中，处于3XX的，都需要进行请求重定向处理</span></span><br><span class="line">    <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">      HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">        <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line"></span><br><span class="line">      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -&gt; &#123;</span><br><span class="line">        <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">        <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="string">"GET"</span> &amp;&amp; method != <span class="string">"HEAD"</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">        <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></span><br><span class="line">        <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></span><br><span class="line">        <span class="comment">// repeat the request (even non-idempotent ones.)</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">          <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">        <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userResponse.request</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// specifically received an instruction to retry without delay</span></span><br><span class="line">          <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据响应获取到位置location，然后根据location，得到重定向的url</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildRedirectRequest</span><span class="params">(userResponse: <span class="type">Response</span>, method: <span class="type">String</span>)</span></span>: Request? &#123;</span><br><span class="line">    <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">    <span class="keyword">if</span> (!client.followRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> location = userResponse.header(<span class="string">"Location"</span>) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">    <span class="keyword">val</span> url = userResponse.request.url.resolve(location) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">    <span class="keyword">val</span> sameScheme = url.scheme == userResponse.request.url.scheme</span><br><span class="line">    <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Most redirects don't include a request body.</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userResponse.request.newBuilder()</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">      <span class="keyword">val</span> maintainBody = HttpMethod.redirectsWithBody(method)</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">        requestBuilder.method(<span class="string">"GET"</span>, <span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> requestBody = <span class="keyword">if</span> (maintainBody) userResponse.request.body <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        requestBuilder.method(method, requestBody)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Type"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">    <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">    <span class="comment">// way to retain them.</span></span><br><span class="line">    <span class="keyword">if</span> (!userResponse.request.url.canReuseConnectionFor(url)) &#123;</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Authorization"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.url(url).build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取请求的response ，判断请求是否异常（释放连接），如果response正常,判断重定向条件</strong></p>
<ul>
<li>3.3.2 BridgeInterceptor 用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="literal">true</span></span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">        <span class="string">"gzip"</span>.equals(networkResponse.header(<span class="string">"Content-Encoding"</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">      <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">            .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">"Content-Type"</span>)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完善请求头和响应头</strong></p>
<ul>
<li>3.3.3 CacheInterceptor 缓存拦截器</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">//如果配置了缓存：优先从缓存中读取Response</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="comment">// 如果缓存不为空，但是策略器得到的结果是不能用缓存，也就是 cacheResponse 为 null，这种情况就是将 cacheCandidate.body() 进行 close 操作</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// //如果根据缓存策略strategy禁止使用网络，并且缓存无效，直接返回空的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 如果根据缓存策略strategy禁止使用网络，且有缓存则直接使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 本地有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 并且服务器返回304状态码（说明缓存还没过期或服务器资源没修改）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="comment">// 使用缓存数据 </span></span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="comment">// 返回缓存</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果网络资源已经修改：使用网络响应返回的最新数据</span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将最新的数据缓存起来</span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.4 ConnectInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">val</span> doExtensiveHealthChecks = request.method != <span class="string">"GET"</span></span><br><span class="line">    <span class="keyword">val</span> exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.5 CallServerInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange()</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向服务器发送请求</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> responseHeadersStarted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 检测是否有请求body</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">      <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return</span></span><br><span class="line">      <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">      <span class="comment">// 询问Server使用愿意接受数据 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equals(request.header(<span class="string">"Expect"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseHeadersStarted = <span class="literal">true</span></span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">          <span class="comment">// 向服务器发送requesyBody</span></span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">      exchange.responseHeadersStart()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建response对象</span></span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">      <span class="comment">// try again to read the actual response</span></span><br><span class="line">      response = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回空的即无效的响应</span></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equals(response.request.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">"close"</span>.equals(response.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="四、连接"><a href="#四、连接" class="headerlink" title="四、连接"></a>四、连接</h6><p><strong><em>Transmitter.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Transmitter(</span><br><span class="line">  private val client: OkHttpClient,</span><br><span class="line">  private val call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  private val connectionPool: RealConnectionPool &#x3D; client.connectionPool.delegate</span><br><span class="line">  private var exchangeFinder: ExchangeFinder? &#x3D; null</span><br><span class="line">    </span><br><span class="line">  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange &#123;</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      check(!noMoreExchanges) &#123; &quot;released&quot; &#125;</span><br><span class="line">      check(exchange &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &quot;cannot make a new request because the previous response is still open: &quot; +</span><br><span class="line">            &quot;please call response.close()&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    val codec &#x3D; exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)</span><br><span class="line">    val result &#x3D; Exchange(this, call, eventListener, exchangeFinder!!, codec)</span><br><span class="line"></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      this.exchange &#x3D; result</span><br><span class="line">      this.exchangeRequestDone &#x3D; false</span><br><span class="line">      this.exchangeResponseDone &#x3D; false</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ExchangeFinder.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">class ExchangeFinder(</span><br><span class="line">  private val transmitter: Transmitter,</span><br><span class="line">  private val connectionPool: RealConnectionPool,</span><br><span class="line">  private val address: Address,</span><br><span class="line">  private val call: Call,</span><br><span class="line">  private val eventListener: EventListener</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  fun find(</span><br><span class="line">    client: OkHttpClient,</span><br><span class="line">    chain: Interceptor.Chain,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): ExchangeCodec &#123;</span><br><span class="line">    val connectTimeout &#x3D; chain.connectTimeoutMillis()</span><br><span class="line">    val readTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">    val writeTimeout &#x3D; chain.writeTimeoutMillis()</span><br><span class="line">    val pingIntervalMillis &#x3D; client.pingIntervalMillis</span><br><span class="line">    val connectionRetryEnabled &#x3D; client.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">      val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled,</span><br><span class="line">          doExtensiveHealthChecks &#x3D; doExtensiveHealthChecks</span><br><span class="line">      )</span><br><span class="line">      return resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw e</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findHealthyConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环调用，直到得到一个健康的RealConnection </span><br><span class="line">    while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 查找连接</span><br><span class="line">      val candidate &#x3D; findConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If this is a brand new connection, we can skip the extensive health checks.</span><br><span class="line">      &#x2F;&#x2F; 如果是一个全新的连接直接拿去使用不需要检查</span><br><span class="line">      synchronized(connectionPool) &#123;</span><br><span class="line">        if (candidate.successCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          return candidate</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br><span class="line">      &#x2F;&#x2F; isn&#39;t, take it out of the pool and start again.</span><br><span class="line">      &#x2F;&#x2F; 检查这个连接是否是健康可用的，如果不是把它移除连接池</span><br><span class="line">      if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        candidate.noNewExchanges()</span><br><span class="line">        continue</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return candidate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    var foundPooledConnection &#x3D; false</span><br><span class="line">    var result: RealConnection? &#x3D; null</span><br><span class="line">    var selectedRoute: Route? &#x3D; null</span><br><span class="line">    var releasedConnection: RealConnection?</span><br><span class="line">    val toClose: Socket?</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">      hasStreamFailure &#x3D; false &#x2F;&#x2F; This is a fresh attempt.</span><br><span class="line">      &#x2F;&#x2F; 优先返回一个已经分配的连接，假如这个连接不为空，并且这个连接上面还可以建立新的stream</span><br><span class="line">      releasedConnection &#x3D; transmitter.connection</span><br><span class="line">      toClose &#x3D; if (transmitter.connection !&#x3D; null &amp;&amp; transmitter.connection!!.noNewExchanges) &#123;</span><br><span class="line">        transmitter.releaseConnectionNoEvents()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (transmitter.connection !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">        releasedConnection &#x3D; null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Attempt to get a connection from the pool.</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">          nextRouteToTry &#x3D; null</span><br><span class="line">        &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">          selectedRoute &#x3D; transmitter.connection!!.route()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done.</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we need a route selection, make one. This is a blocking operation.</span><br><span class="line">    var newRouteSelection &#x3D; false</span><br><span class="line">    if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">      newRouteSelection &#x3D; true</span><br><span class="line">      routeSelection &#x3D; routeSelector.next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">      if (newRouteSelection) &#123;</span><br><span class="line">        &#x2F;&#x2F; Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br><span class="line">        &#x2F;&#x2F; the pool. This could match due to connection coalescing.</span><br><span class="line">        routes &#x3D; routeSelection!!.routes</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">                address, transmitter, routes, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!foundPooledConnection) &#123;</span><br><span class="line">        if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">        &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do.</span><br><span class="line">        result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">        connectingConnection &#x3D; result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we found a pooled connection on the 2nd time around, we&#39;re done.</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">    &#x2F;&#x2F; 执行TCP + TLS握手</span><br><span class="line">    result!!.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">    connectionPool.routeDatabase.connected(result!!.route())</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建socket链接</span><br><span class="line">    var socket: Socket? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      connectingConnection &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br><span class="line">      &#x2F;&#x2F; concurrent connections to the same host.</span><br><span class="line">      &#x2F;&#x2F; 如果有另一个具有相同IP地址的连接被同时创建，那么把这个连接释放，去用另外一个</span><br><span class="line">      &#x2F;&#x2F;这种情况只有Http2的时候才会去执行</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection.</span><br><span class="line">        result!!.noNewExchanges &#x3D; true</span><br><span class="line">        socket &#x3D; result!!.socket()</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新建的连接放入连接池</span><br><span class="line">        connectionPool.put(result!!)</span><br><span class="line">        transmitter.acquireConnectionNoEvents(result!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>Exchange.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Exchange(</span><br><span class="line">  internal val transmitter: Transmitter,</span><br><span class="line">  internal val call: Call,</span><br><span class="line">  internal val eventListener: EventListener,</span><br><span class="line">  private val finder: ExchangeFinder,</span><br><span class="line">  private val codec: ExchangeCodec</span><br><span class="line">) &#123;</span><br><span class="line">  fun connection(): RealConnection? &#x3D; codec.connection()</span><br><span class="line">  </span><br><span class="line">  fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      eventListener.requestHeadersStart(call)</span><br><span class="line">      codec.writeRequestHeaders(request)</span><br><span class="line">      eventListener.requestHeadersEnd(call, request)</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      eventListener.requestFailed(call, e)</span><br><span class="line">      trackFailure(e)</span><br><span class="line">      throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ExchangeCodec.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface ExchangeCodec &#123;</span><br><span class="line">  fun connection(): RealConnection?</span><br><span class="line">  fun createRequestBody(request: Request, contentLength: Long): Sink</span><br><span class="line">  fun writeRequestHeaders(request: Request)</span><br><span class="line">  fun flushRequest()</span><br><span class="line">  fun finishRequest()</span><br><span class="line">  fun readResponseHeaders(expectContinue: Boolean): Response.Builder?</span><br><span class="line">  fun openResponseBodySource(response: Response): Source</span><br><span class="line">  fun cancel()</span><br><span class="line">  companion object &#123;</span><br><span class="line">    const val DISCARD_STREAM_TIMEOUT_MILLIS &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>RealConnectionPool.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class RealConnectionPool(</span><br><span class="line">  &#x2F;** The maximum number of idle connections for each address. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 最大的空闲socket连接数</span><br><span class="line">  private val maxIdleConnections: Int,</span><br><span class="line">  &#x2F;&#x2F; socket的keepAlive时间</span><br><span class="line">  keepAliveDuration: Long,</span><br><span class="line">  timeUnit: TimeUnit</span><br><span class="line">) &#123;</span><br><span class="line">  private val keepAliveDurationNs: Long &#x3D; timeUnit.toNanos(keepAliveDuration)</span><br><span class="line"></span><br><span class="line">  private val cleanupRunnable &#x3D; object : Runnable &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        val waitNanos &#x3D; cleanup(System.nanoTime())</span><br><span class="line">        if (waitNanos &#x3D;&#x3D; -1L) return</span><br><span class="line">        try &#123;</span><br><span class="line">          this@RealConnectionPool.lockAndWaitNanos(waitNanos)</span><br><span class="line">        &#125; catch (_: InterruptedException) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private val connections &#x3D; ArrayDeque&lt;RealConnection&gt;()</span><br><span class="line">  &#x2F;&#x2F; 用来记录连接失败的路线名单</span><br><span class="line">  val routeDatabase &#x3D; RouteDatabase()</span><br><span class="line">  var cleanupRunning: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  init &#123;</span><br><span class="line">    &#x2F;&#x2F; Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span><br><span class="line">    require(keepAliveDuration &gt; 0L) &#123; &quot;keepAliveDuration &lt;&#x3D; 0: $keepAliveDuration&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  companion object &#123;</span><br><span class="line">    private val executor &#x3D; ThreadPoolExecutor(</span><br><span class="line">        0, &#x2F;&#x2F; corePoolSize.</span><br><span class="line">        Int.MAX_VALUE, &#x2F;&#x2F; maximumPoolSize.</span><br><span class="line">        60L, TimeUnit.SECONDS, &#x2F;&#x2F; keepAliveTime.</span><br><span class="line">        SynchronousQueue(),</span><br><span class="line">        threadFactory(&quot;OkHttp ConnectionPool&quot;, true)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fun get(connectionPool: ConnectionPool): RealConnectionPool &#x3D; connectionPool.delegate</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="五、更多阅读"><a href="#五、更多阅读" class="headerlink" title="五、更多阅读"></a>五、更多阅读</h6><p><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="noopener">1. OKHttp源码解析</a></p>
<p><a href="https://www.cnblogs.com/zhangqie/p/8681308.html" target="_blank" rel="noopener">2. Android开源框架源码分析：Okhttp</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Retrofit2 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:14:46 / 修改时间：11:15:06" itemprop="dateCreated datePublished" datetime="2020-05-31T11:14:46+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、Retrofit2-简介"><a href="#一、Retrofit2-简介" class="headerlink" title="一、Retrofit2 简介"></a>一、Retrofit2 简介</h5><p>Retrofit是一个遵循RESTful设计的进行HTTP网络请求框架，底层网络请求基于OkHttp框架</p>
<h6 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"> </span><br><span class="line">GitHubService service = retrofit.create(GitHubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">service.listRepos(<span class="string">"test"</span>).enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="1-2-RxJava、GSON"><a href="#1-2-RxJava、GSON" class="headerlink" title="1.2 RxJava、GSON"></a>1.2 RxJava、GSON</h6><h5 id="二、原理剖析"><a href="#二、原理剖析" class="headerlink" title="二、原理剖析"></a>二、原理剖析</h5><h6 id="2-1-Retrofit的创建"><a href="#2-1-Retrofit的创建" class="headerlink" title="2.1 Retrofit的创建"></a>2.1 Retrofit的创建</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">    <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>(Platform.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">          <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">          &#125;</span><br><span class="line">          Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">          <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">          <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">          <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">          converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">          converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">          converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-create-动态代理"><a href="#2-2-create-动态代理" class="headerlink" title="2.2 create 动态代理"></a>2.2 create 动态代理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回service的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">              @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>HttpServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">        ...   </span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">        Type responseType = callAdapter.responseType();</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line">        okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">          continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);  </span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">        <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">        CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">            <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">            <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendForBody</span>&lt;<span class="title">ResponseT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isNullable;</span><br><span class="line"></span><br><span class="line">    SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter, <span class="keyword">boolean</span> isNullable) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">      <span class="keyword">this</span>.isNullable = isNullable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Object <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      call = callAdapter.adapt(call);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class="line">      Continuation&lt;ResponseT&gt; continuation = (Continuation&lt;ResponseT&gt;) args[args.length - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span> isNullable</span><br><span class="line">          ? KotlinExtensions.awaitNullable(call, continuation)</span><br><span class="line">          : KotlinExtensions.await(call, continuation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>DefaultCallAdapterFactory.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        ? <span class="title">null</span></span></span><br><span class="line">        : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span></span><br><span class="line">            ? call</span><br><span class="line">            : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      delegate.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.request();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="四、更多阅读"><a href="#四、更多阅读" class="headerlink" title="四、更多阅读"></a>四、更多阅读</h6><p><a href="https://www.jianshu.com/p/0b4c41d5d354" target="_blank" rel="noopener">1. 【Android源码伴读】Retrofit源码探秘</a></p>
<p><a href="https://www.jianshu.com/p/097947afddaf" target="_blank" rel="noopener">2. Retrofit源码分析（超详细）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">EventBus 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:13:30 / 修改时间：11:13:57" itemprop="dateCreated datePublished" datetime="2020-05-31T11:13:30+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>EventBus是一个Android端优化的publish／subscribe消息总线，简化了应用程序内各组件内、组件与后台线程间的通信，比如请求网络，等网络返回时，通过Handler、Broadcast更新UI等。它有很多优点：简化应用组件间的通信；解耦事件的发送者和接收者。<br><img src="https://upload-images.jianshu.io/upload_images/2169292-9d0c216714804720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EventBus-Publish-Subscribe.png"></p>
<h5 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h5><p>注册： EventBus.getDefault().register(this);<br>解注册：EventBus.getDefault().unregister(this);<br>事件Event： 事件可以是任意普通的Java对象，没有任何特殊的要求<br>发送消息： EventBus.getDefault().post(new MessageEvent(“Hello EventBus!”));</p>
<h5 id="三、线程模式"><a href="#三、线程模式" class="headerlink" title="三、线程模式"></a>三、线程模式</h5><p>EventBus支持订阅者方法在不同于发布事件所在线程的线程中被调用。你可以使用线程模式来指定调用订阅者方法的线程。EventBus总共支持5种线程模式：</p>
<ul>
<li><p>ThreadMode.POSTING 订阅者方法将在发布事件所在的线程中被调用。这是 默认的线程模式。事件的传递是同步的，一旦发布事件，所有该模式的订阅者方法都将被调用。这种线程模式意味着最少的性能开销，因为它避免了线程的切换。因此，对于不要求是主线程并且耗时很短的简单任务推荐使用该模式。使用该模式的订阅者方法应该快速返回，以避免阻塞发布事件的线程，这可能是主线程。</p>
</li>
<li><p>ThreadMode.MAIN 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.MAIN_ORDERED 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。事件将先进入队列然后才发送给订阅者，所以发布事件的调用将立即返回。这使得事件的处理保持严格的串行顺序。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.BACKGROUND 订阅者方法将在后台线程中被调用。如果发布事件的线程不是主线程，那么订阅者方法将直接在该线程中被调用。如果发布事件的线程是主线程，那么将使用一个单独的后台线程，该线程将按顺序发送所有的事件。使用该模式的订阅者方法应该快速返回，以避免阻塞后台线程。</p>
</li>
<li><p>ThreadMode.ASYNC 订阅者方法将在一个单独的线程中被调用。因此，发布事件的调用将立即返回。如果订阅者方法的执行需要一些时间，例如网络访问，那么就应该使用该模式。避免触发大量的长时间运行的订阅者方法，以限制并发线程的数量。EventBus使用了一个线程池来有效地重用已经完成调用订阅者方法的线程。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.POSTING)</span><br><span class="line">    public void onMessageEventPosting(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventPosting(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN)</span><br><span class="line">public void onMessageEventMain(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMain(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN_ORDERED)</span><br><span class="line">public void onMessageEventMainOrdered(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMainOrdered(), current thread is &quot;</span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.BACKGROUND)</span><br><span class="line">public void onMessageEventBackground(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventBackground(), current thread is &quot; </span><br><span class="line">         + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.ASYNC)</span><br><span class="line">public void onMessageEventAsync(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventAsync(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、粘性事件"><a href="#四、粘性事件" class="headerlink" title="四、粘性事件"></a>四、粘性事件</h5><p>发布一个粘性事件之后，EventBus将在内存中缓存该粘性事件。当有订阅者订阅了该粘性事件，订阅者将接收到该事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发布粘性事件</span><br><span class="line">EventBus.getDefault().postSticky(new MessageEvent(&quot;Hello EventBus!&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅粘性事件</span><br><span class="line">@Subscribe(sticky &#x3D; true)</span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、源码解析"><a href="#五、源码解析" class="headerlink" title="五、源码解析"></a>五、源码解析</h5><ol>
<li>从EventBus.getDefault()方法开始说起。主要是获取EventBus对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 典型的双重校验锁的单例模式</span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">    if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                defaultInstance &#x3D; new EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public EventBus() &#123;</span><br><span class="line">    this(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; key 为订阅事件类型，value为订阅该事件的所有订阅者集合</span><br><span class="line">&#x2F;&#x2F; Subscription则是一个封装了订阅者和方法体的一个类</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; </span><br><span class="line">subscriptionsByEventType;</span><br><span class="line">&#x2F;&#x2F; key为订阅者，value为订阅者的所有订阅方法</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化成员变量</span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadPoster &#x3D; new HandlerPoster(this, Looper.getMainLooper(), 10);</span><br><span class="line">    backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">    asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">    &#x2F;&#x2F;一系列的builder赋值</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">2. 消息注册register(this)函数</span><br></pre></td></tr></table></figure>
public void register(Object subscriber) {<br> Class&lt;?&gt; subscriberClass = subscriber.getClass();<br> // 从订阅类中获取所有的订阅方法信息<br> List<SubscriberMethod> subscriberMethods = subscriberMethodFinder<pre><code>.findSubscriberMethods(subscriberClass);</code></pre> synchronized (this) {<pre><code>for (SubscriberMethod subscriberMethod : subscriberMethods) {
    subscribe(subscriber, subscriberMethod);
}</code></pre> }<br>}</li>
</ol>
<p>List<SubscriberMethod> findSubscriberMethods(Class&lt;?&gt; subscriberClass) {<br>    // 首先从缓存中读取<br>    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);<br>    if (subscriberMethods != null) {<br>        return subscriberMethods;<br>    }<br>    // 默认是false<br>    if (ignoreGeneratedIndex) {<br>        // 利用反射来获取订阅方法中的信息<br>        subscriberMethods = findUsingReflection(subscriberClass);<br>    } else {<br>        // 从注解器获取的类中获得订阅方法信息<br>        subscriberMethods = findUsingInfo(subscriberClass);<br>    }<br>    if (subscriberMethods.isEmpty()) {<br>        throw new EventBusException(“Subscriber “ + subscriberClass<br>                + “ and its super classes have no public methods with “<br>                +” the @Subscribe annotation”);<br>    } else {<br>        // 保存在缓存中<br>        METHOD_CACHE.put(subscriberClass, subscriberMethods);<br>        return subscriberMethods;<br>    }<br>}</p>
<p>private List<SubscriberMethod> findUsingInfo(Class&lt;?&gt; subscriberClass) {<br>    // 准备一个FindState，该FindState保存了订阅者类的信息<br>    FindState findState = prepareFindState();<br>    //对FindState初始化<br>    findState.initForSubscriber(subscriberClass);<br>    while (findState.clazz != null) {<br>        findState.subscriberInfo = getSubscriberInfo(findState);<br>        //获得订阅者的信息，一开始会返回null<br>        if (findState.subscriberInfo != null) {<br>            SubscriberMethod[] array = findState.subscriberInfo<br>                                       .getSubscriberMethods();<br>            for (SubscriberMethod subscriberMethod : array) {<br>                if (findState.checkAdd(subscriberMethod.method<br>                    , subscriberMethod.eventType)) {<br>                    findState.subscriberMethods.add(subscriberMethod);<br>                }<br>            }<br>        } else {<br>            findUsingReflectionInSingleClass(findState);<br>        }<br>        findState.moveToSuperclass();<br>    }<br>return getMethodsAndRelease(findState);<br>}</p>
<p>private void findUsingReflectionInSingleClass(FindState findState) {<br>    Method[] methods;<br>    try {<br>        // This is faster than getMethods, especially when subscribers are<br>       // fat classes like Activities<br>        methods = findState.clazz.getDeclaredMethods();<br>    } catch (Throwable th) {<br>        // Workaround for java.lang.NoClassDefFoundError,<br>        // see <a href="https://github.com/greenrobot/EventBus/issues/149" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus/issues/149</a><br>        methods = findState.clazz.getMethods();<br>        findState.skipSuperClasses = true;<br>    }<br>    for (Method method : methods) {<br>        int modifiers = method.getModifiers();<br>        if ((modifiers &amp; Modifier.PUBLIC) != 0<br>            &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {<br>            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method
                                               .getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    Class<?> eventType = parameterTypes[0];<br>                    if (findState.checkAdd(method, eventType)) {<br>                        ThreadMode threadMode = subscribeAnnotation.threadMode();<br>                        findState.subscriberMethods.add(new SubscriberMethod(method<br>                        , eventType, threadMode,subscribeAnnotation.priority()<br>                        , subscribeAnnotation.sticky()));<br>                    }<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>                   String methodName = method.getDeclaringClass().getName()<br>                                    + “.” + method.getName();<br>                    throw new EventBusException(“@Subscribe method “ + methodName +<br>                 “must have exactly 1 parameter but has “ + parameterTypes.length);<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>            String methodName = method.getDeclaringClass().getName() + “.”<br>                                + method.getName();<br>            throw new EventBusException(methodName +<br>                        “ is a illegal @Subscribe method: must be public “<br>                        + “, non-static, and non-abstract”);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 发送消息源码</span><br></pre></td></tr></table></figure>
<p>public void post(Object event) {<br>    PostingThreadState postingState = currentPostingThreadState.get();<br>    List<Object> eventQueue = postingState.eventQueue;<br>    eventQueue.add(event);<br>    // 如果没有正在发送，则发送消息<br>    if (!postingState.isPosting) {<br>        postingState.isMainThread = isMainThread();<br>        postingState.isPosting = true;<br>        if (postingState.canceled) {<br>          throw new EventBusException(“Internal error. Abort state was not reset”);<br>        }<br>        try {<br>            while (!eventQueue.isEmpty()) {<br>                // 发送消息<br>                postSingleEvent(eventQueue.remove(0), postingState);<br>             }<br>        } finally {<br>            postingState.isPosting = false;<br>            postingState.isMainThread = false;<br>        }<br>    }<br>}</p>
<p>private void postSingleEvent(Object event, PostingThreadState postingState)<br>throws Error {<br>    Class<?> eventClass = event.getClass();
    boolean subscriptionFound = false;
    if (eventInheritance) {
        List<Class<?>&gt; eventTypes = lookupAllEventTypes(eventClass);<br>        int countTypes = eventTypes.size();<br>        for (int h = 0; h &lt; countTypes; h++) {<br>            Class&lt;?&gt; clazz = eventTypes.get(h);<br>            subscriptionFound |= postSingleEventForEventType(event<br>                                 , postingState, clazz);<br>        }<br>     } else {<br>        subscriptionFound = postSingleEventForEventType(event, postingState<br>                                                        , eventClass);<br>     }<br>     if (!subscriptionFound) {<br>        if (logNoSubscriberMessages) {<br>            logger.log(Level.FINE, “No subscribers registered for event “<br>                       + eventClass);<br>        }<br>        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class<br>            &amp;&amp; eventClass != SubscriberExceptionEvent.class) {<br>            post(new NoSubscriberEvent(this, event));<br>        }<br>    }<br>}</p>
<p>private boolean postSingleEventForEventType(Object event<br>                          , PostingThreadState postingState, Class&lt;?&gt; eventClass) {<br>    CopyOnWriteArrayList<Subscription> subscriptions;<br>    synchronized (this) {<br>        // 根据事件类型获取所有的订者<br>        subscriptions = subscriptionsByEventType.get(eventClass);<br>    }<br>    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {<br>        for (Subscription subscription : subscriptions) {<br>            postingState.event = event;<br>            postingState.subscription = subscription;<br>            boolean aborted = false;<br>            try {<br>                postToSubscription(subscription, event, postingState.isMainThread);<br>                aborted = postingState.canceled;<br>            } finally {<br>                postingState.event = null;<br>                postingState.subscription = null;<br>                postingState.canceled = false;<br>            }<br>            if (aborted) {<br>                break;<br>            }<br>        }<br>        return true;<br>    }<br>    return false;<br>}</p>
<p>private void postToSubscription(Subscription subscription, Object event<br>                                , boolean isMainThread) {<br>    switch (subscription.subscriberMethod.threadMode) {<br>        case POSTING:<br>            invokeSubscriber(subscription, event);<br>            break;<br>        case MAIN:<br>            if (isMainThread) {<br>                invokeSubscriber(subscription, event);<br>            } else {<br>                mainThreadPoster.enqueue(subscription, event);<br>            }<br>            break;<br>        case MAIN_ORDERED:<br>            if (mainThreadPoster != null) {<br>                mainThreadPoster.enqueue(subscription, event);<br>            } else {<br>                // temporary: technically not correct as poster not decoupled<br>                // from subscriber<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case BACKGROUND:<br>            if (isMainThread) {<br>                backgroundPoster.enqueue(subscription, event);<br>            } else {<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case ASYNC:<br>            asyncPoster.enqueue(subscription, event);<br>            break;<br>        default:<br>            throw new IllegalStateException(“Unknown thread mode: “<br>                                       + subscription.subscriberMethod.threadMode);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4. 取消注册源码分析</span><br></pre></td></tr></table></figure>
<p>public synchronized void unregister(Object subscriber) {<br>    List&lt;Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class<?> eventType : subscribedTypes) {<br>            unsubscribeByEventType(subscriber, eventType);<br>        }<br>        typesBySubscriber.remove(subscriber);<br>    } else {<br>        logger.log(Level.WARNING, “Subscriber to unregister was not<br>                   “+registered before: “ + subscriber.getClass());<br>    }<br>}</p>
<p>private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {<br>    // 获取事件类型的所有订阅者<br>    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);<br>    if (subscriptions != null) {<br>        int size = subscriptions.size();<br>        // 遍历订阅者集合将解除的订阅者移除<br>        for (int i = 0; i &lt; size; i++) {<br>            Subscription subscription = subscriptions.get(i);<br>            if (subscription.subscriber == subscriber) {<br>                subscription.active = false;<br>                subscriptions.remove(i);<br>                i–;<br>                size–;<br>            }<br>        }<br>    }<br>}</p>
<pre><code>简单的进行总结一下，主要就是注册和发送过程比较重要。

注册：

1. 通过反射或者注解获取所有的订阅方法 
2. 将当前订阅者添加到EventBus总的事件订阅者集合中subscriptionsByEventType 
3. 将当前订阅者所有订阅的事件类型添加到typesBySubscriber，方便解注册

发送：
1. 得到要发送的事件类型 
2. 根据事件类型获取订阅者，并循环向每个订阅者发送

解注册：
1. 通过typesBySubscriber获取当前订阅者所有的订阅事件类型
2. 循环遍历每一个事件类型，并删除当前订阅者的订阅的方法</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">RxJava 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:10:57 / 修改时间：11:13:00" itemprop="dateCreated datePublished" datetime="2020-05-31T11:10:57+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、RxJava-简介"><a href="#一、RxJava-简介" class="headerlink" title="一、RxJava 简介"></a>一、RxJava 简介</h5><p>RxJava是一种基于观察者模式的响应式编程框架，其定义的角色有Observable事件流、ObservableOnSubscribe事件源头、Observer是事件订阅者。</p>
<h5 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;String&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        emitter.onNext(<span class="string">"Android"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"Kotlin"</span>);</span><br><span class="line">        emitter.onNext(<span class="string">"Java"</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(<span class="keyword">new</span> Function&lt;String, Strinsg&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I Love "</span>+ s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"test"</span>, <span class="string">"onNext: "</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"test"</span>, <span class="string">"[onComplete]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test: onNext: I Love Android</span><br><span class="line">test: onNext: I Love Kotlin</span><br><span class="line">test: onNext: I Love Java</span><br><span class="line">test: [onComplete]</span><br></pre></td></tr></table></figure>

<h5 id="三、原理剖析"><a href="#三、原理剖析" class="headerlink" title="三、原理剖析"></a>三、原理剖析</h5><h6 id="3-1-Observable、Observer订阅原理"><a href="#3-1-Observable、Observer订阅原理" class="headerlink" title="3.1 Observable、Observer订阅原理"></a>3.1 Observable、Observer订阅原理</h6><p><strong><em>ObservableSource.java</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ObservableSource&lt;T&gt; &#123;</span><br><span class="line">    void subscribe(@NonNull Observer&lt;? super T&gt; observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>Observable.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="comment">// 创建事件源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅相关</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    	subscribeActual(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>create方法创建事件源,其参数ObservableOnSubscribe 接口定义如下：<br><strong><em>ObservableOnSubscribe.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableOnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;T&gt; emitter)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObservableEmitter可以理解为事件发射器，继承Emitter里卖弄的基本发射方法，同时关连Disposable<br><strong><em>Emitter.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable error)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ObservableEmitter.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Emitter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDisposable</span><span class="params">(@Nullable Disposable d)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setCancellable</span><span class="params">(@Nullable Cancellable c)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">ObservableEmitter&lt;T&gt; <span class="title">serialize</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(@NonNull Throwable t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observable.create方法最终会返回ObservableCreate<T>对象，ObservableCreate类包含了ObservableOnSubscribe对象引用，且实现了subscribeActual订阅方法</p>
<p><strong><em>ObservableCreate.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅的时候会执行该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1 创建 CreateEmitter，也是一个适配器，可以将 Observer -&gt; Disposable，CreateEmitter 中主要持有 observer 对象的引用，并且维护了 dispose 变量。</span></span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        <span class="comment">//2 onSubscribe（）参数是 Disposable。还有一点要注意的是 onSubscribe() 是在我们执行 subscribe() 这句代码的那个线程回调的，并不受线程调度影响。</span></span><br><span class="line">        <span class="comment">// 给 observer 的一个回调，告诉它是否 dispose</span></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//3 将 ObservableOnSubscribe（源头）与 CreateEmitter（Observer，终点）联系起来，即完成订阅，此时 ObservableOnSubscribe 会向 observer 传送事件</span></span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateEmitter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span>&lt;<span class="title">Disposable</span>&gt; <span class="keyword">implements</span> <span class="title">ObservableEmitter</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有被 dispose，会调用 Observer 的 onNext()方法</span></span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                observer.onNext(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!tryOnError(t)) &#123;</span><br><span class="line">                RxJavaPlugins.onError(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryOnError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = <span class="keyword">new</span> NullPointerException(<span class="string">"onError called with null. Null values are generally not allowed in 2.x operators and sources."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onError(t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// onComplete() 和 onError() 互斥只能执行一次</span></span><br><span class="line">            <span class="keyword">if</span> (!isDisposed()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    observer.onComplete();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DisposableHelper.dispose(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Observer订阅者定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull T t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-2-map操作符原理"><a href="#3-2-map操作符原理" class="headerlink" title="3.2 map操作符原理"></a>3.2 map操作符原理</h6><p>map函数的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ObservableMap.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableMap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableMap</span><span class="params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// super()将上游的Observable保存起来 ，用于subscribeActual()中用。</span></span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="comment">// 将function变换函数类保存起来</span></span><br><span class="line">        <span class="keyword">this</span>.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> U&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用 MapObserver 订阅上游 Observable。</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">BasicFuseableObserver</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? <span class="keyword">super</span> U&gt; actual, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">super</span>(actual);</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// done在onError 和 onComplete以后才会是true，默认这里是false，所以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 默认sourceMode是0，所以跳过</span></span><br><span class="line">            <span class="keyword">if</span> (sourceMode != NONE) &#123;</span><br><span class="line">                downstream.onNext(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            U v;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这一步执行变换,将上游传过来的 T，利用 Function 转换成下游需要的 V</span></span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                fail(ex);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 变换后传递给下游Observer</span></span><br><span class="line">            downstream.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> transitiveBoundaryFusion(mode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> U <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            T t = qd.poll();</span><br><span class="line">            <span class="keyword">return</span> t != <span class="keyword">null</span> ? ObjectHelper.&lt;U&gt;requireNonNull(mapper.apply(t), <span class="string">"The mapper function returned a null value."</span>) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-subscribeOn-线程调度"><a href="#3-3-subscribeOn-线程调度" class="headerlink" title="3.3 subscribeOn 线程调度"></a>3.3 subscribeOn 线程调度</h6><p>subscribeOn 函数源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(</span><br><span class="line">        <span class="comment">// 返回Observable，传入上游this和调度器scheduler</span></span><br><span class="line">        <span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(downStream);</span><br><span class="line">        <span class="comment">// SubscribeOnObserver实现了Disposable，将其传递给下游的onSubscribe</span></span><br><span class="line">        downStream.onSubscribe(parent);</span><br><span class="line">        <span class="comment">// 把source的订阅放在Runnable中，由scheduler调度</span></span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                source.subscribe(parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对subscribeOn()的调用是自下向上，所以连续多次调用subscribeOn()，结果会被最上面的subscribeOn()覆盖。（生成和消费都会被覆盖）</strong></p>
<p>observeOn函数源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(</span><br><span class="line">        <span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上代码都很熟悉了，暂不赘述</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableObserveOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler; <span class="comment">// 线程调度器</span></span><br><span class="line">        <span class="keyword">this</span>.delayError = delayError; <span class="comment">// 出现错误是否立刻中断线程</span></span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;   <span class="comment">//缓冲区大小，默认128</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            <span class="comment">// 默认线程则不做线程调度，直接在当前线程中调用</span></span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">            source.subscribe(</span><br><span class="line">                <span class="comment">// 用Worker、和相关参数装饰observer，得到新的Observer注入上游</span></span><br><span class="line">                <span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DisposableHelper.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.s = s;</span><br><span class="line">                <span class="comment">//省略部分代码，创建缓冲队列</span></span><br><span class="line">                queue = <span class="keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span><br><span class="line">                actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        queue.offer(t); <span class="comment">//上游的数据全部先入队列</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行调度</span></span><br><span class="line">      schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 队列如果已经空了，则再次调度</span></span><br><span class="line">        worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Fused 熔断机制，默认false</span></span><br><span class="line">        <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">            drainFused();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drainNormal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该函数在Runnable所在的线程执行，从缓冲队列里拿出事件，向下游发射</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果设置了errorDelay，则不管队列是否为空，发生了错误都会中断发射，并调用observer的onError</span></span><br><span class="line">            <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> d = done;</span><br><span class="line">                T v;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    v = q.poll();   <span class="comment">//队列中取数据</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    Exceptions.throwIfFatal(ex);</span><br><span class="line">                    s.dispose();</span><br><span class="line">                    q.clear();</span><br><span class="line">                    a.onError(ex);</span><br><span class="line">                    worker.dispose();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向下游发射数据</span></span><br><span class="line">                a.onNext(v);</span><br><span class="line">            &#125;</span><br><span class="line">            missed = addAndGet(-missed);</span><br><span class="line">            <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>observeOn()的工作原理是把消费结果先缓存，再切换到新线程上让原始消费者消费，它和生产者是没有一点关系的，就算subscribeOn()调用了，也只是改变observeOn()这个消费者所在的线程，和OperatorObserveOn中存储的原始消费者一点关系都没有，它还是由observeOn()控制。</strong></p>
<h6 id="四、更多阅读"><a href="#四、更多阅读" class="headerlink" title="四、更多阅读"></a>四、更多阅读</h6><ol>
<li><a href="http://www.pianshen.com/article/4401252533/" target="_blank" rel="noopener">RxJava 原理篇</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/JDK%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20%E2%80%94%E2%80%94%20Boolean%E3%80%81Byte/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/JDK%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20%E2%80%94%E2%80%94%20Boolean%E3%80%81Byte/" class="post-title-link" itemprop="url">JDK 源码解析 —— Boolean、Byte</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 22:21:39" itemprop="dateCreated datePublished" datetime="2020-05-30T22:21:39+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先我们来简单的了解一下，基础数据类型的数值范围，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2169292-b6ade8cee55fa85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基础数据类型的数值范围"></p>
<p><strong>Boolean 类型定义如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class Boolean implements java.io.Serializable,</span><br><span class="line">                                      Comparable&lt;Boolean&gt; &#123;</span><br><span class="line">    public static final Boolean TRUE &#x3D; new Boolean(true);</span><br><span class="line">    public static final Boolean FALSE &#x3D; new Boolean(false);</span><br><span class="line">    public static final Class&lt;Boolean&gt; TYPE &#x3D; </span><br><span class="line">                                (Class&lt;Boolean&gt;)Class.getPrimitiveClass(&quot;boolean&quot;);</span><br><span class="line">    private final boolean value;</span><br><span class="line"></span><br><span class="line">    public Boolean(boolean value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean parseBoolean(String s) &#123;</span><br><span class="line">        return ((s !&#x3D; null) &amp;&amp; s.equalsIgnoreCase(&quot;true&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">        return (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java的基本数据类型中，boolean只有两种状态，默认值为false.取值范围是{true,false}，理论上占1bit，实际上：</p>
<ul>
<li><p>1.单个的boolean 类型变量在编译的时候是使用的int 类型。</p>
<blockquote>
<p>boolean a=true;//这个a在JVM中占4个字节即：32位。</p>
</blockquote>
</li>
<li><p>2.boolean 类型的数组时，在编译的时候是作为byte array来编译的所以boolean 数组里面的每一个元件占一个字节，</p>
<blockquote>
<p>boolean[] b = new boolean[10];//数组时，每一个boolean在JVM中占一个字节。</p>
</blockquote>
</li>
</ul>
<p><strong>Byte定义如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class Byte extends Number implements Comparable&lt;Byte&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static final byte   MIN_VALUE &#x3D; -128;</span><br><span class="line">    public static final byte   MAX_VALUE &#x3D; 127;</span><br><span class="line"></span><br><span class="line">    public static String toString(byte b) &#123;</span><br><span class="line">        return Integer.toString((int)b, 10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ByteCache &#123;</span><br><span class="line">        private ByteCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        static final Byte cache[] &#x3D; new Byte[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; cache.length; I++)</span><br><span class="line">                cache[i] &#x3D; new Byte((byte)(i - 128));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Byte valueOf(byte b) &#123;</span><br><span class="line">        final int offset &#x3D; 128;</span><br><span class="line">        return ByteCache.cache[(int)b + offset];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Byte对象中也有一个private final的byte的属性。byte的取值范围为-128-127.在Byte中有一个内部类是ByteCache,用来缓存byte的数据,所以对于byte类型赋值,JVM不会再开辟空间，如果byte类型采用new关键字创建对象JVM会在堆区产生对象,byte可以转换成short,int,long,float,double,toString.其中有parseByte(String),parseByte(String,radix)方法，可以将其他进制的字符串,转换成十进制。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/29%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/29%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">29 应用程序返回按键执行流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。<br>android系统的事件分发流程分为很多部分：</p>
<ul>
<li>Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层</li>
</ul>
<p>所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。</p>
<p><strong>在Native层android系统的事件流程：</strong></p>
<ul>
<li><p>Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。</p>
</li>
<li><p>在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。</p>
</li>
<li><p>将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。</p>
</li>
<li><p>Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。</p>
</li>
<li><p>Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。</p>
</li>
</ul>
<p>可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。</p>
<p><strong>在ViewRootImpl层android系统的事件流程</strong></p>
<p>在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">        onInputEventFinished(seq, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final class ImeInputEventSender extends InputEventSender &#123;</span><br><span class="line">        public ImeInputEventSender(InputChannel inputChannel, Looper looper) &#123;</span><br><span class="line">            super(inputChannel, looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onInputEventFinished(int seq, boolean handled) &#123;</span><br><span class="line">            finishedInputEvent(seq, handled, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void finishedInputEvent(int seq, boolean handled, boolean timeout) &#123;</span><br><span class="line">        final PendingEvent p;</span><br><span class="line">        synchronized (mH) &#123;</span><br><span class="line">            int index &#x3D; mPendingEvents.indexOfKey(seq);</span><br><span class="line">            if (index &lt; 0) &#123;</span><br><span class="line">                return; &#x2F;&#x2F; spurious, event already finished or timed out</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p &#x3D; mPendingEvents.valueAt(index);</span><br><span class="line">            mPendingEvents.removeAt(index);</span><br><span class="line">            Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size());</span><br><span class="line"></span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Timeout waiting for IME to handle input event after &quot;</span><br><span class="line">                        + INPUT_METHOD_NOT_RESPONDING_TIMEOUT + &quot; ms: &quot; + p.mInputMethodId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mH.removeMessages(MSG_TIMEOUT_INPUT_EVENT, p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invokeFinishedInputEventCallback(p, handled);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法finishedInputEvent中，经过一系列的处理之后最终调用的是invokeFinishedInputEventCallback方法，所以我们继续看一下invokeFinishedInputEventCallback方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void invokeFinishedInputEventCallback(PendingEvent p, boolean handled) &#123;</span><br><span class="line">        p.mHandled &#x3D; handled;</span><br><span class="line">        if (p.mHandler.getLooper().isCurrentThread()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Already running on the callback handler thread so we can send the</span><br><span class="line">            &#x2F;&#x2F; callback immediately.</span><br><span class="line">            p.run();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Post the event to the callback handler thread.</span><br><span class="line">            &#x2F;&#x2F; In this case, the callback will be responsible for recycling the event.</span><br><span class="line">            Message msg &#x3D; Message.obtain(p.mHandler, p);</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">            msg.sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里我们首先判断PendingEvent的mHandler所在的线程是否是当前线程，若是的话则直接调用p.run方法，若不是的话则发送一个异步消息，而异步消息最终也是执行的p.run方法，所以我们继续看一下PendingEvent的run方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            mCallback.onFinishedInputEvent(mToken, mHandled);</span><br><span class="line"></span><br><span class="line">            synchronized (mH) &#123;</span><br><span class="line">                recyclePendingEventLocked(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在run方法中我们调用了mCallback的onFinishedInputEvent方法，需要说明的是这里的mCallback就是我们ViewRootImpl中的ImeInputStage类对象，而这里的ViewRootImpl对象就是我们的系统当前界面，前面我们分析Activity的加载绘制流程的时候知道Activity中保存了一个Window对象用于表示窗口信息，而Window对象内部就是通过ViewRootImpl对象实现窗口的加载绘制，所以这里的mCallback对象就是我们当前的App获取焦点的窗口的ViewRootImpl中的ImeInputStage对象，然后我们看一下该对象的onFinishedInputEvent方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final class ImeInputStage extends AsyncInputStage</span><br><span class="line">            implements InputMethodManager.FinishedInputEventCallback &#123;</span><br><span class="line">        ...</span><br><span class="line">        @Override</span><br><span class="line">        public void onFinishedInputEvent(Object token, boolean handled) &#123;</span><br><span class="line">            QueuedInputEvent q &#x3D; (QueuedInputEvent)token;</span><br><span class="line">            if (handled) &#123;</span><br><span class="line">                finish(q, true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            forward(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样经过一系列的调用之后我们消息的处理逻辑上传至了ViewRootImpl中，而在ViewRootImpl中经过一些列的调用之后我们ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4152)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4114)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3807)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3864)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3840)</span><br><span class="line">at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4006)</span><br><span class="line">at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2272)</span><br><span class="line">at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1893)</span><br><span class="line">at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1884)</span><br><span class="line">at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2249)</span><br><span class="line">at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141)</span><br></pre></td></tr></table></figure>
<p>这是通过异常信息打印的堆栈信息，从中我们可以看到在ViewRootImpl中我们经过一系列的调用之后最终执行的是：ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法，这样我们继续看一下processKeyEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int processKeyEvent(QueuedInputEvent q) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; Deliver the key to the view hierarchy.</span><br><span class="line">            if (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">                return FINISH_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">			...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了mView的dispatchKeyEvent方法，而我们分析过Activity窗口加载绘制流程，从中我们知道ViewRootImpl中的mView对象就是我们PhoneWindow中的mDecorView对象（DecorView），所以经过层层调用我们最终执行到了DecorView层。</p>
<p><strong>在DecorView层android系统的事件流程</strong></p>
<p>从上面我们知道在ViewRootImpl中我们最终调用了mView.dispatchKeyEvent方法，即执行的是PhoneWindow%DecorView.dispatchKeyEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int action &#x3D; event.getAction();</span><br><span class="line">            final boolean isDown &#x3D; action &#x3D;&#x3D; KeyEvent.ACTION_DOWN;</span><br><span class="line"></span><br><span class="line">            if (isDown &amp;&amp; (event.getRepeatCount() &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">                &#x2F;&#x2F; First handle chording of panel key: if a panel key is held</span><br><span class="line">                &#x2F;&#x2F; but not released, try to execute a shortcut in it.</span><br><span class="line">                if ((mPanelChordingKey &gt; 0) &amp;&amp; (mPanelChordingKey !&#x3D; keyCode)) &#123;</span><br><span class="line">                    boolean handled &#x3D; dispatchKeyShortcutEvent(event);</span><br><span class="line">                    if (handled) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; If a panel is open, perform a shortcut on it without the</span><br><span class="line">                &#x2F;&#x2F; chorded panel key</span><br><span class="line">                if ((mPreparedPanel !&#x3D; null) &amp;&amp; mPreparedPanel.isOpen) &#123;</span><br><span class="line">                    if (performPanelShortcut(mPreparedPanel, keyCode, event, 0)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!isDestroyed()) &#123;</span><br><span class="line">                final Callback cb &#x3D; getCallback();</span><br><span class="line">                final boolean handled &#x3D; cb !&#x3D; null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event)</span><br><span class="line">                        : super.dispatchKeyEvent(event);</span><br><span class="line">                if (handled) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">                    : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从中我们可以看到如果当前的PhoneWindow不是destroy庄则，则执行cb.dispatchKeyEvent方法，而这里的callback对象就是我们的Activity对象，所以这里最终会执行到Activity的dispatchKeyEvent方法。。。</p>
<p><strong>在Activity层android系统的事件流程</strong></p>
<p>所以我们这里继续看一下Actiivty中的dispatchKeyEvent方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchKeyEvent(KeyEvent event) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Let action bars open menus in response to the menu key prioritized over</span><br><span class="line">        &#x2F;&#x2F; the window handling it</span><br><span class="line">        if (event.getKeyCode() &#x3D;&#x3D; KeyEvent.KEYCODE_MENU &amp;&amp;</span><br><span class="line">                mActionBar !&#x3D; null &amp;&amp; mActionBar.onMenuKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Window win &#x3D; getWindow();</span><br><span class="line">        if (win.superDispatchKeyEvent(event)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        View decor &#x3D; mDecor;</span><br><span class="line">        if (decor &#x3D;&#x3D; null) decor &#x3D; win.getDecorView();</span><br><span class="line">        return event.dispatch(this, decor !&#x3D; null</span><br><span class="line">                ? decor.getKeyDispatcherState() : null, this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从中我们可以看到我们首先调用了Activity的window对象的superDispatchKeyEvent方法，而这个方法就是将处理方法下发带Activity中的View，而这里我们分析的是返回按键，显然的View层是无法处理这里的返回按键的，所以win.superDispatchKeyEvent方法返回的是false，所以最终我们执行的是event.dispatch方法。这样我们继续看一下event.dispatch方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final boolean dispatch(Callback receiver, DispatcherState state,</span><br><span class="line">            Object target) &#123;</span><br><span class="line">        switch (mAction) &#123;</span><br><span class="line">            ...</span><br><span class="line">            case ACTION_UP:</span><br><span class="line">                if (DEBUG) Log.v(TAG, &quot;Key up to &quot; + target + &quot; in &quot; + state</span><br><span class="line">                        + &quot;: &quot; + this);</span><br><span class="line">                if (state !&#x3D; null) &#123;</span><br><span class="line">                    state.handleUpEvent(this);</span><br><span class="line">                &#125;</span><br><span class="line">                return receiver.onKeyUp(mKeyCode, this);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们暂时分析一下ACTION_UP事件，可以发现这里最终调用的是receiver.onKeyUp方法，而这里的receiver就是我们的Actiivty，所以这里又回到了Activity并且执行其onKeyUp方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean onKeyUp(int keyCode, KeyEvent event) &#123;</span><br><span class="line">        if (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;&#x3D; Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">            if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking()</span><br><span class="line">                    &amp;&amp; !event.isCanceled()) &#123;</span><br><span class="line">                onBackPressed();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看onKeyUp方法，我们可以发现当我们按的是返回按键时，其回调了onBackPressed方法，所以我们继续看一下onBackPressed方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onBackPressed() &#123;</span><br><span class="line">        if (mActionBar !&#x3D; null &amp;&amp; mActionBar.collapseActionView()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mFragments.getFragmentManager().popBackStackImmediate()) &#123;</span><br><span class="line">            finishAfterTransition();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在onBackPressed方法中，我们最终调用的是finishAfterTransition方法，所以继续看一下这个方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void finishAfterTransition() &#123;</span><br><span class="line">        if (!mActivityTransitionState.startExitBackTransition(this)) &#123;</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，原来finish方法是在这里调用的，这样我们按下返回按键并抬起之后，经过层层的调用之后最终调用了我们的finish方法，而这个方法就是finish掉Activity的方法，也就解释了我们在App中默认按下返回按键之后Acitivty会被销毁了。</p>
<p>总结：</p>
<ul>
<li><p>本文中由于是分析的返回按键的处理流程，所以事件的分发流程没有做说明，下面的文章中会着重介绍Android的事件分发流程；</p>
</li>
<li><p>事件分发流程从Native –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层都是类似的，无论是按键分发流程还是触摸事件分发流程</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">28 电源开关机按键事件流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。</p>
<p>和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。</p>
<p>下面首先看一下dispatchUnhandledKey方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode&#x3D;&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState&#x3D;&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过前面两篇文章的分析<br>（<a href="http://blog.csdn.net/qq_23547831/article/details/51474288" target="_blank" rel="noopener"> android源码解析（二十六）–&gt;截屏事件流程</a>&nbsp;&nbsp;<br><a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）<br>我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">            case KeyEvent.KEYCODE_POWER: &#123;</span><br><span class="line">                result &amp;&#x3D; ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey &#x3D; false; &#x2F;&#x2F; wake-up will be handled separately</span><br><span class="line">                if (down) &#123;</span><br><span class="line">                    interceptPowerKeyDown(event, interactive);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    interceptPowerKeyUp(event, interactive, canceled);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private void interceptPowerKeyDown(KeyEvent event, boolean interactive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Latch power key state to detect screenshot chord.</span><br><span class="line">        if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mScreenshotChordPowerKeyTriggered &#x3D; true;</span><br><span class="line">            mScreenshotChordPowerKeyTime &#x3D; event.getDownTime();</span><br><span class="line">            interceptScreenshotChord();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Stop ringing or end call if configured to do so when power is pressed.</span><br><span class="line">        TelecomManager telecomManager &#x3D; getTelecommService();</span><br><span class="line">        boolean hungUp &#x3D; false;</span><br><span class="line">        if (telecomManager !&#x3D; null) &#123;</span><br><span class="line">            if (telecomManager.isRinging()) &#123;</span><br><span class="line">                &#x2F;&#x2F; Pressing Power while there&#39;s a ringing incoming</span><br><span class="line">                &#x2F;&#x2F; call should silence the ringer.</span><br><span class="line">                telecomManager.silenceRinger();</span><br><span class="line">            &#125; else if ((mIncallPowerBehavior</span><br><span class="line">                    &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) !&#x3D; 0</span><br><span class="line">                    &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; Otherwise, if &quot;Power button ends call&quot; is enabled,</span><br><span class="line">                &#x2F;&#x2F; the Power button will hang up any current active call.</span><br><span class="line">                hungUp &#x3D; telecomManager.endCall();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the power key has still not yet been handled, then detect short</span><br><span class="line">        &#x2F;&#x2F; press, long press, or multi press and decide what to do.</span><br><span class="line">        mPowerKeyHandled &#x3D; hungUp || mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                || mScreenshotChordVolumeUpKeyTriggered;</span><br><span class="line">        if (!mPowerKeyHandled) &#123;</span><br><span class="line">            if (interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; When interactive, we&#39;re already awake.</span><br><span class="line">                &#x2F;&#x2F; Wait for a long press or for the button to be released to decide what to do.</span><br><span class="line">                if (hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                wakeUpFromPowerKey(event.getDownTime());</span><br><span class="line"></span><br><span class="line">                if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                    mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int maxCount &#x3D; getMaxMultiPressPowerCount();</span><br><span class="line"></span><br><span class="line">                    if (maxCount &lt;&#x3D; 1) &#123;</span><br><span class="line">                        mPowerKeyHandled &#x3D; true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case MSG_POWER_LONG_PRESS:</span><br><span class="line">                    powerLongPress();</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void powerLongPress() &#123;</span><br><span class="line">        final int behavior &#x3D; getResolvedLongPressOnPowerBehavior();</span><br><span class="line">        switch (behavior) &#123;</span><br><span class="line">        case LONG_PRESS_POWER_NOTHING:</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_GLOBAL_ACTIONS:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) &#123;</span><br><span class="line">                performAuditoryFeedbackForAccessibilityIfNeed();</span><br><span class="line">            &#125;</span><br><span class="line">            showGlobalActionsInternal();</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF:</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">            mWindowManagerFuncs.shutdown(behavior &#x3D;&#x3D; LONG_PRESS_POWER_SHUT_OFF);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面：<br><img src="http://img.blog.csdn.net/20160524153125405" alt="这里写图片描述"></p>
<p>然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void showGlobalActionsInternal() &#123;</span><br><span class="line">        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">        if (mGlobalActions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mGlobalActions &#x3D; new GlobalActions(mContext, mWindowManagerFuncs);</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean keyguardShowing &#x3D; isKeyguardShowingAndNotOccluded();</span><br><span class="line">        mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned());</span><br><span class="line">        if (keyguardShowing) &#123;</span><br><span class="line">            &#x2F;&#x2F; since it took two seconds of long press to bring this up,</span><br><span class="line">            &#x2F;&#x2F; poke the wake lock so they have some time to see the dialog.</span><br><span class="line">            mPowerManager.userActivity(SystemClock.uptimeMillis(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（<a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">        mAudioManager &#x3D; (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">        mDreamManager &#x3D; IDreamManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(DreamService.DREAM_SERVICE));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; receive broadcasts</span><br><span class="line">        IntentFilter filter &#x3D; new IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);</span><br><span class="line">        context.registerReceiver(mBroadcastReceiver, filter);</span><br><span class="line"></span><br><span class="line">        ConnectivityManager cm &#x3D; (ConnectivityManager)</span><br><span class="line">                context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        mHasTelephony &#x3D; cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; get notified of phone state changes</span><br><span class="line">        TelephonyManager telephonyManager &#x3D;</span><br><span class="line">                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);</span><br><span class="line">        mContext.getContentResolver().registerContentObserver(</span><br><span class="line">                Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true,</span><br><span class="line">                mAirplaneModeObserver);</span><br><span class="line">        Vibrator vibrator &#x3D; (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">        mHasVibrator &#x3D; vibrator !&#x3D; null &amp;&amp; vibrator.hasVibrator();</span><br><span class="line"></span><br><span class="line">        mShowSilentToggle &#x3D; SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_useFixedVolume);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) &#123;</span><br><span class="line">        mKeyguardShowing &#x3D; keyguardShowing;</span><br><span class="line">        mDeviceProvisioned &#x3D; isDeviceProvisioned;</span><br><span class="line">        if (mDialog !&#x3D; null) &#123;</span><br><span class="line">            mDialog.dismiss();</span><br><span class="line">            mDialog &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; Show delayed, so that the dismiss of the previous dialog completes</span><br><span class="line">            mHandler.sendEmptyMessage(MESSAGE_SHOW);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleShow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void handleShow() &#123;</span><br><span class="line">        awakenIfNecessary();</span><br><span class="line">        mDialog &#x3D; createDialog();</span><br><span class="line">        prepareDialog();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we only have 1 item and it&#39;s a simple press action, just do this action.</span><br><span class="line">        if (mAdapter.getCount() &#x3D;&#x3D; 1</span><br><span class="line">                &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction</span><br><span class="line">                &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) &#123;</span><br><span class="line">            ((SinglePressAction) mAdapter.getItem(0)).onPress();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            WindowManager.LayoutParams attrs &#x3D; mDialog.getWindow().getAttributes();</span><br><span class="line">            attrs.setTitle(&quot;GlobalActions&quot;);</span><br><span class="line">            mDialog.getWindow().setAttributes(attrs);</span><br><span class="line">            mDialog.show();</span><br><span class="line">            mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">private GlobalActionsDialog createDialog() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mAirplaneModeOn &#x3D; new ToggleAction(</span><br><span class="line">                R.drawable.ic_lock_airplane_mode,</span><br><span class="line">                R.drawable.ic_lock_airplane_mode_off,</span><br><span class="line">                R.string.global_actions_toggle_airplane_mode,</span><br><span class="line">                R.string.global_actions_airplane_mode_on_status,</span><br><span class="line">                R.string.global_actions_airplane_mode_off_status) &#123;</span><br><span class="line"></span><br><span class="line">            void onToggle(boolean on) &#123;</span><br><span class="line">                if (mHasTelephony &amp;&amp; Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) &#123;</span><br><span class="line">                    mIsWaitingForEcmExit &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; Launch ECM exit dialog</span><br><span class="line">                    Intent ecmDialogIntent &#x3D;</span><br><span class="line">                            new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);</span><br><span class="line">                    ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                    mContext.startActivity(ecmDialogIntent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    changeAirplaneModeSystemSetting(on);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected void changeStateFromPress(boolean buttonOn) &#123;</span><br><span class="line">                if (!mHasTelephony) return;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; In ECM mode airplane state cannot be changed</span><br><span class="line">                if (!(Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) &#123;</span><br><span class="line">                    mState &#x3D; buttonOn ? State.TurningOn : State.TurningOff;</span><br><span class="line">                    mAirplaneState &#x3D; mState;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showDuringKeyguard() &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showBeforeProvisioning() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        onAirplaneModeChanged();</span><br><span class="line"></span><br><span class="line">        mItems &#x3D; new ArrayList&lt;Action&gt;();</span><br><span class="line">        String[] defaultActions &#x3D; mContext.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_globalActionsList);</span><br><span class="line"></span><br><span class="line">        ArraySet&lt;String&gt; addedKeys &#x3D; new ArraySet&lt;String&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; defaultActions.length; i++) &#123;</span><br><span class="line">            String actionKey &#x3D; defaultActions[i];</span><br><span class="line">            if (addedKeys.contains(actionKey)) &#123;</span><br><span class="line">                &#x2F;&#x2F; If we already have added this, don&#39;t add it again.</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(new PowerAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(mAirplaneModeOn);</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) &#123;</span><br><span class="line">                if (Settings.Global.getInt(mContext.getContentResolver(),</span><br><span class="line">                        Settings.Global.BUGREPORT_IN_POWER_MENU, 0) !&#x3D; 0 &amp;&amp; isCurrentUserOwner()) &#123;</span><br><span class="line">                    mItems.add(getBugReportAction());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) &#123;</span><br><span class="line">                if (mShowSilentToggle) &#123;</span><br><span class="line">                    mItems.add(mSilentModeAction);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) &#123;</span><br><span class="line">                if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) &#123;</span><br><span class="line">                    addUsersToMenu(mItems);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getSettingsAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getLockdownAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getVoiceAssistAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getAssistAction());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;Invalid global action key &quot; + actionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Add here so we don&#39;t add more than one.</span><br><span class="line">            addedKeys.add(actionKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdapter &#x3D; new MyAdapter();</span><br><span class="line"></span><br><span class="line">        AlertParams params &#x3D; new AlertParams(mContext);</span><br><span class="line">        params.mAdapter &#x3D; mAdapter;</span><br><span class="line">        params.mOnClickListener &#x3D; this;</span><br><span class="line">        params.mForceInverseBackground &#x3D; true;</span><br><span class="line"></span><br><span class="line">        GlobalActionsDialog dialog &#x3D; new GlobalActionsDialog(mContext, params);</span><br><span class="line">        dialog.setCanceledOnTouchOutside(false); &#x2F;&#x2F; Handled by the custom class.</span><br><span class="line"></span><br><span class="line">        dialog.getListView().setItemsCanFocus(true);</span><br><span class="line">        dialog.getListView().setLongClickable(true);</span><br><span class="line">        dialog.getListView().setOnItemLongClickListener(</span><br><span class="line">                new AdapterView.OnItemLongClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position,</span><br><span class="line">                            long id) &#123;</span><br><span class="line">                        final Action action &#x3D; mAdapter.getItem(position);</span><br><span class="line">                        if (action instanceof LongPressAction) &#123;</span><br><span class="line">                            return ((LongPressAction) action).onLongPress();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        dialog.setOnDismissListener(this);</span><br><span class="line"></span><br><span class="line">        return dialog;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面：<br><img src="http://img.blog.csdn.net/20160525144307466" alt="这里写图片描述"></p>
<p>好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mItems.add(new PowerAction());</span><br></pre></td></tr></table></figure>
<p>这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final class PowerAction extends SinglePressAction implements LongPressAction &#123;</span><br><span class="line">        private PowerAction() &#123;</span><br><span class="line">            super(com.android.internal.R.drawable.ic_lock_power_off,</span><br><span class="line">                R.string.global_action_power_off);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onLongPress() &#123;</span><br><span class="line">            UserManager um &#x3D; (UserManager) mContext.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) &#123;</span><br><span class="line">                mWindowManagerFuncs.rebootSafeMode(true);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showDuringKeyguard() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showBeforeProvisioning() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onPress() &#123;</span><br><span class="line">            &#x2F;&#x2F; shutdown by making sure radio and power are handled accordingly.</span><br><span class="line">            mWindowManagerFuncs.shutdown(false &#x2F;* confirm *&#x2F;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">		...</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。</p>
<p>经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initPolicy() &#123;</span><br><span class="line">        UiThread.getHandler().runWithScissors(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line"></span><br><span class="line">                mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。</p>
<p>然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false /* confirm */);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void shutdown(boolean confirm) &#123;</span><br><span class="line">        ShutdownThread.shutdown(mContext, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void shutdown(final Context context, boolean confirm) &#123;</span><br><span class="line">        mReboot &#x3D; false;</span><br><span class="line">        mRebootSafeMode &#x3D; false;</span><br><span class="line">        shutdownInner(context, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void shutdownInner(final Context context, boolean confirm) &#123;</span><br><span class="line">        &#x2F;&#x2F; ensure that only one thread is trying to power down.</span><br><span class="line">        &#x2F;&#x2F; any additional calls are just returned</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int longPressBehavior &#x3D; context.getResources().getInteger(</span><br><span class="line">                        com.android.internal.R.integer.config_longPressOnPowerBehavior);</span><br><span class="line">        final int resourceId &#x3D; mRebootSafeMode</span><br><span class="line">                ? com.android.internal.R.string.reboot_safemode_confirm</span><br><span class="line">                : (longPressBehavior &#x3D;&#x3D; 2</span><br><span class="line">                        ? com.android.internal.R.string.shutdown_confirm_question</span><br><span class="line">                        : com.android.internal.R.string.shutdown_confirm);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior&#x3D;&quot; + longPressBehavior);</span><br><span class="line"></span><br><span class="line">        if (confirm) &#123;</span><br><span class="line">            final CloseDialogReceiver closer &#x3D; new CloseDialogReceiver(context);</span><br><span class="line">            if (sConfirmDialog !&#x3D; null) &#123;</span><br><span class="line">                sConfirmDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">            sConfirmDialog &#x3D; new AlertDialog.Builder(context)</span><br><span class="line">                    .setTitle(mRebootSafeMode</span><br><span class="line">                            ? com.android.internal.R.string.reboot_safemode_title</span><br><span class="line">                            : com.android.internal.R.string.power_off)</span><br><span class="line">                    .setMessage(resourceId)</span><br><span class="line">                    .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            beginShutdownSequence(context);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(com.android.internal.R.string.no, null)</span><br><span class="line">                    .create();</span><br><span class="line">            closer.dialog &#x3D; sConfirmDialog;</span><br><span class="line">            sConfirmDialog.setOnDismissListener(closer);</span><br><span class="line">            sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line">            sConfirmDialog.show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            beginShutdownSequence(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">private static void beginShutdownSequence(Context context) &#123;</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            sIsStarted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) &#123;</span><br><span class="line">            mRebootUpdate &#x3D; new File(UNCRYPT_PACKAGE_FILE).exists();</span><br><span class="line">            if (mRebootUpdate) &#123;</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_update_prepare));</span><br><span class="line">                pd.setMax(100);</span><br><span class="line">                pd.setProgressNumberFormat(null);</span><br><span class="line">                pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">                pd.setProgress(0);</span><br><span class="line">                pd.setIndeterminate(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Factory reset path. Set the dialog message accordingly.</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pd.setTitle(context.getText(com.android.internal.R.string.power_off));</span><br><span class="line">            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));</span><br><span class="line">            pd.setIndeterminate(true);</span><br><span class="line">        &#125;</span><br><span class="line">        pd.setCancelable(false);</span><br><span class="line">        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        pd.show();</span><br><span class="line"></span><br><span class="line">        sInstance.mProgressDialog &#x3D; pd;</span><br><span class="line">        sInstance.mContext &#x3D; context;</span><br><span class="line">        sInstance.mPowerManager &#x3D; (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; make sure we never fall asleep again</span><br><span class="line">        sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                    PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;);</span><br><span class="line">            sInstance.mCpuWakeLock.setReferenceCounted(false);</span><br><span class="line">            sInstance.mCpuWakeLock.acquire();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; also make sure the screen stays on for better user experience</span><br><span class="line">        sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">        if (sInstance.mPowerManager.isScreenOn()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                        PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;);</span><br><span class="line">                sInstance.mScreenWakeLock.setReferenceCounted(false);</span><br><span class="line">                sInstance.mScreenWakeLock.acquire();</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; start the thread that initiates shutdown</span><br><span class="line">        sInstance.mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        sInstance.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。</p>
<p>总结：</p>
<ul>
<li><p>电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中；</p>
</li>
<li><p>在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等；</p>
</li>
<li><p>当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/27%20HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/27%20HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">27 HOME事件流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章中我们介绍了android系统的截屏事件，由于截屏事件是一种系统全局处理事件，所以事件的处理逻辑不是在App中执行，而是在PhoneWindowManager中执行。而本文我们现在主要讲解android系统中HOME按键的事件处理，和截屏事件类似，这里的HOME按键也是系统级别的按键事件监听，所以其处理事件的逻辑也应该和截屏事件处理流程类似，从上一篇文章的分析过冲中我们不难发现，系统级别的按键处理逻辑其实都是在PhoneWindowManager中，所以HOME按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中执行，那么我们就从dispatchUnhandleKey方法开始分析HOME按键的处理流程。</p>
<p>好吧我们看一下PhoneWindowManager的dispatchUnhandleKey方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode&#x3D;&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState&#x3D;&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_INPUT) &#123;</span><br><span class="line">            if (fallbackEvent &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Slog.d(TAG, &quot;No fallback.&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.d(TAG, &quot;Performing fallback: &quot; + fallbackEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过查看源码，我们重点看一下dispatchUnhandledKey方法中调用的interceptFallback方法，关于HOME按键的处理逻辑也是在这个方法体中的，所以继续看一下interceptFallback方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析源码我们知道关于HOME按键的处理逻辑主要是在interceptKeyBeforeDispatching方法的实现的，既然这样，我们看一下interceptKeyBeforeDispatching方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; First we always handle the home key here, so applications</span><br><span class="line">        &#x2F;&#x2F; can never break it, although if keyguard is on, we do let</span><br><span class="line">        &#x2F;&#x2F; it handle it, because that gives us the correct 5 second</span><br><span class="line">        &#x2F;&#x2F; timeout.</span><br><span class="line">        if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_HOME) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If we have released the home key, and didn&#39;t do anything else</span><br><span class="line">            &#x2F;&#x2F; while it was pressed, then it is time to go home!</span><br><span class="line">            if (!down) &#123;</span><br><span class="line">                cancelPreloadRecentApps();</span><br><span class="line"></span><br><span class="line">                mHomePressed &#x3D; false;</span><br><span class="line">                if (mHomeConsumed) &#123;</span><br><span class="line">                    mHomeConsumed &#x3D; false;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (canceled) &#123;</span><br><span class="line">                    Log.i(TAG, &quot;Ignoring HOME; event canceled.&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; If an incoming call is ringing, HOME is totally disabled.</span><br><span class="line">                &#x2F;&#x2F; (The user is already on the InCallUI at this point,</span><br><span class="line">                &#x2F;&#x2F; and his ONLY options are to answer or reject the call.)</span><br><span class="line">                TelecomManager telecomManager &#x3D; getTelecommService();</span><br><span class="line">                if (telecomManager !&#x3D; null &amp;&amp; telecomManager.isRinging()) &#123;</span><br><span class="line">                    Log.i(TAG, &quot;Ignoring HOME; there&#39;s a ringing incoming call.&quot;);</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Delay handling home if a double-tap is possible.</span><br><span class="line">                if (mDoubleTapOnHomeBehavior !&#x3D; DOUBLE_TAP_HOME_NOTHING) &#123;</span><br><span class="line">                    mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); &#x2F;&#x2F; just in case</span><br><span class="line">                    mHomeDoubleTapPending &#x3D; true;</span><br><span class="line">                    mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,</span><br><span class="line">                            ViewConfiguration.getDoubleTapTimeout());</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                handleShortPressOnHome();</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If a system window has focus, then it doesn&#39;t make sense</span><br><span class="line">            &#x2F;&#x2F; right now to interact with applications.</span><br><span class="line">            WindowManager.LayoutParams attrs &#x3D; win !&#x3D; null ? win.getAttrs() : null;</span><br><span class="line">            if (attrs !&#x3D; null) &#123;</span><br><span class="line">                final int type &#x3D; attrs.type;</span><br><span class="line">                if (type &#x3D;&#x3D; WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM</span><br><span class="line">                        || type &#x3D;&#x3D; WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG</span><br><span class="line">                        || (attrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) !&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; the &quot;app&quot; is keyguard, so give it the key</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                final int typeCount &#x3D; WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;</span><br><span class="line">                for (int i&#x3D;0; i&lt;typeCount; i++) &#123;</span><br><span class="line">                    if (type &#x3D;&#x3D; WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) &#123;</span><br><span class="line">                        &#x2F;&#x2F; don&#39;t do anything, but also don&#39;t pass it to the app</span><br><span class="line">                        return -1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Remember that home is pressed and handle special actions.</span><br><span class="line">            if (repeatCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                mHomePressed &#x3D; true;</span><br><span class="line">                if (mHomeDoubleTapPending) &#123;</span><br><span class="line">                    mHomeDoubleTapPending &#x3D; false;</span><br><span class="line">                    mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);</span><br><span class="line">                    handleDoubleTapOnHome();</span><br><span class="line">                &#125; else if (mLongPressOnHomeBehavior &#x3D;&#x3D; LONG_PRESS_HOME_RECENT_SYSTEM_UI</span><br><span class="line">                        || mDoubleTapOnHomeBehavior &#x3D;&#x3D; DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) &#123;</span><br><span class="line">                    preloadRecentApps();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) !&#x3D; 0) &#123;</span><br><span class="line">                if (!keyguardOn) &#123;</span><br><span class="line">                    handleLongPressOnHome(event.getDeviceId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Let the application handle the key.</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们主要看一下对android系统HOME按键的处理逻辑，通过分析源码我们知道HOME按键进入launcher界面的主要逻辑是在handleShortPressOnHome();方法中执行的，所以我们继续看一下handleShortPressOnHome方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void handleShortPressOnHome() &#123;</span><br><span class="line">        &#x2F;&#x2F; Turn on the connected TV and switch HDMI input if we&#39;re a HDMI playback device.</span><br><span class="line">        getHdmiControl().turnOnTv();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If there&#39;s a dream running then use home to escape the dream</span><br><span class="line">        &#x2F;&#x2F; but don&#39;t actually go home.</span><br><span class="line">        if (mDreamManagerInternal !&#x3D; null &amp;&amp; mDreamManagerInternal.isDreaming()) &#123;</span><br><span class="line">            mDreamManagerInternal.stopDream(false &#x2F;*immediate*&#x2F;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Go home!</span><br><span class="line">        launchHomeFromHotKey();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在handleShortPressOnHome方法中调用了launchHomeFromHotKey方法，该方法的注释用于go home，所以继续看一下该方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void launchHomeFromHotKey() &#123;</span><br><span class="line">        launchHomeFromHotKey(true &#x2F;* awakenFromDreams *&#x2F;, true &#x2F;*respectKeyguard*&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在launchHomeFromHotKey方法中我们又调用了launchHomeFromHotkey的重构方法，这样我们看一下这个重构方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) &#123;</span><br><span class="line">        if (respectKeyguard) &#123;</span><br><span class="line">            if (isKeyguardShowingAndNotOccluded()) &#123;</span><br><span class="line">                &#x2F;&#x2F; don&#39;t launch home if keyguard showing</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!mHideLockScreen &amp;&amp; mKeyguardDelegate.isInputRestricted()) &#123;</span><br><span class="line">                &#x2F;&#x2F; when in keyguard restricted mode, must first verify unlock</span><br><span class="line">                &#x2F;&#x2F; before launching home</span><br><span class="line">                mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onKeyguardExitResult(boolean success) &#123;</span><br><span class="line">                        if (success) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                ActivityManagerNative.getDefault().stopAppSwitches();</span><br><span class="line">                            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);</span><br><span class="line">                            startDockOrHome(true &#x2F;*fromHomeKey*&#x2F;, awakenFromDreams);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; no keyguard stuff to worry about, just launch home!</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().stopAppSwitches();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mRecentsVisible) &#123;</span><br><span class="line">            &#x2F;&#x2F; Hide Recents and notify it to launch Home</span><br><span class="line">            if (awakenFromDreams) &#123;</span><br><span class="line">                awakenDreams();</span><br><span class="line">            &#125;</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);</span><br><span class="line">            hideRecentApps(false, true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Otherwise, just launch Home</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY);</span><br><span class="line">            startDockOrHome(true &#x2F;*fromHomeKey*&#x2F;, awakenFromDreams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在方法中我们首先调用了ActivityManagerNative.getDefault().stopAppSwitches();该方法主要用于暂停后台的打开Activity的操作，避免打扰用户的操作。比如这时候我们在后台打开一个新的App，那么这时候由于要回到home页面，所以需要先延时打开。方法执行这个方法之后然后执行了sendCloseSystemWindows方法，该方法主要实现了对当前系统App页面的关闭操作，下面我们先看一下ActivityManagerNative.getDefault().stopAppSwitches();方法的实现，这里的ActivityManagerNative.getDefault我们在前面已经多次说过了其是一个Binder对象，是应用进程Binder客户端用于与ActivityManagerService之间通讯，所以这里最终调用的是ActivityManagerService的stopAppsSwitches方法，这样我们就继续看一下ActivityManagerService的stopAppsSwitches方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void stopAppSwitches() &#123;</span><br><span class="line">        if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES)</span><br><span class="line">                !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(&quot;Requires permission &quot;</span><br><span class="line">                    + android.Manifest.permission.STOP_APP_SWITCHES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            mAppSwitchesAllowedTime &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">                    + APP_SWITCH_DELAY_TIME;</span><br><span class="line">            mDidAppSwitch &#x3D; false;</span><br><span class="line">            mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG);</span><br><span class="line">            Message msg &#x3D; mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG);</span><br><span class="line">            mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里主要是发送了一个异步消息，并且msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG，即跳转Activity，然后我们继续我们看一下mHandler的handleMessage方法当msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG时的操作。而且我们可以发现这里的异步消息是一个延时的异步消息，延时的时间为APP_SWITCH_DELAY_TIME，我们可以看一下该变量的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Amount of time after a call to stopAppSwitches() during which we will</span><br><span class="line">    &#x2F;&#x2F; prevent further untrusted switches from happening.</span><br><span class="line">    static final long APP_SWITCH_DELAY_TIME &#x3D; 5*1000;</span><br></pre></td></tr></table></figure>
<p>然后我们可以看一下mHander的handleMessage方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case DO_PENDING_ACTIVITY_LAUNCHES_MSG: &#123;</span><br><span class="line">                synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                    mStackSupervisor.doPendingActivityLaunchesLocked(true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br></pre></td></tr></table></figure>
<p>可以发现这里直接调用了mStackSupervisor.doPendingActivityLaunchesLocked方法，好吧，继续看一下doPendingActivityLaunchesLocked方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void doPendingActivityLaunchesLocked(boolean doResume) &#123;</span><br><span class="line">        while (!mPendingActivityLaunches.isEmpty()) &#123;</span><br><span class="line">            PendingActivityLaunch pal &#x3D; mPendingActivityLaunches.remove(0);</span><br><span class="line">            startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags,</span><br><span class="line">                    doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里就是调用了startActivity的操作了，看过Activity启动流程的同学应该知道：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">android源码解析之（十四）–&gt;Activity启动流程</a> 这里就是开始启动Activity了，所以当我们按下HOME按键的时候，后台的startActivity都会延时5秒钟执行…</p>
<p>然后回到我们的launchHomeFromHotKey方法，看一下launchHomeFromHotKey方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void sendCloseSystemWindows(String reason) &#123;</span><br><span class="line">        PhoneWindow.sendCloseSystemWindows(mContext, reason);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里调用了PhoneWindow的静态方法sendCloseSystemWindow,继续看一下该方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void sendCloseSystemWindows(Context context, String reason) &#123;</span><br><span class="line">        if (ActivityManagerNative.isSystemReady()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().closeSystemDialogs(reason);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，很明显了又是调用了Binder的进程间通讯，最终ActivityManagerService的closeSystemDialogs方法会被执行，所以我们继续看一下ActivityManagerService的closeSystemDialogs方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void closeSystemDialogs(String reason) &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;closeSystemDialogs&quot;);</span><br><span class="line"></span><br><span class="line">        final int pid &#x3D; Binder.getCallingPid();</span><br><span class="line">        final int uid &#x3D; Binder.getCallingUid();</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                &#x2F;&#x2F; Only allow this from foreground processes, so that background</span><br><span class="line">                &#x2F;&#x2F; applications can&#39;t abuse it to prevent system UI from being shown.</span><br><span class="line">                if (uid &gt;&#x3D; Process.FIRST_APPLICATION_UID) &#123;</span><br><span class="line">                    ProcessRecord proc;</span><br><span class="line">                    synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                        proc &#x3D; mPidsSelfLocked.get(pid);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Ignoring closeSystemDialogs &quot; + reason</span><br><span class="line">                                + &quot; from background process &quot; + proc);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                closeSystemDialogsLocked(reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其实在方法体中将关闭窗口的逻辑下发到了closeSystemDialogsLocked中，所以我们继续看一下closeSystemDialogsLocked方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void closeSystemDialogsLocked(String reason) &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        if (reason !&#x3D; null) &#123;</span><br><span class="line">            intent.putExtra(&quot;reason&quot;, reason);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager.closeSystemDialogs(reason);</span><br><span class="line"></span><br><span class="line">        mStackSupervisor.closeSystemDialogsLocked();</span><br><span class="line"></span><br><span class="line">        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null,</span><br><span class="line">                AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                -1, Process.SYSTEM_UID, UserHandle.USER_ALL);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在方法体中首先调用了mWindowManager.closeSystemDialogs方法，该方法就是关闭当前页面中存在的系统窗口，比如输入法，壁纸等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void closeSystemDialogs(String reason) &#123;</span><br><span class="line">        synchronized(mWindowMap) &#123;</span><br><span class="line">            final int numDisplays &#x3D; mDisplayContents.size();</span><br><span class="line">            for (int displayNdx &#x3D; 0; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">                final WindowList windows &#x3D; mDisplayContents.valueAt(displayNdx).getWindowList();</span><br><span class="line">                final int numWindows &#x3D; windows.size();</span><br><span class="line">                for (int winNdx &#x3D; 0; winNdx &lt; numWindows; ++winNdx) &#123;</span><br><span class="line">                    final WindowState w &#x3D; windows.get(winNdx);</span><br><span class="line">                    if (w.mHasSurface) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            w.mClient.closeSystemDialogs(reason);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>讲过这样一层操作之后，我们就关闭了当前中存在的系统窗口。然后还是回到我们的launchHomeFromHotKey方法，我们发现在方法体的最后我们调用了startDockOrHome方法，这个方法就是实际的跳转HOME页面的方法了，我们可以具体看一下该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void startDockOrHome(boolean fromHomeKey, boolean awakenFromDreams) &#123;</span><br><span class="line">        if (awakenFromDreams) &#123;</span><br><span class="line">            awakenDreams();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Intent dock &#x3D; createHomeDockIntent();</span><br><span class="line">        if (dock !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fromHomeKey) &#123;</span><br><span class="line">                    dock.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey);</span><br><span class="line">                &#125;</span><br><span class="line">                startActivityAsUser(dock, UserHandle.CURRENT);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (ActivityNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Intent intent;</span><br><span class="line"></span><br><span class="line">        if (fromHomeKey) &#123;</span><br><span class="line">            intent &#x3D; new Intent(mHomeIntent);</span><br><span class="line">            intent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            intent &#x3D; mHomeIntent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startActivityAsUser(intent, UserHandle.CURRENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们在方法体中调用了createHomeDockIntent，这个方法的作用就是创建到达HOME页面的Intent对象，然后我们调用了startActivityAsUser方法，这样经过一系列的调用之后就调起了home页面的Activity，所以这时候系统就返回到了HOME页面。</p>
<p>总结：</p>
<ul>
<li><p>系统也是在PhoneWindowManager中监听HOME按键的点击并进行处理；</p>
</li>
<li><p>系统监听到HOME按键之后会首先关闭相应的系统弹窗；</p>
</li>
<li><p>通过创建Intent对象，并调用startActivity方法使系统跳转到HOME页面；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/26%20%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/26%20%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">26 截屏事件流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。</p>
<p>我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。</p>
<p>在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** &#123;@inheritDoc&#125; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        if (!mSystemBooted) &#123;</span><br><span class="line">            &#x2F;&#x2F; If we have not yet booted, don&#39;t let key events do anything.</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Handle special keys.</span><br><span class="line">        switch (keyCode) &#123;</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_DOWN:</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_UP:</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_MUTE: &#123;</span><br><span class="line">                if (mUseTvRouting) &#123;</span><br><span class="line">                    &#x2F;&#x2F; On TVs volume keys never go to the foreground app</span><br><span class="line">                    result &amp;&#x3D; ~ACTION_PASS_TO_USER;</span><br><span class="line">                &#125;</span><br><span class="line">                if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_VOLUME_DOWN) &#123;</span><br><span class="line">                    if (down) &#123;</span><br><span class="line">                        if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered &#x3D; true;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime &#x3D; event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed &#x3D; false;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mScreenshotChordVolumeDownKeyTriggered &#x3D; false;</span><br><span class="line">                        cancelPendingScreenshotChordAction();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里首先判断当前系统是否已经boot完毕，若尚未启动完毕，则所有的按键操作都将失效，若启动完成，则执行后续的操作，这里我们只是关注音量减少按键和电源按键组合的处理事件。另外这里多说一句想安卓系统的HOME按键事件，MENU按键事件，进程列表按键事件等等都是在这里实现的，后续中我们会陆续介绍这方面的内容。</p>
<p>回到我们的interceptKeyBeforeQueueing方法，当我用按下音量减少按键的时候回进入到：case KeyEvent.KEYCODE_VOLUME_MUTE分支并执行相应的逻辑，然后同时判断用户是否按下了电源键，若同时按下了电源键，则执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered &#x3D; true;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime &#x3D; event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed &#x3D; false;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里的interceptScreenshotChrod方法就是系统准备开始执行截屏操作的开始，我们继续看一下interceptcreenshotChord方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void interceptScreenshotChord() &#123;</span><br><span class="line">        if (mScreenshotChordEnabled</span><br><span class="line">                &amp;&amp; mScreenshotChordVolumeDownKeyTriggered &amp;&amp; mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; !mScreenshotChordVolumeUpKeyTriggered) &#123;</span><br><span class="line">            final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            if (now &lt;&#x3D; mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS</span><br><span class="line">                    &amp;&amp; now &lt;&#x3D; mScreenshotChordPowerKeyTime</span><br><span class="line">                            + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) &#123;</span><br><span class="line">                mScreenshotChordVolumeDownKeyConsumed &#x3D; true;</span><br><span class="line">                cancelPendingPowerKeyAction();</span><br><span class="line"></span><br><span class="line">                mHandler.postDelayed(mScreenshotRunnable, getScreenshotChordLongPressDelay());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们最终会执行发送一个延迟的异步消息，请求执行截屏的操作而这里的延时时间，若当前输入框是打开状态，则延时时间为输入框关闭时间加上系统配置的按键超时时间，若当前输入框没有打开则直接是系统配置的按键超时处理时间，可看一下getScreenshotChordLongPressDelay方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private long getScreenshotChordLongPressDelay() &#123;</span><br><span class="line">        if (mKeyguardDelegate.isShowing()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Double the time it takes to take a screenshot from the keyguard</span><br><span class="line">            return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER *</span><br><span class="line">                    ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">        &#125;</span><br><span class="line">        return ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>回到我们的interceptScreenshotChord方法，发送了异步消息之后系统最终会被我们发送的Runnable对象的run方法执行，这里关于异步消息的逻辑可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/50751687" target="_blank" rel="noopener">android源码解析之（二）–&gt;异步消息机制</a></p>
<p>这样我们看一下Runnable类型的mScreenshotRunnable的run方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable mScreenshotRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            takeScreenshot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体中并未执行其他操作，直接就是调用了takeScreenshot方法，这样我们继续看一下takeScreenshot方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void takeScreenshot() &#123;</span><br><span class="line">        synchronized (mScreenshotLock) &#123;</span><br><span class="line">            if (mScreenshotConnection !&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ComponentName cn &#x3D; new ComponentName(&quot;com.android.systemui&quot;,</span><br><span class="line">                    &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);</span><br><span class="line">            Intent intent &#x3D; new Intent();</span><br><span class="line">            intent.setComponent(cn);</span><br><span class="line">            ServiceConnection conn &#x3D; new ServiceConnection() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">                    synchronized (mScreenshotLock) &#123;</span><br><span class="line">                        if (mScreenshotConnection !&#x3D; this) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Messenger messenger &#x3D; new Messenger(service);</span><br><span class="line">                        Message msg &#x3D; Message.obtain(null, 1);</span><br><span class="line">                        final ServiceConnection myConn &#x3D; this;</span><br><span class="line">                        Handler h &#x3D; new Handler(mHandler.getLooper()) &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void handleMessage(Message msg) &#123;</span><br><span class="line">                                synchronized (mScreenshotLock) &#123;</span><br><span class="line">                                    if (mScreenshotConnection &#x3D;&#x3D; myConn) &#123;</span><br><span class="line">                                        mContext.unbindService(mScreenshotConnection);</span><br><span class="line">                                        mScreenshotConnection &#x3D; null;</span><br><span class="line">                                        mHandler.removeCallbacks(mScreenshotTimeout);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        msg.replyTo &#x3D; new Messenger(h);</span><br><span class="line">                        msg.arg1 &#x3D; msg.arg2 &#x3D; 0;</span><br><span class="line">                        if (mStatusBar !&#x3D; null &amp;&amp; mStatusBar.isVisibleLw())</span><br><span class="line">                            msg.arg1 &#x3D; 1;</span><br><span class="line">                        if (mNavigationBar !&#x3D; null &amp;&amp; mNavigationBar.isVisibleLw())</span><br><span class="line">                            msg.arg2 &#x3D; 1;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            messenger.send(msg);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void onServiceDisconnected(ComponentName name) &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            if (mContext.bindServiceAsUser(</span><br><span class="line">                    intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) &#123;</span><br><span class="line">                mScreenshotConnection &#x3D; conn;</span><br><span class="line">                mHandler.postDelayed(mScreenshotTimeout, 10000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里通过反射机制创建了一个TakeScreenshotService对象然后调用了bindServiceAsUser，这样就创建了TakeScreenshotService服务并在服务创建之后发送了一个异步消息。好了，我们看一下TakeScreenshotService的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TakeScreenshotService extends Service &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;TakeScreenshotService&quot;;</span><br><span class="line"></span><br><span class="line">    private static GlobalScreenshot mScreenshot;</span><br><span class="line"></span><br><span class="line">    private Handler mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    final Messenger callback &#x3D; msg.replyTo;</span><br><span class="line">                    if (mScreenshot &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        mScreenshot &#x3D; new GlobalScreenshot(TakeScreenshotService.this);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mScreenshot.takeScreenshot(new Runnable() &#123;</span><br><span class="line">                        @Override public void run() &#123;</span><br><span class="line">                            Message reply &#x3D; Message.obtain(null, 1);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                callback.send(reply);</span><br><span class="line">                            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, msg.arg1 &gt; 0, msg.arg2 &gt; 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new Messenger(mHandler).getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在在TakeScreenshotService类的定义中有一个Handler成员变量，而我们在启动TakeScreentshowService的时候回发送一个异步消息，这样就会执行mHandler的handleMessage方法，然后在handleMessage方法中我们创建了一个GlobalScreenshow对象，然后执行了takeScreenshot方法，好吧，继续看一下takeScreentshot方法的执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Takes a screenshot of the current display and shows an animation.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to orient the screenshot correctly (and the Surface api seems to take screenshots</span><br><span class="line">        &#x2F;&#x2F; only in the natural orientation of the device :!)</span><br><span class="line">        mDisplay.getRealMetrics(mDisplayMetrics);</span><br><span class="line">        float[] dims &#x3D; &#123;mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels&#125;;</span><br><span class="line">        float degrees &#x3D; getDegreesForRotation(mDisplay.getRotation());</span><br><span class="line">        boolean requiresRotation &#x3D; (degrees &gt; 0);</span><br><span class="line">        if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Get the dimensions of the device in its native orientation</span><br><span class="line">            mDisplayMatrix.reset();</span><br><span class="line">            mDisplayMatrix.preRotate(-degrees);</span><br><span class="line">            mDisplayMatrix.mapPoints(dims);</span><br><span class="line">            dims[0] &#x3D; Math.abs(dims[0]);</span><br><span class="line">            dims[1] &#x3D; Math.abs(dims[1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Take the screenshot</span><br><span class="line">        mScreenBitmap &#x3D; SurfaceControl.screenshot((int) dims[0], (int) dims[1]);</span><br><span class="line">        if (mScreenBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">            notifyScreenshotError(mContext, mNotificationManager);</span><br><span class="line">            finisher.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rotate the screenshot to the current orientation</span><br><span class="line">            Bitmap ss &#x3D; Bitmap.createBitmap(mDisplayMetrics.widthPixels,</span><br><span class="line">                    mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">            Canvas c &#x3D; new Canvas(ss);</span><br><span class="line">            c.translate(ss.getWidth() &#x2F; 2, ss.getHeight() &#x2F; 2);</span><br><span class="line">            c.rotate(degrees);</span><br><span class="line">            c.translate(-dims[0] &#x2F; 2, -dims[1] &#x2F; 2);</span><br><span class="line">            c.drawBitmap(mScreenBitmap, 0, 0, null);</span><br><span class="line">            c.setBitmap(null);</span><br><span class="line">            &#x2F;&#x2F; Recycle the previous bitmap</span><br><span class="line">            mScreenBitmap.recycle();</span><br><span class="line">            mScreenBitmap &#x3D; ss;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Optimizations</span><br><span class="line">        mScreenBitmap.setHasAlpha(false);</span><br><span class="line">        mScreenBitmap.prepareToDraw();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start the post-screenshot animation</span><br><span class="line">        startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里后两个参数：statusBarVisible，navBarVisible是否可见，而这两个参数在我们PhoneWindowManager.takeScreenshot方法传递的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (mStatusBar !&#x3D; null &amp;&amp; mStatusBar.isVisibleLw())</span><br><span class="line">                            msg.arg1 &#x3D; 1;</span><br><span class="line">                        if (mNavigationBar !&#x3D; null &amp;&amp; mNavigationBar.isVisibleLw())</span><br><span class="line">                            msg.arg2 &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>可见若果mStatusBar可见，则传递的statusBarVisible为true，若mNavigationBar可见，则传递的navBarVisible为true。然后我们在截屏的时候判断nStatusBar是否可见，mNavigationBar是否可见，若可见的时候则截屏同样将其截屏出来。继续回到我们的takeScreenshot方法，然后调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Take the screenshot</span><br><span class="line">mScreenBitmap &#x3D; SurfaceControl.screenshot((int) dims[0], (int) dims[1]);</span><br></pre></td></tr></table></figure>
<p>方法，看注释，这里就是执行截屏事件的具体操作了，然后我看一下SurfaceControl.screenshot方法的具体实现，另外这里需要注意的是，截屏之后返回的是一个Bitmap对象，其实熟悉android绘制机制的童鞋应该知道android中所有显示能够显示的东西，在内存中表现都是Bitmap对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap screenshot(int width, int height) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: should take the display as a parameter</span><br><span class="line">        IBinder displayToken &#x3D; SurfaceControl.getBuiltInDisplay(</span><br><span class="line">                SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN);</span><br><span class="line">        return nativeScreenshot(displayToken, new Rect(), width, height, 0, 0, true,</span><br><span class="line">                false, Surface.ROTATION_0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里调用的是nativeScreenshot方法，它是一个native方法，具体的实现在JNI层，这里就不做过多的介绍了。继续回到我们的takeScreenshot方法，在调用了截屏方法screentshot之后，判断是否截屏成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mScreenBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">            notifyScreenshotError(mContext, mNotificationManager);</span><br><span class="line">            finisher.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>若截屏之后，截屏的bitmap对象为空，这里判断截屏失败，调用了notifyScreenshotError方法，发送截屏失败的notification通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void notifyScreenshotError(Context context, NotificationManager nManager) &#123;</span><br><span class="line">        Resources r &#x3D; context.getResources();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Clear all existing notification, compose the new notification and show it</span><br><span class="line">        Notification.Builder b &#x3D; new Notification.Builder(context)</span><br><span class="line">            .setTicker(r.getString(R.string.screenshot_failed_title))</span><br><span class="line">            .setContentTitle(r.getString(R.string.screenshot_failed_title))</span><br><span class="line">            .setContentText(r.getString(R.string.screenshot_failed_text))</span><br><span class="line">            .setSmallIcon(R.drawable.stat_notify_image_error)</span><br><span class="line">            .setWhen(System.currentTimeMillis())</span><br><span class="line">            .setVisibility(Notification.VISIBILITY_PUBLIC) &#x2F;&#x2F; ok to show outside lockscreen</span><br><span class="line">            .setCategory(Notification.CATEGORY_ERROR)</span><br><span class="line">            .setAutoCancel(true)</span><br><span class="line">            .setColor(context.getColor(</span><br><span class="line">                        com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line">        Notification n &#x3D;</span><br><span class="line">            new Notification.BigTextStyle(b)</span><br><span class="line">                .bigText(r.getString(R.string.screenshot_failed_text))</span><br><span class="line">                .build();</span><br><span class="line">        nManager.notify(R.id.notification_screenshot, n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后继续看takeScreenshot方法，判断截屏的图像是否需要旋转，若需要的话，则旋转图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rotate the screenshot to the current orientation</span><br><span class="line">            Bitmap ss &#x3D; Bitmap.createBitmap(mDisplayMetrics.widthPixels,</span><br><span class="line">                    mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">            Canvas c &#x3D; new Canvas(ss);</span><br><span class="line">            c.translate(ss.getWidth() &#x2F; 2, ss.getHeight() &#x2F; 2);</span><br><span class="line">            c.rotate(degrees);</span><br><span class="line">            c.translate(-dims[0] &#x2F; 2, -dims[1] &#x2F; 2);</span><br><span class="line">            c.drawBitmap(mScreenBitmap, 0, 0, null);</span><br><span class="line">            c.setBitmap(null);</span><br><span class="line">            &#x2F;&#x2F; Recycle the previous bitmap</span><br><span class="line">            mScreenBitmap.recycle();</span><br><span class="line">            mScreenBitmap &#x3D; ss;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在takeScreenshot方法的最后若截屏成功，我们调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Start the post-screenshot animation</span><br><span class="line">        startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br></pre></td></tr></table></figure>
<p>开始截屏的动画，好吧，看一下动画效果的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Starts the animation after taking the screenshot</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible,</span><br><span class="line">            boolean navBarVisible) &#123;</span><br><span class="line">        &#x2F;&#x2F; Add the view for the animation</span><br><span class="line">        mScreenshotView.setImageBitmap(mScreenBitmap);</span><br><span class="line">        mScreenshotLayout.requestFocus();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Setup the animation with the screenshot just taken</span><br><span class="line">        if (mScreenshotAnimation !&#x3D; null) &#123;</span><br><span class="line">            mScreenshotAnimation.end();</span><br><span class="line">            mScreenshotAnimation.removeAllListeners();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams);</span><br><span class="line">        ValueAnimator screenshotDropInAnim &#x3D; createScreenshotDropInAnimation();</span><br><span class="line">        ValueAnimator screenshotFadeOutAnim &#x3D; createScreenshotDropOutAnimation(w, h,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br><span class="line">        mScreenshotAnimation &#x3D; new AnimatorSet();</span><br><span class="line">        mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim);</span><br><span class="line">        mScreenshotAnimation.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                &#x2F;&#x2F; Save the screenshot once we have a bit of time now</span><br><span class="line">                saveScreenshotInWorkerThread(finisher);</span><br><span class="line">                mWindowManager.removeView(mScreenshotLayout);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Clear any references to the bitmap</span><br><span class="line">                mScreenBitmap &#x3D; null;</span><br><span class="line">                mScreenshotView.setImageBitmap(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mScreenshotLayout.post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; Play the shutter sound to notify that we&#39;ve taken a screenshot</span><br><span class="line">                mCameraSound.play(MediaActionSound.SHUTTER_CLICK);</span><br><span class="line"></span><br><span class="line">                mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null);</span><br><span class="line">                mScreenshotView.buildLayer();</span><br><span class="line">                mScreenshotAnimation.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，经过着一些列的操作之后我们实现了截屏之后的动画效果了，这里暂时不分析动画效果，我们看一下动画效果之后做了哪些？还记不记的一般情况下我们截屏之后都会收到一个截屏的notification通知？这里应该也是在其AnimatorListenerAdapter的onAnimationEnd方法中实现的，也就是动画执行完成之后，我们看一下其saveScreenshotInWorkerThread方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Creates a new worker thread and saves the screenshot to the media store.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void saveScreenshotInWorkerThread(Runnable finisher) &#123;</span><br><span class="line">        SaveImageInBackgroundData data &#x3D; new SaveImageInBackgroundData();</span><br><span class="line">        data.context &#x3D; mContext;</span><br><span class="line">        data.image &#x3D; mScreenBitmap;</span><br><span class="line">        data.iconSize &#x3D; mNotificationIconSize;</span><br><span class="line">        data.finisher &#x3D; finisher;</span><br><span class="line">        data.previewWidth &#x3D; mPreviewWidth;</span><br><span class="line">        data.previewheight &#x3D; mPreviewHeight;</span><br><span class="line">        if (mSaveInBgTask !&#x3D; null) &#123;</span><br><span class="line">            mSaveInBgTask.cancel(false);</span><br><span class="line">        &#125;</span><br><span class="line">        mSaveInBgTask &#x3D; new SaveImageInBackgroundTask(mContext, data, mNotificationManager,</span><br><span class="line">                R.id.notification_screenshot).execute(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里主要逻辑就是构造了一个SaveImageInBackgroundTask对象，看样子发送截屏成功的通知应该是在这里实现的，我们看一下SaveImageInBackgroundTask构造方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data,</span><br><span class="line">            NotificationManager nManager, int nId) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Show the intermediate notification</span><br><span class="line">        mTickerAddSpace &#x3D; !mTickerAddSpace;</span><br><span class="line">        mNotificationId &#x3D; nId;</span><br><span class="line">        mNotificationManager &#x3D; nManager;</span><br><span class="line">        final long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        mNotificationBuilder &#x3D; new Notification.Builder(context)</span><br><span class="line">            .setTicker(r.getString(R.string.screenshot_saving_ticker)</span><br><span class="line">                    + (mTickerAddSpace ? &quot; &quot; : &quot;&quot;))</span><br><span class="line">            .setContentTitle(r.getString(R.string.screenshot_saving_title))</span><br><span class="line">            .setContentText(r.getString(R.string.screenshot_saving_text))</span><br><span class="line">            .setSmallIcon(R.drawable.stat_notify_image)</span><br><span class="line">            .setWhen(now)</span><br><span class="line">            .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line"></span><br><span class="line">        mNotificationStyle &#x3D; new Notification.BigPictureStyle()</span><br><span class="line">            .bigPicture(picture.createAshmemBitmap());</span><br><span class="line">        mNotificationBuilder.setStyle(mNotificationStyle);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; For &quot;public&quot; situations we want to show all the same info but</span><br><span class="line">        &#x2F;&#x2F; omit the actual screenshot image.</span><br><span class="line">        mPublicNotificationBuilder &#x3D; new Notification.Builder(context)</span><br><span class="line">                .setContentTitle(r.getString(R.string.screenshot_saving_title))</span><br><span class="line">                .setContentText(r.getString(R.string.screenshot_saving_text))</span><br><span class="line">                .setSmallIcon(R.drawable.stat_notify_image)</span><br><span class="line">                .setCategory(Notification.CATEGORY_PROGRESS)</span><br><span class="line">                .setWhen(now)</span><br><span class="line">                .setColor(r.getColor(</span><br><span class="line">                        com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line"></span><br><span class="line">        mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());</span><br><span class="line"></span><br><span class="line">        Notification n &#x3D; mNotificationBuilder.build();</span><br><span class="line">        n.flags |&#x3D; Notification.FLAG_NO_CLEAR;</span><br><span class="line">        mNotificationManager.notify(nId, n);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; On the tablet, the large icon makes the notification appear as if it is clickable (and</span><br><span class="line">        &#x2F;&#x2F; on small devices, the large icon is not shown) so defer showing the large icon until</span><br><span class="line">        &#x2F;&#x2F; we compose the final post-save notification below.</span><br><span class="line">        mNotificationBuilder.setLargeIcon(icon.createAshmemBitmap());</span><br><span class="line">        &#x2F;&#x2F; But we still don&#39;t set it for the expanded view, allowing the smallIcon to show here.</span><br><span class="line">        mNotificationStyle.bigLargeIcon((Bitmap) null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在构造方法的后面狗仔了一个NotificationBuilder对象，然后发送了一个截屏成功的Notification，这样我们在截屏动画之后就收到了Notification的通知了。</p>
<p>总结：</p>
<ul>
<li><p>在PhoneWindowManager的dispatchUnhandledKey方法中处理App无法处理的按键事件，当然也包括音量减少键和电源按键的组合按键</p>
</li>
<li><p>通过一系列的调用启动TakeScreenshotService服务，并通过其执行截屏的操作。</p>
</li>
<li><p>具体的截屏代码是在native层实现的。</p>
</li>
<li><p>截屏操作时候，若截屏失败则直接发送截屏失败的notification通知。</p>
</li>
<li><p>截屏之后，若截屏成功，则先执行截屏的动画，并在动画效果执行完毕之后，发送截屏成功的notification的通知。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
