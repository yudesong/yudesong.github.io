<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">Java基础知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 14:05:36" itemprop="dateCreated datePublished" datetime="2020-05-31T14:05:36+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java笔记连载"><a href="#Java笔记连载" class="headerlink" title="Java笔记连载"></a>Java笔记连载</h2><hr>
<h4 id="1-HashMap和HashTable的区别"><a href="#1-HashMap和HashTable的区别" class="headerlink" title="1.HashMap和HashTable的区别"></a>1.HashMap和HashTable的区别</h4><ul>
<li><input checked="" disabled="" type="checkbox"> HashMap去掉了contains方法</li>
<li><input checked="" disabled="" type="checkbox"> HashTable是同步的(线程安全)</li>
<li><input checked="" disabled="" type="checkbox"> HashMap允许空键值</li>
<li><input checked="" disabled="" type="checkbox"> HashMap执行快速失败机制</li>
<li><input disabled="" type="checkbox"> <code>Fast-fail</code>机制:在使用迭代器的过程中有其它线程修改了集合对象结构或元素数量,都将抛出ConcurrentModifiedException</li>
</ul>
<h4 id="2-java的线程安全类"><a href="#2-java的线程安全类" class="headerlink" title="2.java的线程安全类"></a>2.java的线程安全类</h4><p>Vector、Stack、HashTable、ConcurrentHashMap、Properties</p>
<h4 id="3-java集合框架"><a href="#3-java集合框架" class="headerlink" title="3.java集合框架"></a>3.java集合框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection - List - ArrayList</span><br><span class="line">Collection - List - LinkedList</span><br><span class="line">Collection - List - Vector</span><br><span class="line">Collection - List - Vector - Stack</span><br><span class="line">Collection - Set - HashSet</span><br><span class="line">Collection - Set - TreeSet</span><br><span class="line">Map - HashMap</span><br><span class="line">Map - TreeMap</span><br><span class="line">Map - HashTable</span><br></pre></td></tr></table></figure>

<p>3.1 <code>ArrayList</code>的构造函数有三个</p>
<ol>
<li>无参构造 容量为10</li>
<li>ArrayList(Collections&lt;?extends E&gt; c)构造包含指定collection的元素的列表</li>
<li>ArrayList(int initialCapacity) 指定初始容量</li>
</ol>
<p>3.2 <code>Iterator</code>支持从源集合安全地删除对象,防止并发修改异常(ConcurrentModifiedException)</p>
<h4 id="4-Java垃圾回收机制"><a href="#4-Java垃圾回收机制" class="headerlink" title="4.Java垃圾回收机制"></a>4.Java垃圾回收机制</h4><p>4.1 调用system.gc() Runtime.getRuntime.gc()</p>
<p>4.2 垃圾回收:释放那些不在持有任何引用的对象的内存</p>
<p>4.3 怎样判断是否需要收集：</p>
<ol>
<li>引用计数法：对象没有任何引用与之关联(无法解决循环引用)</li>
<li>对象引用遍历法：对象引用遍历从一组对象开始,沿着对象图的每条链接,递归确定可以到达的对象,如果某对象不能从这些根对象的一个(至少一个)到达,则将它作为垃圾收集。</li>
</ol>
<p>4.4 垃圾回收方法</p>
<ol>
<li>标记清除法(Mark-Sweeping):易产生内存碎片</li>
<li>复制回收法(Copying)：为了解决Mark-Sweep法而提出,内存空间减至一半</li>
<li>标记压缩法(Mark-Compact):为了解决Copying法的缺陷,标记后移动到一端再清楚</li>
<li>分代回收法(GenerationalCollection):新生代对象存活周期短,需要大量回收对象,需要复制的少,执行copying算法;老年代对象存活周期相对长,回收少量对象,执行mark-compact算法.<br>新生代划分：较大的eden区 和 2个survivor区</li>
</ol>
<p>4.5 内存分配</p>
<ul>
<li>新生代 |Eden Space|From Space|To Space|</li>
<li>对象主要分配在新生代的EdenSpace和FromSpace</li>
<li>如果EdenSapce和FromSpace空间不足,则发起一次GC</li>
<li>若进行GC后,EdenSpace和FromSpace能够容纳该对象,就放在Eden和FromSpace。在GC过程中会将EdenSpace和FromSpace存活的对象移动到ToSpace,然后清理Eden和From。若在清理过程中,ToSpace无法足够容纳该对象,则将该对象移入老年代中。在进行GC后,Eden和From为空,MinorGC完成。From和To标记互换。To区(逻辑上)始终为空。</li>
<li>新生代的回收成为MinorGC,对老年代的回收成为MajorGC又名FullGC</li>
</ul>
<p>其他</p>
<ul>
<li>优先在Eden上分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代</li>
<li>动态对象年龄判定 suvivor区同年龄对象总和大于suvivor区空间的一半,MinorGC时复制至老年代</li>
<li>空间分配担保 新生代放不下借用老年代,虚拟机检测GC租借的老年代内存是否大于剩余的老年代内存。若大于,MinorGC变为一次FullGC。若小于,查看虚拟机是否允许担保失败,若允许则执行一次MinorGC,否则也要变为一次FullGC</li>
</ul>
<h4 id="5-一些重要的关键字"><a href="#5-一些重要的关键字" class="headerlink" title="5.一些重要的关键字"></a>5.一些重要的关键字</h4><ul>
<li><p>volatile<br>Java 语言提供了一种稍弱的同步机制,即<code>volatile</code>变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新。 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的。<code>volatile</code>修饰变量,每次被线程访问时强迫其从主内存重读该值,修改后再写回共享内存。保证读取的可见性,对其他线程立即可见。由于不保证原子性,也就不能保证线程安全。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况。同时,volatile屏蔽了VM中必要的代码优化,效率上较低。另一个优点：禁止指令重排序</p>
</li>
<li><p>final<br><code>final</code>修饰的变量是常量，必须进行初始化，可以显示初始化，也可以通过构造进行初始化，如果不初始化编译会报错。</p>
</li>
</ul>
<h4 id="6-多线程-amp-并发-amp-同步-amp-锁"><a href="#6-多线程-amp-并发-amp-同步-amp-锁" class="headerlink" title="6.多线程 &amp; 并发 &amp; 同步 &amp; 锁"></a>6.多线程 &amp; 并发 &amp; 同步 &amp; 锁</h4><p>6.1 线程的run方法和start方法</p>
<ul>
<li><code>start方法</code><br>用start方法来启动线程,是真正实现了多线程。调用thread类的start方法来启动一个线程,此时线程处于就绪状态,一旦得到cpu时间片,就开始执行run方法。注：此时无需等待run方法执行完毕,即可执行下面的代码,所以run方法并没有实现多线程。</li>
<li><code>run方法</code><br>只是thread类的一个普通方法,若直接调用程序中依然只有主线程这一个线程,还要顺序执行,依然要等待run方法体执行完毕才可执行下面的代码。</li>
</ul>
<p>6.2 ReadWriteLock(读写锁)</p>
<p>写写互斥 读写互斥 读读并发<br>在读多写少的情况下可以提高效率 </p>
<p>6.3 resume(继续挂起的线程)和suspend(挂起线程)一起用</p>
<p>6.4 wait与notify、notifyall一起用</p>
<p>6.5 sleep与wait的异同点</p>
<ol>
<li>sleep是Thread类的静态方法,wait来自object类</li>
<li>sleep不释放锁,wait释放锁</li>
<li>wait,notify,notifyall必须在同步代码块中使用,sleep可以在任何地方使用</li>
<li>都可以抛出InterruptedException</li>
</ol>
<p>6.6 让一个线程停止执行</p>
<p>异常 - 停止执行<br>休眠 - 停止执行<br>阻塞 - 停止执行</p>
<p>6.7 ThreadLocal相关</p>
<ul>
<li>ThreadLocal解决了变量并发访问的冲突问题</li>
</ul>
<p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p>
<ul>
<li>与synchronized同步机制的比较</li>
</ul>
<p>首先,它们都是为了解决多线程中相同变量访问冲突问题。不过,在同步机制中,要通过对象的锁机制保证同一时间只有一个线程访问该变量。该变量是线程共享的,使用同步机制要求程序缜密地分析什么时候对该变量读写,什么时候需要锁定某个对象,什么时候释放对象锁等复杂的问题,程序设计编写难度较大,是一种“以时间换空间”的方式。<br>而ThreadLocal采用了以“以空间换时间”的方式。</p>
<h4 id="7-接口与抽象类"><a href="#7-接口与抽象类" class="headerlink" title="7.接口与抽象类"></a>7.接口与抽象类</h4><ol>
<li>一个子类只能继承一个抽象类,但能实现多个接口</li>
<li>抽象类可以有构造方法,接口没有构造方法</li>
<li>抽象类可以有普通成员变量,接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li>
<li>抽象类可以有静态方法，接口不能有静态方法</li>
<li>抽象类中的方法可以是public、protected和默认;接口方法只有public</li>
</ol>
<h4 id="8-Statement接口"><a href="#8-Statement接口" class="headerlink" title="8.Statement接口"></a>8.Statement接口</h4><p>8.1</p>
<ul>
<li>Statement是最基本的用法，不传参，采用字符串拼接，存在注入漏洞</li>
<li>PreparedStatement传入参数化的sql语句,同时检查合法性，效率高，可以重用,防止sql注入</li>
<li>CallableStatement接口扩展PreparedStatement，用来调用存储过程</li>
<li>public interface CallableStatement extends PreparedStatement </li>
<li>public interface PreparedStatement extends Statement </li>
<li>BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类</li>
</ul>
<p>8.2 Statement与PrepareStatement的区别</p>
<ul>
<li><p>创建时的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement statement &#x3D; conn.createStatement();</span><br><span class="line">PreparedStatement preStatement &#x3D; conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure></li>
<li><p>执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rSet &#x3D; statement.executeQuery(sql);</span><br><span class="line">ResultSet pSet &#x3D; preStatement.executeQuery();</span><br></pre></td></tr></table></figure>
<p>由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，<br>而 statement 不同，如果执行多遍，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些</p>
</li>
<li><p>安全性</p>
</li>
</ul>
<p>preStatement是预编译的，所以可以有效的防止SQL注入等问题</p>
<ul>
<li>代码的可读性和可维护性</li>
</ul>
<p>PreparedStatement更胜一筹</p>
<h4 id="9-抽象类和最终类"><a href="#9-抽象类和最终类" class="headerlink" title="9.抽象类和最终类"></a>9.抽象类和最终类</h4><p>抽象类可以没有抽象方法,最终类可以,没有最终方法</p>
<p>最终类不能被继承,最终方法不能被重写(可以重载)</p>
<h4 id="10-异常"><a href="#10-异常" class="headerlink" title="10.异常"></a>10.异常</h4><p>10.1 throw、throws、try…catch、finally</p>
<ol>
<li>throws用在方法上,方法内部通过throw抛出异常</li>
<li>try用于检测包住的语句块,若有异常,抛出并执行catch子句</li>
<li>catch捕获try块中抛出的异常并处理</li>
</ol>
<p>10.2 关于<code>finally</code></p>
<ol>
<li>finally不管有没有异常都要处理</li>
<li>finally{}比return先执行,多个return执行一个后就不在执行</li>
<li>不管有木有异常抛出,finally在return返回前执行</li>
</ol>
<p>10.3 受检查异常和运行时异常<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<ol>
<li><p>粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 </p>
</li>
<li><p>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… </p>
</li>
<li><p>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 </p>
</li>
</ol>
<h4 id="11-this-amp-super"><a href="#11-this-amp-super" class="headerlink" title="11.this &amp; super"></a>11.this &amp; super</h4><p>11.1 super出现在父类的子类中。有三种存在方式</p>
<ol>
<li>super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用</li>
<li>super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法</li>
<li>super() 调用父类构造</li>
</ol>
<ul>
<li>super只能指代其直接父类</li>
</ul>
<p>11.2 this() &amp; super()在构造方法中的区别</p>
<ol>
<li>调用super()必须写在子类构造方法的第一行,否则编译不通过</li>
<li>super从子类调用父类构造,this在同一类中调用其他构造</li>
<li>均需要放在第一行</li>
<li>尽管可以用this调用一个构造器,却不能调用2个</li>
<li>this和super不能出现在同一个构造器中,否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ol>
<h4 id="12-修饰符一览"><a href="#12-修饰符一览" class="headerlink" title="12.修饰符一览"></a>12.修饰符一览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 			类内部  	同一个包		子类 		任何地方</span><br><span class="line">private 		yes</span><br><span class="line">default         yes			yes</span><br><span class="line">protected		yes			yes				yes</span><br><span class="line">public			yes			yes				yes			yes</span><br></pre></td></tr></table></figure>

<h4 id="13-构造内部类对象"><a href="#13-构造内部类对象" class="headerlink" title="13.构造内部类对象"></a>13.构造内部类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enclosingone</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Enclosingone.Insideone obj1 = <span class="keyword">new</span> Enclosingone().<span class="keyword">new</span> Insideone();</span><br><span class="line">	Enclosingone.Insideone obj2 = <span class="keyword">new</span> Enclosingone.Insideone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-序列化"><a href="#14-序列化" class="headerlink" title="14.序列化"></a>14.序列化</h4><p>声明为static和transient类型的数据不能被序列化,序列化的笔记参见[Java-note-序列化.md][5]</p>
<h4 id="15-Java的方法区"><a href="#15-Java的方法区" class="headerlink" title="15.Java的方法区"></a>15.Java的方法区</h4><p>与堆一样,是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。</p>
<h4 id="16-正则表达式"><a href="#16-正则表达式" class="headerlink" title="16.正则表达式"></a>16.正则表达式</h4><p><strong>次数符号</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 0或多次</span><br><span class="line">+ 1或多次</span><br><span class="line">？0或1次</span><br><span class="line">&#123;n&#125; 恰n次</span><br><span class="line">&#123;n,m&#125; 从n到m次</span><br></pre></td></tr></table></figure>

<p><strong>其他符号</strong></p>
<p>符号    等价形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d		[0-9]</span><br><span class="line">\D      [^0-9]  </span><br><span class="line">\w 		[a-zA-Z_0-9]</span><br><span class="line">\W 		[^a-zA-Z_0-9]</span><br><span class="line">\s 		[\t\n\r\f]</span><br><span class="line">\S 		[^\t\n\r\f]</span><br><span class="line">. 		任何字符</span><br></pre></td></tr></table></figure>

<p><strong>边界匹配器</strong></p>
<p>行开头    ^<br>行结尾  $<br>单词边界 \b</p>
<p><strong>贪婪模式</strong>:最大长度匹配 非贪婪模式:匹配到结果就好,最短匹配</p>
<p><strong>环视</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符 				描述 					匹配对象</span><br><span class="line">.					单个任意字符			</span><br><span class="line">[...] 				字符组 					列出的任意字符</span><br><span class="line">[^...] 										未列出的任意字符</span><br><span class="line">^ 					caret 					行的起始位置</span><br><span class="line">$     				dollar 					行的结束位置</span><br><span class="line">\&lt;   										单词的起始位置</span><br><span class="line">\&gt; 											单词的结束位置</span><br><span class="line">\b   				单词边界</span><br><span class="line">\B 					非单词边界</span><br><span class="line">(?&#x3D;Expression)		顺序肯定环视			成功,如果右边能够匹配</span><br><span class="line">(?!Expression)		顺序否定环视			成功,如果右边不能够匹配</span><br><span class="line">(?&lt;&#x3D;Expression)		逆序肯定环视			成功,如果左边能够匹配</span><br><span class="line">(?&lt;!Expression) 	逆序否定环视			成功,如果左边不能够匹配</span><br></pre></td></tr></table></figure>
<p>举例:北京市(海定区)(朝阳区)(西城区)</p>
<p>Regex: .*(?=\()</p>
<p><strong>模式和匹配器的典型调用次序</strong></p>
<ol>
<li>把正则表达式编译到模式中<br>Pattern p = Pattern.compile(“a*b”);</li>
<li>创建给定输入与此模式的匹配器<br>Matcher m = p.matcher(“aaab”);</li>
<li>尝试将整个区域与此模式匹配<br>boolean b = m.matches();</li>
</ol>
<h4 id="17-Servlet-amp-JSP-amp-Tomcat"><a href="#17-Servlet-amp-JSP-amp-Tomcat" class="headerlink" title="17.Servlet &amp; JSP &amp; Tomcat"></a>17.Servlet &amp; JSP &amp; Tomcat</h4><p>17.1 Servlet继承实现结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Servlet (接口) 			--&gt;      init|service|destroy方法</span><br><span class="line">GenericServlet(抽象类)  --&gt;      与协议无关的Servlet</span><br><span class="line">HttpServlet(抽象类)		--&gt;		 实现了http协议</span><br><span class="line">自定义Servlet			--&gt;		 重写doGet&#x2F;doPost</span><br></pre></td></tr></table></figure>

<p>17.2 编写Servlet的步骤</p>
<ol>
<li>继承HttpServlet</li>
<li>重写doGet/doPost方法</li>
<li>在web.xml中注册servlet</li>
</ol>
<p>17.3 Servlet生命周期</p>
<ol>
<li><code>init</code>:仅执行一次,负责装载servlet时初始化servlet对象</li>
<li><code>service</code>:核心方法,一般get/post两种方式</li>
<li><code>destroy</code>:停止并卸载servlet,释放资源</li>
</ol>
<p>17.4 过程</p>
<ol>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若存在调用相应service方法</li>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若不存在装载Servlet类并创建实例 -&gt; 调用init初始化 -&gt; 调用service</li>
<li>加载和实例化、初始化、处理请求、服务结束</li>
</ol>
<p>17.5 doPost方法要抛出的异常:ServletExcception、IOException</p>
<p>17.6 Servlet容器装载Servlet</p>
<ol>
<li>web.xml中配置load-on-startup启动时装载</li>
<li>客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后,重新装载Servlet</li>
</ol>
<p>17.7 HttpServlet容器响应web客户请求流程</p>
<ol>
<li>Web客户向servlet容器发出http请求</li>
<li>servlet容器解析Web客户的http请求</li>
<li>servlet容器创建一个HttpRequest对象,封装http请求信息</li>
<li>servlet容器创建一个HttpResponse对象</li>
<li>servlet容器调用HttpServlet的service方法,把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象</li>
<li>HttpServlet调用httprequest的有关方法,获取http请求信息</li>
<li>httpservlet调用httpresponse的有关方法,生成响应数据</li>
<li>Servlet容器把HttpServlet的响应结果传给web客户</li>
</ol>
<p>17.8 HttpServletRequest完成的功能</p>
<ol>
<li>request.getCookie()</li>
<li>request.getHeader(String s)</li>
<li>request.getContextPath()</li>
</ol>
<p>17.9 HttpServletResponse完成的功能</p>
<ol>
<li>设http头</li>
<li>设置Cookie</li>
<li>输出返回数据</li>
</ol>
<p>17.10 <code>session</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session &#x3D; request.getSession(boolean create)</span><br><span class="line">返回当前请求的会话</span><br></pre></td></tr></table></figure>

<p>17.11 JSP的前身就是Servlet</p>
<p>17.12 Tomcat容器的等级</p>
<p>Tomcat - <strong>Container</strong> - <strong>Engine</strong> - <strong>Host</strong> - <strong>Servlet</strong> - 多个Context(一个Context对应一个web工程)-Wrapper</p>
<p>17.13 Servlet与JSP九大内置对象的关系</p>
<p>JSP对象                 怎样获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. out				-&gt;		response.getWriter</span><br><span class="line">2. request 		-&gt;		Service方法中的req参数</span><br><span class="line">3. response 		-&gt;		Service方法中的resp参数</span><br><span class="line">4. session 		-&gt;		request.getSession</span><br><span class="line">5. application 	-&gt;		getServletContext</span><br><span class="line">6. exception 		-&gt;		Throwable</span><br><span class="line">7. page  			-&gt;		this</span><br><span class="line">8. pageContext  	-&gt;		PageContext</span><br><span class="line">9. Config 			-&gt;		getServletConfig</span><br></pre></td></tr></table></figure>

<p>exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。</p>
<h4 id="18-struts"><a href="#18-struts" class="headerlink" title="18.struts"></a>18.struts</h4><ol>
<li>struts可进行文件上传</li>
<li>struts基于MVC模式</li>
<li>struts让流程结构更清晰</li>
<li>struts有许多action类,会增加类文件数目</li>
</ol>
<h4 id="19-Hibernate的7大鼓励措施"><a href="#19-Hibernate的7大鼓励措施" class="headerlink" title="19.Hibernate的7大鼓励措施"></a>19.Hibernate的7大鼓励措施</h4><ol>
<li>尽量使用many-to-one,避免使用单项one-to-many</li>
<li>灵活使用单项one-to-many</li>
<li>不用一对一,使用多对一代替一对一</li>
<li>配置对象缓存,不使用集合对象</li>
<li>一对多使用bag,多对一使用set</li>
<li>继承使用显示多态</li>
<li>消除大表,使用二级缓存</li>
</ol>
<h4 id="20-JVM"><a href="#20-JVM" class="headerlink" title="20.JVM"></a>20.JVM</h4><p>20.1 JVM内存配置参数</p>
<ol>
<li>-Xmx:最大堆大小</li>
<li>-Xms:初始堆大小(最小内存值)</li>
<li>-Xmn:年轻代大小</li>
<li>-XXSurvivorRatio:3 意思是Eden:Survivor=3:2</li>
<li>-Xss栈容量</li>
<li>-XX:+PrintGC 输出GC日志</li>
<li>-XX:+PrintGCDetails 输出GC的详细日志</li>
</ol>
<p>20.2 JVM内存结构</p>
<ol>
<li>堆:Eden、Survivor、old 线程共享</li>
<li>方法区(非堆):持久代,代码缓存,线程共享</li>
<li>JVM栈:中间结果,局部变量,线程隔离</li>
<li>本地栈:本地方法(非Java代码)</li>
<li>程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址</li>
<li>注：持久代Java8消失,取代的称为元空间(本地堆内存的一部分)</li>
</ol>
<h4 id="21-面向对象的五大基本原则-solid"><a href="#21-面向对象的五大基本原则-solid" class="headerlink" title="21.面向对象的五大基本原则(solid)"></a>21.面向对象的五大基本原则(solid)</h4><ol>
<li><p>S单一职责<code>SRP</code>:Single-Responsibility Principle<br>一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。</p>
</li>
<li><p>O开放封闭原则<code>OCP</code>:Open-Closed Principle<br>软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭</p>
</li>
<li><p>L里氏替换原则<code>LSP</code>:Liskov-Substitution Principle<br>子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。</p>
</li>
<li><p>I接口隔离原则<code>ISP</code>:Interface-Segregation Principle<br>使用多个小的接口,而不是一个大的总接口</p>
</li>
<li><p>D依赖倒置原则<code>DIP</code>:Dependency-Inversion Principle<br>依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。</p>
</li>
</ol>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><ol>
<li><p>封装变化</p>
</li>
<li><p>少用继承 多用组合</p>
</li>
<li><p>针对接口编程 不针对实现编程</p>
</li>
<li><p>为交互对象之间的松耦合设计而努力</p>
</li>
<li><p>类应该对扩展开发 对修改封闭（开闭OCP原则）</p>
</li>
<li><p>依赖抽象，不要依赖于具体类（依赖倒置DIP原则）</p>
</li>
<li><p>密友原则：只和朋友交谈（最少知识原则）</p>
<p> 说明：将方法调用保持在界限内，只调用属于以下范围的方法：<br> 该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象</p>
</li>
<li><p>别找我（调用我） 我会找你（调用你）（好莱坞原则）</p>
</li>
<li><p>一个类只有一个引起它变化的原因（单一职责SRP原则）</p>
</li>
</ol>
<h4 id="22-null可以被强制转型为任意类型的对象。"><a href="#22-null可以被强制转型为任意类型的对象。" class="headerlink" title="22.null可以被强制转型为任意类型的对象。"></a>22.null可以被强制转型为任意类型的对象。</h4><h4 id="23-代码执行次序"><a href="#23-代码执行次序" class="headerlink" title="23.代码执行次序"></a>23.代码执行次序</h4><ol>
<li>多个静态成员变量,静态代码块按顺序执行</li>
<li>单个类中: 静态代码 -&gt; main方法 -&gt; 构造块 -&gt; 构造方法</li>
<li>构造块在每一次创建对象时执行</li>
<li>涉及父类和子类的初始化过程<br> a.初始化父类中的静态成员变量和静态代码块<br> b.初始化子类中的静态成员变量和静态代码块<br> c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法(注意父类构造方法中的子类方法覆盖)<br> d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法</li>
</ol>
<h4 id="24-红黑树"><a href="#24-红黑树" class="headerlink" title="24.红黑树"></a>24.红黑树</h4><p><strong>二叉搜索树</strong>:(Binary Search Tree又名：二叉查找树,二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： 若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。</p>
<p><strong>红黑树</strong>的定义:满足以下五个性质的二叉搜索树</p>
<ol>
<li>每个结点或是红色的或是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点是黑色的</li>
<li>如果一个结点是红色的,则它的两个子结点是黑色的</li>
<li>对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点</li>
</ol>
<p>黑高</p>
<p>从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。<br>红黑树的黑高为其根结点的黑高。</p>
<p>其他</p>
<ul>
<li>一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1)</li>
<li>结点的属性(五元组):color key left right p</li>
<li>动态集合操作最坏时间复杂度为O(lgn)</li>
</ul>
<h4 id="25-排序"><a href="#25-排序" class="headerlink" title="25.排序"></a>25.排序</h4><ul>
<li><p>稳定排序:插入排序、冒泡排序、归并排序、基数排序</p>
</li>
<li><p>插入排序[稳定]<br>适用于小数组,数组已排好序或接近于排好序速度将会非常快<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>归并排序[稳定]<br>采用分治法<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(n)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>冒泡排序[稳定]<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>基数排序 分配+收集[稳定]<br>复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r)</p>
</li>
<li><p>树排序<br>应用：TreeSet的add方法、TreeMap的put方法<br>不支持相同元素,没有稳定性问题<br>复杂度：平均最差O(nlogn)</p>
</li>
<li><p>堆排序(就地排序)<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>快速排序<br>复杂度：O(nlgn) - O(nlgn) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]<br>栈空间0(lgn) - O(n)</p>
</li>
<li><p>选择排序<br>复杂度：O(n^2) - O(n^2) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>希尔排序<br>复杂度 小于O(n^2) 平均 O(nlgn) 最差O(n^s)[1&lt;s&lt;2] 空间O(1)</p>
</li>
</ul>
<h4 id="26-查找与散列"><a href="#26-查找与散列" class="headerlink" title="26.查找与散列"></a>26.查找与散列</h4><p>26.1 散列函数设计</p>
<ul>
<li>直接定址法:<code>f(key) = a*key+b</code></li>
</ul>
<p>简单、均匀,不易产生冲突。但需事先知道关键字的分布情况,适合查找表较小且连续的情况,故现实中并不常用</p>
<ul>
<li><p>除留余数法:<code>f(key) = key mod p (p&lt;=m) p取小于表长的最大质数 m为表长</code></p>
</li>
<li><p>DJBX33A算法(time33哈希算法<code>hash = hash*33+(unsigned int)str[i];</code></p>
</li>
</ul>
<p>平方取中法 折叠法 更多….</p>
<p>26.2 冲突处理</p>
<p>闭散列(开放地址方法):要求装填因子a较小，闭散列方法把所有记录直接存储在散列表中</p>
<ul>
<li>线性探测:易产生堆积现象(基地址不同堆积在一起)</li>
<li>二次探测:f(key) = (f(key)+di) % m di=1^2,-1^2,2^2,-2^2…可以消除基本聚集</li>
<li>随机探测:f(key) = (f(key)+di),di采用随机函数得到,可以消除基本聚集</li>
<li>双散列:避免二次聚集</li>
</ul>
<p>开散列(链地址法):原地处理</p>
<ul>
<li>同义词记录存储在一个单链表中,散列表中子存储单链表的头指针。</li>
<li>优点:无堆积 事先无需确定表长 删除结点易于实现 装载因子a&gt;=1,缺点:需要额外空间</li>
</ul>
<h4 id="27-枚举类"><a href="#27-枚举类" class="headerlink" title="27.枚举类"></a>27.枚举类</h4><p>JDK1.5出现 每个枚举值都需要调用一次构造函数</p>
<h4 id="28-数组复制方法"><a href="#28-数组复制方法" class="headerlink" title="28.数组复制方法"></a>28.数组复制方法</h4><ol>
<li>for逐一复制</li>
<li>System.arraycopy() -&gt; 效率最高native方法</li>
<li>Arrays.arrayOf() -&gt; 本质调用arraycopy</li>
<li>clone方法 -&gt; 返回Object[],需要强制类型转换</li>
</ol>
<h4 id="29-多态"><a href="#29-多态" class="headerlink" title="29.多态"></a>29.多态</h4><ol>
<li>Java通过方法重写和方法重载实现多态 </li>
<li>方法重写是指子类重写了父类的同名方法 </li>
<li>方法重载是指在同一个类中，方法的名字相同，但是参数列表不同 </li>
</ol>
<h4 id="30-Java文件"><a href="#30-Java文件" class="headerlink" title="30.Java文件"></a>30.Java文件</h4><p>.java文件可以包含多个类，唯一的限制就是：一个文件中只能有一个public类， 并且此public类必须与<br>文件名相同。而且这些类和写在多个文件中没有区别。</p>
<h4 id="31-Java移位运算符"><a href="#31-Java移位运算符" class="headerlink" title="31.Java移位运算符"></a>31.Java移位运算符</h4><p>java中有三种移位运算符</p>
<ol>
<li>&lt;&lt; :左移运算符,x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><blockquote>
<blockquote>
<p>:带符号右移,x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>:无符号右移,忽略符号位,空位都以0补齐</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h4 id="32-形参-amp-实参"><a href="#32-形参-amp-实参" class="headerlink" title="32.形参&amp;实参"></a>32.形参&amp;实参</h4><ol>
<li>形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。</li>
<li>形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。</li>
<li>形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。</li>
</ol>
<h4 id="33-IO"><a href="#33-IO" class="headerlink" title="33.IO"></a>33.IO</h4><p><img src="http://uploadfiles.nowcoder.com/images/20150328/138512_1427527478646_1.png" alt=""></p>
<h4 id="34-局部变量为什么要初始化"><a href="#34-局部变量为什么要初始化" class="headerlink" title="34.局部变量为什么要初始化"></a>34.局部变量为什么要初始化</h4><p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</p>
<h4 id="35-JDK提供的用于并发编程的同步器"><a href="#35-JDK提供的用于并发编程的同步器" class="headerlink" title="35.JDK提供的用于并发编程的同步器"></a>35.JDK提供的用于并发编程的同步器</h4><ol>
<li>Semaphore Java并发库的Semaphore可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</li>
<li>CyclicBarrier 主要的方法就是一个：await()。await()方法每被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此CyclicBarrier上面阻塞的线程开始运行。</li>
<li>直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</li>
</ol>
<h4 id="36-Java类加载器"><a href="#36-Java类加载器" class="headerlink" title="36.Java类加载器"></a>36.Java类加载器</h4><p>一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： </p>
<ol>
<li>Bootstrap ClassLoader(引导类加载器) 负责加载java基础类，主要是 %JRE_HOME/lib/目录下的rt.jar、resources.jar、charsets.jar等</li>
<li>Extension ClassLoader(扩展类加载器) 负责加载java扩展类，主要是 %JRE_HOME/lib/ext目录下的jar等</li>
<li>App ClassLoader(系统类加载器) 负责加载当前java应用的classpath中的所有类。<br>classloader 加载类用的是全盘负责委托机制。 所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。<br>所以，当我们自定义的classloader加载成功了com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。</li>
</ol>
<h4 id="37-Java语言的鲁棒性"><a href="#37-Java语言的鲁棒性" class="headerlink" title="37.Java语言的鲁棒性"></a>37.Java语言的鲁棒性</h4><p>Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。</p>
<h4 id="38-Java语言特性"><a href="#38-Java语言特性" class="headerlink" title="38.Java语言特性"></a>38.Java语言特性</h4><ol>
<li>Java致力于检查程序在编译和运行时的错误</li>
<li>Java虚拟机实现了跨平台接口</li>
<li>类型检查帮助检查出许多开发早期出现的错误</li>
<li>Java自己操纵内存减少了内存出错的可能性</li>
<li>Java还实现了真数组，避免了覆盖数据的可能</li>
</ol>
<h4 id="39-Hibernate延迟加载"><a href="#39-Hibernate延迟加载" class="headerlink" title="39.Hibernate延迟加载"></a>39.Hibernate延迟加载</h4><ol>
<li>Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） </li>
<li>Hibernate3 提供了属性的延迟加载功能<br>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 </li>
<li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 </li>
<li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li>
</ol>
<h4 id="40-包装类的equals-方法不处理数据转型，必须类型和值都一样才相等。"><a href="#40-包装类的equals-方法不处理数据转型，必须类型和值都一样才相等。" class="headerlink" title="40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。"></a>40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。</h4><h4 id="41-子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。"><a href="#41-子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。" class="headerlink" title="41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。"></a>41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。</h4><h4 id="42-Java语法糖"><a href="#42-Java语法糖" class="headerlink" title="42.Java语法糖"></a>42.Java语法糖</h4><ol>
<li>Java7的switch用字符串 - hashcode方法 switch用于enum枚举</li>
<li>伪泛型 - List<E>原始类型</li>
<li>自动装箱拆箱 - Integer.valueOf和Integer.intValue</li>
<li>foreach遍历 - Iterator迭代器实现</li>
<li>条件编译</li>
<li>enum枚举类、内部类</li>
<li>可变参数 - 数组</li>
<li>断言语言</li>
<li>try语句中定义和关闭资源</li>
</ol>
<h4 id="43-JVM工具"><a href="#43-JVM工具" class="headerlink" title="43.JVM工具"></a>43.JVM工具</h4><p>命令行</p>
<ol>
<li>jps(jvm processor status)虚拟机进程状况工具</li>
<li>jstat(jvm statistics monitoring)统计信息监视</li>
<li>jinfo(configuration info for java)配置信息工具</li>
<li>jmap(memory map for java)Java内存映射工具</li>
<li>jhat(JVM Heap Analysis Tool)虚拟机堆转储快照分析工具</li>
<li>jstack(Stack Trace for Java)Java堆栈跟踪工具</li>
<li>HSDIS：JIT生成代码反汇编</li>
</ol>
<p>可视化</p>
<ol>
<li>JConsole(Java Monitoring and Management Console):Java监视与管理控制台</li>
<li>VisualVM(All-in-one Java Troubleshooting Tool):多合一故障处理工具</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java常见面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 14:05:35" itemprop="dateCreated datePublished" datetime="2020-05-31T14:05:35+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java面试问题列表"><a href="#Java面试问题列表" class="headerlink" title="Java面试问题列表"></a>Java面试问题列表</h2><p>Java 面试随着时间的改变而改变。在过去的日子里，当你知道 String 和 StringBuilder 的区别（String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象。因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，影响性能，可以考虑使用可变字符序列StringBuilder）就能让你直接进入第二轮面试，但是现在问题变得越来越高级，面试官问的问题也更深入。 在我初入职场的时候，类似于 Vector 与 Array 的区别、HashMap 与 Hashtable 的区别是最流行的问题，只需要记住它们，就能在面试中获得更好的机会，但这种情形已经不复存在。如今，你将会被问到许多 Java 程序员都没有看过的领域，如 NIO，设计模式，成熟的单元测试，或者那些很难掌握的知识，如并发、算法、数据结构及编码。</p>
<p>由于我喜欢研究面试题，因此我已经收集了许多的面试问题，包括许多许多不同的主题。我已经为这众多的问题准备一段时间了，现在我将它们分享给你们。这里面不但包含经典的面试问题，如线程、集合、equals 和 hashcode、socket，而且还包含了 NIO、数组、字符串、Java 8 等主题。</p>
<p>该列表包含了入门级 Java 程序员和多年经验的高级开发者的问题。无论你是 1、2、3、4、5、6、7、8、9 还是 10 年经验的开发者，你都能在其中找到一些有趣的问题。这里包含了一些超级容易回答的问题，同时包含经验丰富的 Java 程序员也会棘手的问题。</p>
<p>当然你们也是非常幸运的，当今有许多好的书来帮助你准备 Java 面试，其中有一本我觉得特别有用和有趣的是 Markham 的 Java 程序面试揭秘（Java Programming Interview Exposed）。 这本书会告诉你一些 Java 和 JEE 面试中最重要的主题，即使你不是准备 Java 面试，也值得一读。</p>
<p>该问题列表特别长，我们有各个地方的问题，所以，答案必须要短小、简洁、干脆，不拖泥带水。因此，除了这一个段落，你只会听到问题与答案，再无其他内容，没有反馈，也没有评价。为此，我已经写好了一些博文，在这些文章中你可以找到我对某些问题的观点，如我为什么喜欢这个问题，这个问题的挑战是什么？期望从面试者那获取到什么样的答案？</p>
<p>这个列表有一点不同，我鼓励你采用类似的方式去分享问题和答案，这样容易温习。我希望这个列表对面试官和候选人都有很好的用处，面试官可以对这些问题上做一些改变以获取新奇和令人惊奇的元素，这对一次好的面试来说非常重要。而候选者，可以扩展和测试 Java 程序语言和平台关键领域的知识。2015 年，会更多的关注并发概念，JVM 内部，32 位 JVM 和 64 JVM的区别，单元测试及整洁的代码。我确信，如果你读过这个庞大的 Java 面试问题列表，无论是电话面试还是面对面的面试，你都能有很好的表现。</p>
<h3 id="Java-面试中的重要话题"><a href="#Java-面试中的重要话题" class="headerlink" title="Java 面试中的重要话题"></a>Java 面试中的重要话题</h3><p>除了你看到的惊人的问题数量，我也尽量保证质量。我不止一次分享各个重要主题中的问题，也确保包含所谓的高级话题，这些话题很多程序员不喜欢准备或者直接放弃，因为他们的工作不会涉及到这些。Java NIO 和 JVM 底层就是最好的例子。你也可以将设计模式划分到这一类中，但是越来越多有经验的程序员了解 GOF 设计模式并应用这些模式。我也尽量在这个列表中包含 2015 年最新的面试问题，这些问题可能是来年关注的核心。为了给你一个大致的了解,下面列出这份 Java 面试问题列表包含的主题：</p>
<ul>
<li>多线程，并发及线程基础</li>
<li>数据类型转换的基本原则</li>
<li>垃圾回收（GC）</li>
<li>Java 集合框架</li>
<li>数组</li>
<li>字符串</li>
<li>GOF 设计模式</li>
<li>SOLID （单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）设计原则</li>
<li>抽象类与接口</li>
<li>Java 基础，如 equals 和 hashcode</li>
<li>泛型与枚举</li>
<li>Java IO 与 NIO</li>
<li>常用网络协议</li>
<li>Java 中的数据结构和算法</li>
<li>正则表达式</li>
<li>JVM 底层</li>
<li>Java 最佳实践</li>
<li>JDBC</li>
<li>Date, Time 与 Calendar</li>
<li>Java 处理 XML</li>
<li>JUnit</li>
<li>编程</li>
</ul>
<h3 id="120-大-Java-面试题及答案"><a href="#120-大-Java-面试题及答案" class="headerlink" title="120 大 Java 面试题及答案"></a>120 大 Java 面试题及答案</h3><p>现在是时候给你展示我近 5 年从各种面试中收集来的 120 个问题了。我确定你在自己的面试中见过很多这些问题，很多问题你也能正确回答。</p>
<p><strong>多线程、并发及线程的基础问题</strong></p>
<p>1）Java 中能创建 volatile 数组吗？</p>
<p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p>
<p>2）volatile 能使得一个非原子操作变成原子操作吗？</p>
<p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<p>3）volatile 修饰符的有过什么实践？</p>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
<p>4）volatile 类型变量提供什么保证？</p>
<p>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。</p>
<p>5) 10 个线程和 2 个线程的同步代码，哪个更容易写？</p>
<p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<p>6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</p>
<p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The standard idiom for using the wait method</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">while</span> (condition does not hold)</span><br><span class="line">obj.wait(); <span class="comment">// (Releases lock, and reacquires on wakeup)</span></span><br><span class="line">... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。</p>
<p>7）什么是多线程环境下的伪共享（false sharing）？</p>
<p>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/11/2bccd7f52a70db95aa72524ef3a55164.gif" alt="False Sharing in Multi-threaded application"></p>
<p>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。</p>
<h3 id="有经验程序员的-Java-面试题"><a href="#有经验程序员的-Java-面试题" class="headerlink" title="有经验程序员的 Java 面试题"></a>有经验程序员的 Java 面试题</h3><p>8）什么是 Busy spin？我们为什么要使用它？</p>
<p>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</p>
<p>9）Java 中怎么获取一份线程 dump 文件？</p>
<p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。</p>
<p>10）Swing 是线程安全的？</p>
<p>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</p>
<p>11）什么是线程局部变量？</p>
<p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。</p>
<p>ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>总结：</p>
<p>a.实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的</p>
<p>b.为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p>
<p>c.在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法</p>
<p>12）用 wait-notify 写一段代码来解决生产者-消费者问题？</p>
<p>请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。</p>
<p>13) 用 Java 写一个线程安全的单例模式（Singleton）？</p>
<p>请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。</p>
<p>14）Java 中 sleep 方法和 wait 方法的区别？</p>
<p>虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。</p>
<p>15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？</p>
<p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。</p>
<p>16）我们能创建一个包含可变对象的不可变对象吗？</p>
<p>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。</p>
<p>数据类型和 Java 基础面试问题</p>
<p>17）Java 中应该使用什么数据类型来代表价格？</p>
<p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<p>18）怎么将 byte 转换为 String？</p>
<p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<p>19）Java 中怎样将 bytes 转换为 long 类型？</p>
<p>String接收bytes的构造器转成String，再Long.parseLong</p>
<p>20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</p>
<p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。</p>
<p>21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；</p>
<p>可以，向下转型。但是不建议使用，容易出现类型转型异常.</p>
<p>22）哪个类包含 clone 方法？是 Cloneable 还是 Object？</p>
<p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<p>23）Java 中 ++ 操作符是线程安全的吗？</p>
<p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p>
<p>24）a = a + b 与 a += b 的区别</p>
<p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">byte</span> a = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// error : cannot convert from int to byte</span></span><br><span class="line">b += a; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>（因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p>
<p>25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？</p>
<p>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</p>
<p>26）3*0.1 == 0.3 将会返回什么？true 还是 false？</p>
<p>false，因为有些浮点数不能完全精确的表示出来。</p>
<p>27）int 和 Integer 哪个会占用更多的内存？</p>
<p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<p>28）为什么 Java 中的 String 是不可变的（Immutable）？</p>
<p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。</p>
<p>29）我们能在 Switch 中使用 String 吗？</p>
<p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p>
<p>30）Java 中的构造器链是什么？</p>
<p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p>
<h3 id="JVM-底层-与-GC（Garbage-Collection）-的面试问题"><a href="#JVM-底层-与-GC（Garbage-Collection）-的面试问题" class="headerlink" title="JVM 底层 与 GC（Garbage Collection） 的面试问题"></a>JVM 底层 与 GC（Garbage Collection） 的面试问题</h3><p>31）64 位 JVM 中，int 的长度是多数？</p>
<p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<p>32）Serial 与 Parallel GC之间的不同之处？</p>
<p>Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。</p>
<p>33）32 位和 64 位的 JVM，int 类型变量的长度是多数？</p>
<p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。</p>
<p>34）Java 中 WeakReference 与 SoftReference的区别？</p>
<p>Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。</p>
<p>StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收</p>
<p>WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在 JVM 内不再有强引用时, 将被GC回收</p>
<p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</p>
<p>35）WeakHashMap 是怎么工作的？</p>
<p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<p>36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？</p>
<p>当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。</p>
<p>37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</p>
<p>你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。</p>
<p>38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</p>
<p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p>
<p>39）JRE、JDK、JVM 及 JIT 之间有什么不同？</p>
<p>JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/11/4468a2440b48658c08acc50f15c3985b.jpg" alt="JVM JRE JDK"></p>
<h3 id="3-年工作经验的-Java-面试题"><a href="#3-年工作经验的-Java-面试题" class="headerlink" title="3 年工作经验的 Java 面试题"></a>3 年工作经验的 Java 面试题</h3><p>40）解释 Java 堆空间及 GC？</p>
<p>当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。</p>
<h3 id="JVM-底层面试题及答案"><a href="#JVM-底层面试题及答案" class="headerlink" title="JVM 底层面试题及答案"></a>JVM 底层面试题及答案</h3><p>41）你能保证 GC 执行吗？</p>
<p>不能，虽然你可以调用 System.gc() 或者 Runtime.getRuntime().gc()，但是没有办法保证 GC 的执行。</p>
<p>42）怎么获取 Java 程序使用的内存？堆使用的百分比？</p>
<p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p>
<p>43）Java 中堆和栈有什么区别？</p>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。<br>Difference between stack and heap memory in Java</p>
<h3 id="关于内存的的面试问题和答案"><a href="#关于内存的的面试问题和答案" class="headerlink" title="关于内存的的面试问题和答案"></a>关于内存的的面试问题和答案</h3><p><strong>Java 基本概念面试题</strong></p>
<p>44）“a==b”和”a.equals(b)”有什么区别？</p>
<p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<p>45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</p>
<p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<p>46）final、finalize 和 finally 的不同之处？</p>
<p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>
<p>47）Java 中的编译期常量是什么？使用它又什么风险？</p>
<p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h3 id="Java-集合框架的面试题"><a href="#Java-集合框架的面试题" class="headerlink" title="Java 集合框架的面试题"></a>Java 集合框架的面试题</h3><p>这部分也包含数据结构、算法及数组的面试问题</p>
<p>48) List、Set、Map 和 Queue 之间的区别(答案)</p>
<p>List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。</p>
<p>49）poll() 方法和 remove() 方法的区别？</p>
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<p>50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？(答案)</p>
<p>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p>
<p>51）ArrayList 与 LinkedList 的不区别？(答案)</p>
<p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。</p>
<p>52）用哪两种方式来实现集合的排序？(答案)</p>
<p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p>
<p>53）Java 中怎么打印数组？(answer答案)</p>
<p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p>
<p>54）Java 中的 LinkedList 是单向链表还是双向链表？(答案)</p>
<p>是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。</p>
<p>55）Java 中的 TreeMap 是采用什么树实现的？(答案)</p>
<p>Java 中的 TreeMap 是使用红黑树实现的。</p>
<p>56) Hashtable 与 HashMap 有什么不同之处？(答案)</p>
<p>这两个类有许多不同的地方，下面列出了一部分：<br>a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。<br>b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。<br>c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。<br>更多的不同之处参见答案。</p>
<p>57）Java 中的 HashSet，内部是如何工作的？(answer答案)</p>
<p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p>
<p>58）写一段代码在遍历 ArrayList 时移除一个元素？(答案)</p>
<p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p>
<p>59）我们能自己写一个容器类，然后使用 for-each 循环吗？</p>
<p>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</p>
<p>60）ArrayList 和 HashMap 的默认大小是多数？(答案)</p>
<p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from ArrayList.java JDK 1.7</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//from HashMap.java JDK 7</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<p>61）有没有可能两个不相等的对象有有相同的 hashcode？</p>
<p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p>
<p>62）两个相同的对象会有不同的的 hash code 吗？</p>
<p>不能，根据 hash code 的规定，这是不可能的。</p>
<p>63）我们可以在 hashcode() 中使用随机数字吗？(答案)</p>
<p>不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。</p>
<p>64）Java 中，Comparator 与 Comparable 有什么不同？(答案)</p>
<p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<p>65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案)</p>
<p>因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h3 id="Java-IO-和-NIO-的面试题"><a href="#Java-IO-和-NIO-的面试题" class="headerlink" title="Java IO 和 NIO 的面试题"></a>Java IO 和 NIO 的面试题</h3><p>IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。</p>
<p>66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？</p>
<p>67）Java 中怎么创建 ByteBuffer？</p>
<p>68）Java 中，怎么读写 ByteBuffer ？</p>
<p>69）Java 采用的是大端还是小端？</p>
<p>70）ByteBuffer 中的字节序是什么？</p>
<p>71）Java 中，直接缓冲区与非直接缓冲器有什么区别？(答案)</p>
<p>72）Java 中的内存映射缓存区是什么？(answer答案)</p>
<p>73）socket 选项 TCP NO DELAY 是指什么？</p>
<p>74）TCP 协议与 UDP 协议有什么区别？(answer答案)</p>
<p>75）Java 中，ByteBuffer 与 StringBuffer有什么区别？(答案)</p>
<h3 id="Java-最佳实践的面试问题"><a href="#Java-最佳实践的面试问题" class="headerlink" title="Java 最佳实践的面试问题"></a>Java 最佳实践的面试问题</h3><p>包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。</p>
<p>76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？(答案)</p>
<p>这是我在写Java 并发程序的时候遵循的一些最佳实践：<br>a）给线程命名，这样可以帮助调试。<br>b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。<br>c）如果可以，更偏向于使用 volatile 而不是 synchronized。<br>d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。<br>e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p>
<p>77）说出几点 Java 中使用 Collections 的最佳实践(答案)</p>
<p>这是我在使用 Java 中 Collectionc 类的一些最佳实践：<br>a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。<br>b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。<br>c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。<br>d）使用迭代器来循环集合。<br>e）使用集合的时候使用泛型。</p>
<p>78）说出至少 5 点在 Java 中使用线程的最佳实践。(答案)</p>
<p>这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：<br>a）对线程命名<br>b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。<br>c）使用线程池</p>
<p>79）说出 5 条 IO 的最佳实践(答案)</p>
<p>IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：<br>a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。<br>b）使用 NIO 和 NIO2<br>c）在 finally 块中关闭流，或者使用 try-with-resource（Java7） 语句。<br>d）使用内存映射文件获取更快的 IO。</p>
<p>80）列出 5 个应该遵循的 JDBC 最佳实践(答案)</p>
<p>有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：<br>a）使用批量的操作来插入和更新数据<br>b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。<br>c）使用数据库连接池<br>d）通过列名来获取结果集，不要使用列的下标来获取。</p>
<p>81）说出几条 Java 中方法重载的最佳实践？(答案)</p>
<p>下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。<br>a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。<br>b）不要重载参数数量一致，而只是参数顺序不同的方法。<br>c）如果重载的方法参数个数多于 5 个，采用可变参数。</p>
<h3 id="Date、Time-及-Calendar-的面试题"><a href="#Date、Time-及-Calendar-的面试题" class="headerlink" title="Date、Time 及 Calendar 的面试题"></a>Date、Time 及 Calendar 的面试题</h3><p>82）在多线程环境下，SimpleDateFormat 是线程安全的吗？(答案)</p>
<p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<p>83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？(答案)</p>
<p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<p>84）Java 中，怎么在格式化的日期中显示时区？</p>
<p>pattern中加z <code>yyyy-MM-dd HH:mm:ss.SSS Z</code></p>
<p>85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？</p>
<p>java.sql.Date是针对SQL语句使用的，它只包含日期而没有时间部分,它们都有getTime方法返回毫秒数，自然就可以直接构建。java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。</p>
<p>86）Java 中，如何计算两个日期之间的差距？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dateDiff</span><span class="params">(Date d1, Date d2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">long</span> n1 = d1.getTime();</span><br><span class="line"><span class="keyword">long</span> n2 = d2.getTime();</span><br><span class="line"><span class="keyword">long</span> diff = Math.abs(n1 - n2);</span><br><span class="line"></span><br><span class="line">diff /= <span class="number">3600</span> * <span class="number">1000</span> * <span class="number">24</span>;</span><br><span class="line"><span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>87）Java 中，如何将字符串 YYYYMMDD 转换为日期？</p>
<p>SimpleDateFormat的parse方法</p>
<h3 id="单元测试-JUnit-面试题"><a href="#单元测试-JUnit-面试题" class="headerlink" title="单元测试 JUnit 面试题"></a>单元测试 JUnit 面试题</h3><p>89）如何测试静态方法？(答案)</p>
<p>可以使用 PowerMock 库来测试静态方法。</p>
<p>90）怎么利用 JUnit 来测试一个方法的异常？(答案)</p>
<p>91）你使用过哪个单元测试库来测试你的 Java 程序？(答案)</p>
<p>92）@Before 和 @BeforeClass 有什么区别？(答案)</p>
<h3 id="编程和代码相关的面试题"><a href="#编程和代码相关的面试题" class="headerlink" title="编程和代码相关的面试题"></a>编程和代码相关的面试题</h3><p>93）怎么检查一个字符串只包含数字？(解决方案)</p>
<p>94）Java 中如何利用泛型写一个 LRU 缓存？(答案)</p>
<p>95）写一段 Java 程序将 byte 转换为 long？(答案)</p>
<p>95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？(解决方案)</p>
<p>97）Java 中，怎么获取一个文件中单词出现的最高频率？(解决方案)</p>
<p>98）如何检查出两个给定的字符串是反序的？(解决方案)</p>
<p>99）Java 中，怎么打印出一个字符串的所有排列？(解决方案)</p>
<p>100）Java 中，怎样才能打印出数组中的重复元素？(解决方案)</p>
<p>101）Java 中如何将字符串转换为整数？(解决方案)</p>
<p>102）在没有使用临时变量的情况如何交换两个整数变量的值？(解决方案)</p>
<h3 id="关于-OOP-和设计模式的面试题"><a href="#关于-OOP-和设计模式的面试题" class="headerlink" title="关于 OOP 和设计模式的面试题"></a>关于 OOP 和设计模式的面试题</h3><p>这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。</p>
<p>103）接口是什么？为什么要使用接口而不是直接使用具体类？</p>
<p>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。</p>
<p>104）Java 中，抽象类与接口之间有什么不同？(答案)</p>
<p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。</p>
<p>105）除了单例模式，你在生产环境中还用过什么设计模式？</p>
<p>这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。</p>
<p>106）你能解释一下里氏替换原则吗?(答案)</p>
<p>107) 什么情况下会违反迪米特法则？为什么会有这个问题？(答案)</p>
<p>迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。</p>
<p>108）适配器模式是什么？什么时候使用？</p>
<p>适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。</p>
<p>109）什么是“依赖注入”和“控制反转”？为什么有人使用？(答案)</p>
<p>110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？(答案)</p>
<p>111）构造器注入和 setter 依赖注入，那种方式更好？(答案)</p>
<p>每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。</p>
<p>112）依赖注入和工厂模式之间有什么不同？(答案)</p>
<p>虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。</p>
<p>113）适配器模式和装饰器模式有什么区别？(答案)</p>
<p>虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。</p>
<p>114）适配器模式和代理模式之前有什么不同？(答案)</p>
<p>这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。</p>
<p>115）什么是模板方法模式？(答案)</p>
<p>模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。</p>
<p>116）什么时候使用访问者模式？(答案)</p>
<p>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。</p>
<p>117）什么时候使用组合模式？(答案)</p>
<p>组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。</p>
<p>118）继承和组合之间有什么不同？(答案)</p>
<p>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</p>
<p>119）描述 Java 中的重载和重写？(答案)</p>
<p>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。</p>
<p>120）Java 中，嵌套公共静态类与顶级类有什么不同？(答案)</p>
<p>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</p>
<p>121) OOP 中的 组合、聚合和关联有什么区别？(答案)</p>
<p>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</p>
<p>122）给我一个符合开闭原则的设计模式的例子？(答案)</p>
<p>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。</p>
<p>123）抽象工厂模式和原型模式之间的区别？(答案)</p>
<p>124）什么时候使用享元模式？(答案)</p>
<p>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。</p>
<h3 id="Java-面试中其他各式各样的问题"><a href="#Java-面试中其他各式各样的问题" class="headerlink" title="Java 面试中其他各式各样的问题"></a>Java 面试中其他各式各样的问题</h3><p>这部分包含 Java 中关于 XML 的面试题，JDBC 面试题，正则表达式面试题，Java 错误和异常及序列化面试题</p>
<p>125）嵌套静态类与顶级类有什么区别？(答案)</p>
<p>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。</p>
<p>126）你能写出一个正则表达式来判断一个字符串是否是一个数字吗？(解决方案)</p>
<p>一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，你可以下一个如下的正则表达式来判断给定的字符串是不是数字。</p>
<p>127）Java 中，受检查异常 和 不受检查异常的区别？(答案)</p>
<p>受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<p>128）Java 中，throw 和 throws 有什么区别？(答案)</p>
<p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：<br>throw new IllegalArgumentException(“size must be multiple of 2″)<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<p>129）Java 中，Serializable 与 Externalizable 的区别？(答案)</p>
<p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<p>130）Java 中，DOM 和 SAX 解析器有什么不同？(答案)</p>
<p>DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。</p>
<p>131）说出 JDK 1.7 中的三个新特性？(答案)</p>
<p>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。</p>
<p>132）说出 5 个 JDK 1.8 引入的新特性？(答案)</p>
<p>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<p>133）Java 中，Maven 和 ANT 有什么区别？(答案)</p>
<p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见答案。</p>
<p>这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP 和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web 开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建一份最新的、最优的 Java 面试问题列表。</p>
<h3 id="Java-EE-相关的面试题"><a href="#Java-EE-相关的面试题" class="headerlink" title="Java EE 相关的面试题"></a>Java EE 相关的面试题</h3><p>为了做 Java EE 的朋友，这里列出了一些 web 开发的特定问题，你们可以用来准备 JEE 部分的面试：</p>
<p>10 大 Spring 框架面试题及答案(参见)</p>
<p>10 个非常好的 XML 面试问题（Java 程序员）(参见)</p>
<p>20 个非常好的设计模式面试问题(参见)</p>
<p>10个最流行的 Struts 面试题（Java 开发者）(参见)</p>
<p>20 个 Tibco Rendezvous 及 EMS 的面试题(更多)</p>
<p>10 个最频繁被问到的 Servlet 面试问题及答案(参见)</p>
<p>20 个 jQuery 面试问题（Java Web 开发者）(列表)</p>
<p>10 个非常好的 Oracle 面试问题（Java 开发者）(参见)</p>
<p>10 大 来自 J2EE 面试中的 JSP 问题(更多)</p>
<p>12 个很好的 RESTful Web Services 面试问题(参见)</p>
<p>10 大 EJB 面试问题及答案(参见)</p>
<p>10 大 JMS 及 MQ 系列面试题及答案(列表)</p>
<p>10 个非常好 Hibernate 面试问题（Java EE 开发者）(参见)</p>
<p>10 个非常好的 JDBC 面试题（Java 开发者）(参见)</p>
<p>15 个 Java NIO 和网络面试题及答案(参见)</p>
<p>10 大 XSLT 面试题及答案(更多)</p>
<p>15 个来自 Java 面试的数据结构和算法问题(参见)</p>
<p>10 大 Java 面试难题及答案(参见)</p>
<p>40 个核心 Java 移动开发面试题及答案(列表)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Java面试题整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 14:05:35 / 修改时间：14:41:14" itemprop="dateCreated datePublished" datetime="2020-05-31T14:05:35+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java面试题整理"><a href="#Java面试题整理" class="headerlink" title="Java面试题整理"></a>Java面试题整理</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>1.停止等待协议</p>
<p>停止等待协议是最基本的数据链路层协议，它的工作原理是这样的。</p>
<p>在发送端，每发送完一帧就停止发送，等待接收端的确认，如果收到确认就发送下一帧。</p>
<p>在接收端，每收到一个无差错的帧，就把这个帧交付上层并向发送端发送确认。若该帧有差错，就丢弃，其他什么也不做。</p>
<p>其他细节：</p>
<p>停止等待协议为了可靠交付，需要对帧进行编号，由于每次只发送一帧，所有停止等待协议使用1个比特编号，编号0和1</p>
<p>停止等待协议会出现死锁现象（A等待B的确认），解决办法，启动超时计时器，超时计时器有一个重传时间。重传时间一般选择略大于“正常情况下从发完数据帧到收到确认帧所需的平均时间”。</p>
<p>2.滑动窗口协议</p>
<p>再说滑动窗口之前，先说下连续ARQ，连续ARQ又称Go-back-N ARQ，意思是当出现差错必须重传时，要向回走N个帧，然后再开始重传，也就意味着只要有一帧出现差错，即使已经正确的帧也需要重传，白白浪费时间，增大开销。为此，应该对发送出去但未被确认的帧的数目加以限制，这就是滑动窗口协议。滑动窗口指收发两端分别维护一个发送窗口和接收窗口，发送窗口有一个窗口值Wt，窗口值Wt代表在没有收到对方确认的情况下最多可以发送的帧的数目。当发送的帧的序号被接收窗口正确收下后，接收端向前滑动并向发送端发去确认，发送端收到确认后，发送窗口向前滑动。收发两端按规律向前推进。</p>
<p>连续ARQ和选择重传ARQ均是窗口大于1的滑动窗口协议，而停止等待协议相当于收发两端窗口等于1.</p>
<p>滑动窗口指接收和发送两端的窗口按规律不断向前推进，是一种流量控制的策略。</p>
<p>3.Http1.0和Http1.1的区别</p>
<p>1.HTTP/1.0协议使用非持久连接,即在非持久连接下,一个tcp连接只传输一个Web对象。<br>2.HTTP/1.1默认使用持久连接(然而,HTTP/1.1协议的客户机和服务器可以配置成使用非持久连接)。在持久连接下,不必为每个Web对象的传送建立一个新的连接,一个连接中可以传输多个对象。</p>
<p>4.Post和Get的区别</p>
<p>1.安全性上说：get的方式是把数据在地址栏中明文的形式发送，URL中可见，POST方式对用户是透明的，安全性更高。<br>2.数据量说：Get传送的数据量较小，一般不能大于2KB，POST传送的数据量更大。<br>3.适用范围说：查询用Get，数据添加、修改和删除建议Post</p>
<p>5.TCP/IP体系各层功能及协议</p>
<p>TCP/IP体系共有四个层次，分别为网络接口层Host-to-Network Layer, 网际层 Internet Layer， 传输层Transport Layer，应用层Application Layer。</p>
<p><strong>网络接口层</strong> -&gt; 接收和发送数据报</p>
<p>主要负责将数据发送到网络传输介质上以及从网络上接收TCP/IP数据报，相当于OSI参考模型的物理层和数据链路层。在实际中，先后流行的以太网、令牌环网、ATM、帧中继等都可视为其底层协议。它将发送的信息组装成帧并通过物理层向选定网络发送，或者从网络上接收物理帧，将去除控制信息后的IP数据报交给网络层。</p>
<p><strong>网际层</strong> -&gt; 数据报封装和路由寻址</p>
<p>网际层主要功能是寻址和对数据报的封装以及路由选择功能。这些功能大部分通过IP协议完成，并通过地址解析协议ARP、逆地址解析协议RARP、因特网控制报文协议ICMP、因特网组管理协议IGMP从旁协助。所以IP协议是网络层的核心。</p>
<p>网际协议IP：IP协议是一个无连接的协议，主要负责将数据报从源结点转发到目的结点。也就是说IP协议通过对数据报中源地址和目的地址进行分析，然后进行路由选择，最后再转发到目的地。需要注意的是：IP协议只负责对数据进行转发，并不对数据进行检查，也就是说，它不负责数据的可靠性，这样设计的主要目的是提高IP协议传送和转发数据的效率。</p>
<p>ARP：该协议负责将IP地址解析转换为计算机的物理地址。</p>
<p>虽然我们使用IP地址进行通信，但IP地址只是主机在抽象的网络层中的地址。最终要传到数据链路层封装成MAC帧才能发送到实际的网络。因此不管使用什么协议最终需要的还是硬件地址。</p>
<p>每个主机拥有一个ARP高速缓存（存放所在局域网内主机和路由器的IP地址到硬件地址的映射表）</p>
<p>举例：A发送B</p>
<p>(1).A在自己的ARP高速缓存中查到B的MAC地址，写入MAC帧发往此B</p>
<p>(2)没查到，A向本局域网广播ARP请求分组，内容包括自己的地址映射和B的IP地址</p>
<p>(3)B发送ARP响应分组，内容为自己的IP地址到物理地址的映射，同时将A的映射写入自己的ARP高速缓存（单播的方式）</p>
<p>注：ARP Cache映射项目具有一个生存时间。</p>
<p>RARP：将计算机物理地址转换为IP地址</p>
<p>ICMP：该协议主要负责发送和传递包含控制信息的数据报，这些控制信息包括了哪台计算机出现了什么错误，网络路由出现了什么错误等内容。</p>
<p><strong>传输层</strong> -&gt; 应用进程间端到端的通信</p>
<p>传输层主要负责应用进程间“端到端”的通信，即从某个应用进程传输到另一个应用进程，它与OSI参考模型的传输层功能类似。</p>
<p>传输层在某个时刻可能要同时为多个不同的应用进程服务，因此传输层在每个分组中必须增加用于识别应用进程的标识，即端口。</p>
<p>TCP/IP体系的传输层主要包含两个主要协议，即传输控制协议TCP和用户数据报协议UDP。TCP协议是一种可靠的、面向连接的协议，保证收发两端有可靠的字节流传输，进行了流量控制，协调双方的发送和接收速度，达到正确传输的目的。</p>
<p>UDP是一种不可靠的、无连接的协议，其特点是协议简单、额外开销小、效率较高，不能保证可靠传输。</p>
<p>传输层提供应用进程间的逻辑通信。它使应用进程看见的就好像是在两个运输层实体间一条端到端的逻辑通信信道。</p>
<p>当运输层采用TCP时，尽管下面的网络是不可靠的，但这种逻辑通信信道相当于一条全双工的可靠信道。可以做到报文的无差错、按序、无丢失、无重复。</p>
<p>注：单单面向连接只是可靠的必要条件，不充分。还需要其他措施，如确认重传，按序接收，无丢失无重复。</p>
<p>熟知端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20 FTP数据连接 </span><br><span class="line">21 FTP控制连接 </span><br><span class="line">22 SSH </span><br><span class="line">23 TELNET </span><br><span class="line">25 SMTP </span><br><span class="line">53 DNS </span><br><span class="line">69 TFTP</span><br><span class="line">80 HTTP</span><br><span class="line">161 SNMP</span><br></pre></td></tr></table></figure>

<p><strong>UDP</strong>重要</p>
<p>UDP的优点：</p>
<p>1.发送之前无需建立连接，减小了开销和发送数据的时延</p>
<p>2.UDP不使用拥塞控制，不使用可靠交付，因此主机不需要维护复杂的参数表、连接状态表</p>
<p>3.UDP用户数据报只有8个字节的首部开销，而TCP要20字节。</p>
<p>4.由于没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（IP电话等实时应用要求源主机以恒定的速率发送数据）</p>
<p>Table，使用TCP和UDP的应用</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>运输层协议</th>
</tr>
</thead>
<tbody><tr>
<td>名字转换</td>
<td>DNS</td>
<td>UDP</td>
</tr>
<tr>
<td>文件传送</td>
<td>TFTP</td>
<td>UDP</td>
</tr>
<tr>
<td>路由选择协议</td>
<td>RIP</td>
<td>UDP</td>
</tr>
<tr>
<td>IP地址配置</td>
<td>BOOTTP,DHCP</td>
<td>UDP</td>
</tr>
<tr>
<td>网络管理</td>
<td>SNMP</td>
<td>UDP</td>
</tr>
<tr>
<td>远程文件服务器</td>
<td>NFS</td>
<td>UDP</td>
</tr>
<tr>
<td>IP电话</td>
<td>专用协议</td>
<td>UDP</td>
</tr>
<tr>
<td>流式多媒体通信</td>
<td>专用协议</td>
<td>UDP</td>
</tr>
<tr>
<td>电子邮件</td>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端接入</td>
<td>TELNET</td>
<td>TCP</td>
</tr>
<tr>
<td>万维网</td>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传送</td>
<td>FTP</td>
<td>TCP</td>
</tr>
</tbody></table>
<p>注：TFTP：Trivial File Transfer Protocol</p>
<p>UDP的过程：</p>
<p>1.服务器进程运行着，等待TFTP客户进程的服务请求。客户端TFTP进程启动时，向操作系统申请一个临时端口号，然后操作系统为该进程创建2个队列，<br>入队列和出队列。只要进程在执行，2个队列一直存在。</p>
<p>2.客户进程将报文发送到出队列中。UDP按报文在队列的先后顺序发送。在传送到IP层前给报文加上UDP首部，其中目的端口后为69。然后发给IP层。<br>出队列若溢出，则操作系统通知应用层TFTP客户进程暂停发送。</p>
<p>3.客户端收到来自IP层的报文时，UDP检查报文中目的端口号是否正确，若正确，放入入队列队尾，客户进程按先后顺序一一取走。若不正确，UDP丢弃该报文，并请ICMP发送”端口不可达“差错报文给服务器端。入队列可能会溢出，若溢出，UDP丢弃该报文，不通知对方。</p>
<p>服务器端类似。</p>
<p>UDP首部：源端口 - 目的端口 - 长度 - 检验和，每个字段22字节。</p>
<p>IP数据报检验和只检验IP数据报的首部，而UDP的检验和将首部和数据部分一起都检验。</p>
<p><strong>TCP</strong>重要</p>
<p>细节：</p>
<p>TCP报文段是面向字节的数据流。</p>
<p>TCP首部：20字节固定首部</p>
<p>确认比特ACK，ACK=1 确认号字段才有效；同步比特SYN：SYN=1 ACK=0表示一个连接请求报文段；终止比特FIN，FIN=1时要求释放连接。</p>
<p>窗口：将TCP收发两端记为A和B，A根据TCP缓存空间的大小确定自己的接收窗口大小。并在A发送给B的窗口字段写入该值。作为B的发送窗口的上限。意味着B在未收到A的确认情况下，最多发送的字节数。</p>
<p>选项：最大报文段长度MSS，MSS告诉对方TCP：我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节。若主机未填写，默认为536字节。</p>
<p>TCP的可靠是使用了序号和确认。当TCP发送一个报文时，在自己的重传队列中存放一个副本。若收到副本，删除副本。</p>
<p>TCP使用捎带确认。</p>
<p>TCP报文段的发送时机：1.维持一个变量等于MSS，发送缓存达到MSS就发送 2.发送端应用进程指明要发送，即TCP支持的PUSH操作。3.设定计时器</p>
<p><strong>TCP的拥塞控制：TCP使用慢开始和拥塞避免算法进行拥塞控制</strong></p>
<p><strong>慢开始和拥塞避免</strong></p>
<p>接收端根据自身资源情况控制发送端发送窗口的大小。</p>
<p>每个TCP连接需要维持一下2个状态变量：</p>
<p>接收端窗口rwnd（receiver window）：接收端根据目前接收缓存大小设置的窗口值，是来自接收端的流量控制</p>
<p>拥塞窗口cwnd（congestion window）：是发送端根据自己估计的网络拥塞程度设置的窗口值，是来自发送端的流量控制</p>
<p>发送端的窗口上限值=Min(rwnd, cwnd)</p>
<p>慢开始算法原理：主机刚开始发送数据时，如果立即将较大的发送窗口的全部字节注入网络，由于不清楚网络状况，可能会引起拥塞。通常的做法是将cwnd设置为1个MSS，每收到一个确认，将cwnd+1，由小到大逐步增大cwnd，使分组注入网络的速率更加合理。为了防止拥塞窗口增长引起网络拥塞，还需设置一个状态变量ssthresh，即慢开始门限。</p>
<p>慢开始门限：ssthresh，当cwnd &lt; ssthresh,执行慢开始算法；cwnd &gt; ssthresh，改用拥塞避免算法。 cwnd = ssthresh时，都可以。</p>
<p>拥塞避免算法使发送端的拥塞窗口每经过一个RTT增加一个MSS（而不管在此期间收到多少ACK），这样，拥塞窗口cwnd按线性规律增长，拥塞窗口此时比慢开始增长速率缓慢很多。这一过程称为加法增大，目的在于使拥塞窗口缓慢增长，防止网络过早拥塞。</p>
<p>无论是慢开始还是拥塞避免，只要发送端发现网络出现拥塞（根据是没有按时收到ACK或者收到重复ACK），就将慢开始门限ssthresh设置为拥塞窗口值的一半并将拥塞窗口cwnd置为1，重新执行慢开始算法。这一过程称为乘法减小。目的在于迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>上述TCP确认都是通过捎带确认执行的。</p>
<p><strong>快重传和快恢复</strong></p>
<p>上述的慢开始和拥塞避免算法是早期TCP使用的拥塞控制算法。因为有时TCP连接会在重传时会因等待重传计时器的超时时间而空闲。为此在快重传中：只要发送端一连收到三个重复的ACK,即可断定分组丢失，不必等待重传计数器，立即重传丢失的报文。</p>
<p>与快重传搭配使用的还有快恢复：当不使用快恢复时，发送端若发现网络拥塞就将拥塞窗口降为1，然后执行慢开始算法，这样的缺点是网络不能很快恢复到正常状态。快恢复是指当发送端收到3个重复的ACK时，执行乘法减小，ssthresh变为拥塞窗口值的一半。但是cwnd不是置为1，而是ssthresh+3xMSS。若收到的重复ACK<br>为n(n &gt; 3)，则cwnd=ssthresh+n*MSS.这样做的理由是基于发送端已经收到3个重复的ACK，它表明已经有3个分组离开了网络，它们不在消耗网络的资源。</p>
<p>注意的是：在使用快恢复算法时，慢开始算法只在TCP连接建立时使用。</p>
<p>TCP的重传机制</p>
<p>每发送一个报文段，就对这个报文段设置一次计时器。新的重传时间=γ*旧的重传时间。</p>
<p><strong>TCP连接建立和释放的过程</strong></p>
<p>SYN置1和FIN的报文段要消耗一个序号。</p>
<p>客户端连接状态变迁：CLOSED -&gt; 主动打开,发送SYN=1 -&gt; SYN_SENT -&gt; 收到服务器的SYN=1和ACK时,发送三次握手的最后一个ACK<br>-&gt; ESTABLISHED -&gt; 数据传送 -&gt; 主动关闭 -&gt; 发送FIN=1,等待确认ACK的到达 -&gt; FIN_WAIT_1 -&gt; 收到确认ACK后 -&gt; FIN_WAIT_2<br>-&gt;收到服务器发送的FIN=1报文，响应，发送四次挥手的的最后一个确认ACK -&gt; 进入TIME_WAIT状态<br>-&gt; 经过2倍报文寿命，TCP删除连接记录 -&gt; 回到CLOSED状态 </p>
<p>服务器端连接状态变迁：CLOSED -&gt; 被动打开 -&gt; LISTEN -&gt; 收到SYN=1的报文，发送SYN=1和确认ACK -&gt; 进入SYN_RCVD -&gt; 收到三次握手<br>的最后一个确认ACK -&gt; ESTABLISHED -&gt; 数据传送 -&gt; 数据传送完毕，收到FIN=1 -&gt; 发送确认ACK并进入CLOSED_WAIT -&gt; 发送FIN=1给客户端 -&gt; LAST_ACK<br>-&gt; 收到客户端四次挥手的最后一个确认ACK -&gt; 删除连接记录 -&gt; 回到CLOSED状态 </p>
<p>应用层</p>
<p>应用层位于TCP/IP体系结构的最高一层，也是直接为应用进程服务的一层，即当不同的应用进程数据交换时，就去调用应用层的不同协议实体，让这些实体去调用传输层的TCP或者UDP来进行网络传输。具体的应用层协议有，SMTP 25、DNS 53、HTTP 80、FTP 20数据端口 21控制端口、TFTP 69、TELNET 23、SNMP 161等</p>
<p>6.网络的划分 </p>
<p>按网络拓扑结构：总线、星型、环型、树型、网状结构和混合型。</p>
<p>按覆盖范围：局域网、城域网、广域网</p>
<p>按传播方式：广播网络和点对点网络</p>
<p>广播式网络是指网络中的计算机使用一个共享信道进行数据传播，网络中的所有结点都能收到某一结点发出的数据信息。</p>
<p>单播：一对一的发送形式。</p>
<p>组播：采用一对一组的发送形式，将数据发送给网络中的某一组主机。</p>
<p>广播：采用一对所有，将数据发送给网络所有目的结点。</p>
<p>点对点网络中两个结点间的通信方式是点对点的。如果两台计算机之间没有直连的线路，则需要中间结点的接收、存储、转发直至目的结点。</p>
<p>7.TCP的三次握手和四次挥手的过程</p>
<p>连接建立（三次握手）：首先Client端发送连接请求报文SYN并进入SYN_SENT状态，Server收到后发送ACK+SYN报文，并为这次连接分配资源。Client端接收到Server端的SYN+ACK后发送三次握手的最后一个ACK，并分配资源，连接建立。</p>
<p>连接释放（四次挥手）：假设Client端发起断开连接请求，首先发送FIN=1,等待确认ACK的到达 -&gt; FIN_WAIT_1 -&gt; 收到确认Server端的确认ACK后时 -&gt; FIN_WAIT_2<br>-&gt;收到服务器发送的FIN=1报文，响应，发送四次挥手的的最后一个确认ACK -&gt;进入TIME_WAIT状态<br>-&gt; 经过2倍报文寿命，TCP删除连接记录 -&gt; 回到CLOSED状态</p>
<p>8.为什么连接建立是三次握手，而连接释放要四次挥手？</p>
<p>因为当Server端收到Client端发送的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK用来应答，SYN用来同步。但是关闭连接时，当Server端收到FIN报文后，并不会立即关闭socket，所以先回复一个ACK，告诉Client端“你的FIN我收到了”，只有等Server端的所有报文发送完了，Server端才发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
<p>9.为什么TIME_WAIT状态需要2MSL（最大报文段生存时间）才能返回Closed状态？</p>
<p>这是因为虽然双方都同意关闭连接了，而且四次挥手的报文也都协调发送完毕。但是我们必须假想网络是不可靠的，无法保证最后发送的ACK报文一定被对方收到，因此处于LAST_ACK状态下的<br>Server端可能会因未收到ACK而重发FIN，所以TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p>
<p>10.Http报文格式</p>
<p>Http请求报文格式：1.请求行 2.Http头 3.报文主体</p>
<p>请求行由三部分组成，分别是请求方法，请求地址，Http版本</p>
<p>Http头：有三种，分别为请求头（request header），普通头（General Header）和实体头（entity header）。Get方法没有实体头。</p>
<p>报文主体：只在POST方法请求中存在。</p>
<p>Http响应报文：1.状态行 2.Http头 3.返回内容</p>
<p>状态行：第一部分为Http版本，第二部分为响应状态码 第三部分为状态码的描述</p>
<p>其中第三部分为状态码的描述，信息类100-199 响应成功200-299 重定向类300-399 客户端错误400-499 服务器端错误500-599</p>
<p>Http头：响应头（Response Header），普通头（General Header）和实体头(Entity Header)</p>
<p>返回内容：即Http请求的信息，可以是HTML也可以是图片等等。</p>
<p>11.Http和Https的区别</p>
<p>Https即Secure Hypertext Transfer Protocol，即安全超文本传输协议，它是一个安全通信信道，基于Http开发，用于在客户机和服务器间交换信息。它使用安全套接字层SSL进行信息交换，是Http的安全版。</p>
<p>Https协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>Http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>http是80端口，https是443端口</p>
<p>12.浏览器输入一个URL的过程</p>
<ol>
<li><p>浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址</p>
</li>
<li><p>解析出IP地址后，根据IP地址和默认端口80和服务器建立TCP连接</p>
</li>
<li><p>浏览器发出Http请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</p>
</li>
<li><p>服务器做出响应，把对应的请求资源发送给浏览器</p>
</li>
<li><p>释放TCP连接</p>
</li>
<li><p>浏览器解析并显示内容</p>
</li>
</ol>
<p>13.中间人攻击</p>
<p>中间人获取server发给client的公钥，自己伪造一对公私钥，然后伪造自己让client以为它是server，然后将伪造的公钥发给client，并拦截client发给server的密文，用伪造的私钥即可得到client发出去的内容，最后用真实的公钥对内容加密发给server。</p>
<p>解决办法：数字证书，证书链，可信任的中间人</p>
<p>14.差错检测</p>
<p>误码率：传输错误的比特与传输总比特数的比率</p>
<p>CRC是检错方法并不能纠错，FCS（Frame Check Sequence）是冗余码。</p>
<p>计算冗余码（余数R）的方法：先补0（n个）再对生成多项式取模。</p>
<p>CRC只能表示以接近1的概率认为它没有差错。但不能做到可靠传输。可靠传输还需要确认和重传机制。</p>
<p>生成多项式P(X)：CRC-16，CRC-CCITT，CRC-32</p>
<p>15.数据链路层的协议</p>
<p>停止等待协议 - 连续ARQ - 选择重传ARQ - PPP - 以太网协议- 帧中继 - ATM - HDLC</p>
<p>16.截断二进制指数退避算法</p>
<p>是以太网用于解决当发生碰撞时就停止发送然后重发再碰撞这一问题。</p>
<p>截断二进制指数退避算法：基本退避时间为2τ k=min{重传次数，10} r=random(0~2^k-1) 重传所需时延为r倍的基本退避时间</p>
<h3 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h3><p>1.equals与==的区别</p>
<p>区别1.==是一个运算符 equals是Object类的方法</p>
<p>区别2.用于基本类型的变量比较时：==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。</p>
<p>b.用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。</p>
<p>2.Object有哪些公用方法？<br>clone equals hashcode wait notify notifyall finalize toString getClass<br>除了clone和finalize其他均为公共方法。</p>
<p>3.Java中的四种引用</p>
<p>StrongReference：JVM默认，只要StrongReference存在，GC将不会回收被引用的对象</p>
<p>SoftReference：尽可能长时间保留引用，直到JVM内存不足，适合某些缓存应用</p>
<p>WeakReference：尽可能长时间的存活于JVM内直到下一次GC发生前</p>
<p>PhantomReference：它是最弱的一种引用关系，也无法通过PhantomReference取得对象的实例。仅用来当该对象被回收时收到一个通知</p>
<p>4.Hashcode的作用<br>HashCode是Object类的一个方法。hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。也就是说，</p>
<p>如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等</p>
<p>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同</p>
<p>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false</p>
<p>如果两个对象的hashcode值相等，则equals方法得到的结果未知</p>
<p>注意的一点是：在重写equals方法的同时，必须重写hashCode方法。让equals方法和hashCode方法在逻辑上保持一致性。</p>
<p>为什么要重写：不重写可能会违反hashcode方法的约定，即“相等的对象必须具有相等的hashcode值”，导致对基于 hash 的集合类无法正常工作，比如说HashMap，它是使用Key对象的hashCode()和equals()方法去决定key-value对的。如果只重写equals方法，将某个对象用put方法放入散列桶中，get时可能从另外一个散列桶获取，因为两个方法的传入参数的equals虽然相同，但hashcode可能不同。</p>
<p>5.String、StringBuffer与StringBuilder的区别</p>
<p>第一点：可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</p>
<p>第二点：线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</p>
<p>6.并发和并行</p>
<p>“并行”是指无论从微观还是宏观，二者都是一起执行的，也就是同一时刻执行<br>而“并发”在微观上不是同时执行的。是在同一时间间隔交替轮流执行</p>
<p>7.switch能否用String做参数</p>
<p>Java1.7开始支持，但实际这是一颗Java语法糖。除此之外，byte，short，long，枚举，boolean均可用于switch，只有浮点型不可以。</p>
<p>8.Java语法糖</p>
<ol>
<li>Java7的switch用字符串 - 实际为hashcode方法</li>
<li>伪泛型 - 实际为List<E>原始类型</li>
<li>自动装箱拆箱 - 实际为Integer.valueOf和Integer.intValue</li>
<li>foreach遍历 - 实际为Iterator迭代器实现</li>
<li>条件编译</li>
<li>enum枚举类、内部类</li>
<li>可变参数 - 实际为数组实现</li>
<li>断言语言</li>
<li>try语句中定义和关闭资源</li>
</ol>
<p>9.try catch finally问题</p>
<p>1)不管有木有出现异常，finally块中代码都会执行 </p>
<p>2)当try和catch中有return时，finally仍然会执行</p>
<p>3)finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的</p>
<p>4)finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</p>
<p>10.受检查异常和运行时异常<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<p>1.粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 </p>
<p>2.绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… </p>
<p>3.而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 </p>
<p>11.封装、继承、多态</p>
<p><strong>封装</strong>：</p>
<p>1.概念：就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。</p>
<p>2.好处：</p>
<p>(1)隐藏内部实现细节。</p>
<p><strong>继承</strong>：</p>
<p>1.概念：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力</p>
<p>2.好处：提高代码的复用，缩短开发周期。</p>
<p><strong>多态</strong>：</p>
<p>1.概念：多态（Polymorphism）按字面的意思就是“多种状态，即同一个实体同时具有多种形式。一般表现形式是程序在运行的过程中，同一种类型在不同的条件下表现不同的结果。多态也称为动态绑定，一般是在运行时刻才能确定方法的具体执行对象。</p>
<p>2.好处：<br>1）将接口和实现分开，改善代码的组织结构和可读性，还能创建可拓展的程序。<br>2）消除类型之间的耦合关系。允许将多个类型视为同一个类型。<br>3）一个多态方法的调用允许有多种表现形式</p>
<p>12.抽象类与接口</p>
<p>1.一个子类只能继承一个抽象类,但能实现多个接口</p>
<p>2.抽象类可以有构造方法,接口没有构造方法</p>
<p>3.抽象类可以有普通成员变量,接口没有普通成员变量</p>
<p>4.抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</p>
<p>5.抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</p>
<p>6.抽象类可以有静态方法，接口不能有静态方法</p>
<p>7.抽象类中的方法可以是public、protected和默认;接口方法只有public abstract</p>
<p>13.静态内部类和普通内部类</p>
<p>静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>1.List集合和Set集合</p>
<p>List接口：</p>
<p>List中元素存取是有序的、可重复的；Set集合中元素是无序的，不可重复的。</p>
<p>CopyOnWriteArrayList:COW的策略，即写时复制的策略。适用于读多写少的并发场景</p>
<p>Set接口：</p>
<p>Set集合元素存取无序，且元素不可重复。</p>
<p>HashSet不保证迭代顺序，线程不安全；LinkedHashSet是Set接口的哈希表和链接列表的实现，保证迭代顺序，线程不安全。</p>
<p>TreeSet：可以对Set集合中的元素排序，元素以二叉树形式存放，线程不安全。</p>
<p>2.ArrayList、LinkedList、Vector的区别</p>
<p>首先它们均是List接口的实现。</p>
<p>ArrayList、LinkedList的区别</p>
<p>1.随机存取：ArrayList是基于可变大小的数组实现，LinkedList是链接列表的实现。这也就决定了对于随机访问的get和set的操作，ArrayList要优于LinkedList，因为LinkedList要移动指针。</p>
<p>2.插入和删除：LinkedList要好一些，因为ArrayList要移动数据，更新索引。</p>
<p>3.内存消耗：LinkedList需要更多的内存，因为需要维护指向后继结点的指针。</p>
<p>Vector从Java 1.0起就存在，在1.2时改为实现List接口，功能与ArrayList类似，但是Vector具备线程安全。</p>
<p>3.Map集合</p>
<p>Hashtable:基于Dictionary类，线程安全，速度快。底层是哈希表数据结构。是同步的。<br>不允许null作为键，null作为值。</p>
<p>Properties:Hashtable的子类。用于配置文件的定义和操作，使用频率非常高，同时键和值都是字符串。</p>
<p>HashMap：线程不安全，底层是数组加链表实现的哈希表。允许null作为键，null作为值。HashMap去掉了contains方法。<br>注意：HashMap不保证元素的迭代顺序。如果需要元素存取有序，请使用LinkedHashMap</p>
<p>TreeMap：可以用来对Map集合中的键进行排序。</p>
<p>ConcurrentHashMap:是JUC包下的一个并发集合。</p>
<p>为什么使用ConcurrentHashMap而不是HashMap或Hashtable？</p>
<p>HashMap的缺点：主要是多线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会死循环，CPU达到100%，所以在并发情况下不能使用HashMap。让HashMap同步：Map m = Collections.synchronizeMap(hashMap);而Hashtable虽然是同步的，使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。 </p>
<p>ConcurrentHashMap的原理：</p>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因在于所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap的结构：</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，当对某个HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p>ConcurrentHashMap的构造、get、put操作：</p>
<p>构造函数：传入参数分别为 1、初始容量，默认16 2、装载因子 装载因子用于rehash的判定，就是当ConcurrentHashMap中的元素大于装载因子*最大容量时进行扩容，默认0.75 3、并发级别 这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16;。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。默认16.</p>
<p>初始化的一些动作：</p>
<p>初始化segments数组（根据并发级别得到数组大小ssize），默认16</p>
<p>初始化segmentShift和segmentMask（这两个全局变量在定位segment时的哈希算法里需要使用），默认情况下segmentShift为28，segmentMask为15</p>
<p>初始化每个Segment，这一步会确定Segment里HashEntry数组的长度.</p>
<p>put操作：</p>
<p>1、判断value是否为null，如果为null，直接抛出异常。</p>
<p>2、key通过一次hash运算得到一个hash值。将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&amp;运算得到segment的索引j。即segmentFor方法</p>
<p>3、使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&amp;运算获取HashEntry的索引，然后set）。</p>
<p>get操作：</p>
<p>1、和put操作一样，先通过key进行hash确定应该去哪个Segment中取数据。</p>
<p>2、使用Unsafe获取对应的Segment，然后再进行一次&amp;运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。</p>
<p>定位Segment的hash算法：(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask</p>
<p>定位HashEntry所使用的hash算法：int index = hash &amp; (tab.length - 1);</p>
<p>注：tab为HashEntry数组</p>
<p>4.Collection 和 Collections的区别</p>
<p>Collection是集合类的上级接口，子接口主要有Set 和List、Queue<br>Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<p>5.Map、Set、List、Queue、Stack的特点与用法</p>
<p>Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。 List集合代表元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。 Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(LIFO后进先出) Queue用于模拟”队列”这种数据结构(先进先出 FIFO)。 Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值。</p>
<p>6.HashMap的工作原理</p>
<p>HashMap维护了一个Entry数组，Entry内部类有key,value，hash和next是个字段，其中next也是一个Entry类型。可以将Entry数组理解为一个个的散列桶。每一个桶实际上是一个单链表。当执行put操作时，会根据key的hashcode定位到相应的桶。遍历单链表检查该key是否已经存在，如果存在，覆盖该value，反之，新建一个新的Entry，并放在单链表的头部。当通过传递key调用get方法时，它再次使用key.hashCode()来找到相应的散列桶，然后使用key.equals()方法找出单链表中正确的Entry，然后返回它的值。</p>
<p>7.HashMap和Hashtable的区别</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Hashtable是基于陈旧的Dictionary的Map接口的实现，而HashMap是基于哈希表的Map接口的实现</li>
<li><input checked="" disabled="" type="checkbox"> 从方法上看，HashMap去掉了Hashtable的contains方法</li>
<li><input checked="" disabled="" type="checkbox"> HashTable是同步的(线程安全)，而HashMap线程不安全</li>
<li><input checked="" disabled="" type="checkbox"> HashMap允许空键值，而Hashtable不允许</li>
<li><input checked="" disabled="" type="checkbox"> HashMap的iterator迭代器执行快速失败机制，也就是说在迭代过程中修改集合结构，除非调用迭代器自身的remove方法，否则以其他任何方式的修改都将抛出并发修改异常。如果寻求迭代的时候修改Map，可以使用ConcurrentHashMap。而Hashtable返回的Enumeration不是快速失败的。</li>
</ul>
<p>8.Map的实现类的介绍</p>
<p>HashMap基于散列表来的实现，即使用hashCode()进行快速查询元素的位置，显著提高性能。插入和查询“键值对”的开销是固定的。可以通过设置容量和装载因子，以调整容器的性能。</p>
<p>LinkedHashMap, 类似于HashMap,但是迭代遍历它时，保证迭代的顺序是其插入的次序，因为它使用链表维护内部次序。此外可以在构造器中设定LinkedHashMap，使之采用LRU算法。使没有被访问过的元素或较少访问的元素出现在前面，访问过的或访问多的出现在后面。这对于需要定期清理元素以节省空间的程序员来说，此功能使得程序员很容易得以实现。</p>
<p>TreeMap, 是基于红黑树的实现。同时TreeMap实现了SortedMap接口，该接口可以确保键处于排序状态。所以查看“键”和“键值对”时，所有得到的结果都是经过排序的，次序由自然排序或提供的Comparator决定。SortedMap接口拥有其他额外的功能，如：返回当前Map使用的Comparator比较强，firstKey()，lastKey(),headMap(toKey),tailMap(fromKey)以及可以返回一个子树的subMap()方法等。</p>
<p>WeakHashMap，表示弱键映射，WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<p>ConcurrentHashMap， 在HashMap基础上分段锁机制实现的线程安全的HashMap。</p>
<p>IdentityHashMap 使用==代替equals() 对“键”进行比较的散列映射。专为解决特殊问题而设计。</p>
<p>HashTable：基于Dictionary类的Map接口的实现，它是线程安全的。</p>
<p>9.LinkedList 和 PriorityQueue 的区别</p>
<p>它们均是Queue接口的实现。拥有FIFO的特点，它们的区别在于排序行为。LinkedList 支持双向列表操作，<br>PriorityQueue 按优先级组织的队列，元素的出队次序由元素的自然排序或者由Comparator比较器指定。</p>
<p>10.线程安全的集合类。Vector、HashTable、Properties和Stack</p>
<p>11.BlockingQueue</p>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行获取元素时，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
<p>12.如何对一组对象进行排序</p>
<p>如果需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collections.sort()方法。排序时是默认根据元素的自然排序（使用Comparable）或使用Comparator外部比较器。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。</p>
<p>13.Comparable和Comparator接口区别</p>
<p>Comparator位于包java.util下，而Comparable位于包java.lang下</p>
<p>如果我们需要使用Arrays或Collections的排序方法对对象进行排序时，我们需要在自定义类中实现Comparable接口并重写compareTo方法，compareTo方法接收一个参数，如果this对象比传递的参数小，相等或大时分别返回负整数、0、正整数。Comparable被用来提供对象的自然排序。String、Integer实现了该接口。</p>
<p>Comparator比较器的compare方法接收2个参数，根据参数的比较大小分别返回负整数、0和正整数。<br>Comparator 是一个外部的比较器，当这个对象自然排序不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。</p>
<p>14.与Java集合框架相关的有哪些最好的实践</p>
<p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。<br>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。<br>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。<br>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。<br>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<h3 id="IO-NIO"><a href="#IO-NIO" class="headerlink" title="IO/NIO"></a>IO/NIO</h3><p>1.IO和NIO</p>
<p>在以前的Java IO中，都是阻塞式IO，NIO引入了非阻塞式IO。<br>第一种方式：我从硬盘读取数据，然后程序一直等，数据读完后，继续操作。这种方式是最简单的，叫阻塞IO。<br>第二种方式：我从硬盘读取数据，然后程序继续向下执行，等数据读取完后，通知当前程序（对硬件来说叫中断，对程序来说叫回调），然后此程序可以立即处理数据，也可以执行完当前操作在读取数据。</p>
<p>2.流与块的比较</p>
<p>原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。这样做是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。<br>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>3.通道与流</p>
<p>Channel是一个对象，可以通过它读取和写入数据。通道与流功能类似，不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而通道可以用于读、写或者同时用于读写。</p>
<p>4.缓冲区Buffer</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在 NIO 库中，所有数据都是用缓冲区处理的。</p>
<p>Position: 表示下一次访问的缓冲区位置<br>Limit: 表示当前缓冲区存放的数据容量。<br>Capacity:表示缓冲区最大容量</p>
<p>flip()方法:它将 limit 设置为当前 position。它将 position 设置为 0</p>
<p>clear方法:它将 limit 设置为与 capacity 相同。它设置 position 为 0。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1.什么是线程</p>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100 毫秒，那么用十个线程完成改任务只需 10 毫秒。Java在语言层面对多线程提供了很好的支持。</p>
<p>2.线程和进程有什么区别</p>
<p>从概念上：<br>进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。<br>线程：存在于进程内，是进程内的基本调度单位。共享进程的资源。</p>
<p>从执行过程中来看：<br>进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。<br>线程：每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看：（重要区别）<br>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。</p>
<p>简言之，一个程序至少有一个进程,一个进程至少有一个线程。进程是资源分配的基本单位，线程共享进程的资源。</p>
<p>3.如何在 Java 中实现线程</p>
<p>继承Thread类或实现Runnable接口。</p>
<p>4.用 Runnable 还是 Thread</p>
<p>Java 不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是实现Runnable接口好了。</p>
<p>5.Thread 类中的 start () 和 run () 方法有什么区别</p>
<p>start ()方法被用来启动新创建的线程，而且 start ()内部调用了 run ()方法，这和直接调用 run ()方法的效果不一样。当你调用 run ()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start ()方法才会启动新线程。也就是用start方法来启动线程,才是真正实现了多线程。而run方法只是一个普通方法。</p>
<p>6.Java 中 Runnable 和 Callable 有什么不同</p>
<p>Runnable和 Callable 都代表那些要在不同的线程中执行的任务。Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。它们的主要区别是 Callable 的 call () 方法可以返回值和抛出异常，而 Runnable 的 run ()方法没有这些功能。</p>
<p>7.Java 中 CyclicBarrier 和 CountDownLatch 有什么不同</p>
<p>它们都是JUC下的类，CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。区别在于CountdownLatch计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 </p>
<p>8.Java 内存模型是什么</p>
<p>Java 内存模型规定和指引Java 程序在不同的内存架构、CPU 和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。</p>
<p>线程内的代码能够按先后顺序执行，这被称为程序次序规则。</p>
<p>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。</p>
<p>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。</p>
<p>一个线程内的任何操作必需在这个线程的 start ()调用之后，也叫作线程启动规则。</p>
<p>一个线程的所有操作都会在线程终止之前，线程终止规则。</p>
<p>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。</p>
<p>传递性</p>
<p>9.Java 中的 volatile 变量是什么</p>
<p>Java 语言提供了一种稍弱的同步机制,即<code>volatile</code>变量。但是volatile并不容器完全被正确、完整的理解。<br>一般来说，volatile具备2条语义，或者说2个特性。第一是保证volatile修饰的变量对所有线程的可见性，这里的可见性是指当一条线程修改了该变量，新值对于其它线程来说是立即可以得知的。而普通变量做不到这一点。</p>
<p>第二条语义是禁止指令重排序优化，这条语义在JDK1.5才被修复。</p>
<p>关于第一点：根据JMM，所有的变量存储在主内存，而每个线程还有自己的工作内存，线程的工作内存保存该线程使用到的变量的主内存副本拷贝，线程对变量的操作在工作内存中进行，不能直接读写主内存的变量。在volatile可见性这一点上，普通变量做不到的原因正因如此。比如，线程A修改了一个普通变量的值，然后向主内存进行回写，线程B在线程A回写完成后再从主内存读取，新变量才能对线程B可见。其实，按照虚拟机规范，volatile变量依然有工作内存的拷贝，要借助主内存来实现可见性。但由于volatile的特殊规则保证了新值能立即同步回主内存，以及每次使用从主内存刷新，以此保证了多线程操作volatile变量的可见性。</p>
<p>关于第二点：先说指令重排序，指令重排序是指CPU采用了允许将多条指令不按规定顺序分开发送给相应的处理单元处理，但并不是说任意重排，CPU需要正确处理指令依赖情况确保最终的正确结果，指令重排序是机器级的优化操作。那么为什么volatile要禁止指令重排序呢，又是如何去做的。举例，DCL（双重检查加锁）的单例模式。volatile修饰后，代码中将会插入许多内存屏障指令保证处理器不发生乱序执行。同时由于Happens-before规则的保证，在刚才的例子中写操作会发生在后续的读操作之前。</p>
<p>除了以上2点，volatile还保证对于64位long和double的读取是原子性的。因为在JMM中允许虚拟机对未被volatile修饰的64位的long和double读写操作分为2次32位的操作来执行，这也就是所谓的long和double的非原子性协定。</p>
<p>基于以上几点，我们知道volatile虽然有这些语义和特性在并发的情况下仍然不能保证线程安全。大部分情况下仍然需要加锁。</p>
<p>除非是以下2种情况，1.运算结果不依赖变量的当前值，或者能够确保只有单一线程修改变量的值；2.变量不需要与其他的状态变量共同参与不变约束。</p>
<p>10.Java 中，编写多线程程序的时候你会遵循哪些最佳实践？</p>
<p>a）给线程命名，这样可以帮助调试。<br>b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。<br>c）如果可以，更偏向于使用 volatile 而不是 synchronized。<br>d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。<br>e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p>
<p>11.什么是线程安全？Vector 是一个线程安全类吗</p>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的， 而和它相似的 ArrayList 不是线程安全的。</p>
<p>12.Java 中什么是竞态条件？ 举个例子说明。</p>
<p>竞态条件会导致程序在并发情况下出现一些 bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的 bugs。这种 bugs 很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理。</p>
<p>13.Java 中如何停止一个线程</p>
<p>当 run () 或者 call () 方法执行完的时候线程会自动结束，如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run ()方法的循环或者是取消任务来中断线程。其他情形：异常 - 停止执行 休眠 - 停止执行 阻塞 - 停止执行</p>
<p>14.一个线程运行时发生异常会怎样</p>
<p>简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 Thread.getUncaughtExceptionHandler ()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException ()方法进行处理。</p>
<p>15.如何在两个线程间共享数据？</p>
<p>通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构</p>
<p>16.Java 中 notify 和 notifyAll 有什么区别</p>
<p>notify ()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而 notifyAll ()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p>
<p>17.为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面</p>
<p>一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的。如果线程需要等待某些锁那么调用对象中的 wait ()方法就有意义了。如果 wait ()方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。</p>
<p>18.什么是ThreadLocal</p>
<p>ThreadLocal，线程局部变量。</p>
<p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。</p>
<p>ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>总结：</p>
<p>a.实际通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的</p>
<p>b.为何threadLocals的键为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p>
<p>c.在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法</p>
<p>19.什么是 FutureTask？</p>
<p>在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable 接口所以它可以提交给 Executor 来执行。</p>
<p>20.Java 中 interrupted 和 isInterruptedd 方法的区别</p>
<p>interrupted是静态方法，isInterruptedd是一个普通方法</p>
<p>如果当前线程被中断（没有抛出中断异常，否则中断状态就会被清除），你调用interrupted方法，第一次会返回true。然后，当前线程的中断状态被方法内部清除了。第二次调用时就会返回false。如果你刚开始一直调用isInterrupted，则会一直返回true，除非中间线程的中断状态被其他操作清除了。也就是说isInterrupted 只是简单的查询中断状态，不会对状态进行修改。</p>
<p>21.为什么 wait 和 notify 方法要在同步块中调用</p>
<p>如果不这么做，代码会抛出 IllegalMonitorStateException异常。还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</p>
<p>22.为什么你应该在循环中检查等待条件？</p>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在 notify ()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 wait ()方法效果更好的原因。</p>
<p>23.Java 中的同步集合与并发集合有什么区别</p>
<p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java1.5加入了并发集合像 ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。它们大部分位于JUC包下。</p>
<p>24.Java 中堆和栈有什么不同</p>
<p>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<p>25.什么是线程池？ 为什么要使用它？</p>
<p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从 JDK1.5 开始，Java API 提供了 Executor 框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。</p>
<p>26.如何写代码来解决生产者消费者问题？</p>
<p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用 wait 和 notify 来解决这个问题，比较赞的办法是用 Semaphore 或者 BlockingQueue 来实现生产者消费者模型。</p>
<p>27.如何避免死锁？</p>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<p>28.Java 中活锁和死锁有什么区别？</p>
<p>活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<p>29.怎么检测一个线程是否拥有锁</p>
<p>在 java.lang.Thread 中有一个方法叫 holdsLock ()，当且仅当当前线程拥有某个具体对象的锁时它返回true。</p>
<p>30.你如何在 Java 中获取线程堆栈</p>
<p>eak 组合键来获取线程堆栈，Linux 下用 kill -3 命令。你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。</p>
<p>31.JVM内存配置参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.-Xmx:最大堆大小</span><br><span class="line">2.-Xms:初始堆大小(最小内存值)</span><br><span class="line">3.-Xmn:年轻代大小</span><br><span class="line">4.-XXSurvivorRatio:3 意思是Eden:Survivor=3:2</span><br><span class="line">5.-Xss栈容量</span><br><span class="line">6.-XX:+PrintGC 输出GC日志</span><br><span class="line">7.-XX:+PrintGCDetails 输出GC的详细日志</span><br></pre></td></tr></table></figure>

<p>32.Java 中 synchronized 和 ReentrantLock 有什么不同</p>
<p>Java 在过去很长一段时间只能通过 synchronized 关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过 Lock 接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<p>33.有三个线程 T1，T2，T3，怎么确保它们按顺序执行</p>
<p>可以用线程类的 join ()方法。具体操作是在T3的run方法中调用t2.join()，让t2执行完再执行t3；T2的run方法中调用t1.join()，让t1执行完再执行t2。这样就按T1，T2，T3的顺序执行了</p>
<p>34.Thread 类中的 yield 方法有什么作用</p>
<p>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield ()的线程有可能在进入到暂停状态后马上又被执行。</p>
<p>35.Java 中 ConcurrentHashMap 的并发度是什么</p>
<p>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</p>
<p>36.Java 中 Semaphore是什么</p>
<p>JUC下的一种新的同步类，它是一个计数信号。从概念上讲，Semaphore信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire ()，然后再获取该许可。每个 release ()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<p>37.如果你提交任务时，线程池队列已满。会发会生什么？</p>
<p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么 ThreadPoolExecutor’s submit ()方法将会抛出一个 RejectedExecutionException 异常。</p>
<p>38.Java 线程池中 submit () 和 execute ()方法有什么区别</p>
<p>两个方法都可以向线程池提交任务，execute ()方法的返回类型是 void，它定义在 Executor 接口中， 而 submit ()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</p>
<p>39.什么是阻塞式方法？</p>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的 accept ()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p>
<p>40.Swing 是线程安全的吗？</p>
<p>你可以很肯定的给出回答，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。</p>
<p>41.Java 中 invokeAndWait 和 invokeLater 有什么区别</p>
<p>这两个方法是 Swing API 提供给 Java 开发者用来从当前线程而不是事件派发线程更新 GUI 组件用的。InvokeAndWait ()同步更新 GUI 组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用 invokeAndWait ()方法请求事件派发线程对组件进行相应更新。而 invokeLater ()方法是异步调用更新组件的。</p>
<p>42.Swing API 中那些方法是线程安全的？</p>
<p>虽然Swing不是线程安全的但是有一些方法是可以被多线程安全调用的。如repaint ()， revalidate ()。 JTextComponent 的 setText ()方法和 JTextArea 的 insert () 和 append () 方法也是线程安全的。</p>
<p>43.如何在 Java 中创建 Immutable 对象</p>
<p>Immutable 对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是 Java 没有@Immutable 这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供 setter 方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p>
<p>44.Java 中的 ReadWriteLock 是什么？</p>
<p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java 中的 ReadWriteLock 是 Java 5 中新增的一个接口，一个 ReadWriteLock 维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用 JDK 中的 ReentrantReadWriteLock 来实现这个规则，它最多支持 65535 个写锁和 65535 个读锁。</p>
<p>45.多线程中的忙循环是什么?</p>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法 wait ()， sleep () 或 yield () 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<p>46.volatile 变量和 atomic 变量有什么不同</p>
<p>volatile 变量和 atomic 变量看起来很像，但功能却不一样。volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前， 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作并不是原子性的。而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如 getAndIncrement ()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<p>47.如果同步块内的线程抛出异常会发生什么？</p>
<p>无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在 finally block 里释放锁实现。</p>
<p>48.如何在 Java 中创建线程安全的 Singleton</p>
<p>5种，急加载，同步方法，双检锁，静态内部类，枚举</p>
<p>49.如何强制启动一个线程？</p>
<p>这个问题就像是如何强制进行 Java 垃圾回收，目前还没有觉得方法，虽然你可以使用 System.gc ()来进行垃圾回收，但是不保证能成功。在 Java 里面没有办法强制启动一个线程，它是被线程调度器控制着且 Java 没有公布相关的 API。</p>
<p>50.Java 中的 fork join 框架是什么？</p>
<p>fork join 框架是 JDK7 中出现的一款高效的工具，Java 开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join 框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p>
<p>51.Java 多线程中调用 wait () 和 sleep ()方法有什么不同？</p>
<p>Java 程序中 wait 和 sleep 都会造成某种形式的暂停，它们可以满足不同的需要。wait ()方法意味着条件等待，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep ()方法仅仅释放 CPU 资源或者让当前线程短暂停顿，但不会释放锁。</p>
<p>52.双亲委派模型中的方法</p>
<p>findLoadedClass(),LoadClass(),findBootstrapClassOrNull(),findClass(),resolveClass()</p>
<p>53.NIO、AIO、BIO</p>
<p>BIO即同步阻塞IO，适用于连接数目较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4之前的唯一选择，但程序直观、简单、易理解。</p>
<p>NIO即同步非阻塞IO，适用于连接数目多且连接比较短的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO即异步非阻塞IO，适用于连接数目多且连接比较长的架构，如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK1.7开始支持</p>
<h3 id="GC、内存相关"><a href="#GC、内存相关" class="headerlink" title="GC、内存相关"></a>GC、内存相关</h3><p>1.对哪些区域回收<br>Java运行时数据区域：程序计数器、JVM栈、本地方法栈、方法区和堆。</p>
<p>由于程序计数器、JVM栈、本地方法栈3个区域随线程而生随线程而灭，对这几个区域内存的回收和分配具有确定性。而方法区和堆则不一样，程序需要在运行时才知道创建哪些对象，对这部分内存的分配是动态的，GC关注的也就是这部分内存。</p>
<p>2.如何判定对象需要回收<br>引用计数法：给对象加上一个计数器，当有一个地方引用它，计数器+1，引用失效时，计数器-1，当计数器为0时，判定该对象可回收。引用计数法优点是实现简单，python，flashplayer等使用引用计数法进行内存管理。引用计数法的缺点在于无法解决循环引用的问题。</p>
<p>在Java中使用可达性分析算法法判定对象是否“死亡”。可达性分析法是指通过称为GC-Roots的对象为起始点，从这些结点向下搜索，当从GCRoots到这个对象不可达时，被判定为可收回的对象。</p>
<p>3.可作为GC Roots的对象</p>
<p>可作为GC Roots的对象：虚拟机栈中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象</p>
<p>4.对象的自我救赎</p>
<p>即使在可达性算法中判定为不可达时，也并非一定被回收。对象存在自我救赎的可能。要真正宣告对象的死亡，需要经历2次标记的过程。如果对象经过可达性分析法发现不可达时，对象将被第一次标记被进行筛选，筛选的条件是此对象是否有必要执行finalize方法。如果对象没有重写finalize方法或finalize方法已经被JVM调用过，则判定为不需要执行。</p>
<p>如果对象被判定为需要执行finalize方法，该对象将被放置在一个叫做F-Queue的队列中，JVM会建立一个低优先级的线程执行finalize方法，如果对象想要完成自我救赎需要在finalize方法中与引用链上的对象关联，比如把自己也就是this赋值给某个类变量。当GC第二次对F-Queue中对象标记时，该对象将被移出“即将回收”的集合，完成自我救赎。简言之，finalize方法是对象逃脱死亡命运的最后机会，并且任何对象的finalize方法只会被JVM调用一次。</p>
<p>5.垃圾回收算法</p>
<p>Mark-Sweep法：标记清除法 容易产生内存碎片，导致分配较大对象时没有足够的连续内存空间而提前出发GC。这里涉及到另一个问题，即对象创建时的内存分配，对象创建内存分配主要有2种方法，分别是指针碰撞法和空闲列表法。指针碰撞法：使用的内存在一侧，空闲的在另一侧，中间使用一个指针作为分界点指示器，对象内存分配时只要指针向空闲的移动对象大小的距离即可。<br>空闲列表法：使用的和空闲的内存相互交错无法进行指针碰撞，JVM必须维护一个列表记录哪些内存块可用，分配时从列表中找出一个足够的分配给对象，并更新列表记录。所以，当采用Mark-Sweep算法的垃圾回收器时，内存分配通常采用空闲列表法。</p>
<p>Copy法：将内存分为2块，每次使用其中的一块，当一块满了，将存活的对象复制到另一块，把使用过的那一块一次性清除。显然，Copy法解决了内存碎片的问题，但算法的代价是内存缩小为原来的一半。现代的垃圾收集器对新生代采用的正是Copy算法。但通常不执行1:1的策略，HotSpot虚拟机默认Eden区Survivor区8:1。每次使用Eden和其中一块Survivor区。也就是说新生代可用内存为新生代内存空间的90%。</p>
<p>Mark-Compact法：标记整理法。它的第一阶段与Mark-Sweep法一样，但不直接清除，而是将存活对象向一端移动，然后清除端边界以外的内存，这样也不存在内存碎片。</p>
<p>分代收集算法：将堆内存划分为新生代，老年代，根据新生代老年代的特点选取不同的收集算法。因为新生代对象大多朝生夕死，而老年代对象存活率高，没有额外空间进行分配担保，通常对新生代执行复制算法，老年代执行Mark-Sweep算法或Mark-Compact算法。</p>
<p>6.垃圾收集器</p>
<p>通常来说，新生代老年代使用不同的垃圾收集器。新生代的垃圾收集器有Serial（单线程）、ParNew（Serial的多线程版本）、ParallelScavenge（吞吐量优先的垃圾收集器），老年代有SerialOld（单线程老年代）、ParallelOld（与ParallelScavenge搭配的多线程执行标记整理算法的老年代收集器）、CMS（标记清除算法，容易产生内存碎片，可以开启内存整理的参数），以及当前最先进的垃圾收集器G1，G1通常面向服务器端的垃圾收集器，在我自己的Java应用程序中通过-XX:+PrintGCDetails，发现自己的垃圾收集器是使用了ParallelScavenge+ParallelOld的组合。</p>
<p>7.内存分配和回收的策略</p>
<p>1.对象优先在Eden区分配，默认Eden与Survivor的比例为8:1</p>
<p>2.大对象直接进入老年代</p>
<p>3.长期存活的进入老年代：JVM给每个对象定义一个年龄计数器，当对象在Eden区出生并躲过一次MinorGC，并且Survivor可以容纳的话，将被移入Survivor区，年龄设为1。以后每在Survivor区躲过一次MinorGC，年龄加一岁，当对象年龄加到15岁时，晋升到老年代。当然15岁的默认值可以通过-XX虚拟机参数设置。</p>
<p>4.动态对象年龄判定：有的时候无需到达15岁即晋升老年代。判定方法是如果Survivor区中相同年龄的所有对象大小的总和大于Survivor区空间的一半，年龄大于或等于该年龄的对象直接进入老年代</p>
<p>5.空间分配担保</p>
<p>在发生MinorGC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象总和，如果成立，确保这次MinorGC安全。否则，虚拟机会查看HandlePromotionFailure设置是否允许担保失败。如果允许，虚拟机会接着查看老年代最大连续可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，则进行一次MinorGC，尽管这次MinorGC是有风险的，如果小于或者HandlePromotionFailure设置为不允许，要改为一次FullGC</p>
<p>8.方法区的回收</p>
<p>方法区通常会与永久代划等号，实际上二者并不等价，只不过是HotSpot虚拟机设计者用永久代实现方法区，并将GC分代扩展至方法区。<br>永久代垃圾回收通常包括两部分内容：废弃常量和无用的类。常量的回收与堆区对象的回收类似，当没有其他地方引用该字面量时，如果有必要，将被清理出常量池。</p>
<p>判定无用的类的3个条件：</p>
<p>1.该类的所有实例都已经被回收，也就是说堆中不存在该类的任何实例</p>
<p>2.加载该类的ClassLoader已经被回收</p>
<p>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>当然，这也仅仅是判定，不代表立即卸载该类。</p>
<p>9.Java中有内存泄漏吗？</p>
<p>内存泄露的定义: 当某些对象不再被应用程序所使用,但是由于仍然被引用而导致垃圾收集器不能释放。</p>
<p>内存泄漏的原因：对象的生命周期不同。比如说</p>
<p>对象A引用了对象B. A的生命周期比B的要长得多，当对象B在应用程序中不会再被使用以后, 对象 A 仍然持有着B的引用. (根据虚拟机规范)在这种情况下GC不能将B从内存中释放. 这种情况很可能会引起内存问题，倘若A还持有着其他对象的引用,那么这些被引用的(无用)对象也不会被回收,并占用着内存空间。甚至有可能B也持有一大堆其他对象的引用。这些对象由于被 B 所引用,也不会被垃圾收集器所回收，所有这些无用的对象将消耗大量宝贵的内存空间。并可能导致内存泄漏</p>
<p>怎样防止：</p>
<p>1、当心集合类,比如HashMap,ArrayList等,因为这是最容易发生内存泄露的地方.当集合对象被声明为static时,他们的生命周期一般和整个应用程序一样长。</p>
<p>10.OOM解决办法、</p>
<p>内存溢出的空间：Permanent Generation和Heap Space，也就是永久代和堆区</p>
<p>第一种情况永久代的溢出：出现这种问题的原因可能是应用程序加载了大量的jar或class，使虚拟机装载类的空间不够，与Permanent Generation Space的大小有关。</p>
<p>解决办法有2种：1、通过虚拟机参数-XX：PermSize和-XX：MaxPermSize调整永久代大小 2、清理程序中的重复的Jar文件，减少类的重复加载</p>
<p>第二种堆区的溢出：发生这种问题的原因是java虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了，与Heap Space的size有关。解决这类问题有两种思路：</p>
<p>1、检查程序，看是否存在死循环或不必要地重复创建大量对象，定位原因，修改程序和算法。</p>
<p>2、通过虚拟机参数-Xms和-Xmx设置初始堆和最大堆的大小</p>
<p>11.DirectMemory直接内存</p>
<p>直接内存并不是Java虚拟机规范定义的内存区域的一部分，但是这部分内存也被频繁使用，而且也可能导致OOM异常的出现。</p>
<p>JDK1.4引入了NIO，这是一种基于通道和缓冲区的非阻塞IO模式，它可以使用Native函数库分配直接堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，使得在某些场合显著提高性能，因为它避免了在Java堆和本地堆之间来回复制数据。</p>
<h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>1.如何判断链表是否有环</p>
<p>方法1：快慢指针法 2.设两个工作指针p、q，p总是向前走，但q每次都从头开始走，对于每个节点，看p走的步数是否和q一样。比如p从A走到D，用了4步，而q则用了14步。因而步数不等，出现矛盾，存在环。</p>
<p>2.红黑树</p>
<p><strong>二叉搜索树</strong>:(Binary Search Tree又名：二叉查找树，二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： 若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。</p>
<p>红黑树是一棵二叉搜索树，它在每个结点上增加一个存储位来表示结点的颜色，可以是RED或BLACK。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树没有一条路径会比其他路径长出2倍，所以红黑树是近似平衡的，使得红黑树的查找、插入、删除等操作的时间复杂度最坏为O(log n)，但需要注意到在红黑树上执行插入或删除后将不在满足红黑树性质，恢复红黑树的属性需要少量(O(log<br>n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操<br>作时间仍可以保持为 O(log n) 次。具体如何保证？引出红黑树的5个性质。</p>
<p>红黑树的5个性质：满足以下五个性质的二叉搜索树</p>
<ol>
<li>每个结点或是红色的或是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点是黑色的</li>
<li>如果一个结点是红色的,则它的两个子结点是黑色的</li>
<li>对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点</li>
</ol>
<p>插入操作：</p>
<p>由于性质的约束，插入的结点都是红色的。插入时性质1、3始终保持。破坏性质2当且仅当当前插入结点为根节点。变一下颜色即可。如果是破坏性质4或5，则需要旋转和变色来继续满足红黑树的性质。下面说一说插入的几种情况，约定当前插入结点为N，其父结点为P，叔叔为U，祖父为G</p>
<p>情形1：树空，直接插入违反性质1，将红色改黑。</p>
<p>情形2：N的父结点为黑，不必修改，直接插入</p>
<p>从情形3开始的情形假定N结点的父结点P为红色，所以存在G，并且G为黑色。且N存在一个叔叔结点U，尽管U可能为叶结点。</p>
<p>情形3：P为红，U为红（G结点一定存在且为黑）这里不论P是G的左孩子还是右孩子；不论N是P的左孩子还是右孩子。</p>
<p>首先把P、U改黑，G改红，并以G作为一个新插入的红结点重新进行各种情况的检查，若一路检索至根节点还未结束，则将根结点变黑。</p>
<p>情形4：P为红，U为黑或不存在（G结点一定存在且为黑），且P为G的左孩子，N为P的左孩子（或者P为G的右孩子，N为P的右孩子，保证同向的）。<br>P、G右旋并将P、G变相反色。因为P取代之前黑G的位置，所以P变黑可以理解，而G变红是为了不违反性质5。</p>
<p>情形5：P为红，U为黑或不存在，且P为G的左孩子，N为P的右孩子（或P为G的右孩子，N为P的左孩子，保证是反向的），对N，P进行一次左旋转换为情形4</p>
<p>删除操作比插入复杂一些，但最多不超过三次旋转可以让红黑树恢复平衡。</p>
<p>其他</p>
<ul>
<li>黑高从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。红黑树的黑高为其根结点的黑高。</li>
<li>一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1)</li>
<li>结点的属性(五元组):color key left right p</li>
<li>动态集合操作最坏时间复杂度为O(lgn)</li>
</ul>
<p>3.数据库索引的实现</p>
<p>数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>B树：</p>
<p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录。那么B-Tree是满足下列条件的数据结构：</p>
<ol>
<li><p>d为大于1的一个正整数，称为B-Tree的度。用来表示每个结点包含的关键字个数的上界和下界。可以证明h&lt;=logd((N+1)/2)</p>
</li>
<li><p>h为一个正整数，称为B-Tree的高度。</p>
</li>
<li><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
</li>
<li><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
</li>
<li><p>所有叶节点具有相同的深度，等于树高h。</p>
</li>
<li><p>key和指针互相间隔，节点两端是指针。</p>
</li>
<li><p>一个节点中的key从左到右非递减排列。</p>
</li>
<li><p>所有节点组成树结构。</p>
</li>
<li><p>每个指针要么为null，要么指向另外一个节点。</p>
</li>
<li><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</p>
</li>
<li><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p>
</li>
<li><p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。</p>
</li>
</ol>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。</p>
<p>一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>B+树：</p>
<p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>B+树是B树的变形，它把所有的data都放在叶子结点中，只将关键字和子女指针保存于内结点，内结点完全是索引的功能。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>1、每个节点的指针上限为2d而不是2d+1。</p>
<p>2、内节点不存储data，只存储key；叶子节点存储data不存储指针。</p>
<p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针</p>
<p>例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<p>为什么B树（B+树）？</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<p>这涉及到磁盘存取原理、局部性原理和磁盘预读。</p>
<p>先从B-Tree分析，根据B-Tree的定义，<strong>可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</strong>为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p><strong>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</strong></p>
<p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</strong></p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>至于B+Tree为什么更适合外存索引，原因和内节点出度d有关。</p>
<p>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>4.一致性Hash</p>
<p>第一：简单介绍<br>一致性哈希算法是分布式系统中常用的算法。比如，一个分布式的存储系统，要将对象存储到具体的节点上，如果采用普通的hash方法，将数据映射到具体的节点上，如key%N，N是机器节点数。</p>
<p>1、考虑到比如一个服务器down掉，服务器结点N变为N-1，映射公式必须变为key%(N-1)</p>
<p>2、访问量加重，需要添加服务器结点，N变为N+1，映射公式变为hash(object)%(N+1)</p>
<p>当出现1,2的情况意味着我们的映射都将无效，对服务器来说将是一场灾难，尤其是对缓存服务器来说，因为缓存服务器映射的失效，洪水般的访问都将冲向后台服务器。</p>
<p>第二点：hash算法的单调性</p>
<p>Hash 算法的一个衡量指标是单调性，单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p>
<p>consistent hash 也是一种hash 算法，简单的说，在移除 / 添加一个结点时，它能够尽可能小的改变已存在的映射关系，尽可能的满足单调性的要求。</p>
<p>第三点：将对象和服务器结点分别映射到环型空间</p>
<p>通常的一致性哈希做法是将 value 映射到一个 32 位的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环。</p>
<p>我们可以通过hash函数将我们的key映射到环型空间中，同时根据相同的哈希算法把服务器也映射到环型空间中，顺便提一下服务器或者某个计算节点的 hash 计算，一般的方法可以使用机器的 IP 地址或者机器名作为 hash 输入。</p>
<p>第四点：将对象映射到服务器</p>
<p>在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 服务器结点，那么就将该对象存储在这个服务器结点上，因为对象和服务器的hash 值是固定的，因此这个 cache 必然是唯一和确定的。</p>
<p>这时候考察某个服务器down机或者需要添加服务器结点，也就是移除和添加的操作，我们只需要几个对象的映射。</p>
<p>第五点：虚拟结点</p>
<p> Hash 算法的另一个指标是平衡性 (Balance)。平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p>
<p> 对于上述的做法，可能导致某些对象都映射到某个服务器，使得分布不平衡。为此可以采用“虚拟结点”的做法。</p>
<p> “虚拟结点”（ virtual node ）是实际节点在 hash 空间的复制品，一实际结点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。引入“虚拟结点”会让我们的映射分布更为平衡一些。</p>
<p>引入“虚拟结点”前：<br>Hash(“192.168.1.1”);</p>
<p>引入“虚拟结点”后：<br>Hash(“192.168.1.1#1”);<br>Hash(“192.168.1.1#2”);</p>
<h3 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h3><p>1、解析XML</p>
<p>DOM、SAX、JDOM、DOM4J</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> DOM DOM树驻留内存</li>
</ul>
<p>可以进行修改和写入,耗费内存。</p>
<p>步骤：创建DocumentBuilderFactory对象 -&gt; 创建DocumentBuilder对象 -&gt; Document document = db.parse(“xml”)</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> SAX 事件驱动模式</li>
</ul>
<p>获取一个SAXParserFactory工厂的实例 -&gt; 根据该实例获取SAXParser -&gt; 创建Handler对象 -&gt; 调用SAXParser的parse方法解析</p>
<p>用于读取节点数据 不易编码 事件有顺序 很难同时访问xml的多处数据</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> JDOM</li>
</ul>
<p>创建一个SAXBuilder的对象 -&gt; 创建一个输入流，加载xml文件 -&gt;通过saxBuilder的build方法将输入流加载至saxBuilder并接收Document对象</p>
<p>使用具体类而不使用接口</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> DOM4J</li>
</ul>
<p>通过SAXReader的read方法加载xml文件并获取document对象</p>
<p>使用接口和抽象类，灵活性好，功能强大</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.开源软件有哪些？</p>
<p>Eclipse、Linux及其Linux下的大多数软件、Git等。</p>
<p>Apache下的众多软件：Lucene、Velocity、Maven、高性能Java网络框架MINA、版本控制系统SVN、应用服务器Tomcat、Http服务器Apache、MVC框架Struts、持久层框架iBATIS、Apache SPARK、ActiveMQ</p>
<p>2.开源协议</p>
<p>MIT：相对宽松。适用：JQuery</p>
<p>Apache：相对宽松与MIT类似的协议，考虑有专利的情况。适用：Apache服务器、SVN</p>
<p>GPL：GPLV2和GPLV3，如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p>
<p>LGPL：主要用于一些代码库。衍生代码可以以此协议发布（言下之意你可以用其他协议），但与此协议相关的代码必需遵循此协议。</p>
<p>BSD：较为宽松的协议，包含两个变种BSD 2-Clause 和BSD 3-Clause，两者都与MIT协议只存在细微差异。</p>
<p>上面各协议只是针对软件或代码作品，如果你的作品不是代码，比如视频，音乐，图片，文章等，共享于公众之前，也最好声明一下协议以保证自己的权益不被侵犯，CC协议。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/ThreadLocal%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/ThreadLocal%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">ThreadLocal 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:44:43 / 修改时间：11:52:23" itemprop="dateCreated datePublished" datetime="2020-05-31T11:44:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ThreadLocal-概述"><a href="#ThreadLocal-概述" class="headerlink" title="ThreadLocal 概述"></a>ThreadLocal 概述</h4><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而且只有在指定的线程里才能获取到存储的数据，对于其他线程来说是获取不到的。ThreadLocal适用于变量在线程间隔离而在方法或类间共享的场景。</p>
<h4 id="ThreadLocal维护线程与实例的映射"><a href="#ThreadLocal维护线程与实例的映射" class="headerlink" title="ThreadLocal维护线程与实例的映射"></a>ThreadLocal维护线程与实例的映射</h4><p>一个可能的方案是ThreadLocal维护一个Map，键是Thread，值是它在该Thread内的实例。线程通过该ThreadLocal的get()方案获取实例时，只需要以线程为键，从Map中找出对应的实例即可。</p>
<p>这里存在两个问题：</p>
<ul>
<li>需要加锁来保证Map在线程的安全性；</li>
<li>线程结束时，需要保证它所访问的所有ThreadLocal中对应的映射均删除，否则可能会引起内存泄漏。</li>
</ul>
<h4 id="Thread维护ThreadLocal与实例的映射"><a href="#Thread维护ThreadLocal与实例的映射" class="headerlink" title="Thread维护ThreadLocal与实例的映射"></a>Thread维护ThreadLocal与实例的映射</h4><p>上述方案中，出现锁的问题，原因在于多线程访问同一个Map。如果该Map由Thread维护，从而使得每个Thread只访问自己的Map，那就不存在多线程写的问题，也就不需要锁。</p>
<p>该方案虽然没有锁的问题，但是由于每个线程访问某ThreadLocal变量后，都会在自己的Map内维护该ThreadLocal变量与具体实例的映射，如果不删除这些引用（映射），则这些ThreadLocal不能被回收，可能会造成内存泄漏。</p>
<h4 id="ThreadLocal在JDK-8中的实现"><a href="#ThreadLocal在JDK-8中的实现" class="headerlink" title="ThreadLocal在JDK 8中的实现"></a>ThreadLocal在JDK 8中的实现</h4><h5 id="ThreadLocalMap与内存泄漏"><a href="#ThreadLocalMap与内存泄漏" class="headerlink" title="ThreadLocalMap与内存泄漏"></a>ThreadLocalMap与内存泄漏</h5><p>该方案中，Map由ThreadLocal类的静态内部类ThreadLocalMap提供。该类的实例维护某个 ThreadLocal 与具体实例的映射。与 HashMap 不同的是，ThreadLocalMap 的每个 Entry 都是一个对键的弱引用，这一点从super(k)可看出。另外，每个 Entry 都包含了一个对值的强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">    private static final int INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line">    private Entry[] table;</span><br><span class="line"></span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用弱引用的原因在于，当没有强引用指向 ThreadLocal 变量时，它可被回收，从而避免上文所述 ThreadLocal 不能被回收而造成的内存泄漏的问题。</p>
<p>但是，这里又可能出现另外一种内存泄漏的问题。ThreadLocalMap 维护 ThreadLocal 变量与具体实例的映射，当 ThreadLocal 变量被回收后，该映射的键变为 null，该 Entry 无法被移除。从而使得实例被该 Entry 引用而无法被回收造成内存泄漏。</p>
<p>注：Entry虽然是弱引用，但它是 ThreadLocal 类型的弱引用（也即上文所述它是对键的弱引用），而非具体实例的的弱引用，所以无法避免具体实例相关的内存泄漏。</p>
<h5 id="读取实例"><a href="#读取实例" class="headerlink" title="读取实例"></a>读取实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            (&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e &#x3D; table[i];</span><br><span class="line">    if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    &#x2F;&#x2F; initialValue()方法可被重写</span><br><span class="line">    T value &#x3D; initialValue();</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap是 Thread 类的一个字段，即由 Thread 维护 ThreadLocal 对象与具体实例的映射。读取实例时，线程首先通过getMap(t)方法获取自身的 ThreadLocalMap。</p>
<p>获取到 ThreadLocalMap 后，通过map.getEntry(this)方法获取该 ThreadLocal 在当前线程的 ThreadLocalMap 中对应的 Entry。</p>
<p>如果获取到的 Entry 不为 null，从 Entry 中取出值即为所需访问的本线程对应的实例。如果获取到的 Entry 为 null，则通过setInitialValue()方法设置该 ThreadLocal 变量在该线程中对应的具体实例的初始值。</p>
<h5 id="设置实例"><a href="#设置实例" class="headerlink" title="设置实例"></a>设置实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法先获取该线程的 ThreadLocalMap 对象，然后直接将 ThreadLocal 对象（即代码中的 this）与目标实例的映射添加进 ThreadLocalMap 中。如果映射已经存在，就直接覆盖。如果获取到的 ThreadLocalMap 为 null，则先创建该 ThreadLocalMap 对象。</p>
<h5 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h5><p>对于已经不再被使用且已被回收的 ThreadLocal 对象，它在每个线程内对应的实例由于被线程的 ThreadLocalMap 的 Entry 强引用，无法被回收，可能会造成内存泄漏。</p>
<p>针对该问题，ThreadLocalMap 的 set 方法中，通过 replaceStaleEntry 方法将所有键为 null 的 Entry 的值设置为 null，从而使得该值可被回收。另外，会在 rehash 方法中通过 expungeStaleEntry 方法将键和值为 null 的 Entry 设置为 null 从而使得该 Entry 可被回收。通过这种方式，ThreadLocal 可防止内存泄漏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len-1);</span><br><span class="line"></span><br><span class="line">    for (Entry e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private static final int THREAD_NUM &#x3D; 3;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(THREAD_NUM);</span><br><span class="line">        ThreadLocalHelper localHelper &#x3D; new ThreadLocalHelper();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                localHelper.add(&quot;My &quot;);</span><br><span class="line">                localHelper.print();</span><br><span class="line">                localHelper.add(&quot;name &quot;);</span><br><span class="line">                localHelper.print();</span><br><span class="line">                localHelper.add(&quot;is &quot;);</span><br><span class="line">                localHelper.print();</span><br><span class="line">                localHelper.add(&quot;hearing&quot;);</span><br><span class="line">                localHelper.print();</span><br><span class="line">                localHelper.set(&quot;Hello World!&quot;);</span><br><span class="line">                localHelper.print();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, &quot;thread-&quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ThreadLocalHelper &#123;</span><br><span class="line">        public void add(String s) &#123;</span><br><span class="line">            StringBuilder stringBuilder &#x3D; ThreadLocalHolder.sThreadLocal.get();</span><br><span class="line">            ThreadLocalHolder.sThreadLocal.set(stringBuilder &#x3D;&#x3D; null ? new StringBuilder(s) : stringBuilder.append(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void set(String s) &#123;</span><br><span class="line">            ThreadLocalHolder.sThreadLocal.set(new StringBuilder(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.printf(&quot;Thread: %s, ThreadLocal: %s, Value hash: %s, Value: %s\n&quot;,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    ThreadLocalHolder.sThreadLocal.hashCode(),</span><br><span class="line">                    ThreadLocalHolder.sThreadLocal.get().hashCode(),</span><br><span class="line">                    ThreadLocalHolder.sThreadLocal.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ThreadLocalHolder &#123;</span><br><span class="line">        private static ThreadLocal&lt;StringBuilder&gt; sThreadLocal &#x3D; new ThreadLocal&lt;StringBuilder&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            protected StringBuilder initialValue() &#123;</span><br><span class="line">                return new StringBuilder();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread: thread-1, ThreadLocal: 1917401118, Value hash: 968353463, Value: My</span><br><span class="line">Thread: thread-1, ThreadLocal: 1917401118, Value hash: 968353463, Value: My name</span><br><span class="line">Thread: thread-1, ThreadLocal: 1917401118, Value hash: 968353463, Value: My name is</span><br><span class="line">Thread: thread-1, ThreadLocal: 1917401118, Value hash: 968353463, Value: My name is hearing</span><br><span class="line">Thread: thread-1, ThreadLocal: 1917401118, Value hash: 322612362, Value: Hello World!</span><br><span class="line">Thread: thread-2, ThreadLocal: 1917401118, Value hash: 360097141, Value: My</span><br><span class="line">Thread: thread-2, ThreadLocal: 1917401118, Value hash: 360097141, Value: My name</span><br><span class="line">Thread: thread-0, ThreadLocal: 1917401118, Value hash: 2089736231, Value: My</span><br><span class="line">Thread: thread-2, ThreadLocal: 1917401118, Value hash: 360097141, Value: My name is</span><br><span class="line">Thread: thread-0, ThreadLocal: 1917401118, Value hash: 2089736231, Value: My name</span><br><span class="line">Thread: thread-2, ThreadLocal: 1917401118, Value hash: 360097141, Value: My name is hearing</span><br><span class="line">Thread: thread-0, ThreadLocal: 1917401118, Value hash: 2089736231, Value: My name is</span><br><span class="line">Thread: thread-2, ThreadLocal: 1917401118, Value hash: 464607659, Value: Hello World!</span><br><span class="line">Thread: thread-0, ThreadLocal: 1917401118, Value hash: 2089736231, Value: My name is hearing</span><br><span class="line">Thread: thread-0, ThreadLocal: 1917401118, Value hash: 2024887150, Value: Hello World!</span><br></pre></td></tr></table></figure>
<p>从上面的输出可看出：</p>
<ul>
<li>每个线程所访问到的是同一个ThreadLocal变量；</li>
<li>每个线程通过ThreadLocal的get()方法拿到的是不同的StringBuilder实例；</li>
<li>虽然从代码上都是对ThreadLocalHolder类的静态sThreadLocal字段进行get()得到StringBuilder实例并追加字符串，但是实际上每个线程都是操作各自的StringBuidler实例；</li>
<li>使用set(T t)方法后，ThreadLocal变量所指向的StringBuilder实例被替换。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>ThreadLocal隐式地在不同线程内创建独立实例副本避免了实例线程安全的问题；</li>
<li>每个线程持有一个Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题；</li>
<li>ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题；</li>
<li>ThreadLocalMap的set方法回收键为null的Entry对象的值（即为具体实例）以及Entry对象本身从而防止内存泄漏；</li>
<li>ThreadLocal适用于变量在线程间隔离且在方法间共享的场景。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Volley源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:26:01 / 修改时间：11:35:52" itemprop="dateCreated datePublished" datetime="2020-05-31T11:26:01+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>本文基于Volley 1.1.1版本的源码。</p>
<p>Volley是Google官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持HttpClient、HttpUrlConnection，甚至支持OkHttp。Volley不适用于下载大量内容的操作或流式传输操作，因为在解析过程中，Volley会将所有响应存储在内存中，因此Volley不适合上传和下载大文件。</p>
<p>添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.android.volley:volley:1.1.1&#39;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue queue &#x3D; Volley.newRequestQueue(context);</span><br><span class="line">String url &#x3D;&quot;http:&#x2F;&#x2F;www.google.com&quot;;</span><br><span class="line"></span><br><span class="line">StringRequest stringRequest &#x3D; new StringRequest(Request.Method.GET, url,</span><br><span class="line">            new Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    public void onResponse(String response) &#123;</span><br><span class="line">        &#x2F;&#x2F; in UI Thread</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, new Response.ErrorListener() &#123;</span><br><span class="line">    </span><br><span class="line">    public void onErrorResponse(VolleyError error) &#123;</span><br><span class="line">        &#x2F;&#x2F; in UI Thread</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">stringRequest.setTag(TAG);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Add the request to the RequestQueue.</span><br><span class="line">queue.add(stringRequest);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; onStop</span><br><span class="line">queue.cancelAll(TAG);</span><br></pre></td></tr></table></figure>

<h5 id="创建请求队列"><a href="#创建请求队列" class="headerlink" title="创建请求队列"></a>创建请求队列</h5><p>Volley类中有多个重载的newRequestQueue静态方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Volley &#123;</span><br><span class="line">    private static final String DEFAULT_CACHE_DIR &#x3D; &quot;volley&quot;;</span><br><span class="line"></span><br><span class="line">    public static RequestQueue newRequestQueue(Context context) &#123;</span><br><span class="line">        return newRequestQueue(context, (BaseHttpStack) null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123;</span><br><span class="line">        BasicNetwork network;</span><br><span class="line">        if (stack &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;&#x3D; 9) &#123;</span><br><span class="line">                network &#x3D; new BasicNetwork(new HurlStack());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            network &#x3D; new BasicNetwork(stack);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return newRequestQueue(context, network);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static RequestQueue newRequestQueue(Context context, Network network) &#123;</span><br><span class="line">        final Context appContext &#x3D; context.getApplicationContext();</span><br><span class="line">        DiskBasedCache.FileSupplier cacheSupplier &#x3D;</span><br><span class="line">                new DiskBasedCache.FileSupplier() &#123;</span><br><span class="line">                    private File cacheDir &#x3D; null;</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                    public File get() &#123;</span><br><span class="line">                        if (cacheDir &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            cacheDir &#x3D; new File(appContext.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return cacheDir;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">        RequestQueue queue &#x3D; new RequestQueue(new DiskBasedCache(cacheSupplier), network);</span><br><span class="line">        queue.start();</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestQueue类构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class RequestQueue &#123;</span><br><span class="line">    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE &#x3D; 4;</span><br><span class="line">    private final Cache mCache;</span><br><span class="line">    private final Network mNetwork;</span><br><span class="line">    private final ResponseDelivery mDelivery;</span><br><span class="line">    private final NetworkDispatcher[] mDispatchers;</span><br><span class="line">    private CacheDispatcher mCacheDispatcher;</span><br><span class="line"></span><br><span class="line">    public RequestQueue(</span><br><span class="line">            Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) &#123;</span><br><span class="line">        mCache &#x3D; cache;</span><br><span class="line">        mNetwork &#x3D; network;</span><br><span class="line">        mDispatchers &#x3D; new NetworkDispatcher[threadPoolSize];</span><br><span class="line">        mDelivery &#x3D; delivery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</span><br><span class="line">        this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestQueue(Cache cache, Network network) &#123;</span><br><span class="line">        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestQueue#start()方法如下，可以看出就是启动了一个Cache Dispatcher和指定数目的Network Dispatcher：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Starts the dispatchers in this queue. *&#x2F;</span><br><span class="line">public void start() &#123;</span><br><span class="line">    &#x2F;&#x2F; Make sure any currently running dispatchers are stopped.</span><br><span class="line">    stop();</span><br><span class="line">    &#x2F;&#x2F; Create the cache dispatcher and start it.</span><br><span class="line">    mCacheDispatcher &#x3D; new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create network dispatchers (and corresponding threads) up to the pool size.</span><br><span class="line">    for (int i &#x3D; 0; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher &#x3D; new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] &#x3D; networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** Stops the cache and network dispatchers. *&#x2F;</span><br><span class="line">public void stop() &#123;</span><br><span class="line">    if (mCacheDispatcher !&#x3D; null) &#123;</span><br><span class="line">        mCacheDispatcher.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    for (final NetworkDispatcher mDispatcher : mDispatchers) &#123;</span><br><span class="line">        if (mDispatcher !&#x3D; null) &#123;</span><br><span class="line">            mDispatcher.quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RequestQueue事件"><a href="#RequestQueue事件" class="headerlink" title="RequestQueue事件"></a>RequestQueue事件</h5><p>在RequestQueue类中定义了一些事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public  RequestEvent &#123;</span><br><span class="line">    &#x2F;** The request was added to the queue. *&#x2F;</span><br><span class="line">    public static final int REQUEST_QUEUED &#x3D; 0;</span><br><span class="line">    &#x2F;** Cache lookup started for the request. *&#x2F;</span><br><span class="line">    public static final int REQUEST_CACHE_LOOKUP_STARTED &#x3D; 1;</span><br><span class="line">    &#x2F;** Cache lookup finished for the request and cached response is delivered or request is queued for network dispatching. *&#x2F;</span><br><span class="line">    public static final int REQUEST_CACHE_LOOKUP_FINISHED &#x3D; 2;</span><br><span class="line">    &#x2F;** Network dispatch started for the request. *&#x2F;</span><br><span class="line">    public static final int REQUEST_NETWORK_DISPATCH_STARTED &#x3D; 3;</span><br><span class="line">    &#x2F;** The network dispatch finished for the request and response (if any) is delivered. *&#x2F;</span><br><span class="line">    public static final int REQUEST_NETWORK_DISPATCH_FINISHED &#x3D; 4;</span><br><span class="line">    &#x2F;** All the work associated with the request is finished and request is removed from all the queues. *&#x2F;</span><br><span class="line">    public static final int REQUEST_FINISHED &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface RequestEventListener &#123;</span><br><span class="line">    void onRequestEvent(Request&lt;?&gt; request, @RequestEvent int event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final List&lt;RequestEventListener&gt; mEventListeners &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">可以通过下面几个方法操作这些事件：</span><br><span class="line"></span><br><span class="line">void sendRequestEvent(Request&lt;?&gt; request, @RequestEvent int event) &#123;</span><br><span class="line">    synchronized (mEventListeners) &#123;</span><br><span class="line">        for (RequestEventListener listener : mEventListeners) &#123;</span><br><span class="line">            listener.onRequestEvent(request, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addRequestEventListener(RequestEventListener listener) &#123;</span><br><span class="line">    synchronized (mEventListeners) &#123;</span><br><span class="line">        mEventListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void removeRequestEventListener(RequestEventListener listener) &#123;</span><br><span class="line">    synchronized (mEventListeners) &#123;</span><br><span class="line">        mEventListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h5><p>RequestQueue#add()方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger mSequenceGenerator &#x3D; new AtomicInteger();</span><br><span class="line">private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue &#x3D; new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">private final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue &#x3D; new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123;</span><br><span class="line">    &#x2F;&#x2F; Tag the request as belonging to this queue and add it to the set of current requests.</span><br><span class="line">    request.setRequestQueue(this);</span><br><span class="line">    synchronized (mCurrentRequests) &#123;</span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Process requests in the order they are added.</span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(&quot;add-to-queue&quot;);</span><br><span class="line">    sendRequestEvent(request, RequestEvent.REQUEST_QUEUED);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果请求不需要缓存的话，直接交给网络请求队列去执行，默认是需要缓存的</span><br><span class="line">    if (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        return request;</span><br><span class="line">    &#125;</span><br><span class="line">    mCacheQueue.add(request);</span><br><span class="line">    return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中把请求交给了缓存队列或者网络队列去处理。</p>
<h5 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h5><p>CacheDispatcher继承自Thread，在RequestQueue#start()方法中已经将其启动了，因此直接看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">public class CacheDispatcher extends Thread &#123;</span><br><span class="line">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;</span><br><span class="line">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;</span><br><span class="line">    private final Cache mCache;</span><br><span class="line">    private final ResponseDelivery mDelivery;</span><br><span class="line">    private volatile boolean mQuit &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Manage list of waiting requests and de-duplicate requests with same cache key. *&#x2F;</span><br><span class="line">    private final WaitingRequestManager mWaitingRequestManager;</span><br><span class="line"></span><br><span class="line">    public CacheDispatcher(</span><br><span class="line">            BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue,</span><br><span class="line">            BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</span><br><span class="line">            Cache cache,</span><br><span class="line">            ResponseDelivery delivery) &#123;</span><br><span class="line">        mCacheQueue &#x3D; cacheQueue;</span><br><span class="line">        mNetworkQueue &#x3D; networkQueue;</span><br><span class="line">        mCache &#x3D; cache;</span><br><span class="line">        mDelivery &#x3D; delivery;</span><br><span class="line">        mWaitingRequestManager &#x3D; new WaitingRequestManager(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void quit() &#123;</span><br><span class="line">        mQuit &#x3D; true;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Make a blocking call to initialize the cache.</span><br><span class="line">        mCache.initialize();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                processRequest();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; We may have been interrupted because it was time to quit.</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                VolleyLog.e(&quot;Ignoring spurious interrupt of CacheDispatcher thread; &quot; + &quot;use quit() to terminate it&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processRequest() throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 阻塞式队列</span><br><span class="line">        final Request&lt;?&gt; request &#x3D; mCacheQueue.take();</span><br><span class="line">        processRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123;</span><br><span class="line">        request.addMarker(&quot;cache-queue-take&quot;);</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_STARTED);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; If the request has been canceled, don&#39;t bother dispatching it.</span><br><span class="line">            if (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(&quot;cache-discard-canceled&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Attempt to retrieve this item from cache.</span><br><span class="line">            Cache.Entry entry &#x3D; mCache.get(request.getCacheKey());</span><br><span class="line">            if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">                request.addMarker(&quot;cache-miss&quot;);</span><br><span class="line">                &#x2F;&#x2F; Cache miss; send off to the network dispatcher.</span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If it is completely expired, just send it to the network.</span><br><span class="line">            if (entry.isExpired()) &#123;</span><br><span class="line">                request.addMarker(&quot;cache-hit-expired&quot;);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; We have a cache hit; parse its data for delivery back to the request.</span><br><span class="line">            request.addMarker(&quot;cache-hit&quot;);</span><br><span class="line">            Response&lt;?&gt; response &#x3D; request.parseNetworkResponse(new NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">            request.addMarker(&quot;cache-hit-parsed&quot;);</span><br><span class="line"></span><br><span class="line">            if (!response.isSuccess()) &#123;</span><br><span class="line">                request.addMarker(&quot;cache-parsing-failed&quot;);</span><br><span class="line">                mCache.invalidate(request.getCacheKey(), true);</span><br><span class="line">                request.setCacheEntry(null);</span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!entry.refreshNeeded()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 缓存不需要刷新，直接交给ResponseDelivery去处理</span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 软过期的缓存命中，可以分发缓存的response，但是我们还需要将请求发送到网络以进行刷新。</span><br><span class="line">                request.addMarker(&quot;cache-hit-refresh-needed&quot;);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                &#x2F;&#x2F; Mark the response as intermediate.</span><br><span class="line">                response.intermediate &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将intermediate响应发回给用户，然后将请求转发到网络。</span><br><span class="line">                    mDelivery.postResponse(</span><br><span class="line">                            request,</span><br><span class="line">                            response,</span><br><span class="line">                            new Runnable() &#123;</span><br><span class="line">                                </span><br><span class="line">                                public void run() &#123;</span><br><span class="line">                                    try &#123;</span><br><span class="line">                                        &#x2F;&#x2F; 如果缓存需要刷新，这个地方还需要再重新请求网络</span><br><span class="line">                                        mNetworkQueue.put(request);</span><br><span class="line">                                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                                        &#x2F;&#x2F; Restore the interrupted status</span><br><span class="line">                                        Thread.currentThread().interrupt();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 该请求已添加到等待请求的列表中，以便在第一个请求返回时从第一个请求接收网络响应。</span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            request.sendEvent(RequestQueue.RequestEvent.REQUEST_CACHE_LOOKUP_FINISHED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有缓存，就取出来去处理，没有或者过期等，就加入到网络请求队列中去请求，需要网络请求的有几个地方：</p>
<ul>
<li>请求不需要缓存</li>
<li>请求在缓存中没有找到</li>
<li>请求的缓存过期</li>
<li>请求的缓存需要刷新</li>
</ul>
<h5 id="NetworkDispatcher"><a href="#NetworkDispatcher" class="headerlink" title="NetworkDispatcher"></a>NetworkDispatcher</h5><p>NetworkDispatcher<br>NetworkDispatcher也继承自Thread，它们在RequestQueue#start()方法中已经被启动了，因此直接看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public class NetworkDispatcher extends Thread &#123;</span><br><span class="line">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue;</span><br><span class="line">    private final Network mNetwork;</span><br><span class="line">    private final Cache mCache;</span><br><span class="line">    private final ResponseDelivery mDelivery;</span><br><span class="line">    private volatile boolean mQuit &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public NetworkDispatcher(</span><br><span class="line">            BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</span><br><span class="line">            Network network,</span><br><span class="line">            Cache cache,</span><br><span class="line">            ResponseDelivery delivery) &#123;</span><br><span class="line">        mQueue &#x3D; queue;</span><br><span class="line">        mNetwork &#x3D; network;</span><br><span class="line">        mCache &#x3D; cache;</span><br><span class="line">        mDelivery &#x3D; delivery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void quit() &#123;</span><br><span class="line">        mQuit &#x3D; true;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                processRequest();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; We may have been interrupted because it was time to quit.</span><br><span class="line">                if (mQuit) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                VolleyLog.e(&quot;Ignoring spurious interrupt of NetworkDispatcher thread; &quot; + &quot;use quit() to terminate it&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processRequest() throws InterruptedException &#123;</span><br><span class="line">        Request&lt;?&gt; request &#x3D; mQueue.take();</span><br><span class="line">        processRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void processRequest(Request&lt;?&gt; request) &#123;</span><br><span class="line">        long startTimeMs &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">        request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_STARTED);</span><br><span class="line">        try &#123;</span><br><span class="line">            request.addMarker(&quot;network-queue-take&quot;);</span><br><span class="line"></span><br><span class="line">            if (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(&quot;network-discard-cancelled&quot;);</span><br><span class="line">                request.notifyListenerResponseNotUsable();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 执行网络请求</span><br><span class="line">            NetworkResponse networkResponse &#x3D; mNetwork.performRequest(request);</span><br><span class="line">            request.addMarker(&quot;network-http-complete&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the server returned 304 AND we delivered a response already,</span><br><span class="line">            &#x2F;&#x2F; we&#39;re done -- don&#39;t deliver a second identical response.</span><br><span class="line">            if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                request.finish(&quot;not-modified&quot;);</span><br><span class="line">                request.notifyListenerResponseNotUsable();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Parse the response here on the worker thread.</span><br><span class="line">            Response&lt;?&gt; response &#x3D; request.parseNetworkResponse(networkResponse);</span><br><span class="line">            request.addMarker(&quot;network-parse-complete&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Write to cache if applicable.</span><br><span class="line">            &#x2F;&#x2F; TODO: Only update cache metadata instead of entire record for 304s.</span><br><span class="line">            if (request.shouldCache() &amp;&amp; response.cacheEntry !&#x3D; null) &#123;</span><br><span class="line">                mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                request.addMarker(&quot;network-cache-written&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Post the response back.</span><br><span class="line">            request.markDelivered();</span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">            request.notifyListenerResponseReceived(response);</span><br><span class="line">        &#125; catch (VolleyError volleyError) &#123;</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</span><br><span class="line">            VolleyError volleyError &#x3D; new VolleyError(e);</span><br><span class="line">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">            mDelivery.postError(request, volleyError);</span><br><span class="line">            request.notifyListenerResponseNotUsable();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            request.sendEvent(RequestQueue.RequestEvent.REQUEST_NETWORK_DISPATCH_FINISHED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在NetworkDispatcher中，最主要的就是调用了mNetwork.performRequest(request)执行网络请求，而在Network是个接口，具体实现类是BasicNetwork。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">BasicNetwork</span><br><span class="line">public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</span><br><span class="line">    long requestStart &#x3D; SystemClock.elapsedRealtime();</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            httpResponse &#x3D; mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            &#x2F;&#x2F; return NetworkResponse</span><br><span class="line">        &#125; catch (SocketTimeoutException e) &#123;</span><br><span class="line">            attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            int statusCode;</span><br><span class="line">            if (httpResponse !&#x3D; null) &#123;</span><br><span class="line">                statusCode &#x3D; httpResponse.getStatusCode();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new NoConnectionError(e);</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</span><br><span class="line">            NetworkResponse networkResponse;</span><br><span class="line">            if (responseContents !&#x3D; null) &#123;</span><br><span class="line">                networkResponse &#x3D;</span><br><span class="line">                        new NetworkResponse(</span><br><span class="line">                                statusCode,</span><br><span class="line">                                responseContents,</span><br><span class="line">                                &#x2F;* notModified&#x3D; *&#x2F; false,</span><br><span class="line">                                SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                                responseHeaders);</span><br><span class="line">                if (statusCode &#x3D;&#x3D; HttpURLConnection.HTTP_UNAUTHORIZED</span><br><span class="line">                        || statusCode &#x3D;&#x3D; HttpURLConnection.HTTP_FORBIDDEN) &#123;</span><br><span class="line">                    attemptRetryOnException(</span><br><span class="line">                            &quot;auth&quot;, request, new AuthFailureError(networkResponse));</span><br><span class="line">                &#125; else if (statusCode &gt;&#x3D; 400 &amp;&amp; statusCode &lt;&#x3D; 499) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t retry other client errors.</span><br><span class="line">                    throw new ClientError(networkResponse);</span><br><span class="line">                &#125; else if (statusCode &gt;&#x3D; 500 &amp;&amp; statusCode &lt;&#x3D; 599) &#123;</span><br><span class="line">                    if (request.shouldRetryServerErrors()) &#123;</span><br><span class="line">                        attemptRetryOnException(</span><br><span class="line">                                &quot;server&quot;, request, new ServerError(networkResponse));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new ServerError(networkResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 3xx? No reason to retry.</span><br><span class="line">                    throw new ServerError(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                attemptRetryOnException(&quot;network&quot;, request, new NetworkError());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请求重试</span><br><span class="line">private static void attemptRetryOnException(</span><br><span class="line">        String logPrefix, Request&lt;?&gt; request, VolleyError exception) throws VolleyError &#123;</span><br><span class="line">    RetryPolicy retryPolicy &#x3D; request.getRetryPolicy();</span><br><span class="line">    int oldTimeout &#x3D; request.getTimeoutMs();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        retryPolicy.retry(exception);</span><br><span class="line">    &#125; catch (VolleyError e) &#123;</span><br><span class="line">        request.addMarker(String.format(&quot;%s-timeout-giveup [timeout&#x3D;%s]&quot;, logPrefix, oldTimeout));</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    request.addMarker(String.format(&quot;%s-retry [timeout&#x3D;%s]&quot;, logPrefix, oldTimeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DefaultRetryPolicy implements RetryPolicy &#123;</span><br><span class="line">    </span><br><span class="line">    public void retry(VolleyError error) throws VolleyError &#123;</span><br><span class="line">        mCurrentRetryCount++;</span><br><span class="line">        mCurrentTimeoutMs +&#x3D; (int) (mCurrentTimeoutMs * mBackoffMultiplier);</span><br><span class="line">        if (!hasAttemptRemaining()) &#123;</span><br><span class="line">            throw error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Returns true if this policy has attempts remaining, false otherwise. *&#x2F;</span><br><span class="line">    protected boolean hasAttemptRemaining() &#123;</span><br><span class="line">        return mCurrentRetryCount &lt;&#x3D; mMaxNumRetries;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在BasicNetwork#performRequest()中调用了httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);，这里的mBaseHttpStack就是前面创建RequestQueue时新建的HurlStack和HttpClientStack(@Deprecated，上面RequestQueue的构造函数中还有个新建了HttpClientStack对象的方法，不过已经废弃了，不做解析)。因此在 HttpStack的executeRequest()中就是具体的网络请求。</p>
<p>HurlStack</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HurlStack extends BaseHttpStack &#123;</span><br><span class="line">    </span><br><span class="line">    public HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span><br><span class="line">            throws IOException, AuthFailureError &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个类是使用HttpURLConnection来实现真的的网络请求，可以自定义</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ResponseDelivery"><a href="#ResponseDelivery" class="headerlink" title="ResponseDelivery"></a>ResponseDelivery</h5><p>ResponseDelivery是一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public interface ResponseDelivery &#123;</span><br><span class="line">    &#x2F;** Parses a response from the network or cache and delivers it. *&#x2F;</span><br><span class="line">    void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Parses a response from the network or cache and delivers it. The provided Runnable will be</span><br><span class="line">     * executed after delivery.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable);</span><br><span class="line"></span><br><span class="line">    &#x2F;** Posts an error for the given request. *&#x2F;</span><br><span class="line">    void postError(Request&lt;?&gt; request, VolleyError error);</span><br><span class="line">&#125;</span><br><span class="line">具体实现类是ExecutorDelivery，它保证了客户端调用的回调运行在UI线程：</span><br><span class="line"></span><br><span class="line">public class ExecutorDelivery implements ResponseDelivery &#123;</span><br><span class="line">    private final Executor mResponsePoster;</span><br><span class="line">    &#x2F;&#x2F; 在上面的分析中可以看到这里的handle &#x3D; new Handler(Looper.getMainLooper())</span><br><span class="line">    public ExecutorDelivery(final Handler handler) &#123;</span><br><span class="line">        mResponsePoster &#x3D; new Executor() &#123;</span><br><span class="line">                </span><br><span class="line">                public void execute(Runnable command) &#123;</span><br><span class="line">                    handler.post(command);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ExecutorDelivery(Executor executor) &#123;</span><br><span class="line">        mResponsePoster &#x3D; executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) &#123;</span><br><span class="line">        postResponse(request, response, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(&quot;post-response&quot;);</span><br><span class="line">        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void postError(Request&lt;?&gt; request, VolleyError error) &#123;</span><br><span class="line">        request.addMarker(&quot;post-error&quot;);</span><br><span class="line">        Response&lt;?&gt; response &#x3D; Response.error(error);</span><br><span class="line">        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ResponseDeliveryRunnable implements Runnable &#123;</span><br><span class="line">        private final Request mRequest;</span><br><span class="line">        private final Response mResponse;</span><br><span class="line">        private final Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) &#123;</span><br><span class="line">            mRequest &#x3D; request;</span><br><span class="line">            mResponse &#x3D; response;</span><br><span class="line">            mRunnable &#x3D; runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (&quot;unchecked&quot;)</span><br><span class="line">        </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(&quot;canceled-at-delivery&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这里会调用在创建Request时传入的回调</span><br><span class="line">            if (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(&quot;intermediate-response&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mRequest.finish(&quot;done&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果有需要执行的任务，如前面缓存需要刷新等，就会在这个地方进行调用</span><br><span class="line">            if (mRunnable !&#x3D; null) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Volley中主要的类有这些：</p>
<ul>
<li>Volley: 提供了构建RequestQueue的统一方法，我们也可以不通过Volley类而是自己构建RequestQueue；</li>
<li>RequestQueue: 负责分发请求到不同的请求队列中；</li>
<li>CacheDispatcher: 处理缓存请求；</li>
<li>NetworkDispatcher: 处理网络请求；</li>
<li>ResponseDelivery: 获取请求后进行处理，具体实现类为ExecutorDelivery；</li>
<li>Cache: 缓存接口，具体实现类有DiskBasedCache；</li>
<li>Network: 网络接口，具体实现类有BasicNetwork；</li>
<li>HttpStack: 真正执行请求，具体实现类有HttpClientStack(已废弃)，BaseHttpStack(子类有HurlStack，AdaptedHttpStack等)；</li>
<li>Request: 封装请求信息并处理回调，具体实现类有StringRequest，JsonRequest，ImageRequest等；</li>
<li>NetworkResponse：请求网络时的返回的response；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Kotlin 实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:19:43" itemprop="dateCreated datePublished" datetime="2020-05-31T11:19:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Kotlin-引入-Android-项目"><a href="#Kotlin-引入-Android-项目" class="headerlink" title="Kotlin 引入 Android 项目"></a>Kotlin 引入 Android 项目</h4><p>Kotlin是基于JVM新的编程语言，由 JetBrains 开发，可以编译成java字节码，也可以编译成JavaScript。而JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，也在 Apache 许可下已经开源其Kotlin 编程语言。</p>
<h5 id="一、导入依赖库"><a href="#一、导入依赖库" class="headerlink" title="一、导入依赖库"></a>一、导入依赖库</h5><ul>
<li><p>在工程根目录bulid.grade文件添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version &#x3D; &#39;1.3.21&#39;</span><br><span class="line">    </span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>app或者module工程， bulid.grade文件添加一下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;kotlin-android&#39;</span><br><span class="line">apply plugin: &#39;kotlin-android-extensions&#39;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h5><ul>
<li>Activity 中使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    </span><br><span class="line">    private var mRecyclerView: RecyclerView? &#x3D; null</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 定义静态方法</span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val KEY_FROM: String &#x3D; &quot;key_from&quot;</span><br><span class="line">        const val KEY_SHOW_OPEN_VIEW &#x3D; &quot;key_show_open_view&quot;</span><br><span class="line">        </span><br><span class="line">        fun startActivity(context: Context, from: String, showOpen: Boolean) &#123;</span><br><span class="line">            var intent &#x3D; Intent(context, MainActivity::class.java)</span><br><span class="line">            intent.putExtra(KEY_FROM, from)</span><br><span class="line">            intent.putExtra(KEY_SHOW_OPEN_VIEW, showOpen)</span><br><span class="line">            if (context !is Activity) &#123;</span><br><span class="line">               intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class="line">            &#125;</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        handlerIntent()</span><br><span class="line">        initView()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun handlerIntent() &#123;</span><br><span class="line">        if (intent !&#x3D; null) &#123;</span><br><span class="line">            mFrom &#x3D; intent.getStringExtra(KEY_FROM)</span><br><span class="line">            mShowOpenView &#x3D; intent.getBooleanExtra(KEY_SHOW_OPEN_VIEW, false)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun initView() &#123;</span><br><span class="line">        mRecyclerView &#x3D; findViewById(R.id.recycler_view)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、常用设计模式-Kotlin代码示例"><a href="#三、常用设计模式-Kotlin代码示例" class="headerlink" title="三、常用设计模式 Kotlin代码示例"></a>三、常用设计模式 Kotlin代码示例</h5><h6 id="3-1-单例模式"><a href="#3-1-单例模式" class="headerlink" title="3.1 单例模式"></a>3.1 单例模式</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoRewardHelper</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mInstance = SingletonHolder.mInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> SingletonHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> mInstance = VideoRewardHelper()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-基于RxJava实现观察者模式"><a href="#3-2-基于RxJava实现观察者模式" class="headerlink" title="3.2 基于RxJava实现观察者模式"></a>3.2 基于RxJava实现观察者模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.Observable;</span><br><span class="line">import io.reactivex.subjects.PublishSubject;</span><br><span class="line">import io.reactivex.subjects.Subject;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 基于RxJava的事总线</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 单例模式 &amp; 门面模式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RxBus&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private volatile Subject&lt;T&gt; mSubject;</span><br><span class="line"></span><br><span class="line">    private RxBus() &#123;</span><br><span class="line">        mSubject &#x3D; PublishSubject.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Singleton &#123;</span><br><span class="line">        public static RxBus mInstance &#x3D; new RxBus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RxBus getInstance() &#123;</span><br><span class="line">        return Singleton.mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sendPost(T t) &#123;</span><br><span class="line">        mSubject.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sendComplete() &#123;</span><br><span class="line">        mSubject.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Observable&lt;T&gt; getObservable() &#123;</span><br><span class="line">        return mSubject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-注册"><a href="#1-注册" class="headerlink" title="1. 注册"></a>1. 注册</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Disposable disposable;</span><br><span class="line"></span><br><span class="line">private Observer&lt;StatusInfo&gt; mObserver &#x3D; new Observer&lt;StatusInfo&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        disposable &#x3D; d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(StatusInfo info) &#123;</span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RxBus.getInstance().getObservable().subscribeOn(AndroidSchedulers.mainThread()).subscribe(mObserver);</span><br></pre></td></tr></table></figure>

<h6 id="2-解注册"><a href="#2-解注册" class="headerlink" title="2. 解注册"></a>2. 解注册</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (disposable !&#x3D; null &amp;&amp; !disposable.isDisposed()) &#123;</span><br><span class="line">    XLLog.d(&quot;Rxjava&quot;, &quot;dispose: &quot;);</span><br><span class="line">    disposable.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-普通观察者模式"><a href="#3-3-普通观察者模式" class="headerlink" title="3.3 普通观察者模式"></a>3.3 普通观察者模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">interface CountDownObserver &#123;</span><br><span class="line">    fun onTimer(resource: PostResource)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountDownObservable : Observable&lt;CountDownObserver&gt;() &#123;</span><br><span class="line">    fun onTimer(resource: PostResource) &#123;</span><br><span class="line">        if (mObservers.isNotEmpty()) &#123;</span><br><span class="line">            val observers &#x3D; ArrayList&lt;CountDownObserver&gt;(mObservers)</span><br><span class="line">            for (observer in observers) &#123;</span><br><span class="line">                observer.onTimer(resource)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountDownManager &#123;</span><br><span class="line">    private var mCountDownObservable: CountDownObservable &#x3D; CountDownObservable()</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        var TAG: String &#x3D; &quot;CountDownManager&quot;</span><br><span class="line">        val mInstance &#x3D; SingletonHolder.mInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private object SingletonHolder &#123;</span><br><span class="line">        val mInstance &#x3D; CountDownManager()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun registerCountDownObserver(observer: CountDownObserver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mCountDownObservable.registerObserver(observer)</span><br><span class="line">        &#125; catch (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun unregisterCountDownObserver(observer: CountDownObserver) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mCountDownObservable.unregisterObserver(observer)</span><br><span class="line">        &#125; catch (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun notifyOnTimer(resource: PostResource) &#123;</span><br><span class="line">        mCountDownObservable.onTimer(resource)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用的特性"><a href="#常用的特性" class="headerlink" title="常用的特性"></a>常用的特性</h4><h5 id="一、内联扩展函数"><a href="#一、内联扩展函数" class="headerlink" title="一、内联扩展函数"></a>一、内联扩展函数</h5><ul>
<li>let : 定义的变量在特定的作用域范围内使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object.let &#123;</span><br><span class="line">   &#x2F;&#x2F; 在函数体内使用it替代object对象去访问其公有的属性和方法</span><br><span class="line">   it.todo() </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 另一种用途 判断object为null的操作</span><br><span class="line">object?.let &#123;</span><br><span class="line">   &#x2F;&#x2F; 表示object不为null的条件下，才会去执行let函数体</span><br><span class="line">   it.todo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>with : 将某对象作为函数的参数，在函数块内可以通过 this 指代该对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123;</span><br><span class="line">   val item &#x3D; getItem(position)?: return</span><br><span class="line">   with(item)&#123;</span><br><span class="line">      holder.tvNewsTitle.text &#x3D; StringUtils.trimToEmpty(titleEn)</span><br><span class="line">	   holder.tvNewsSummary.text &#x3D; StringUtils.trimToEmpty(summary)</span><br><span class="line">	   holder.tvExtraInf.text &#x3D; &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>run : run函数实际上可以说是let和with两个函数的结合体，run函数只接收一个lambda函数为参数，以闭包形式返回</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123;</span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">      holder.tvNewsTitle.text &#x3D; StringUtils.trimToEmpty(titleEn)</span><br><span class="line">	   holder.tvNewsSummary.text &#x3D; StringUtils.trimToEmpty(summary)</span><br><span class="line">	   holder.tvExtraInf &#x3D; &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>apply : 整体作用功能和run函数很像，唯一不同点就是它返回的值是对象本身</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply &#123;</span><br><span class="line">    &#x2F;&#x2F;mSectionMetaData不为空的时候操作mSectionMetaData</span><br><span class="line">&#125;?.questionnaire?.apply&#123;</span><br><span class="line">    &#x2F;&#x2F;questionnaire不为空的时候操作questionnaire</span><br><span class="line">&#125;?.section?.apply&#123;</span><br><span class="line">    &#x2F;&#x2F;section不为空的时候操作section</span><br><span class="line">&#125;?.sectionArticle?.apply&#123;</span><br><span class="line">    &#x2F;&#x2F;sectionArticle不为空的时候操作sectionArticle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>also : 适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是let函数最后的返回值是最后一行的返回值而also函数的返回值是返回当前的这个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val result &#x3D; &quot;testLet&quot;.also &#123;</span><br><span class="line">    println(it.length)</span><br><span class="line">    1000</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Glide 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:17:43" itemprop="dateCreated datePublished" datetime="2020-05-31T11:17:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Glide-源码剖析"><a href="#Glide-源码剖析" class="headerlink" title="Glide 源码剖析"></a>Glide 源码剖析</h4><p><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a>是Google出品的一款性能优异的图片加载框架。</p>
<p>依赖库导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">  google()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;</span><br><span class="line">  annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(myFragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .centerCrop()</span><br><span class="line">    .placeholder(R.drawable.loading_spinner)</span><br><span class="line">    .into(myImageView);</span><br></pre></td></tr></table></figure>

<h5 id="对比图片加载框架"><a href="#对比图片加载框架" class="headerlink" title="对比图片加载框架"></a>对比图片加载框架</h5><p>下面我们将会带着以下一些问题深入的剖析源码，去寻找答案。</p>
<ul>
<li>Glide的with方法是如何绑定Activity/Fragment生命周期的？</li>
<li>Glide的网络请求是怎样发出的？</li>
<li>Glide请求完成之后，图片是如何展示的？</li>
<li>Glide的缓存策略是什么样的？</li>
<li>Glide的OOM解决办法？</li>
<li>Glide自定义BitmapTransformation</li>
</ul>
<h6 id="1-with-Context-方法，返回RequestManager"><a href="#1-with-Context-方法，返回RequestManager" class="headerlink" title="1. with(Context)方法，返回RequestManager"></a>1. with(Context)方法，返回RequestManager</h6><p>Glide.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Glide &#123;</span><br><span class="line"></span><br><span class="line">  public static RequestManager with(Context context) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(Activity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(FragmentActivity activity) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(android.app.Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(Fragment fragment) &#123;</span><br><span class="line">        RequestManagerRetriever retriever &#x3D; RequestManagerRetriever.get();</span><br><span class="line">        return retriever.get(fragment);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">**with()**方法重载了5个方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RequestManagerRetriever.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManagerRetriever implements Handler.Callback {<br>    private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();</p>
<pre><code>public static RequestManagerRetriever get() {
    return INSTANCE;
}

public RequestManager get(Context context) {
    if (context == null) {
        throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);
    } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {
        if (context instanceof FragmentActivity) {
            return get((FragmentActivity) context);
        } else if (context instanceof Activity) {
            return get((Activity) context);
        } else if (context instanceof ContextWrapper) {
            return get(((ContextWrapper) context).getBaseContext());
        }
    }

    return getApplicationManager(context);
}

// 生命周期和Application相关连
private RequestManager getApplicationManager(Context context) {
    if (applicationManager == null) {
        synchronized (this) {
            if (applicationManager == null) {
                applicationManager = new RequestManager(context.getApplicationContext(),
                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());
            }
        }
    }
    return applicationManager;
}

// activity.getSupportFragmentManager(),会创建SupportRequestManagerFragment
public RequestManager get(FragmentActivity activity) {
    if (Util.isOnBackgroundThread()) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        FragmentManager fm = activity.getSupportFragmentManager();
        return supportFragmentGet(activity, fm);
    }
}

RequestManager supportFragmentGet(Context context, FragmentManager fm) {
    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);
    // 内部新建ActivityFragmentLifecycle对象
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        // 将SupportRequestManagerFragment的LifeCycle注入到RequestManager
        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
     // 将current.getLifecycle()与 requestManager进行了绑定
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) {
    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        current = pendingSupportRequestManagerFragments.get(fm);
        if (current == null) {
            current = new SupportRequestManagerFragment();
            pendingSupportRequestManagerFragments.put(fm, current);
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}

// activity.getFragmentManager会创建RequestManagerFragment
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public RequestManager get(Activity activity) {
    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        android.app.FragmentManager fm = activity.getFragmentManager();
        return fragmentGet(activity, fm);
    }
}

@TargetApi(Build.VERSION_CODES.HONEYCOMB)
RequestManager fragmentGet(Context context, android.app.FragmentManager fm) {
    RequestManagerFragment current = getRequestManagerFragment(fm);
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {
    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        current = pendingRequestManagerFragments.get(fm);
        if (current == null) {
            current = new RequestManagerFragment();
            pendingRequestManagerFragments.put(fm, current);
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断如果是Application则创建RequestManager绑定Application，否则创建SupportRequestManagerFragment、RequestManagerFragment并将RequestManager与之绑定</span><br><span class="line"></span><br><span class="line">SupportRequestManagerFragment.java</span><br></pre></td></tr></table></figure>
<p>public class SupportRequestManagerFragment extends Fragment {<br>    private RequestManager requestManager;<br>    private final ActivityFragmentLifecycle lifecycle;</p>
<p>  @Override<br>    public void onStart() {<br>        super.onStart();<br>        lifecycle.onStart();<br>    }</p>
<pre><code>@Override
public void onStop() {
    super.onStop();
    lifecycle.onStop();
}

@Override
public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这样SupportRequestManagerFragment就和ActivityFragmentLifecycle进行了绑定管理者Fragment的生命周期</span><br><span class="line">在RequestManager的构造函数中会调用lifecycle.addListener(RequestManager.this);进行绑定。至此整个生命周期的传递过程就形成了。</span><br><span class="line">SupportRequestManagerFragment -&gt; ActivityFragmentLifecycle -&gt; RequestManager -&gt; requestTracker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 2. load()方法,返回DrawableTypeRequest</span><br><span class="line"></span><br><span class="line">RequestManager.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManager implements LifecycleListener {<br>  private final Lifecycle lifecycle;<br>  private final RequestTracker requestTracker;</p>
<pre><code>RequestManager(Context context, final Lifecycle lifecycle, ...) {
    ...
    if (Util.isOnBackgroundThread()) {
        new Handler(Looper.getMainLooper()).post(new Runnable() {
            @Override
            public void run() {
                lifecycle.addListener(RequestManager.this);
            }
        });
    } else {
        lifecycle.addListener(this);
    }
    ...
}

public DrawableTypeRequest&lt;String&gt; load(String string) {
    return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);
}

public DrawableTypeRequest&lt;String&gt; fromString() {
    return loadGeneric(String.class);
}

private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) {
    ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =
            Glide.buildFileDescriptorModelLoader(modelClass, context);
    if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
        throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot;
                + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot;
                + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;);
    }

    return optionsApplier.apply(
            new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
                    glide, requestTracker, lifecycle, optionsApplier));
}

@Override
public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) {
    super.load(model);
    return this;
}

@Override
public void onStart() {
    resumeRequests();
}

@Override
public void onStop() {
    pauseRequests();
}

@Override
public void onDestroy() {
    requestTracker.clearRequests();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DrawableTypeRequest.java</span><br></pre></td></tr></table></figure>
<p>public class DrawableTypeRequest<ModelType> extends DrawableRequestBuilder<ModelType> implements DownloadOptions {<br>    private final ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader;<br>    private final ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader;<br>    private final RequestManager.OptionsApplier optionsApplier;</p>
<pre><code>private static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide,
        ModelLoader&lt;A, InputStream&gt; streamModelLoader,
        ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass,
        Class&lt;R&gt; transcodedClass,
        ResourceTranscoder&lt;Z, R&gt; transcoder) {
    if (streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
        return null;
    }

    if (transcoder == null) {
        transcoder = glide.buildTranscoder(resourceClass, transcodedClass);
    }
    DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,
            resourceClass);
    ImageVideoModelLoader&lt;A&gt; modelLoader = new ImageVideoModelLoader&lt;A&gt;(streamModelLoader,
            fileDescriptorModelLoader);
    return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);
}

DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader,
        ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide,
        RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) {
    super(context, modelClass,
            buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,
                    GlideDrawable.class, null),
            glide, requestTracker, lifecycle);
    this.streamModelLoader = streamModelLoader;
    this.fileDescriptorModelLoader = fileDescriptorModelLoader;
    this.optionsApplier = optionsApplier;
}

public BitmapTypeRequest&lt;ModelType&gt; asBitmap() {
    return optionsApplier.apply(new BitmapTypeRequest&lt;ModelType&gt;(this, streamModelLoader,
            fileDescriptorModelLoader, optionsApplier));
}

public GifTypeRequest&lt;ModelType&gt; asGif() {
    return optionsApplier.apply(new GifTypeRequest&lt;ModelType&gt;(this, streamModelLoader, optionsApplier));
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DrawableRequestBuilder.java</span><br></pre></td></tr></table></figure>
<p>public class DrawableRequestBuilder<ModelType><br>        extends GenericRequestBuilder&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt;<br>        implements BitmapOptions, DrawableOptions {</p>
<pre><code>@Override
public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) {
    super.load(model); //调用其父类GenericRequestBuilder的load函数赋值model变量
    return this;
}

@Override
public Target&lt;GlideDrawable&gt; into(ImageView view) {
    return super.into(view);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">into()方法,返回Target对象</span><br><span class="line"></span><br><span class="line">GenericRequestBuilder.java</span><br></pre></td></tr></table></figure>
<p>public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable {<br>    protected final Glide glide;<br>    protected final Class<TranscodeType> transcodeClass;<br>    protected final RequestTracker requestTracker;<br>    protected final Lifecycle lifecycle;<br>    private GenericRequestBuilder&lt;?, ?, ?, TranscodeType&gt; thumbnailRequestBuilder;</p>
<pre><code>@Override
public Target&lt;GlideDrawable&gt; into(ImageView view) {
    return super.into(view);
}

/**
 * into ImageView 之后，才会去从缓存LruCache&lt;Key, Resource&lt;?&gt;&gt;、弱引用Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt;、磁盘缓存diskCacheService、
 */

public Target&lt;TranscodeType&gt; into(ImageView view) {
    Util.assertMainThread();
    if (view == null) {
        throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;);
    }

    if (!isTransformationSet &amp;&amp; view.getScaleType() != null) {
        switch (view.getScaleType()) {
            case CENTER_CROP:
                applyCenterCrop();
                break;
            case FIT_CENTER:
            case FIT_START:
            case FIT_END:
                applyFitCenter();
                break;
            //$CASES-OMITTED$
            default:
                // Do nothing.
        }
    }

    return into(glide.buildImageViewTarget(view, transcodeClass));
}    

public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) {
    Util.assertMainThread();
    if (target == null) {
        throw new IllegalArgumentException(&quot;You must pass in a non null Target&quot;);
    }
    if (!isModelSet) {
        throw new IllegalArgumentException(&quot;You must first set a model (try #load())&quot;);
    }

    Request previous = target.getRequest();

    if (previous != null) {
        previous.clear();
        requestTracker.removeRequest(previous);
        previous.recycle();
    }

    Request request = buildRequest(target);
    target.setRequest(request);
    lifecycle.addListener(target);
    requestTracker.runRequest(request);

    return target;
}

// 根据是缩略图划分，返回ThumbnailRequestCoordinator、GenericRequest
private Request buildRequest(Target&lt;TranscodeType&gt; target) {
    if (priority == null) {
        priority = Priority.NORMAL;
    }
    return buildRequestRecursive(target, null);
}

private Request buildRequestRecursive(Target&lt;TranscodeType&gt; target, ThumbnailRequestCoordinator parentCoordinator) {
    if (thumbnailRequestBuilder != null) {
        if (isThumbnailBuilt) {
            throw new IllegalStateException(&quot;You cannot use a request as both the main request and a thumbnail, &quot;
                    + &quot;consider using clone() on the request(s) passed to thumbnail()&quot;);
        }
        // Recursive case: contains a potentially recursive thumbnail request builder.
        if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
            thumbnailRequestBuilder.animationFactory = animationFactory;
        }

        if (thumbnailRequestBuilder.priority == null) {
            thumbnailRequestBuilder.priority = getThumbnailPriority();
        }

        if (Util.isValidDimensions(overrideWidth, overrideHeight)
                &amp;&amp; !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                        thumbnailRequestBuilder.overrideHeight)) {
          thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
        }

        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
        // Guard against infinite recursion.
        isThumbnailBuilt = true;
        // Recursively generate thumbnail requests.
        Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
        isThumbnailBuilt = false;
        coordinator.setRequests(fullRequest, thumbRequest);
        return coordinator;
    } else if (thumbSizeMultiplier != null) {
        // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
        ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
        Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
        Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
        coordinator.setRequests(fullRequest, thumbnailRequest);
        return coordinator;
    } else {
        // Base case: no thumbnail.
        return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
    }
}

private Request obtainRequest(Target&lt;TranscodeType&gt; target, float sizeMultiplier, Priority priority,
        RequestCoordinator requestCoordinator) {
    return GenericRequest.obtain(
            loadProvider,
            model,
            signature,
            context,
            priority,
            target,
            sizeMultiplier,
            placeholderDrawable,
            placeholderId,
            errorPlaceholder,
            errorId,
            fallbackDrawable,
            fallbackResource,
            requestListener,
            requestCoordinator,
            glide.getEngine(),
            transformation,
            transcodeClass,
            isCacheable,
            animationFactory,
            overrideWidth,
            overrideHeight,
            diskCacheStrategy);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">网络请求</span><br><span class="line"></span><br><span class="line">RequestTracker.java (Request集合, 负责Request的执行，暂停，取消等等关于图片请求的操作)</span><br></pre></td></tr></table></figure>
<p>public class RequestTracker {<br>    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap&lt;Request, Boolean&gt;());<br>    private final List<Request> pendingRequests = new ArrayList<Request>();<br>    private boolean isPaused;</p>
<pre><code>public void runRequest(Request request) {
    requests.add(request);
    if (!isPaused) {
        request.begin();
    } else {
        pendingRequests.add(request);
    }
}

public void pauseRequests() {
    isPaused = true;
    for (Request request : Util.getSnapshot(requests)) {
        if (request.isRunning()) {
            request.pause();
            pendingRequests.add(request);
        }
    }
}

public void resumeRequests() {
    isPaused = false;
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled() &amp;&amp; !request.isRunning()) {
            request.begin();
        }
    }
    pendingRequests.clear();
}

public void restartRequests() {
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled()) {
            // Ensure the request will be restarted in onResume.
            request.pause();
            if (!isPaused) {
                request.begin();
            } else {
                pendingRequests.add(request);
            }
        }
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GenericRequest.java</span><br></pre></td></tr></table></figure>
<p>public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback,<br>        ResourceCallback {</p>
<pre><code>@Override
public void begin() {
    startTime = LogTime.getLogTime();
    if (model == null) {
        onException(null);
        return;
    }

    status = Status.WAITING_FOR_SIZE;
    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
        onSizeReady(overrideWidth, overrideHeight);
    } else {
        target.getSize(this);
    }

    if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) {
        // 设置Placeholder图片
        target.onLoadStarted(getPlaceholderDrawable());
        // 最终调用view.setImageDrawable(Drawable drawable)
    }
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished run method in &quot; + LogTime.getElapsedMillis(startTime));
    }
}    

@Override
public void onSizeReady(int width, int height) {
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;Got onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));
    }
    if (status != Status.WAITING_FOR_SIZE) {
        return;
    }
    status = Status.RUNNING;

    width = Math.round(sizeMultiplier * width);
    height = Math.round(sizeMultiplier * height);

    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();
    final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);

    if (dataFetcher == null) {
        onException(new Exception(&quot;Failed to load model: \&apos;&quot; + model + &quot;\&apos;&quot;));
        return;
    }
    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished setup for calling load in &quot; + LogTime.getElapsedMillis(startTime));
    }
    loadedFromMemoryCache = true;
    // 开始网络加载图片
    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
            priority, isMemoryCacheable, diskCacheStrategy, this);
    loadedFromMemoryCache = resource != null;
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logV(&quot;finished onSizeReady in &quot; + LogTime.getElapsedMillis(startTime));
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Engine.java</span><br></pre></td></tr></table></figure>
<p>public class Engine implements EngineJobListener,<br>        MemoryCache.ResourceRemovedListener,<br>        EngineResource.ResourceListener {</p>
<pre><code>public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher,
        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,
        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {
    Util.assertMainThread();
    long startTime = LogTime.getLogTime();

    final String id = fetcher.getId();
    // 根据请求key以及width、height一起构成了一个EngineKey, 如果width、height改变了，
    // 则会认为是一个新的Key，会重新缓存。
    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),
            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),
            transcoder, loadProvider.getSourceEncoder());

    // 1.从内存中获取，isMemoryCacheable：是否允许内存缓存策略
    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
        cb.onResourceReady(cached);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);
        }
        return null;
    }

    //2.从activeResources中获取 isMemoryCacheable：是否允许内存缓存策略
    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
        cb.onResourceReady(active);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);
        }
        return null;
    }


    EngineJob current = jobs.get(key);
    if (current != null) {
        current.addCallback(cb);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);
        }
        return new LoadStatus(cb, current);
    }

    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);
    DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,
            transcoder, diskCacheProvider, diskCacheStrategy, priority);
    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);
    jobs.put(key, engineJob);
    engineJob.addCallback(cb);
    engineJob.start(runnable);

    if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);
    }
    return new LoadStatus(cb, engineJob);
}    </code></pre><p>}            </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EngineJob.java</span><br></pre></td></tr></table></figure>
<p>class EngineJob implements EngineRunnable.EngineRunnableManager {</p>
<pre><code>@Override
public void run() {
    if (isCancelled) {
        return;
    }

    Exception exception = null;
    Resource&lt;?&gt; resource = null;
    try {
        resource = decode();
    } catch (OutOfMemoryError e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, &quot;Out Of Memory Error decoding&quot;, e);
        }
        exception = new ErrorWrappingGlideException(e);
    } catch (Exception e) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, &quot;Exception decoding&quot;, e);
        }
        exception = e;
    }

    if (isCancelled) {
        if (resource != null) {
            resource.recycle();
        }
        return;
    }

    if (resource == null) {
        onLoadFailed(exception);
    } else {
        onLoadComplete(resource);
    }
}

/**
 * 优先从磁盘缓存中寻找
 */
private Resource&lt;?&gt; decode() throws Exception {
    if (isDecodingFromCache()) {
        return decodeFromCache();
    } else {
        return decodeFromSource();
    }
}

// 进行网路请求
private Resource&lt;?&gt; decodeFromSource() throws Exception {
    return decodeJob.decodeFromSource();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**DecodeJob.java**</span><br></pre></td></tr></table></figure>
<p>class DecodeJob&lt;A, T, Z&gt; {</p>
<pre><code>public Resource&lt;Z&gt; decodeFromSource() throws Exception {
    // 网络请求
    Resource&lt;T&gt; decoded = decodeSource();
    // 对返回结果进行Encode编码
    return transformEncodeAndTranscode(decoded);
}

private Resource&lt;T&gt; decodeSource() throws Exception {
    Resource&lt;T&gt; decoded = null;
    try {
        // 最终会走到HttpUrlFetcher.loadData返回InputStream
        final A data = fetcher.loadData(priority);
        decoded = decodeFromSourceData(data);
    } finally {
        fetcher.cleanup();
    }
    return decoded;
}

// 此处最终会走到StreamBitmapDecoder的decode方法
// 计算sampleSize、
// Bitmap result = BitmapFactory.decodeStream(is, null, options);
private Resource&lt;T&gt; decodeFromSourceData(A data) throws IOException {
    final Resource&lt;T&gt; decoded;
    decoded = loadProvider.getSourceDecoder().decode(data, width, height);
    return decoded;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**HttpUrlFetcher**</span><br></pre></td></tr></table></figure>
<p>public class HttpUrlFetcher implements DataFetcher<InputStream> {</p>
<pre><code>private HttpURLConnection urlConnection;
private InputStream stream;

@Override
public InputStream loadData(Priority priority) throws Exception {
    return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
}

private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers)
        throws IOException {
    ...
    urlConnection = connectionFactory.build(url);
    for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(2500);
    urlConnection.setReadTimeout(2500);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) { // 200 OK
        return getStreamForSuccessfulRequest(urlConnection);
    } else if (statusCode / 100 == 3) { // 3XX 重定向
        String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);
        if (TextUtils.isEmpty(redirectUrlString)) {
            throw new IOException(&quot;Received empty or null redirect url&quot;);
        }
        URL redirectUrl = new URL(url, redirectUrlString);
        return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    }
    ...
}

private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection) throws IOException {
    ...
    stream = urlConnection.getInputStream();
    return stream;
}    </code></pre><p>}</p>
<p>```</p>
<p><img src="https://img-blog.csdn.net/20170515074139121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRXRoYW5Dbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Glide 执行过程"></p>
<h4 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h4><p><a href="https://blog.csdn.net/u011733020/article/details/52446902" target="_blank" rel="noopener">1. Glide（图片异步加载缓存库）发起request获取resource</a></p>
<p><a href="https://juejin.im/post/5e2109e25188254c257c40c6#heading-42" target="_blank" rel="noopener">2. Android主流三方库源码分析（三、深入理解Glide源码）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Picasso 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:16:36" itemprop="dateCreated datePublished" datetime="2020-05-31T11:16:36+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="Picasso简介"><a href="#Picasso简介" class="headerlink" title="Picasso简介"></a>Picasso简介</h5><p>Picasso是鼎鼎有名的Square公司的一个开源项目，该公司同时开源了许多知名的项目，比如Okhttp，Retrofit，Otto等。Picasso继承了Okhttp的链式调用风格，使得它使用起来非常简单和方便，并且它的设计和实现也很轻量简单，使得整个库的接口数量和体积都很小，因此被很多开发者使用在项目中。下面我们来看一下Picasso的总体设计：</p>
<p><img src="https://img-blog.csdnimg.cn/20190126151924568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rZ2F5cw==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>Picasso是通过服务器来实现的本地缓存并且都是原图，因此如果能根据图片尺寸来控制缓存图片的大小可以进一步降低本地储存的空间和图片处理的开销。(Glide 就是根据不同的图片尺寸来缓存不同的图片)</p>
<h5 id="Picasso-源码剖析"><a href="#Picasso-源码剖析" class="headerlink" title="Picasso 源码剖析"></a>Picasso 源码剖析</h5><h6 id="get、load、with-函数"><a href="#get、load、with-函数" class="headerlink" title="get、load、with 函数"></a>get、load、with 函数</h6><p>Picasso.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">public class Picasso &#123;</span><br><span class="line">  static volatile Picasso singleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单例模式</span><br><span class="line">  public static Picasso get() &#123;</span><br><span class="line">    if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">      synchronized (Picasso.class) &#123;</span><br><span class="line">        if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">          if (PicassoProvider.context &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;context &#x3D;&#x3D; null&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          singleton &#x3D; new Builder(PicassoProvider.context).build();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 构建模式，初始化Picasso关键成员变量</span><br><span class="line">  public static class Builder &#123;</span><br><span class="line">    public Picasso build() &#123;</span><br><span class="line">      Context context &#x3D; this.context;</span><br><span class="line"></span><br><span class="line">      if (downloader &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 图片下载</span><br><span class="line">        downloader &#x3D; new OkHttp3Downloader(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (cache &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 内存缓存</span><br><span class="line">        cache &#x3D; new LruCache(context);</span><br><span class="line">      &#125;</span><br><span class="line">      if (service &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池 (默认开启3个线程, 根据网络WiFi-&gt;4 、4G-&gt;3、 3G-&gt;2, 2G-&gt;1)</span><br><span class="line">        service &#x3D; new PicassoExecutorService();</span><br><span class="line">      &#125;</span><br><span class="line">      if (transformer &#x3D;&#x3D; null) &#123;</span><br><span class="line">        transformer &#x3D; RequestTransformer.IDENTITY;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 记录缓存命中次数、丢失次数等</span><br><span class="line">      Stats stats &#x3D; new Stats(cache);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 分发器</span><br><span class="line">      Dispatcher dispatcher &#x3D; new Dispatcher(context, service, HANDLER, downloader, cache, stats);</span><br><span class="line"></span><br><span class="line">      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</span><br><span class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static final Handler HANDLER &#x3D; new Handler(Looper.getMainLooper()) &#123;</span><br><span class="line">    @Override public void handleMessage(Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case HUNTER_BATCH_COMPLETE: &#123;</span><br><span class="line">          &#x2F;&#x2F; 更新UI界面</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;BitmapHunter&gt; batch &#x3D; (List&lt;BitmapHunter&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            BitmapHunter hunter &#x3D; batch.get(i);</span><br><span class="line">            hunter.picasso.complete(hunter); </span><br><span class="line">            &#x2F;&#x2F; 最终会调用action.complete(result, from);显示图片</span><br><span class="line">            &#x2F;&#x2F; 最终会调到这里：target.setImageDrawable(drawable)</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_GCED: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">            log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), &quot;target got garbage collected&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          action.picasso.cancelExistingRequest(action.getTarget());</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_BATCH_RESUME:</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) List&lt;Action&gt; batch &#x3D; (List&lt;Action&gt;) msg.obj;</span><br><span class="line">          &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">          for (int i &#x3D; 0, n &#x3D; batch.size(); i &lt; n; i++) &#123;</span><br><span class="line">            Action action &#x3D; batch.get(i);</span><br><span class="line">            action.picasso.resumeAction(action);</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; load URL,会创建RequestCreator对象</span><br><span class="line">  public RequestCreator load(@Nullable String path) &#123;</span><br><span class="line">    if (path &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return new RequestCreator(this, null, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (path.trim().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return load(Uri.parse(path));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator load(@Nullable Uri uri) &#123;</span><br><span class="line">    return new RequestCreator(this, uri, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; RequestCreator会在into(ImageView)方法的时候，封装ImageViewAction extends Action</span><br><span class="line">  void enqueueAndSubmit(Action action) &#123;</span><br><span class="line">    Object target &#x3D; action.getTarget();</span><br><span class="line">    if (target !&#x3D; null &amp;&amp; targetToAction.get(target) !&#x3D; action) &#123;</span><br><span class="line">      &#x2F;&#x2F; This will also check we are on the main thread.</span><br><span class="line">      cancelExistingRequest(target);</span><br><span class="line">      targetToAction.put(target, action);</span><br><span class="line">    &#125;</span><br><span class="line">    submit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void submit(Action action) &#123;</span><br><span class="line">    dispatcher.dispatchSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Picasso 的get()方法采用双重检验锁形式获取Picasso单例，在<strong>new Picasso()</strong> 的时候采用Builder构造模式初始化Picasso关键成员变量。主要有<strong>PicassoExecutorService</strong>、<strong>OkHttp3Downloader</strong>、<strong>LruCache</strong>、<strong>Dispatcher</strong>。值得关注的是<strong>PicassoProvider</strong>这个内容提供者，<strong>onCreate</strong>方法的调用是ActivityThread的启动的时候就已经调用了，比Application的初始化要早。像这种获取Context对象黑技术在Leakcanary里面也是一样的。</p>
<p><strong>RequestCreator.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">public class RequestCreator &#123;</span><br><span class="line">  private final Picasso picasso;</span><br><span class="line">  private final Request.Builder data;</span><br><span class="line">  private boolean deferred;</span><br><span class="line"></span><br><span class="line">  RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123;</span><br><span class="line">    this.picasso &#x3D; picasso;</span><br><span class="line">    this.data &#x3D; new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator fit() &#123;</span><br><span class="line">    deferred &#x3D; true;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public RequestCreator placeholder(@NonNull Drawable placeholderDrawable) &#123;</span><br><span class="line">    this.placeholderDrawable &#x3D; placeholderDrawable;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static boolean isMain() &#123;</span><br><span class="line">    return Looper.getMainLooper().getThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void checkMain() &#123;</span><br><span class="line">    if (!isMain()) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Method call should happen from the main thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target) &#123;</span><br><span class="line">    into(target, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void into(ImageView target, Callback callback) &#123;</span><br><span class="line">    long started &#x3D; System.nanoTime();</span><br><span class="line">    checkMain();</span><br><span class="line">    &#x2F;&#x2F; 检查Uri 或者 resourceId是否为空</span><br><span class="line">    if (!data.hasImage()) &#123;  &#x2F;&#x2F; -&gt; uri !&#x3D; null || resourceId !&#x3D; 0</span><br><span class="line">      picasso.cancelRequest(target);</span><br><span class="line">      if (setPlaceholder) &#123;</span><br><span class="line">        setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (deferred) &#123;</span><br><span class="line">      if (data.hasSize()) &#123;  &#x2F;&#x2F; -&gt; targetWidth !&#x3D; 0 || targetHeight !&#x3D; 0</span><br><span class="line">        throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      int width &#x3D; target.getWidth();</span><br><span class="line">      int height &#x3D; target.getHeight();</span><br><span class="line">      if (width &#x3D;&#x3D; 0 || height &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (setPlaceholder) &#123;</span><br><span class="line">          setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">        &#125;</span><br><span class="line">        picasso.defer(target, new DeferredRequestCreator(this, target, callback));</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      data.resize(width, height);  &#x2F;&#x2F; -&gt; this.targetWidth &#x3D; targetWidth; this.targetHeight &#x3D; targetHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; createRequest(started);</span><br><span class="line">    String requestKey &#x3D; createKey(request);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 缓存中存在，则从缓存中获取, 取消请求，返回缓存值</span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      Bitmap bitmap &#x3D; picasso.quickMemoryCacheCheck(requestKey);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        picasso.cancelRequest(target);</span><br><span class="line">        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), &quot;from &quot; + MEMORY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (callback !&#x3D; null) &#123;</span><br><span class="line">          callback.onSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置placeholder</span><br><span class="line">    if (setPlaceholder) &#123;</span><br><span class="line">      setPlaceholder(target, getPlaceholderDrawable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建Action用于网络请求</span><br><span class="line">    Action action &#x3D;</span><br><span class="line">        new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId,</span><br><span class="line">            errorDrawable, requestKey, tag, callback, noFade);</span><br><span class="line"></span><br><span class="line">    picasso.enqueueAndSubmit(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Request createRequest(long started) &#123;</span><br><span class="line">    int id &#x3D; nextId.getAndIncrement();</span><br><span class="line"></span><br><span class="line">    Request request &#x3D; data.build();</span><br><span class="line">    request.id &#x3D; id;</span><br><span class="line">    request.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">    boolean loggingEnabled &#x3D; picasso.loggingEnabled;</span><br><span class="line">    if (loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_MAIN, VERB_CREATED, request.plainId(), request.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request transformed &#x3D; picasso.transformRequest(request);</span><br><span class="line">    if (transformed !&#x3D; request) &#123;</span><br><span class="line">      &#x2F;&#x2F; If the request was changed, copy over the id and timestamp from the original.</span><br><span class="line">      transformed.id &#x3D; id;</span><br><span class="line">      transformed.started &#x3D; started;</span><br><span class="line"></span><br><span class="line">      if (loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_MAIN, VERB_CHANGED, transformed.logId(), &quot;into &quot; + transformed);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return transformed;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RequestCreator</strong>, 在into(ImageView)的时候会进行必要的参数校验，创建Request请求对象，从LruCache缓存中检测是否有已经请求的返回结果，如果有的则直接返回，否则创建ImageViewAction对象后面进行网络请求。<strong>picasso.enqueueAndSubmit(action)</strong> 最终会调到<strong>dispatcher.dispatchSubmit(action);</strong></p>
<p><strong>Dispatcher.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">class Dispatcher &#123;</span><br><span class="line">  final Map&lt;String, BitmapHunter&gt; hunterMap;</span><br><span class="line">  final Map&lt;Object, Action&gt; failedActions;</span><br><span class="line">  final Map&lt;Object, Action&gt; pausedActions;</span><br><span class="line"></span><br><span class="line">  private static class DispatcherHandler extends Handler &#123;</span><br><span class="line">    private final Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">    DispatcherHandler(Looper looper, Dispatcher dispatcher) &#123;</span><br><span class="line">      super(looper);</span><br><span class="line">      this.dispatcher &#x3D; dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void handleMessage(final Message msg) &#123;</span><br><span class="line">      switch (msg.what) &#123;</span><br><span class="line">        case REQUEST_SUBMIT: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performSubmit(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case REQUEST_CANCEL: &#123;</span><br><span class="line">          Action action &#x3D; (Action) msg.obj;</span><br><span class="line">          dispatcher.performCancel(action);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_PAUSE: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performPauseTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case TAG_RESUME: &#123;</span><br><span class="line">          Object tag &#x3D; msg.obj;</span><br><span class="line">          dispatcher.performResumeTag(tag);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，会回调到此处</span><br><span class="line">        case HUNTER_COMPLETE: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performComplete(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_RETRY: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performRetry(hunter);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DECODE_FAILED: &#123;</span><br><span class="line">          BitmapHunter hunter &#x3D; (BitmapHunter) msg.obj;</span><br><span class="line">          dispatcher.performError(hunter, false);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case HUNTER_DELAY_NEXT_BATCH: &#123;</span><br><span class="line">          dispatcher.performBatchComplete();</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case NETWORK_STATE_CHANGE: &#123;</span><br><span class="line">          NetworkInfo info &#x3D; (NetworkInfo) msg.obj;</span><br><span class="line">          dispatcher.performNetworkStateChange(info);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        case AIRPLANE_MODE_CHANGE: &#123;</span><br><span class="line">          dispatcher.performAirplaneModeChange(msg.arg1 &#x3D;&#x3D; AIRPLANE_MODE_ON);</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">          Picasso.HANDLER.post(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">              throw new AssertionError(&quot;Unknown handler message received: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 通过handler发送REQUEST_SUBMIT消息，最终会走到performSubmit(action)</span><br><span class="line">  void dispatchSubmit(Action action) &#123;</span><br><span class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void performSubmit(Action action) &#123;</span><br><span class="line">    performSubmit(action, true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * performSubmit执行过程：</span><br><span class="line">   * 1. 检查action 是否在pausedTags集合中，如果存在则直接替换覆盖</span><br><span class="line">   * 2. 如果action 存在hunterMap中， 则直接attach</span><br><span class="line">   * 3. 创建BitmapHunter，添加到PicassoExecutorService线程池</span><br><span class="line">   *&#x2F;</span><br><span class="line">  void performSubmit(Action action, boolean dismissFailed) &#123;</span><br><span class="line">    if (pausedTags.contains(action.getTag())) &#123;</span><br><span class="line">      pausedActions.put(action.getTarget(), action);</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</span><br><span class="line">            &quot;because tag &#39;&quot; + action.getTag() + &quot;&#39; is paused&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BitmapHunter hunter &#x3D; hunterMap.get(action.getKey());</span><br><span class="line">    if (hunter !&#x3D; null) &#123;</span><br><span class="line">      hunter.attach(action);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (service.isShutdown()) &#123;</span><br><span class="line">      if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), &quot;because shut down&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hunter &#x3D; forRequest(action.getPicasso(), this, cache, stats, action);</span><br><span class="line">    hunter.future &#x3D; service.submit(hunter);</span><br><span class="line">    hunterMap.put(action.getKey(), hunter);</span><br><span class="line">    if (dismissFailed) &#123;</span><br><span class="line">      failedActions.remove(action.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (action.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 创建BitmapHunter对象</span><br><span class="line">   * 1. picasso.getRequestHandlers() 类似于拦截器作用，依次从ResourceRequestHandler、</span><br><span class="line">   * ContactsPhotoRequestHandler、MediaStoreRequestHandler、ContentStreamRequestHandler、</span><br><span class="line">   * AssetRequestHandler、FileRequestHandler、NetworkRequestHandler 调用canHandleRequest方法，判断交给那个Handler处理， 一般的网络图片就是NetworkRequestHandler</span><br><span class="line">   * </span><br><span class="line">   *&#x2F;</span><br><span class="line">  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats,</span><br><span class="line">      Action action) &#123;</span><br><span class="line">    Request request &#x3D; action.getRequest();</span><br><span class="line">    List&lt;RequestHandler&gt; requestHandlers &#x3D; picasso.getRequestHandlers();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Index-based loop to avoid allocating an iterator.</span><br><span class="line">    &#x2F;&#x2F;noinspection ForLoopReplaceableByForEach</span><br><span class="line">    for (int i &#x3D; 0, count &#x3D; requestHandlers.size(); i &lt; count; i++) &#123;</span><br><span class="line">      RequestHandler requestHandler &#x3D; requestHandlers.get(i);</span><br><span class="line">      if (requestHandler.canHandleRequest(request)) &#123;</span><br><span class="line">        return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 网络请求成功会回调到performComplete</span><br><span class="line">  void performComplete(BitmapHunter hunter) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加到Cache缓存</span><br><span class="line">    if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</span><br><span class="line">      cache.set(hunter.getKey(), hunter.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    hunterMap.remove(hunter.getKey());</span><br><span class="line">    batch(hunter);</span><br><span class="line">    if (hunter.getPicasso().loggingEnabled) &#123;</span><br><span class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), &quot;for completion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 网络返回结果，将hunter添加到batch之中，延迟200ms发送HUNTER_DELAY_NEXT_BATCH</span><br><span class="line">  private void batch(BitmapHunter hunter) &#123;</span><br><span class="line">    if (hunter.isCancelled()) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hunter.result !&#x3D; null) &#123;</span><br><span class="line">      hunter.result.prepareToDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    batch.add(hunter);</span><br><span class="line">    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</span><br><span class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知主线程更新UI界面</span><br><span class="line">  void performBatchComplete() &#123;</span><br><span class="line">    List&lt;BitmapHunter&gt; copy &#x3D; new ArrayList&lt;&gt;(batch);</span><br><span class="line">    batch.clear();</span><br><span class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</span><br><span class="line">    logBatch(copy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Dispatcher</strong>分发器的作用就是：调度网络请求，回调返回结果</p>
<p><strong>BitmapHunter.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class BitmapHunter implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">  @Override public void run() &#123;</span><br><span class="line">      ...</span><br><span class="line">      result &#x3D; hunt();</span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        dispatcher.dispatchFailed(this);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 网络请求成功，回调到Dispatcher</span><br><span class="line">        dispatcher.dispatchComplete(this);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Bitmap hunt() throws IOException &#123;</span><br><span class="line">    Bitmap bitmap &#x3D; null;</span><br><span class="line"></span><br><span class="line">    if (shouldReadFromMemoryCache(memoryPolicy)) &#123;</span><br><span class="line">      bitmap &#x3D; cache.get(key);</span><br><span class="line">      if (bitmap !&#x3D; null) &#123;</span><br><span class="line">        stats.dispatchCacheHit();</span><br><span class="line">        loadedFrom &#x3D; MEMORY;</span><br><span class="line">        if (picasso.loggingEnabled) &#123;</span><br><span class="line">          log(OWNER_HUNTER, VERB_DECODED, data.logId(), &quot;from cache&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bitmap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    networkPolicy &#x3D; retryCount &#x3D;&#x3D; 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;</span><br><span class="line">    RequestHandler.Result result &#x3D; requestHandler.load(data, networkPolicy);</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      loadedFrom &#x3D; result.getLoadedFrom();</span><br><span class="line">      exifOrientation &#x3D; result.getExifOrientation();</span><br><span class="line">      bitmap &#x3D; result.getBitmap();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If there was no Bitmap then we need to decode it from the stream.</span><br><span class="line">      if (bitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">        Source source &#x3D; result.getSource();</span><br><span class="line">        try &#123;</span><br><span class="line">          bitmap &#x3D; decodeStream(source, data);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            &#x2F;&#x2F;noinspection ConstantConditions If bitmap is null then source is guranteed non-null.</span><br><span class="line">            source.close();</span><br><span class="line">          &#125; catch (IOException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bitmap !&#x3D; null) &#123;</span><br><span class="line">      if (picasso.loggingEnabled) &#123;</span><br><span class="line">        log(OWNER_HUNTER, VERB_DECODED, data.logId());</span><br><span class="line">      &#125;</span><br><span class="line">      stats.dispatchBitmapDecoded(bitmap);</span><br><span class="line">      if (data.needsTransformation() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">        synchronized (DECODE_LOCK) &#123;</span><br><span class="line">          if (data.needsMatrixTransform() || exifOrientation !&#x3D; 0) &#123;</span><br><span class="line">            bitmap &#x3D; transformResult(data, bitmap, exifOrientation);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (data.hasCustomTransformations()) &#123;</span><br><span class="line">            bitmap &#x3D; applyCustomTransformations(data.transformations, bitmap);</span><br><span class="line">            if (picasso.loggingEnabled) &#123;</span><br><span class="line">              log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), &quot;from custom transformations&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bitmap !&#x3D; null) &#123;</span><br><span class="line">          stats.dispatchBitmapTransformed(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BitmapHunter</strong> 的run方法就是利用OKHttpClient进行网络请求</p>
<p>NetworkRequestHandler.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class NetworkRequestHandler extends RequestHandler &#123;</span><br><span class="line"></span><br><span class="line">  @Override public Result load(Request request, int networkPolicy) throws IOException &#123;</span><br><span class="line">    okhttp3.Request downloaderRequest &#x3D; createRequest(request, networkPolicy);</span><br><span class="line">    Response response &#x3D; downloader.load(downloaderRequest);</span><br><span class="line">    ResponseBody body &#x3D; response.body();</span><br><span class="line"></span><br><span class="line">    if (!response.isSuccessful()) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ResponseException(response.code(), request.networkPolicy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache response is only null when the response comes fully from the network. Both completely</span><br><span class="line">    &#x2F;&#x2F; cached and conditionally cached responses will have a non-null cache response.</span><br><span class="line">    Picasso.LoadedFrom loadedFrom &#x3D; response.cacheResponse() &#x3D;&#x3D; null ? NETWORK : DISK;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Sometimes response content length is zero when requests are being replayed. Haven&#39;t found</span><br><span class="line">    &#x2F;&#x2F; root cause to this but retrying the request seems safe to do so.</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; DISK &amp;&amp; body.contentLength() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      body.close();</span><br><span class="line">      throw new ContentLengthException(&quot;Received response with 0 content-length header.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (loadedFrom &#x3D;&#x3D; NETWORK &amp;&amp; body.contentLength() &gt; 0) &#123;</span><br><span class="line">      stats.dispatchDownloadFinished(body.contentLength());</span><br><span class="line">    &#125;</span><br><span class="line">    return new Result(body.source(), loadedFrom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OkHttp3Downloader.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class OkHttp3Downloader implements Downloader &#123;</span><br><span class="line">  @VisibleForTesting final Call.Factory client;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建磁盘缓存目录</span><br><span class="line">  public OkHttp3Downloader(final Context context) &#123;</span><br><span class="line">    this(Utils.createDefaultCacheDir(context));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull @Override public Response load(@NonNull Request request) throws IOException &#123;</span><br><span class="line">    return client.newCall(request).execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Picasso 缓存策略： 首先从内存缓存 -&gt; OkHttp磁盘缓存 -&gt; 网络请求</strong></p>
<h5 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h5><p><a href="https://www.jianshu.com/p/a5a79d861787" target="_blank" rel="noopener">1. picasso详解及其源码简析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:15:34" itemprop="dateCreated datePublished" datetime="2020-05-31T11:15:34+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、OkHttp-简介"><a href="#一、OkHttp-简介" class="headerlink" title="一、OkHttp 简介"></a>一、OkHttp 简介</h5><p>HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：</p>
<ul>
<li>支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接</li>
<li>连接池减少请求延时</li>
<li>透明的GZIP压缩减少响应数据的大小</li>
<li>缓存响应内容，避免一些完全重复的请求</li>
</ul>
<p>当网络出现问题的时候OkHttp依然坚守自己的职责，它会自动恢复一般的连接问题，如果你的服务有多个IP地址，当第一个IP请求失败时，OkHttp会交替尝试你配置的其他IP，OkHttp使用现代TLS技术(SNI, ALPN)初始化新的连接，当握手失败时会回退到TLS 1.0。</p>
<p>官网链接地址：<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">https://square.github.io/okhttp/</a></p>
<h5 id="二、OkHttp-使用"><a href="#二、OkHttp-使用" class="headerlink" title="二、OkHttp 使用"></a>二、OkHttp 使用</h5><h5 id="2-1-同步请求"><a href="#2-1-同步请求" class="headerlink" title="2.1 同步请求"></a>2.1 同步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line">     </span><br><span class="line">Response response = okHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>

<h5 id="2-2-异步请求"><a href="#2-2-异步请求" class="headerlink" title="2.2 异步请求"></a>2.2 异步请求</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient().newBuilder()</span><br><span class="line">     .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS).build();</span><br><span class="line">     </span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .get().url(<span class="string">"https://www.baidu.com/"</span>).build();</span><br><span class="line"></span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="三、OkHttp-原理剖析"><a href="#三、OkHttp-原理剖析" class="headerlink" title="三、OkHttp 原理剖析"></a>三、OkHttp 原理剖析</h5><p><img src="https://upload-images.jianshu.io/upload_images/692087-b2db5588ceb9d9c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt="OkHttp 结构图"></p>
<h6 id="3-1-OkHttpClient-构建"><a href="#3-1-OkHttpClient-构建" class="headerlink" title="3.1 OkHttpClient 构建"></a>3.1 OkHttpClient 构建</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  builder: Builder</span><br><span class="line">) : Cloneable, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line">    <span class="keyword">val</span> dispatcher: Dispatcher = builder.dispatcher</span><br><span class="line">    <span class="keyword">val</span> connectionPool: ConnectionPool = builder.connectionPool</span><br><span class="line">    <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt; = builder.interceptors.toImmutableList()</span><br><span class="line">    <span class="keyword">val</span> networkInterceptors: List&lt;Interceptor&gt; = builder.networkInterceptors.toImmutableList()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(Builder())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">newBuilder</span><span class="params">()</span></span>: Builder = Builder(<span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> dispatcher: Dispatcher = Dispatcher()</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectionPool: ConnectionPool = ConnectionPool()</span><br><span class="line">        <span class="comment">// 用户定义应用层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()</span><br><span class="line">        <span class="comment">// 用户自定义网络层拦截器</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">val</span> networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()    </span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> connectTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> readTimeout = <span class="number">10_000</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">var</span> writeTimeout = <span class="number">10_000</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">writeTimeout</span><span class="params">(duration: <span class="type">Duration</span>)</span></span> = apply &#123;</span><br><span class="line">            writeTimeout = checkDuration(<span class="string">"timeout"</span>, duration.toMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: OkHttpClient = OkHttpClient(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newCall</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Call &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, forWebSocket = <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OkHttpClient内部采用构建模式，定义了<strong>连接池、分发器、拦截器</strong></p>
<h6 id="3-2-Call-对象"><a href="#3-2-Call-对象" class="headerlink" title="3.2 Call 对象"></a>3.2 Call 对象</h6><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">  <span class="keyword">val</span> client: OkHttpClient,</span><br><span class="line">  <span class="keyword">val</span> originalRequest: Request,</span><br><span class="line">  <span class="keyword">val</span> forWebSocket: <span class="built_in">Boolean</span></span><br><span class="line">) : Call &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> transmitter: Transmitter</span><br><span class="line">  <span class="keyword">var</span> executed: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newRealCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      client: <span class="type">OkHttpClient</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      originalRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      forWebSocket: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: RealCall &#123;</span><br><span class="line">      <span class="keyword">return</span> RealCall(client, originalRequest, forWebSocket).apply &#123;</span><br><span class="line">        transmitter = Transmitter(client, <span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 同步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.timeoutEnter()</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 把当前的RealCall添加到分发器的Deque&lt;RealCall&gt; runningSyncCalls队列中</span></span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="comment">// 开始执行请求</span></span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 请求完成之后，将当前的RealCall从当前正在运行的同步RealCall队列中移除出去</span></span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      check(!executed) &#123; <span class="string">"Already Executed"</span> &#125;</span><br><span class="line">      executed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    transmitter.callStart()</span><br><span class="line">    <span class="comment">// 将异步请求AsyncCall</span></span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> responseCallback: Callback</span><br><span class="line">  ) : Runnable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">executeOn</span><span class="params">(executorService: <span class="type">ExecutorService</span>)</span></span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(client.dispatcher))</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">this</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RejectedExecutionException) &#123;</span><br><span class="line">        <span class="keyword">val</span> ioException = InterruptedIOException(<span class="string">"executor rejected"</span>)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        transmitter.noMoreExchanges(ioException)</span><br><span class="line">        responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, ioException)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>) <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">      threadName(<span class="string">"OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">        transmitter.timeoutEnter()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">          signalledCallback = <span class="literal">true</span></span><br><span class="line">          responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">          <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.<span class="keyword">get</span>().log(INFO, <span class="string">"Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>"</span>, e)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += (client.cache)</span><br><span class="line">    interceptors += ConnectICacheInterceptornterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>, originalRequest, <span class="keyword">this</span>,</span><br><span class="line">        client.connectTimeoutMillis, client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RealCall提供了同步请求<strong>execute</strong>会将当前的RealCall对象添加到runningSyncCalls队列里面，并且开始执行<strong>getResponseWithInterceptorChain()</strong>通过拦截器链获取请求结果。<br>当请求成功之后，将当前的RealCall从runningSyncCalls队列中移除出去。</p>
<p>异步请求则是通过<strong>enqueue</strong>方法创建关联了callback回调接口的AsyncCall对象，添加在readyAsyncCalls队列里面，然后开始调用<strong>promoteAndExecute</strong>遍历readyAsyncCalls列表：<br>(1) 正在运行的线程数量是否超过最大限制64<br>(2) 当前的异步请求所对应的Host是否超过了最大值5<br>如果条件(1)、(2)都不满足，则将遍历的AsyncCall从readyAsyncCalls队列里面移除，添加到executableCalls队列、runningAsyncCalls队列里面。执行所有的executableCalls队列里面的异步请求。</p>
<p>分发器：<strong><em>Dispatcher.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line">    <span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> idleCallback: Runnable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">if</span> (executorServiceOrNull == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 核心线程数为0, 所有的空闲线程运行结束之后，全部回收</span></span><br><span class="line">            <span class="comment">// 因为OKHttp是自己管理了阻塞队列，所以将线程池阻塞队列设置为SynchronousQueue</span></span><br><span class="line">            executorServiceOrNull = ThreadPoolExecutor(<span class="number">0</span>, <span class="built_in">Int</span>.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                SynchronousQueue(), threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="literal">false</span>))</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> executorServiceOrNull!!</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()    </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">      runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 异步请求，先放到异步readyAsyncCalls队列里面</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        readyAsyncCalls.add(call)</span><br><span class="line">        <span class="keyword">if</span> (!call.<span class="keyword">get</span>().forWebSocket) &#123;</span><br><span class="line">          <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host())</span><br><span class="line">          <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      promoteAndExecute()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历readyAsyncCalls集合，找到所有满足运行条件的AsyncCall, 从readyAsyncCalls集合中移除并且添加到executableCalls、runningAsyncCalls队列。</span></span><br><span class="line">  <span class="comment">// 运行executableCalls集合中所有的AsyncCall</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      assert(!Thread.holdsLock(<span class="keyword">this</span>))</span><br><span class="line">      <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">      <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">      synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">          <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">          <span class="comment">// 如果正在运行的异步请求数量超过了64则break</span></span><br><span class="line">          <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">          <span class="keyword">if</span> (asyncCall.callsPerHost().<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line">          <span class="comment">// 从readyAsyncCalls队列里面移除，添加到runningAsyncCalls队列</span></span><br><span class="line">          i.remove()</span><br><span class="line">          asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">          executableCalls.add(asyncCall)</span><br><span class="line">          runningAsyncCalls.add(asyncCall)</span><br><span class="line">        &#125;</span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">        asyncCall.executeOn(executorService)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isRunning</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">        finished(runningSyncCalls, call)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经运行结束的Call，从相对应的队列中移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">        synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>)</span><br><span class="line">          idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">          idleCallback.run()</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dispatcher是在OKHttp创建的时候,就初始化了。内部定义了当前正在运行的异步请求数量上限64，并且同一个Host请求的最大数量为5。需要注意的是，核心线程数为0, 最大线程数为Int.MAX_VALUE,采用的是SynchronousQueue阻塞队列(没有容量，是无缓冲等待队列，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素)。</p>
<h6 id="3-3-拦截器链"><a href="#3-3-拦截器链" class="headerlink" title="3.3 拦截器链"></a>3.3 拦截器链</h6><p><img src="https://upload-images.jianshu.io/upload_images/10259072-269cd57a864d7f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/613/format/webp" alt="拦截器链"><br><strong><em>RealInterceptorChain.kt</em></strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> interceptors: List&lt;Interceptor&gt;,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> transmitter: Transmitter,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> exchange: Exchange?,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> request: Request,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> call: Call,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> connectTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> readTimeout: <span class="built_in">Int</span>,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> writeTimeout: <span class="built_in">Int</span></span><br><span class="line">) : Interceptor.Chain &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> calls: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>, transmitter: <span class="type">Transmitter</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size) <span class="keyword">throw</span> AssertionError()</span><br><span class="line">    calls++</span><br><span class="line">    <span class="keyword">val</span> next = RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">        index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line">    <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(<span class="string">"interceptor <span class="variable">$interceptor</span> returned null"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> response  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RealInterceptorChain拦截器是通过next变量来控制拦截器链上的各个拦截器的运行方向。可以理解为一种递归的方式，只有最后的一个interceptor，才会return response;然后再逐层回溯。</p>
<ul>
<li>3.3.1 RetryAndFollowUpInterceptor 失败重试及重定向</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">var</span> request = chain.request()</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line">    <span class="keyword">var</span> followUpCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> priorResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// while 死循环, 如果失败或者重定向，会重新走realChain.proceed,交给下一个拦截器处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      transmitter.prepareToConnect(request)</span><br><span class="line">      <span class="comment">// 检查当前请求是否被取消，如果这时请求被取消了，则会释放连接，并抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IOException(<span class="string">"Canceled"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> response: Response</span><br><span class="line">      <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取出网络请求结果response</span></span><br><span class="line">        response = realChain.proceed(request, transmitter, <span class="literal">null</span>)</span><br><span class="line">        success = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">        <span class="keyword">if</span> (!recover(e.lastConnectException, transmitter, <span class="literal">false</span>, request)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> e.firstConnectException</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">        <span class="keyword">val</span> requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException</span><br><span class="line">        <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// The network call threw an exception. Release any resources.</span></span><br><span class="line">        <span class="comment">// 在请求过程中，只要发生异常，就会将连接释放掉</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          transmitter.exchangeDoneDueToException()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">      <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                .body(<span class="literal">null</span>)</span><br><span class="line">                .build())</span><br><span class="line">            .build()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> exchange = response.exchange</span><br><span class="line">      <span class="keyword">val</span> route = exchange?.connection()?.route()</span><br><span class="line">      <span class="comment">// 响应response来执行followUpRequest方法，来检查是否需要进行重定向操作</span></span><br><span class="line">      <span class="keyword">val</span> followUp = followUpRequest(response, route)</span><br><span class="line">      <span class="comment">// 不需要重定向，则断开链接，返回response</span></span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">          transmitter.timeoutEarlyExit()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> followUpBody = followUp.body</span><br><span class="line">      <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">        exchange?.detachWithViolence()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 重定向次数大于阈值</span></span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ProtocolException(<span class="string">"Too many follow-up requests: <span class="variable">$followUpCount</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      request = followUp</span><br><span class="line">      priorResponse = response</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, route: <span class="type">Route</span>?)</span></span>: Request? &#123;</span><br><span class="line">    <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">    <span class="comment">// 我们知道，在Http响应码中，处于3XX的，都需要进行请求重定向处理</span></span><br><span class="line">    <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">      HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">        <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">          <span class="keyword">throw</span> ProtocolException(<span class="string">"Received HTTP_PROXY_AUTH (407) code while not using proxy"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line"></span><br><span class="line">      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT -&gt; &#123;</span><br><span class="line">        <span class="comment">// "If the 307 or 308 status code is received in response to a request other than GET</span></span><br><span class="line">        <span class="comment">// or HEAD, the user agent MUST NOT automatically redirect the request"</span></span><br><span class="line">        <span class="keyword">if</span> (method != <span class="string">"GET"</span> &amp;&amp; method != <span class="string">"HEAD"</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">        <span class="comment">// 408's are rare in practice, but some servers like HAProxy use this response code. The</span></span><br><span class="line">        <span class="comment">// spec says that we may repeat the request without modifications. Modern browsers also</span></span><br><span class="line">        <span class="comment">// repeat the request (even non-idempotent ones.)</span></span><br><span class="line">        <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">          <span class="comment">// The application layer has directed us not to retry the request.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">        <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userResponse.request</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">          <span class="comment">// We attempted to retry and got another timeout. Give up.</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// specifically received an instruction to retry without delay</span></span><br><span class="line">          <span class="keyword">return</span> userResponse.request</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据响应获取到位置location，然后根据location，得到重定向的url</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">buildRedirectRequest</span><span class="params">(userResponse: <span class="type">Response</span>, method: <span class="type">String</span>)</span></span>: Request? &#123;</span><br><span class="line">    <span class="comment">// Does the client allow redirects?</span></span><br><span class="line">    <span class="keyword">if</span> (!client.followRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> location = userResponse.header(<span class="string">"Location"</span>) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">// Don't follow redirects to unsupported protocols.</span></span><br><span class="line">    <span class="keyword">val</span> url = userResponse.request.url.resolve(location) ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If configured, don't follow redirects between SSL and non-SSL.</span></span><br><span class="line">    <span class="keyword">val</span> sameScheme = url.scheme == userResponse.request.url.scheme</span><br><span class="line">    <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Most redirects don't include a request body.</span></span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userResponse.request.newBuilder()</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">      <span class="keyword">val</span> maintainBody = HttpMethod.redirectsWithBody(method)</span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">        requestBuilder.method(<span class="string">"GET"</span>, <span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> requestBody = <span class="keyword">if</span> (maintainBody) userResponse.request.body <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        requestBuilder.method(method, requestBody)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Type"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When redirecting across hosts, drop all authentication headers. This</span></span><br><span class="line">    <span class="comment">// is potentially annoying to the application layer since they have no</span></span><br><span class="line">    <span class="comment">// way to retain them.</span></span><br><span class="line">    <span class="keyword">if</span> (!userResponse.request.url.canReuseConnectionFor(url)) &#123;</span><br><span class="line">      requestBuilder.removeHeader(<span class="string">"Authorization"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.url(url).build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过realChain.proceed(request, transmitter, null)获取返回结果response, 判断重定向条件,如果需要重定向，则交给下一个拦截器继续进行网络请求。</p>
<ul>
<li>3.3.2 BridgeInterceptor 用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> userRequest = chain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBuilder = userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> body = userRequest.body</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> contentType = body.contentType()</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> contentLength = body.contentLength()</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1L</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="keyword">var</span> transparentGzip = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="literal">true</span></span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cookies = cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    <span class="keyword">if</span> (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> networkResponse = chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip &amp;&amp;</span><br><span class="line">        <span class="string">"gzip"</span>.equals(networkResponse.header(<span class="string">"Content-Encoding"</span>), ignoreCase = <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      <span class="keyword">val</span> responseBody = networkResponse.body</span><br><span class="line">      <span class="keyword">if</span> (responseBody != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> gzipSource = GzipSource(responseBody.source())</span><br><span class="line">        <span class="keyword">val</span> strippedHeaders = networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">            .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        <span class="keyword">val</span> contentType = networkResponse.header(<span class="string">"Content-Type"</span>)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -<span class="number">1L</span>, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完善请求头和响应头</strong></p>
<ul>
<li>3.3.3 CacheInterceptor 缓存拦截器</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">//如果配置了缓存：优先从缓存中读取Response</span></span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="comment">// 如果缓存不为空，但是策略器得到的结果是不能用缓存，也就是 cacheResponse 为 null，这种情况就是将 cacheCandidate.body() 进行 close 操作</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// //如果根据缓存策略strategy禁止使用网络，并且缓存无效，直接返回空的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 如果根据缓存策略strategy禁止使用网络，且有缓存则直接使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class="line">    <span class="comment">// 本地有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 并且服务器返回304状态码（说明缓存还没过期或服务器资源没修改）</span></span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="comment">// 使用缓存数据 </span></span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="comment">// 返回缓存</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果网络资源已经修改：使用网络响应返回的最新数据</span></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将最新的数据缓存起来</span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.3.4 ConnectInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> transmitter = realChain.transmitter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">val</span> doExtensiveHealthChecks = request.method != <span class="string">"GET"</span></span><br><span class="line">    <span class="comment">// 从连接池里面复用connect</span></span><br><span class="line">    <span class="keyword">val</span> exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConnectInterceptor主要是建立和目标服务器的连接，会优先从ConnectionPool连接池里面获取复用的connect, 如果连接池里面没找到，获取路由表重新从连接池里面获取复用connect，还是没找到就重新创建一个连接，并添加到连接池。至此3次握手就已经建立起来了，如果是Https还会有TLS握手。</p>
<ul>
<li>3.3.5 CallServerInterceptor </li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">    <span class="keyword">val</span> exchange = realChain.exchange()</span><br><span class="line">    <span class="keyword">val</span> request = realChain.request()</span><br><span class="line">    <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">    <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向服务器发送请求</span></span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> responseHeadersStarted = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 检测是否有请求body</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// HTTP/1.1 协议里设计 100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP/1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。</span></span><br><span class="line">      <span class="comment">// 询问Server使用愿意接受数据 </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equals(request.header(<span class="string">"Expect"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseHeadersStarted = <span class="literal">true</span></span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">          <span class="comment">// 向服务器发送requesyBody</span></span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">          <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">      exchange.responseHeadersStart()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建response对象</span></span><br><span class="line">    <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">var</span> code = response.code</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">      <span class="comment">// try again to read the actual response</span></span><br><span class="line">      response = exchange.readResponseHeaders(<span class="literal">false</span>)!!</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code = response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回空的即无效的响应</span></span><br><span class="line">    response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equals(response.request.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">        <span class="string">"close"</span>.equals(response.header(<span class="string">"Connection"</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">          <span class="string">"HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="四、连接池-重点"><a href="#四、连接池-重点" class="headerlink" title="四、连接池 (重点)"></a>四、连接池 (重点)</h6><p><strong><em>Transmitter.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Transmitter(</span><br><span class="line">  private val client: OkHttpClient,</span><br><span class="line">  private val call: Call</span><br><span class="line">) &#123;</span><br><span class="line">  private val connectionPool: RealConnectionPool &#x3D; client.connectionPool.delegate</span><br><span class="line">  private var exchangeFinder: ExchangeFinder? &#x3D; null</span><br><span class="line">    </span><br><span class="line">  internal fun newExchange(chain: Interceptor.Chain, doExtensiveHealthChecks: Boolean): Exchange &#123;</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      check(!noMoreExchanges) &#123; &quot;released&quot; &#125;</span><br><span class="line">      check(exchange &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &quot;cannot make a new request because the previous response is still open: &quot; +</span><br><span class="line">            &quot;please call response.close()&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    val codec &#x3D; exchangeFinder!!.find(client, chain, doExtensiveHealthChecks)</span><br><span class="line">    val result &#x3D; Exchange(this, call, eventListener, exchangeFinder!!, codec)</span><br><span class="line"></span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      this.exchange &#x3D; result</span><br><span class="line">      this.exchangeRequestDone &#x3D; false</span><br><span class="line">      this.exchangeResponseDone &#x3D; false</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exchange是基于Okio的一个专门用于异步非阻塞NIO的封装。是在connect连接建立之上的，用于和服务器进行IO通信。</p>
<p><strong><em>ExchangeFinder.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">class ExchangeFinder(</span><br><span class="line">  private val transmitter: Transmitter,</span><br><span class="line">  private val connectionPool: RealConnectionPool,</span><br><span class="line">  private val address: Address,</span><br><span class="line">  private val call: Call,</span><br><span class="line">  private val eventListener: EventListener</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  fun find(</span><br><span class="line">    client: OkHttpClient,</span><br><span class="line">    chain: Interceptor.Chain,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): ExchangeCodec &#123;</span><br><span class="line">    val connectTimeout &#x3D; chain.connectTimeoutMillis()</span><br><span class="line">    val readTimeout &#x3D; chain.readTimeoutMillis()</span><br><span class="line">    val writeTimeout &#x3D; chain.writeTimeoutMillis()</span><br><span class="line">    val pingIntervalMillis &#x3D; client.pingIntervalMillis</span><br><span class="line">    val connectionRetryEnabled &#x3D; client.retryOnConnectionFailure</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 首先从连接池里面找到一个健康的Connection，没找到就创建一个新的。</span><br><span class="line">      val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled,</span><br><span class="line">          doExtensiveHealthChecks &#x3D; doExtensiveHealthChecks</span><br><span class="line">      )</span><br><span class="line">      &#x2F;&#x2F; 为已经找到的Connection创建一个ExchangeCodec用于IO通信</span><br><span class="line">      return resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw e</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      trackFailure()</span><br><span class="line">      throw RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findHealthyConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean,</span><br><span class="line">    doExtensiveHealthChecks: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环调用，直到得到一个健康的RealConnection </span><br><span class="line">    while (true) &#123;</span><br><span class="line">      &#x2F;&#x2F; 查找连接</span><br><span class="line">      val candidate &#x3D; findConnection(</span><br><span class="line">          connectTimeout &#x3D; connectTimeout,</span><br><span class="line">          readTimeout &#x3D; readTimeout,</span><br><span class="line">          writeTimeout &#x3D; writeTimeout,</span><br><span class="line">          pingIntervalMillis &#x3D; pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled &#x3D; connectionRetryEnabled</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If this is a brand new connection, we can skip the extensive health checks.</span><br><span class="line">      &#x2F;&#x2F; 如果是一个全新的连接直接拿去使用不需要检查</span><br><span class="line">      synchronized(connectionPool) &#123;</span><br><span class="line">        if (candidate.successCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          return candidate</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br><span class="line">      &#x2F;&#x2F; isn&#39;t, take it out of the pool and start again.</span><br><span class="line">      &#x2F;&#x2F; 检查这个连接是否是健康可用的，如果不是把它移除连接池</span><br><span class="line">      if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        candidate.noNewExchanges()</span><br><span class="line">        continue</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return candidate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun findConnection(</span><br><span class="line">    connectTimeout: Int,</span><br><span class="line">    readTimeout: Int,</span><br><span class="line">    writeTimeout: Int,</span><br><span class="line">    pingIntervalMillis: Int,</span><br><span class="line">    connectionRetryEnabled: Boolean</span><br><span class="line">  ): RealConnection &#123;</span><br><span class="line">    var foundPooledConnection &#x3D; false</span><br><span class="line">    var result: RealConnection? &#x3D; null</span><br><span class="line">    var selectedRoute: Route? &#x3D; null</span><br><span class="line">    var releasedConnection: RealConnection?</span><br><span class="line">    val toClose: Socket?</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">      hasStreamFailure &#x3D; false &#x2F;&#x2F; This is a fresh attempt.</span><br><span class="line">      &#x2F;&#x2F; 优先返回一个已经分配的连接，假如这个连接不为空，并且这个连接上面还可以建立新的stream</span><br><span class="line">      releasedConnection &#x3D; transmitter.connection</span><br><span class="line">      toClose &#x3D; if (transmitter.connection !&#x3D; null &amp;&amp; transmitter.connection!!.noNewExchanges) &#123;</span><br><span class="line">        transmitter.releaseConnectionNoEvents()</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        null</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (transmitter.connection !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">        releasedConnection &#x3D; null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Attempt to get a connection from the pool.</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">          nextRouteToTry &#x3D; null</span><br><span class="line">        &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">          selectedRoute &#x3D; transmitter.connection!!.route()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    &#125;</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done.</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we need a route selection, make one. This is a blocking operation.</span><br><span class="line">    var newRouteSelection &#x3D; false</span><br><span class="line">    if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">      newRouteSelection &#x3D; true</span><br><span class="line">      routeSelection &#x3D; routeSelector.next()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 进行路由选择，重新再连接池寻找可复用的Connection</span><br><span class="line">    var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      if (transmitter.isCanceled) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">      if (newRouteSelection) &#123;</span><br><span class="line">        &#x2F;&#x2F; Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br><span class="line">        &#x2F;&#x2F; the pool. This could match due to connection coalescing.</span><br><span class="line">        routes &#x3D; routeSelection!!.routes</span><br><span class="line">        if (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">                address, transmitter, routes, false)) &#123;</span><br><span class="line">          foundPooledConnection &#x3D; true</span><br><span class="line">          result &#x3D; transmitter.connection</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 从连接池里面没找到可用的Connection,则新创建一个Connection, 并添加到连接池</span><br><span class="line">      if (!foundPooledConnection) &#123;</span><br><span class="line">        if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">          selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">        &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do.</span><br><span class="line">        result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">        connectingConnection &#x3D; result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If we found a pooled connection on the 2nd time around, we&#39;re done.</span><br><span class="line">    if (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result!!)</span><br><span class="line">      return result!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">    &#x2F;&#x2F; 执行TCP + TLS握手</span><br><span class="line">    result!!.connect(</span><br><span class="line">        connectTimeout,</span><br><span class="line">        readTimeout,</span><br><span class="line">        writeTimeout,</span><br><span class="line">        pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled,</span><br><span class="line">        call,</span><br><span class="line">        eventListener</span><br><span class="line">    )</span><br><span class="line">    connectionPool.routeDatabase.connected(result!!.route())</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 创建socket连接</span><br><span class="line">    var socket: Socket? &#x3D; null</span><br><span class="line">    synchronized(connectionPool) &#123;</span><br><span class="line">      connectingConnection &#x3D; null</span><br><span class="line">      &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br><span class="line">      &#x2F;&#x2F; concurrent connections to the same host.</span><br><span class="line">      &#x2F;&#x2F; 如果有另一个具有相同IP地址的连接被同时创建，那么把这个连接释放，去用另外一个</span><br><span class="line">      &#x2F;&#x2F; 这种情况只有Http2的时候才会去执行</span><br><span class="line">      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection.</span><br><span class="line">        result!!.noNewExchanges &#x3D; true</span><br><span class="line">        socket &#x3D; result!!.socket()</span><br><span class="line">        result &#x3D; transmitter.connection</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 将新建的连接放入连接池</span><br><span class="line">        connectionPool.put(result!!)</span><br><span class="line">        transmitter.acquireConnectionNoEvents(result!!)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>Exchange.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Exchange(</span><br><span class="line">  internal val transmitter: Transmitter,</span><br><span class="line">  internal val call: Call,</span><br><span class="line">  internal val eventListener: EventListener,</span><br><span class="line">  private val finder: ExchangeFinder,</span><br><span class="line">  private val codec: ExchangeCodec</span><br><span class="line">) &#123;</span><br><span class="line">  fun connection(): RealConnection? &#x3D; codec.connection()</span><br><span class="line">  </span><br><span class="line">  fun writeRequestHeaders(request: Request) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      eventListener.requestHeadersStart(call)</span><br><span class="line">      codec.writeRequestHeaders(request)</span><br><span class="line">      eventListener.requestHeadersEnd(call, request)</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      eventListener.requestFailed(call, e)</span><br><span class="line">      trackFailure(e)</span><br><span class="line">      throw e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>ExchangeCodec.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface ExchangeCodec &#123;</span><br><span class="line">  fun connection(): RealConnection?</span><br><span class="line">  fun createRequestBody(request: Request, contentLength: Long): Sink</span><br><span class="line">  fun writeRequestHeaders(request: Request)</span><br><span class="line">  fun flushRequest()</span><br><span class="line">  fun finishRequest()</span><br><span class="line">  fun readResponseHeaders(expectContinue: Boolean): Response.Builder?</span><br><span class="line">  fun openResponseBodySource(response: Response): Source</span><br><span class="line">  fun cancel()</span><br><span class="line">  companion object &#123;</span><br><span class="line">    const val DISCARD_STREAM_TIMEOUT_MILLIS &#x3D; 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于Okio的封装接口，采用非阻塞方式和服务器进行IO通信</p>
<p><strong><em>RealConnectionPool.kt</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class RealConnectionPool(</span><br><span class="line">  &#x2F;** The maximum number of idle connections for each address. *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 最大的空闲socket连接数</span><br><span class="line">  private val maxIdleConnections: Int,</span><br><span class="line">  &#x2F;&#x2F; socket的keepAlive时间</span><br><span class="line">  keepAliveDuration: Long,</span><br><span class="line">  timeUnit: TimeUnit</span><br><span class="line">) &#123;</span><br><span class="line">  private val keepAliveDurationNs: Long &#x3D; timeUnit.toNanos(keepAliveDuration)</span><br><span class="line"></span><br><span class="line">  private val cleanupRunnable &#x3D; object : Runnable &#123;</span><br><span class="line">    override fun run() &#123;</span><br><span class="line">      while (true) &#123;</span><br><span class="line">        val waitNanos &#x3D; cleanup(System.nanoTime())</span><br><span class="line">        if (waitNanos &#x3D;&#x3D; -1L) return</span><br><span class="line">        try &#123;</span><br><span class="line">          this@RealConnectionPool.lockAndWaitNanos(waitNanos)</span><br><span class="line">        &#125; catch (_: InterruptedException) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private val connections &#x3D; ArrayDeque&lt;RealConnection&gt;()</span><br><span class="line">  &#x2F;&#x2F; 用来记录连接失败的路线名单</span><br><span class="line">  val routeDatabase &#x3D; RouteDatabase()</span><br><span class="line">  var cleanupRunning: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">  init &#123;</span><br><span class="line">    &#x2F;&#x2F; Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span><br><span class="line">    require(keepAliveDuration &gt; 0L) &#123; &quot;keepAliveDuration &lt;&#x3D; 0: $keepAliveDuration&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  companion object &#123;</span><br><span class="line">    private val executor &#x3D; ThreadPoolExecutor(</span><br><span class="line">        0, &#x2F;&#x2F; corePoolSize.</span><br><span class="line">        Int.MAX_VALUE, &#x2F;&#x2F; maximumPoolSize.</span><br><span class="line">        60L, TimeUnit.SECONDS, &#x2F;&#x2F; keepAliveTime.</span><br><span class="line">        SynchronousQueue(),</span><br><span class="line">        threadFactory(&quot;OkHttp ConnectionPool&quot;, true)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fun get(connectionPool: ConnectionPool): RealConnectionPool &#x3D; connectionPool.delegate</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h5><h5 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h5><p><strong>SynchronousQueue 原理</strong></p>
<p>在OKHttp中像异步网络请求，<strong>内部使用的线程池是采用SynchronousQueue这个特殊的阻塞队列：每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final SynchronousQueue&lt;Integer&gt; queue &#x3D; new SynchronousQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        Thread putThread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;put thread start&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue.put(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;put thread end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread takeThread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;take thread start&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;take from putThread: &quot; + queue.take());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;take thread end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        putThread.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        takeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行结果</span><br><span class="line">put thread start</span><br><span class="line">take thread start</span><br><span class="line">take from putThread: 1</span><br><span class="line">take thread end</span><br><span class="line">put thread end</span><br></pre></td></tr></table></figure>

<h6 id="五、更多阅读"><a href="#五、更多阅读" class="headerlink" title="五、更多阅读"></a>五、更多阅读</h6><p><a href="https://www.jianshu.com/p/82f74db14a18" target="_blank" rel="noopener">1. OKHttp源码解析</a><br><a href="https://www.cnblogs.com/zhangqie/p/8681308.html" target="_blank" rel="noopener">2. Android开源框架源码分析：Okhttp</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Retrofit2 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 11:14:46 / 修改时间：11:15:06" itemprop="dateCreated datePublished" datetime="2020-05-31T11:14:46+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、Retrofit2-简介"><a href="#一、Retrofit2-简介" class="headerlink" title="一、Retrofit2 简介"></a>一、Retrofit2 简介</h5><p>Retrofit是一个遵循RESTful设计的进行HTTP网络请求框架，底层网络请求基于OkHttp框架</p>
<h6 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"> </span><br><span class="line">GitHubService service = retrofit.create(GitHubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">service.listRepos(<span class="string">"test"</span>).enqueue(<span class="keyword">new</span> Callback&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="1-2-RxJava、GSON"><a href="#1-2-RxJava、GSON" class="headerlink" title="1.2 RxJava、GSON"></a>1.2 RxJava、GSON</h6><h5 id="二、原理剖析"><a href="#二、原理剖析" class="headerlink" title="二、原理剖析"></a>二、原理剖析</h5><h6 id="2-1-Retrofit的创建"><a href="#2-1-Retrofit的创建" class="headerlink" title="2.1 Retrofit的创建"></a>2.1 Retrofit的创建</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">    <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> HttpUrl baseUrl;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>(Platform.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">          <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">          &#125;</span><br><span class="line">          Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">          <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">          &#125;</span><br><span class="line">          List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">          <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">          <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">          converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">          converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">          converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-create-动态代理"><a href="#2-2-create-动态代理" class="headerlink" title="2.2 create 动态代理"></a>2.2 create 动态代理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回service的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">              @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>ServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>HttpServiceMethod.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceMethod</span>&lt;<span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">        ...   </span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">        Type responseType = callAdapter.responseType();</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line">        okhttp3.Call.Factory callFactory = retrofit.callFactory;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">          continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT&gt; <span class="function">Converter&lt;ResponseBody, ResponseT&gt; <span class="title">createResponseConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, Type responseType)</span> </span>&#123;</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);  </span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">        <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallAdapted</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">ReturnT</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">        CallAdapted(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">            <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">            <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendForBody</span>&lt;<span class="title">ResponseT</span>&gt; <span class="keyword">extends</span> <span class="title">HttpServiceMethod</span>&lt;<span class="title">ResponseT</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isNullable;</span><br><span class="line"></span><br><span class="line">    SuspendForBody(RequestFactory requestFactory, okhttp3.Call.Factory callFactory,</span><br><span class="line">        Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">        CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter, <span class="keyword">boolean</span> isNullable) &#123;</span><br><span class="line">      <span class="keyword">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">      <span class="keyword">this</span>.callAdapter = callAdapter;</span><br><span class="line">      <span class="keyword">this</span>.isNullable = isNullable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Object <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> </span>&#123;</span><br><span class="line">      call = callAdapter.adapt(call);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//noinspection unchecked Checked by reflection inside RequestFactory.</span></span><br><span class="line">      Continuation&lt;ResponseT&gt; continuation = (Continuation&lt;ResponseT&gt;) args[args.length - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">return</span> isNullable</span><br><span class="line">          ? KotlinExtensions.awaitNullable(call, continuation)</span><br><span class="line">          : KotlinExtensions.await(call, continuation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>DefaultCallAdapterFactory.java</em></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">          <span class="string">"Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        ? <span class="title">null</span></span></span><br><span class="line">        : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span></span><br><span class="line">            ? call</span><br><span class="line">            : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      delegate.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"CloneDoesntCallSuperClone"</span>) <span class="comment">// Performing deep clone.</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.request();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="四、更多阅读"><a href="#四、更多阅读" class="headerlink" title="四、更多阅读"></a>四、更多阅读</h6><p><a href="https://www.jianshu.com/p/0b4c41d5d354" target="_blank" rel="noopener">1. 【Android源码伴读】Retrofit源码探秘</a></p>
<p><a href="https://www.jianshu.com/p/097947afddaf" target="_blank" rel="noopener">2. Retrofit源码分析（超详细）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
