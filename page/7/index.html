<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">啃碎并发（九）：内存模型之基础概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 09:03:19" itemprop="dateCreated datePublished" datetime="2020-06-03T09:03:19+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在并发编程中，需要解决两个关键问题：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/%E7%AE%97%E6%B3%95%20--%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/02/%E7%AE%97%E6%B3%95%20--%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">算法 -- 动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-02 19:19:17" itemprop="dateCreated datePublished" datetime="2020-06-02T19:19:17+08:00">2020-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-青蛙跳台阶"><a href="#0-青蛙跳台阶" class="headerlink" title="0. 青蛙跳台阶"></a>0. 青蛙跳台阶</h4><p>问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static int fun(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    int[] dp &#x3D; new int[n + 1];</span><br><span class="line">    dp[1] &#x3D; 1; dp[2] &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-最大连续子序列和"><a href="#1-最大连续子序列和" class="headerlink" title="1. 最大连续子序列和"></a>1. 最大连续子序列和</h4><p>给定k个整数的序列{N1,N2,…,Nk }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= k。最大连续子序列是所有连续子序中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{11,-4,13}，最大连续子序列和即为20。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 状态转移方程 dp[i] &#x3D; max&#123;dp[i-1] + A[i], A[i]&#125;</span><br><span class="line">private static int MaxSubSequence2(int[] A) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[A.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; 0;</span><br><span class="line">        if (i &#x3D;&#x3D; 0) continue;</span><br><span class="line">        if (A[i] &gt; dp[i - 1] + A[i]) &#123;</span><br><span class="line">            dp[i] &#x3D; A[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int max &#x3D; dp[0];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; dp.length; i++) &#123;</span><br><span class="line">        if (max &lt; dp[i]) max &#x3D; dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最长递增子序列（LIS）"><a href="#2-最长递增子序列（LIS）" class="headerlink" title="2. 最长递增子序列（LIS）"></a>2. 最长递增子序列（LIS）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 【最长递增子序列（LIS）】</span><br><span class="line"> * 1.若arr[i]&gt;arr[j],说明第i个元素可以接在第j个元素后面作为新的递增序列的结尾,即dp[i] &#x3D; max(dp[j])+1 &#x3D; max(dp[j] + 1)</span><br><span class="line"> * 2.若arr[i]&lt;&#x3D;arr[j],说明第i个元素比前面所有的数都小,此时以i元素作为结尾的递增序列长度为1,即dp[i] &#x3D; 1</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int LIS(int[] A) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[A.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; 1;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (A[i] &gt; A[j] &amp;&amp; dp[i] &lt; (dp[j] + 1)) &#123;</span><br><span class="line">                dp[i] &#x3D; dp[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp &#x3D; dp[0];</span><br><span class="line">    for (int m &#x3D; 0; m &lt; dp.length; m++) &#123;</span><br><span class="line">        if (temp &lt; dp[m]) &#123;</span><br><span class="line">            temp &#x3D; dp[m];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-最长公共子序列（LCS）"><a href="#3-最长公共子序列（LCS）" class="headerlink" title="3. 最长公共子序列（LCS）"></a>3. 最长公共子序列（LCS）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 【最长公共子序列（LCS）】</span><br><span class="line"> * 设序列X&#x3D;&#123;x1,x2,…,xm&#125;和Y&#x3D;&#123;y1,y2,…,yn&#125;的最长公共子序列为Z&#x3D;&#123;z1,z2,…,zk&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int LCS(int[] X, int[] Y) &#123;</span><br><span class="line">	int m &#x3D; X.length;</span><br><span class="line">	int n &#x3D; Y.length;</span><br><span class="line">	int[][] L &#x3D; new int[m][n];</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (X[i] &#x3D;&#x3D; Y[j]) &#123;</span><br><span class="line">			if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i - 1][j - 1] + 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			L[i][j] &#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; else if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">			if (L[i - 1][j] &gt; L[i][j - 1]) &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i - 1][j];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i][j - 1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return L[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-编辑距离"><a href="#4-编辑距离" class="headerlink" title="4. 编辑距离"></a>4. 编辑距离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 编辑距离</span><br><span class="line"> * 1、维护一个dp数组，其中dp[i][j]表示s1[0]---s1[i]和s2[0]--s2[j]相同需要进行的最少步骤；</span><br><span class="line"> * 2、边界条件初始化，dp[i][0]&#x3D;i，相当于将s1挨个变成空所要进行的步数，对于dp[0][j]&#x3D;j同理；</span><br><span class="line"> * 3、状态转移方程，我们要得到dp[i][j]的值，假设s1[i-1]和s2[j-1]之前的都已经相等了，那么如果s1[i]&#x3D;&#x3D;s2[j]，显然不需要进行操作，dp[i][j]&#x3D;&#x3D;dp[i-1][j-1]；如果s1[i]!&#x3D;s2[j]，那么到达dp[i][j]的就有三条路，分别从dp[i-1][j-1]、dp[i-1][j]、dp[i][j-1]，对应的含义分别是修改字符、删除字符和插入字符，在三种操作下，经历的步数都要+1，所以我们只要找三者的最小值然后+1就可以了。</span><br><span class="line">*&#x2F;</span><br><span class="line">private static int editDistance(String s1, String s2) &#123;</span><br><span class="line">    int s1_len &#x3D; s1.length();</span><br><span class="line">    int s2_len &#x3D; s2.length();</span><br><span class="line">    int[][] dp &#x3D; new int[s1_len][s2_len];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; s1_len; i++) &#123;</span><br><span class="line">        dp[i][0] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 0; j &lt; s2_len; j++) &#123;</span><br><span class="line">        dp[0][j] &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 1; i &lt; s1_len; i++)</span><br><span class="line">        for (int j &#x3D; 1; j &lt; s2_len; j++) &#123;</span><br><span class="line">            if (s1.charAt(i) &#x3D;&#x3D; s2.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i - 1][j - 1] + 1);</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i][j - 1] + 1);</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i - 1][j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    return dp[s1_len - 1][s2_len - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
<p><strong>1. 暴力破解算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">    if (s.isEmpty()) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    String res &#x3D; s.substring(0, 1);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt;&#x3D; s.length(); j++) &#123;</span><br><span class="line">            String k &#x3D; s.substring(i, j);</span><br><span class="line">            String rk &#x3D; new StringBuffer(k).reverse().toString();</span><br><span class="line">            if (k.equals(rk) &amp;&amp; k.length() &gt; res.length()) &#123;</span><br><span class="line">                res &#x3D; k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 动态规划</strong></p>
<p>创建一个二维数组，boolean[][] dp, 其中dp[i][j]表示字符串第i到j是否为回文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string longestPalindrome(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.empty()) return &quot;&quot;;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    if (len &#x3D;&#x3D; 1)return s;</span><br><span class="line">    int longest &#x3D; 1;</span><br><span class="line">    int start&#x3D;0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(len,vector&lt;int&gt;(len));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] &#x3D; 1;</span><br><span class="line">        if(i&lt;len-1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + 1] &#x3D; 1;</span><br><span class="line">                start&#x3D;i;</span><br><span class="line">                longest&#x3D;2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int l &#x3D; 3; l &lt;&#x3D; len; l++)&#x2F;&#x2F;子串长度</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i+l-1 &lt; len; i++)&#x2F;&#x2F;枚举子串的起始点</span><br><span class="line">        &#123;</span><br><span class="line">            int j&#x3D;l+i-1;&#x2F;&#x2F;终点</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[j] &amp;&amp; dp[i+1][j-1]&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] &#x3D; 1;</span><br><span class="line">                start&#x3D;i;</span><br><span class="line">                longest &#x3D; l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(start,longest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-无重复字符最长子串长度"><a href="#6-无重复字符最长子串长度" class="headerlink" title="6. 无重复字符最长子串长度"></a>6. 无重复字符最长子串长度</h4><p>dp[i]表示字符串以i结尾的中最长无重复字符的长度。 状态转移方程可以表述为：</p>
<ol>
<li>dp[i] = dp[i-1] + 1 (dp[i] 在1…i-1里面不重复）</li>
<li>dp[i] = max(d, i-1-d) </li>
</ol>
<h1 id="方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max-dp-）"><a href="#方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max-dp-）" class="headerlink" title="方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max(dp)）"></a>方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max(dp)）</h1><h1 id="状态转移："><a href="#状态转移：" class="headerlink" title="状态转移："></a>状态转移：</h1><h1 id="1-若s-j-不存在于s-j-，那么dp-j-dp-j-1-1"><a href="#1-若s-j-不存在于s-j-，那么dp-j-dp-j-1-1" class="headerlink" title="1. 若s[j]不存在于s[:j]，那么dp[j]=dp[j-1]+1;"></a>1. 若s[j]不存在于s[:j]，那么dp[j]=dp[j-1]+1;</h1><h1 id="2-若s-j-存在于s-j-中，但是s-j-和之前重复的那个元素之间的距离d-gt-dp-j-1-，那么不对当前产生影响，dp-j-dp-j-1-1，例如：s-”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；"><a href="#2-若s-j-存在于s-j-中，但是s-j-和之前重复的那个元素之间的距离d-gt-dp-j-1-，那么不对当前产生影响，dp-j-dp-j-1-1，例如：s-”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；" class="headerlink" title="2. 若s[j]存在于s[:j]中，但是s[j]和之前重复的那个元素之间的距离d&gt;dp[j-1]，那么不对当前产生影响，dp[j]=dp[j-1]+1，例如：s=”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；"></a>2. 若s[j]存在于s[:j]中，但是s[j]和之前重复的那个元素之间的距离d&gt;dp[j-1]，那么不对当前产生影响，dp[j]=dp[j-1]+1，例如：s=”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；</h1><h1 id="3-若d-lt-dp-j-1-，那么dp-j-d"><a href="#3-若d-lt-dp-j-1-，那么dp-j-d" class="headerlink" title="3. 若d&lt;dp[j-1]，那么dp[j]=d"></a>3. 若d&lt;dp[j-1]，那么dp[j]=d</h1><h4 id="7-纸牌游戏"><a href="#7-纸牌游戏" class="headerlink" title="7. 纸牌游戏"></a>7. 纸牌游戏</h4><p>有一个整型数组A，代表数值不同的纸牌排成一条线。玩家a和玩家b依次拿走每张纸牌，规定玩家a先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家a和玩家b都绝顶聪明，他们总会采用最优策略。请返回最后获胜者的分数。</p>
<p>给定纸牌序列A及序列的大小n，请返回最后分数较高者得分数(相同则返回任意一个分数)。保证A中的元素均小于等于1000。且A的大小小于等于300。</p>
<blockquote>
<p>测试样例：<br>[1,2,100,4],4<br>返回：101</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int cardGame(int[] A, int n) &#123;</span><br><span class="line">    int[][] f &#x3D; new int[n][n];</span><br><span class="line">    int[][] s &#x3D; new int[n][n];</span><br><span class="line">    &#x2F;&#x2F; 注意j，i的取值范围</span><br><span class="line">    for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">        f[j][j] &#x3D; A[j];</span><br><span class="line">        for (int i &#x3D; j - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            f[i][j] &#x3D; Math.max(A[i] + s[i + 1][j], A[j] + s[i][j - 1]);</span><br><span class="line">            s[i][j] &#x3D; Math.min(f[i + 1][j], f[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       return Math.max(f[0][n - 1], s[0][n - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-0-1背包问题"><a href="#8-0-1背包问题" class="headerlink" title="8. 0-1背包问题"></a>8. 0-1背包问题</h4><p>给定n个重量为W1、W2、W3 .. Wn , 价值为V1、V2、V3 .. Vn的物品和容量为j的背包</p>
<p>定义V(i,j)：当前背包容量j，前i个物品最佳组合对应的价值</p>
<ol>
<li>如果： j &lt; w(i)  则V(i, j) = V(i - 1, j)</li>
<li>如果： j &gt;= w(i) 则V(i, j) = max{ V(i - 1, j)，V(i - 1, j - w(i)) + v(i) ｝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 1; j &lt;&#x3D; bagV; j++) &#123;</span><br><span class="line">        if (j &lt; w[i])</span><br><span class="line">            dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">        else</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486294&idx=1&sn=dd8968700d19ea8b1db29065dc2f7b01&chksm=ce404082f937c994444393163a2bf53f32e18f9a752aad610c3d4988f31c328cae203a84809b&scene=21#wechat_redirect" target="_blank" rel="noopener">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">数据结构 -- 布隆过滤器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-02 10:14:21 / 修改时间：19:18:16" itemprop="dateCreated datePublished" datetime="2020-06-02T10:14:21+08:00">2020-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-问题情景"><a href="#1-问题情景" class="headerlink" title="1. 问题情景"></a>1. 问题情景</h4><p>如果面试官问你，一个网站有 100 亿 url 存在一个黑名单中，每条 url 平均 64 字节。问这个黑名单要怎么存？若此时随便输入一个 url，如何判断该 url 是否在这个黑名单中？</p>
<p>对于第一个问题，如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p>
<p>那该怎么办？ok，现在该介绍今天的主角了 —— 布隆过滤器就可以解决这样的问题。</p>
<blockquote>
<p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制矢量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<h4 id="2-具体介绍"><a href="#2-具体介绍" class="headerlink" title="2. 具体介绍"></a>2. 具体介绍</h4><blockquote>
<p>布隆过滤器实际上是一个很长的二进制矢量和一系列随机映射函数。</p>
</blockquote>
<p>「很长的二进制矢量」：这是一个长度很长的数组，什么类型的数组呢？bit 类型的数组，也是我们说的「位」，（1Byte = 8bit，1KB = 1024Byte）。<br>「一系列随机映射函数」：有多个哈希函数。那什么是哈希函数呢？JDK 里面有计算得到哈希值的方法，那就是一个哈希函数。<br>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p>
<h4 id="3-解决过程"><a href="#3-解决过程" class="headerlink" title="3. 解决过程"></a>3. 解决过程</h4><p>下面我说下大体的过程，细节部分可先不理解，重要的是明白流程，细节我后面补充。</p>
<p>假设，bit 类型数组的长度为 m，每个元素值为 0，有 k 个哈希函数。</p>
<p>首先，当输入一个 url 的时候，此时这个 url 会经过 k 个哈希函数处理，得到多个哈希值（v1,v2,…,vk）。之后得到这些哈希值对应在数组的下标位置，最后将这些下标的元素都置为 1。</p>
<p>那么如何判断一个 url 在黑名单里面呢？输入一条 url，它经过上述处理之后，会得到多个数组的下标位置。如果这些下标的元素值都已经为 1 了，说明该在黑名单里面，否则不在。</p>
<p>总体就是这样的流程，下面说下大家可能存在的疑问：</p>
<p>1、bit 类型的数组如何构建<br>2、得到 v1,v2,…,vk 这些哈希值后，如何得到其在数组的下标位置，并将其设置为 1 呢？</p>
<p>两个问题我一起说下，Java 里面没有 bit 这样的类型，怎么构建呢？—— 不难，我们可以使用 int，一个 int 是 32 位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建了一个 100 * 32bit 的数组</span><br><span class="line">int[] arr &#x3D; new int[100]; </span><br><span class="line">&#x2F;&#x2F; 代表 bit 数组 0-31 位的元素</span><br><span class="line">arr[0];</span><br></pre></td></tr></table></figure>

<p>因此上面再会说「分别将这些哈希值除以数组的长度 m，和对 m 取模，得到这些哈希值对应在数组的下标位置」。</p>
<p>具体我们可以拿一个哈希值 data 来举个栗子，假设 int 数组长度为 100。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Set(int data) &#123;</span><br><span class="line">       &#x2F;&#x2F; ByteNO 是表示在 table 数组中那个元素</span><br><span class="line">       int ByteNo &#x3D; data &#x2F; 32;</span><br><span class="line">       &#x2F;&#x2F; bitNo 是表示在 32 位 bit 中哪个 bit 位。</span><br><span class="line">       int BitNo &#x3D; data % 32;</span><br><span class="line">       &#x2F;&#x2F; 置 1</span><br><span class="line">       _table[ByteNo] |&#x3D; (1 &lt;&lt; BitNo); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-使用效果"><a href="#4-使用效果" class="headerlink" title="4. 使用效果"></a>4. 使用效果</h4><p>最开始我们提到，如果将 100 亿 url 放到 HashMap 中需要 640GB，那么使用布隆过滤器后又需要多少空间呢？答案是约等于 23 GB。相比之下，这个空间大小是不是就可以接受很多了。</p>
<h4 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a>5. 缺点</h4><p>布隆过滤器有宁可错杀一百，也不能放过一个的性质。讲人话就是属于黑名单的 url 一定能够正确判断它在黑名单中，但不属于黑名单中的 url 也可能会被认为在黑名单中，存在一定的失误率。</p>
<p><a href="https://juejin.im/post/5ce60f8ce51d4510bf1d65ea" target="_blank" rel="noopener">大白话布隆过滤器</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90wait&notify%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90wait&notify%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（八）：深入分析wait&notify原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 20:44:24" itemprop="dateCreated datePublished" datetime="2020-06-01T20:44:24+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>上一节讲了Synchronized关键词的原理与优化分析，而配合Synchronized使用的另外两个关键词<strong>wait&amp;notify</strong>是本章讲解的重点。最简单的东西，往往包含了最复杂的实现，因为需要为上层的存在提供一个稳定的基础，<strong>Object作为Java中所有对象的基类，其存在的价值不言而喻，其中wait&amp;notify方法的实现多线程协作提供了保证。</strong></p>
<h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1 源码"></a>1 源码</h4><p>今天我们要学习或者说分析的是<strong>Object</strong>类中的 wait&amp;notify 这两个方法，其实说是两个方法，这两个方法包括他们的重载方法一共有 5 个，而 Object 类中一共才 12 个方法，可见这 2 个方法的重要性。我们先看看 JDK 中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final native void notify();</span><br><span class="line">public final native void notifyAll();</span><br><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">&#125;</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (timeout &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                            &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 此处对于纳秒的处理不精准，只是简单增加了1毫秒，</span><br><span class="line">    if (nanos &gt; 0) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这五个方法。其中有<strong>3 个方法是 native 的，也就是由虚拟机本地的 c 代码执行的。</strong>有 2 个 wait 重载方法最终还是调用了 wait（long） 方法。</p>
<p><strong>1.wait方法：</strong>wait是要释放对象锁，进入等待池。既然是释放对象锁，那么肯定是先要获得锁。所以wait必须要写在synchronized代码块中，否则会报异常。</p>
<p><strong>2.notify方法：</strong>也需要写在synchronized代码块中，调用对象的这两个方法也需要先获得该对象的锁。 <strong>notify，notifyAll，唤醒等待该对象同步锁的线程，并放入该对象的锁池中。对象的锁池中线程可以去竞争得到对象锁，然后开始执行。</strong></p>
<blockquote>
<p>1.<strong>如果是通过notify来唤起的线程，</strong>那先进入wait的线程会先被唤起来，并非随机唤醒；<br>2.<strong>如果是通过nootifyAll唤起的线程</strong>，默认情况是最后进入的会先被唤起来，即LIFO的策略；</p>
</blockquote>
<p>另外一点比较重要，notify，notifyAll调用时并不会释放对象锁。比如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void test()</span><br><span class="line">&#123;</span><br><span class="line">    Object object &#x3D; new Object();</span><br><span class="line">    synchronized (object)&#123;</span><br><span class="line">        object.notifyAll();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然调用了notifyAll，但是紧接着进入了一个死循环。<strong>导致一直不能出临界区，一直不能释放对象锁。</strong>所以，即使它把所有在等待池中的线程都唤醒放到了对象的锁池中，<strong>但是锁池中的所有线程都不会运行，因为他们始终拿不到锁。</strong></p>
<h4 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h4><p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread A is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;thread A get lock&quot;);</span><br><span class="line">                        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                        System.out.println(&quot;thread A do wait method&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(&quot;wait end&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread B is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    System.out.println(&quot;thread B get lock&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    System.out.println(&quot;thread B do notify method&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread A is waiting to get lock</span><br><span class="line">thread A get lock</span><br><span class="line">thread B is waiting to get lock</span><br><span class="line">thread A do wait method</span><br><span class="line">thread B get lock</span><br><span class="line">thread B do notify method</span><br><span class="line">wait end</span><br></pre></td></tr></table></figure>

<p><strong>前提：必须由同一个lock对象调用wait、notify方法</strong></p>
<blockquote>
<ol>
<li>当线程A执行wait方法时，该线程会被挂起；</li>
<li>当线程B执行notify方法时，会唤醒一个被挂起的线程A；</li>
</ol>
</blockquote>
<p><strong>lock对象、线程A和线程B三者是一种什么关系？</strong>根据上面的结论，可以想象一个场景：</p>
<blockquote>
<p>1.lock对象维护了一个等待队列list；<br>2.线程A中执行lock的wait方法，把线程A保存到list中；<br>3.线程B中执行lock的notify方法，从等待队列中取出线程A继续执行；</p>
</blockquote>
<h4 id="3-相关疑问"><a href="#3-相关疑问" class="headerlink" title="3 相关疑问"></a>3 相关疑问</h4><h5 id="3-1-为何wait-amp-notify必须要加synchronized锁"><a href="#3-1-为何wait-amp-notify必须要加synchronized锁" class="headerlink" title="3.1 为何wait&amp;notify必须要加synchronized锁"></a>3.1 为何wait&amp;notify必须要加synchronized锁</h5><p>从实现上来说，这个锁至关重要，正因为这把锁，才能让整个wait/notify玩转起来，当然我觉得其实通过其他的方式也可以实现类似的机制，不过hotspot至少是完全依赖这把锁来实现wait/notify的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Sort(int [] array) &#123;</span><br><span class="line">    &#x2F;&#x2F; synchronize this operation so that some other thread can&#39;t</span><br><span class="line">    &#x2F;&#x2F; manipulate the array while we are sorting it. This assumes that other</span><br><span class="line">    &#x2F;&#x2F; threads also synchronize their accesses to the array.</span><br><span class="line">    synchronized(array) &#123;</span><br><span class="line">        &#x2F;&#x2F; now sort elements in array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized 代码块通过javap生成的字节码中包含** monitorenter 和 monitorexit **指令。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-e4d758d80ff508f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/533/format/webp" alt="javap生成的字节码"></p>
<p>执行 monitorenter 指令可以获取对象的monitor，而 lock.wait() 方法通过调用native方法wait(0)实现，其中接口注释中有这么一句：</p>
<blockquote>
<p>The current thread must own this object’s monitor.</p>
</blockquote>
<p>表示线程执行*<em>lock.wait() *</em>方法时，必须持有该lock对象的monitor，如果wait方法在synchronized代码中执行，该线程很显然已经持有了monitor。</p>
<p><strong>3.2 为什么wait方法可能抛出InterruptedException异常</strong><br>这个异常大家应该都知道，当我们调用了某个线程的interrupt方法时，对应的线程会抛出这个异常，wait方法也不希望破坏这种规则，因此就算当前线程因为wait一直在阻塞，当某个线程希望它起来继续执行的时候，它还是得从阻塞态恢复过来，因此wait方法被唤醒起来的时候会去检测这个状态，当有线程interrupt了它的时候，它就会抛出这个异常从阻塞状态恢复过来。</p>
<p>这里有两点要注意：</p>
<blockquote>
<p>1.如果被interrupt的线程只是创建了，并没有start，那等他start之后进入wait态之后也是不能会恢复的；</p>
<p>2.如果被interrupt的线程已经start了，在进入wait之前，如果有线程调用了其interrupt方法，那这个wait等于什么都没做，会直接跳出来，不会阻塞；</p>
</blockquote>
<p><strong>3.3 notify执行之后立马唤醒线程吗?</strong><br>其实hotspot里真正的实现是退出同步块的时候才会去真正唤醒对应的线程，不过这个也是个默认策略，也可以改的，在notify之后立马唤醒相关线程。</p>
<p><strong>3.4 notifyAll是怎么实现全唤起所有线程</strong><br>或许大家立马想到这个简单，一个for循环就搞定了，不过在JVM里没实现这么简单，而是借助了monitorexit，上面提到了当某个线程从wait状态恢复出来的时候，要先获取锁，然后再退出同步块，所以notifyAll的实现是调用notify的线程在退出其同步块的时候唤醒起最后一个进入wait状态的线程，然后这个线程退出同步块的时候继续唤醒其倒数第二个进入wait状态的线程，依次类推，同样这这是一个策略的问题，JVM里提供了挨个直接唤醒线程的参数，不过都很罕见就不提了。</p>
<p><strong>3.5 wait的线程是否会影响load</strong><br>这个或许是大家比较关心的话题，因为关乎系统性能问题，wait/nofity 是通过JVM里的 park/unpark 机制来实现的，在Linux下这种机制又是通过<br>pthread_cond_wait/pthread_cond_signal 来玩的，因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。</p>
<p>4 其他资料<br>1.<a href="https://blog.csdn.net/boling_cavalry/article/details/77793224" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之一：JVM源码分析</a><br>2.<a href="https://blog.csdn.net/boling_cavalry/article/details/77897108" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之二：修改JVM源码看参数</a><br>3.<a href="https://blog.csdn.net/boling_cavalry/article/details/77995069" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之三：修改JVM源码控制抢锁顺序</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（七）：深入分析Synchronized原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 20:44:03" itemprop="dateCreated datePublished" datetime="2020-06-01T20:44:03+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/Synchronized/" itemprop="url" rel="index"><span itemprop="name">Synchronized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">啃碎并发（六）：Java线程同步与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:30:50 / 修改时间：20:43:38" itemprop="dateCreated datePublished" datetime="2020-06-01T20:30:50+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p><strong>为何要使用Java线程同步？</strong> Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时，将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<p><strong>但其并发编程的根本，就是使线程间进行正确的通信。</strong>其中两个比较重要的关键点，如下：</p>
<blockquote>
<p>1.线程通信：重点关注线程同步的几种方式；<br>2.正确通信：重点关注是否有线程安全问题；</p>
</blockquote>
<p>Java中提供了很多线程同步操作，比如：<strong>synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</strong>本文主要说明一下这几种同步方式的使用及优劣。</p>
<h4 id="1-ReentrantLock可重入锁"><a href="#1-ReentrantLock可重入锁" class="headerlink" title="1 ReentrantLock可重入锁"></a>1 ReentrantLock可重入锁</h4><p>自JDK5开始，新增了Lock接口以及它的一个实现类ReentrantLock。ReentrantLock可重入锁是J.U.C包内置的一个锁对象，可以用来实现同步，基本使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line">    private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000l);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest &#x3D; new ReentrantLockTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子表示 同一时间段只能有1个线程执行execute方法，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br></pre></td></tr></table></figure>
<p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起。</strong>可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1。</p>
<p>举个例子再次说明一下可重入的意思：在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用(调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void anotherLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">Thread-0 invoke anotherLock</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br><span class="line">Thread-1 invoke anotherLock</span><br></pre></td></tr></table></figure>

<h5 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 synchronized</h5><p>synchronized跟ReentrantLock一样，也支持可重入锁。但是它是 一个关键字，是一种语法级别的同步方式，称为内置锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedKeyWordTest &#123;</span><br><span class="line">    public synchronized void execute() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void anotherLock() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynchronizedKeyWordTest reentrantLockTest &#x3D; new SynchronizedKeyWordTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果跟ReentrantLock一样，这个例子说明内置锁可以作用在方法上。synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p>
<p>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p>
<p><strong>synchronized跟ReentrantLock相比，有几点局限性：</strong></p>
<blockquote>
<p>1.加锁的时候不能设置超时。ReentrantLock有提供tryLock方法，可以设置超时时间，如果超过了这个时间并且没有获取到锁，就会放弃，而synchronized却没有这种功能；<br>2.ReentrantLock可以使用多个Condition，而synchronized却只能有1个<br>3.不能中断一个试图获得锁的线程；<br>4.ReentrantLock可以选择公平锁和非公平锁；<br>5.ReentrantLock可以获得正在等待线程的个数，计数器等；</p>
</blockquote>
<p>所以，Lock的操作与synchronized相比，灵活性更高，而且Lock提供多种方式获取锁，有Lock、ReadWriteLock接口，以及实现这两个接口的ReentrantLock类、ReentrantReadWriteLock类。</p>
<p><strong>关于Lock对象和synchronized关键字选择的考量：</strong></p>
<blockquote>
<p>1.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。<br>2.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码。<br>3.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁。</p>
</blockquote>
<p>在性能考量上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h5 id="3-Condition条件对象"><a href="#3-Condition条件对象" class="headerlink" title="3 Condition条件对象"></a>3 Condition条件对象</h5><p>Condition条件对象的意义在于 对于一个已经获取Lock锁的线程，如果还需要等待其他条件才能继续执行的情况下，才会使用Condition条件对象。</p>
<p>Condition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。</p>
<p>为什么方法名不直接叫wait()/notify()/nofityAll()？因为Object的这几个方法是final的，不可重写！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">        Condition condition &#x3D; lock.newCondition();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中thread1执行到condition.await()时，当前线程会被挂起，直到thread2调用了condition.signalAll()方法之后，thread1才会重新被激活执行。</p>
<p>这里需要注意的是thread1调用Condition的await方法之后，thread1线程释放锁，然后马上加入到Condition的等待队列，由于thread1释放了锁，thread2获得锁并执行，thread2执行signalAll方法之后，Condition中的等待队列thread1被取出并加入到AQS中，接下来thread2执行完毕之后释放锁，由于thread1已经在AQS的等待队列中，所以thread1被唤醒，继续执行。</p>
<p>传统线程的通信方式，Condition都可以实现。Condition的强大之处在于它可以为多个线程间建立不同的Condition。</p>
<p>注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<h5 id="4-wait-amp-notify-notifyAll方式"><a href="#4-wait-amp-notify-notifyAll方式" class="headerlink" title="4 wait&amp;notify/notifyAll方式"></a>4 wait&amp;notify/notifyAll方式</h5><p>Java线程的状态转换图与相关方法，如下：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2fb881c9f4656c80.png" alt="线程状态转换图"></p>
<p>在图中，红框标识的部分方法，可以认为已过时，不再使用。上图中的方法能够参与到线程同步中的方法，如下：</p>
<p><strong>1. wait、notify、notifyAll方法：线程中通信可以使用的方法。线程中调用了wait方法，则进入阻塞状态，只有等另一个线程调用与wait同一个对象的notify方法。这里有个特殊的地方，调用wait或者notify，前提是需要获取锁，也就是说，需要在同步块中做以上操作。</strong></p>
<blockquote>
<p>wait/notifyAll方式跟ReentrantLock/Condition方式的原理是一样的。</p>
<p>Java中每个对象都拥有一个内置锁，在内置锁中调用wait，notify方法相当于调用锁的Condition条件对象的await和signalAll方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyAllTest &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">            this.notifyAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WaitNotifyAllTest waitNotifyAllTest &#x3D; new WaitNotifyAllTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doNotify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 调用wait/notifyAll方法的时候一定要获得当前线程的锁，否则会发生IllegalMonitorStateException异常。</p>
<p><strong>2.join方法：该方法主要作用是在该线程中的run方法结束后，才往下执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.thread.simple;</span><br><span class="line">public class ThreadJoin &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread&#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                   System.err.println(&quot;线程&quot;+Thread.currentThread().getId()+&quot; 打印信息&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">     </span><br><span class="line">        try &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;主线程打印信息&quot;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. yield方法：线程本身的调度方法，使用时线程可以在run方法执行完毕时，调用该方法，告知线程已可以出让CPU资源。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. sleep方法：通过sleep(millis)</strong>使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法告诉操作系统 至少在指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。实际上，调用sleep方法时并不要求持有任何锁。</p>
<p>所以，sleep方法并不需要持有任何形式的锁，也就不需要包裹在synchronized中。</p>
<h5 id="5-ThreadLocal"><a href="#5-ThreadLocal" class="headerlink" title="5 ThreadLocal"></a>5 ThreadLocal</h5><p>ThreadLocal是一种把变量放到线程本地的方式来实现线程同步的。比如：SimpleDateFormat不是一个线程安全的类，可以使用ThreadLocal实现同步，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal &#x3D; new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为何SimpleDateFormat不是线程安全的类？具体请参考：</strong></p>
<p><a href="https://blog.csdn.net/zdp072/article/details/41044059" target="_blank" rel="noopener">https://blog.csdn.net/zdp072/article/details/41044059</a><br><a href="https://blog.csdn.net/zq602316498/article/details/40263083" target="_blank" rel="noopener">https://blog.csdn.net/zq602316498/article/details/40263083</a></p>
<p>ThreadLocal与同步机制的对比选择：</p>
<blockquote>
<p>ThreadLocal与同步机制都是 为了解决多线程中相同变量的访问冲突问题。<br>前者采用以 “空间换时间” 的方法，后者采用以 “时间换空间” 的方式。</p>
</blockquote>
<h5 id="6-volatile修饰变量"><a href="#6-volatile修饰变量" class="headerlink" title="6 volatile修饰变量"></a>6 volatile修饰变量</h5><p>volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只给出要修改的代码，其余代码与上同</span><br><span class="line">public class Bank &#123;</span><br><span class="line">    &#x2F;&#x2F;需要同步的变量加上volatile</span><br><span class="line">    private volatile int account &#x3D; 100;</span><br><span class="line">    public int getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这里不再需要synchronized </span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account +&#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</p>
<h5 id="7-Semaphore信号量"><a href="#7-Semaphore信号量" class="headerlink" title="7 Semaphore信号量"></a>7 Semaphore信号量</h5><p>Semaphore信号量被用于控制特定资源在同一个时间被访问的个数。类似连接池的概念，保证资源可以被合理的使用。可以使用构造器初始化资源个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">    private static Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date());</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-0 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-3 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-2 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-4 Mon Apr 18 18:03:56 CST 2016</span><br></pre></td></tr></table></figure>

<h5 id="8-并发包下的工具类"><a href="#8-并发包下的工具类" class="headerlink" title="8 并发包下的工具类"></a>8 并发包下的工具类</h5><h5 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h5><p>CountDownLatch是一个计数器，它的构造方法中需要设置一个数值，用来设定计数的次数。每次调用countDown()方法之后，这个计数器都会减去1，CountDownLatch会一直阻塞着调用await()方法的线程，直到计数器的值变为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;all thread over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-2 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-3 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-4 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-0 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-1 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">all thread over</span><br></pre></td></tr></table></figure>

<h5 id="8-2-CyclicBarrier"><a href="#8-2-CyclicBarrier" class="headerlink" title="8.2 CyclicBarrier"></a>8.2 CyclicBarrier</h5><p>CyclicBarrier阻塞调用的线程，直到条件满足时，阻塞的线程同时被打开。</p>
<p>调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>在CyclicBarrier的构造方法中，还可以设置一个barrierAction。在所有的屏障都到达之后，会启动一个线程来运行这里面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int secs &#x3D; random.nextInt(5);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run, sleep &quot; + secs + &quot; secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(secs * 1000);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; runs over&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比CountDownLatch，CyclicBarrier是可以被循环使用的，而且遇到线程中断等情况时，还可以利用reset()方法，重置计数器，从这些方面来说，CyclicBarrier会比CountDownLatch更加灵活一些。</p>
<h5 id="9-使用原子变量实现线程同步"><a href="#9-使用原子变量实现线程同步" class="headerlink" title="9 使用原子变量实现线程同步"></a>9 使用原子变量实现线程同步</h5><p>有时需要使用线程同步的根本原因在于 对普通变量的操作不是原子的。那么什么是原子操作呢？</p>
<p>原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作<br>即-这几种行为要么同时完成，要么都不完成。</p>
<p>在java.util.concurrent.atomic包中提供了创建原子类型变量的工具类，使用该类可以简化线程同步。比如：其中AtomicInteger以原子方式更新int的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line">    private AtomicInteger account &#x3D; new AtomicInteger(100);</span><br><span class="line"></span><br><span class="line">    public AtomicInteger getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account.addAndGet(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-AbstractQueuedSynchronizer"><a href="#10-AbstractQueuedSynchronizer" class="headerlink" title="10 AbstractQueuedSynchronizer"></a>10 AbstractQueuedSynchronizer</h5><p>AQS是很多同步工具类的基础，比如：ReentrantLock里的公平锁和非公平锁，Semaphore里的公平锁和非公平锁，CountDownLatch里的锁等他们的底层都是使用AbstractQueuedSynchronizer完成的。</p>
<p>基于AbstractQueuedSynchronizer自定义实现一个独占锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class MySynchronizer extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">        if(compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryRelease(int arg) &#123;</span><br><span class="line">        setState(0);</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MySynchronizer mySynchronizer &#x3D; new MySynchronizer();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; will sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-使用阻塞队列实现线程同步"><a href="#11-使用阻塞队列实现线程同步" class="headerlink" title="11 使用阻塞队列实现线程同步"></a>11 使用阻塞队列实现线程同步</h5><p>前面几种同步方式都是基于底层实现的线程同步，但是在实际开发当中，应当尽量远离底层结构。本节主要是使用LinkedBlockingQueue<E>来实现线程的同步。</p>
<p>LinkedBlockingQueue<E>是一个基于链表的队列，先进先出的顺序（FIFO），范围任意的blocking queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.xhj.thread;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BlockingSynchronizedThread &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个阻塞队列用来存储生产出来的商品</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LinkedBlockingQueue&lt;Integer&gt; queue &#x3D; new LinkedBlockingQueue&lt;Integer&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义生产商品个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final int size &#x3D; 10;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int flag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private class LinkBlockThread implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int new_flag &#x3D; flag++;</span><br><span class="line">            System.out.println(&quot;启动线程 &quot; + new_flag);</span><br><span class="line">            if (new_flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    int b &#x3D; new Random().nextInt(255);</span><br><span class="line">                    System.out.println(&quot;生产商品：&quot; + b + &quot;号&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(b);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size &#x2F; 2; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int n &#x3D; queue.take();</span><br><span class="line">                        System.out.println(&quot;消费者买去了&quot; + n + &quot;号商品&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO: handle exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingSynchronizedThread bst &#x3D; new BlockingSynchronizedThread();</span><br><span class="line">        LinkBlockThread lbt &#x3D; bst.new LinkBlockThread();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(lbt);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(lbt);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">啃碎并发（五）：Java线程安全特性与问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:09:11 / 修改时间：20:30:20" itemprop="dateCreated datePublished" datetime="2020-06-01T20:09:11+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在单线程中不会出现线程安全问题，而在多线程编程中，有可能会出现同时访问同一个<strong>共享、可变资源</strong>的情况，这种资源可以是：<strong>一个变量、一个对象、一个文件等。</strong>特别注意两点：</p>
<blockquote>
<p>1.共享： 意味着该资源可以由多个线程同时访问；<br>2.可变： 意味着该资源可以在其生命周期内被修改；</p>
</blockquote>
<p>简单的说，<strong>如果你的代码在单线程下执行和在多线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</strong>那么，当进行多线程编程时，我们又会面临哪些线程安全的要求呢？又是要如何去解决的呢？</p>
<h4 id="1-线程安全特性"><a href="#1-线程安全特性" class="headerlink" title="1 线程安全特性"></a>1 线程安全特性</h4><h5 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h5><p>跟数据库事务的原子性概念差不多，<strong>即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。</strong></p>
<p>关于原子性，一个非常经典的例子就是银行转账问题：</p>
<blockquote>
<p>比如：A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p>
</blockquote>
<h5 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a>1.2 可见性</h5><p>可见性是指，<strong>当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。</strong>可见性问题是好多人忽略或者理解错误的一点。</p>
<p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。<strong>每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。</strong>此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p><strong>这一点是操作系统或者说是硬件层面的机制，</strong>所以很多应用开发人员经常会忽略。</p>
<h5 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3 有序性"></a>1.3 有序性</h5><p>有序性指的是，<strong>程序执行的顺序按照代码的先后顺序执行。</strong>以下面这段代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean started &#x3D; false; &#x2F;&#x2F; 语句1</span><br><span class="line">long counter &#x3D; 0L; &#x2F;&#x2F; 语句2</span><br><span class="line">counter &#x3D; 1; &#x2F;&#x2F; 语句3</span><br><span class="line">started &#x3D; true; &#x2F;&#x2F; 语句4</span><br></pre></td></tr></table></figure>

<p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p>
<p><strong>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</strong></p>
<p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，<strong>CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</strong></p>
<h4 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2 线程安全问题"></a>2 线程安全问题</h4><h5 id="2-1-竞态条件与临界区"><a href="#2-1-竞态条件与临界区" class="headerlink" title="2.1 竞态条件与临界区"></a>2.1 竞态条件与临界区</h5><p>线程之间共享堆空间，在编程的时候就要格外注意避免竞态条件。危险在于多个线程同时访问相同的资源并进行读写操作。<strong>当其中一个线程需要根据某个变量的状态来相应执行某个操作的之前，该变量很可能已经被其它线程修改。</strong></p>
<blockquote>
<p>也就是说，当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在<strong>竞态条件</strong>。导致竟态条件发生的代码称作<strong>临界区</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 以下这段代码就存在竞态条件，其中return ++count就是临界区。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Obj &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public int incr()&#123;</span><br><span class="line">        return ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-死锁"><a href="#2-2-死锁" class="headerlink" title="2.2 死锁"></a>2.2 死锁</h5><p>死锁：<strong>指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</strong>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>关于死锁发生的条件：</strong></p>
<blockquote>
<p><strong>1.互斥条件：</strong>线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。<br><strong>2.请求和保持条件：</strong>线程T1至少已经保持了一个资源R1占用，但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。<br><strong>3.不剥夺条件：</strong>线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。<br><strong>4.环路等待条件：</strong>在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn}，进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。<strong>（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）。</strong></p>
</blockquote>
<h5 id="2-3-活锁"><a href="#2-3-活锁" class="headerlink" title="2.3 活锁"></a>2.3 活锁</h5><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。<strong>这样你让我，我让你，最后两个线程都无法使用资源。</strong></p>
<p><strong>关于“死锁与活锁”的比喻：</strong></p>
<blockquote>
<p><strong>死锁：</strong>迎面开来的汽车A和汽车B过马路，汽车A得到了半条路的资源（满足死锁发生条件1：资源访问是排他性的，我占了路你就不能上来，除非你爬我头上去），汽车B占了汽车A的另外半条路的资源，A想过去必须请求另一半被B占用的道路（死锁发生条件2：必须整条车身的空间才能开过去，我已经占了一半，尼玛另一半的路被B占用了），B若想过去也必须等待A让路，A是辆兰博基尼，B是开奇瑞QQ的屌丝，A素质比较低开窗对B狂骂：快给老子让开，B很生气，你妈逼的，老子就不让（死锁发生条件3：在未使用完资源前，不能被其他线程剥夺），于是两者相互僵持一个都走不了（死锁发生条件4：环路等待条件），而且导致整条道上的后续车辆也走不了。</p>
<p><strong>活锁：</strong>马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。</p>
</blockquote>
<h5 id="2-4-饥饿"><a href="#2-4-饥饿" class="headerlink" title="2.4 饥饿"></a>2.4 饥饿</h5><p>饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，<strong>T2可能永远等待。</strong></p>
<p>也就是，如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，<strong>这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</strong></p>
<p><strong>关于“饥饿”的比喻：</strong></p>
<blockquote>
<p>在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的却没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p>
</blockquote>
<p>在Java中，下面三个常见的原因会导致线程饥饿，如下：</p>
<p><strong>1.高优先级线程吞噬所有的低优先级线程的CPU时间</strong></p>
<blockquote>
<p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。</p>
</blockquote>
<p><strong>2.线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问</strong></p>
<blockquote>
<p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>
</blockquote>
<p><strong>3.线程在等待一个本身（在其上调用wait()）也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒</strong></p>
<blockquote>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
</blockquote>
<h5 id="2-5-公平"><a href="#2-5-公平" class="headerlink" title="2.5 公平"></a>2.5 公平</h5><p><strong>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。</strong>在Java中实现公平性方案，需要：</p>
<blockquote>
<p>1.使用锁，而不是同步块；<br>2.使用公平锁；<br>3.注意性能方面；</p>
</blockquote>
<p>在Java中实现公平性，虽Java不可能实现100%的公平性，依然可以通过同步结构在线程间实现公平性的提高。</p>
<p>首先来学习一段简单的同步态代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    public synchronized void doSynchronized () &#123;</span><br><span class="line">        &#x2F;&#x2F; do a lot of work which takes a long time</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。</p>
<p>改为 使用锁方式替代同步块，为了提高等待线程的公平性，我们使用锁方式来替代同步块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line">    public void doSynchronized() throws InterruptedException&#123;</span><br><span class="line">        this.lock.lock();</span><br><span class="line">        &#x2F;&#x2F;critical section, do a lot of work which takes a long time</span><br><span class="line">        this.lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。下面是用Lock类做的一个实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Lock&#123;</span><br><span class="line"></span><br><span class="line">    private boolean isLocked      &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException&#123;</span><br><span class="line">        while(isLocked)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; true;</span><br><span class="line">        lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。</p>
<p>这回看下doSynchronized()，你会注意到在lock()和unlock()之间的注释：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。</p>
<p>在早些时候提到过，同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。</p>
<p>但我们能够改变这种情况，如下：</p>
<blockquote>
<p>当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
</blockquote>
<p>下面将上面Lock类转变为公平锁FairLock。你会注意到新的实现和之前的Lock类中的同步和wait()/notify()稍有不同。重点是，每一个调用lock()的线程都会进入一个队列，当解锁时，只有队列里的第一个线程被允许锁住FairLock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class FairLock &#123;</span><br><span class="line">    private boolean isLocked &#x3D; false;</span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line">    private List&lt;QueueObject&gt; waitingThreads &#x3D; new ArrayList&lt;QueueObject&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() throws InterruptedException&#123;</span><br><span class="line">        &#x2F;&#x2F; 当前线程创建“令牌”</span><br><span class="line">        QueueObject queueObject &#x3D; new QueueObject();</span><br><span class="line">        boolean isLockedForThisThread &#x3D; true;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            &#x2F;&#x2F; 所有线程的queueObject令牌，入队</span><br><span class="line">            waitingThreads.add(queueObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(isLockedForThisThread)&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                &#x2F;&#x2F; 1. 判断是否已被锁住：是否已有线程获得锁，正在执行同步代码块</span><br><span class="line">                &#x2F;&#x2F; 2. 判断头部令牌与当前线程令牌是否一致：也就是只锁住头部令牌对应的线程；</span><br><span class="line">                isLockedForThisThread &#x3D; isLocked || waitingThreads.get(0) !&#x3D; queueObject;</span><br><span class="line">                if(!isLockedForThisThread)&#123;</span><br><span class="line">                    isLocked &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; 移除头部令牌</span><br><span class="line">                    waitingThreads.remove(queueObject);</span><br><span class="line">                    lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                &#x2F;&#x2F; 其他线程执行doWait()，进行等待</span><br><span class="line">                queueObject.doWait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        if(waitingThreads.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 唤醒头部令牌对应的线程，可以执行</span><br><span class="line">            waitingThreads.get(0).doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QueueObject &#123;</span><br><span class="line">    private boolean isNotified &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() throws InterruptedException &#123;</span><br><span class="line">        while(!isNotified)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.isNotified &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        this.isNotified &#x3D; true;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        return this &#x3D;&#x3D; o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先注意到lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。</p>
<blockquote>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队操作。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p>
</blockquote>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个线程调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。</p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p>
<h4 id="3-如何确保线程安全特性"><a href="#3-如何确保线程安全特性" class="headerlink" title="3 如何确保线程安全特性"></a>3 如何确保线程安全特性</h4><h5 id="3-1-如何确保原子性"><a href="#3-1-如何确保原子性" class="headerlink" title="3.1 如何确保原子性"></a>3.1 如何确保原子性</h5><h5 id="3-1-1-锁和同步"><a href="#3-1-1-锁和同步" class="headerlink" title="3.1.1 锁和同步"></a>3.1.1 锁和同步</h5><p>常用的保证Java操作原子性的工具是 锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    synchronized (anyObject)&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论使用锁还是synchronized，本质都是一样，通过锁或同步来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</p>
<h5 id="3-1-2-CAS（compare-and-swap）"><a href="#3-1-2-CAS（compare-and-swap）" class="headerlink" title="3.1.2 CAS（compare and swap）"></a>3.1.2 CAS（compare and swap）</h5><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line">for(int b &#x3D; 0; b &lt; numThreads; b++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for(int a &#x3D; 0; a &lt; iteration; a++) &#123;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-如何确保可见性"><a href="#3-2-如何确保可见性" class="headerlink" title="3.2 如何确保可见性"></a>3.2 如何确保可见性</h5><p>Java提供了volatile关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它线程缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
<p>volatile适用场景：volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isRunning &#x3D; false;</span><br><span class="line">public void start () &#123;</span><br><span class="line">    new Thread( () -&gt; &#123;</span><br><span class="line">        while(isRunning) &#123;</span><br><span class="line">            someOperation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">public void stop () &#123;</span><br><span class="line">    isRunning &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用stop()方法将isRunning设置为false，循环也不一定会立即结束。可以通过volatile关键字，保证while循环及时得到isRunning最新的状态从而及时停止循环，结束线程。</p>
<h5 id="3-3-如何确保有序性"><a href="#3-3-如何确保有序性" class="headerlink" title="3.3 如何确保有序性"></a>3.3 如何确保有序性</h5><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p>
<blockquote>
<p>Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。</p>
</blockquote>
<p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p>
<p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p>
<p>happens-before原则（先行发生原则），如下：</p>
<blockquote>
<p><strong>1.传递规则：</strong>如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性。<br><strong>2.锁定规则：</strong>一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取。<br><strong>3.volatile变量规则：</strong>对一个被volatile修饰的写操作先发生于后面对该变量的读操作。<br><strong>4.程序次序规则：</strong>一个线程内，按照代码顺序执行。<br><strong>5.线程启动规则：</strong>Thread对象的start()方法先发生于此线程的其它动作。<br><strong>6.线程终结原则：</strong>线程的终止检测后发生于线程中其它的所有操作。<br><strong>7.线程中断规则： *<em>对线程interrupt()方法的调用先发生于对该中断异常的获取。<br>*</em>8.对象终结规则：</strong>一个对象构造先于它的finalize发生。</p>
</blockquote>
<h5 id="4-关于线程安全的几个为什么"><a href="#4-关于线程安全的几个为什么" class="headerlink" title="4 关于线程安全的几个为什么"></a>4 关于线程安全的几个为什么</h5><p><strong>1.平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？</strong></p>
<blockquote>
<p>锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。</p>
</blockquote>
<p><strong>2.锁和synchronized为何能保证可见性？</strong></p>
<blockquote>
<p>根据JDK 7的Java doc中对concurrent包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由happen-before原则推断出在读操作之前发生。</p>
</blockquote>
<p><strong>3.既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？</strong></p>
<blockquote>
<p>synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</p>
</blockquote>
<p><strong>4.既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？</strong></p>
<blockquote>
<p>锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。</p>
</blockquote>
<p><strong>5.还有没有别的办法保证线程安全？</strong></p>
<blockquote>
<p>有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。</p>
</blockquote>
<p><strong>6.synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？</strong></p>
<blockquote>
<p>synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/Android%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Android%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">Android基础之四大组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 15:33:18" itemprop="dateCreated datePublished" datetime="2020-06-01T15:33:18+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Android基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity生命周期"></p>
<p>注意：当activityB在activityA之前启动时，将在A上调用onPause()回调。在A的onPause()返回之前，将不会创建B，因此请确保onPause()中不要做任何冗长的操作。</p>
<ol>
<li><p>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为entire lifetime。</p>
</li>
<li><p>当执行onStart回调方法时，Activity开始被用户所见（也就是说，onCreate时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到onStop之前，此阶段Activity都是被用户可见，称之为visible lifetime。</p>
</li>
<li><p>当执行到onResume回调方法时，Activity可以响应用户交互，一直到onPause方法之前，此阶段Activity称之为foreground lifetime。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序启动</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.687</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.819</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.823</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.802</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.815</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.824</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">54.156</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.672</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.716</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.717</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br><span class="line"><span class="comment">// 按下home键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.703</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.722</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.723</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 返回应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.968</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">20.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.274</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.925</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.959</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.963</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入task</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.056</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.068</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.088</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 后台终止</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">51.310</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="打印生命周期"><a href="#打印生命周期" class="headerlink" title="打印生命周期"></a>打印生命周期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BaseActivity"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onCreate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onResume"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onPause"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onRestart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStop"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onNewIntent"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onActivityResult"><a href="#onActivityResult" class="headerlink" title="onActivityResult"></a>onActivityResult</h2><p>MainActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>), 0)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"MainActivity-onActivityResult"</span>);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"result = "</span> + data.getStringExtra(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecondActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"value"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">setResult(<span class="number">1</span>, intent);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.038</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.070</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.166</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.170</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.659</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.672</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.679</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.682</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">40.015</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">48.965</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onActivityResult</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: result = hearing</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.395</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.396</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br></pre></td></tr></table></figure>

<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>通过android:launchMode配置</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是Activity默认的启动模式，在不指定Activity启动模式的情况下，所有Activity使用的都是standard模式。</p>
<p>在standard模式下，每当启动一个新的Activity，它就会进入任务栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会判断该Activity在栈中是否存在，每次启动都会创建一个新的实例。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop模式与standard类似，不同的是，当启动的Activity已经位于栈顶时，则直接使用它不创建新的实例，此时栈顶的Activity实例会调onNewIntent方法。如果启动的Activity没有位于栈顶时，则创建一个新的实例位于栈顶。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>如果希望Activity在整个应用程序中只存在一个实例，可以使用singleTask模式，当Activity的启动模式指定为 singleTask，每次启动该Activity时，系统首先会检查栈中是否存在该Activity的实例，如果发现已经存在则直接使用该实例，此时栈顶的Activity实例会调onNewIntent方法，并将当前Activity之上的所有Activity出栈，如果没有发现则创建一个新的实例。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>在程序开发过程中，如果需要Activity在整个系统中都只有一个实例，这时就需要用到singleInstance模式。指定为singleInstance模式的Activity会启动一个新的任务栈来管理这个Activity。</p>
<p>singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。采用这种模式启动Activity会分为一下两种情况：</p>
<ul>
<li>如果要启动的Activity不存在，系统会创建一个新的任务栈，在创建该Activity的实例，并把该Activity加入栈顶.</li>
<li>如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。</li>
</ul>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a>allowTaskReparenting</h3><p>如果该Activity的allowTaskReparenting设置为true，它进入后台，当一个和它有相同affinity的Task进入前台时，它会重新宿主，进入到该前台的task中。</p>
<table>
<thead>
<tr>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">taskAffinity</th>
<th align="center">allowTaskReparenting</th>
</tr>
</thead>
<tbody><tr>
<td align="center">application1</td>
<td align="center">Activity1</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">application2</td>
<td align="center">Activity2</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>创建两个工程：application1和application2，分别含有Activity1和Activity2，它们的taskAffinity相同，Activity1的allowTaskReparenting为true。</p>
<p>首先，我们启动application1,加载Activity1，然后按Home键，使该task（假设为task1）进入后台。然后启动application2，默认加载Activity2。本来应该是显示Activity2，但是我们却看到了Activity1。实际上Activity2也被加载了，只是Activity1重新宿主，所以看到了Activity1。</p>
<h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>如果加载某个Activity的intent，Flag被设置成FLAG_ACTIVITY_NEW_TASK时，它会首先检查是否存在与自己taskAffinity相同的Task，如果存在，那么它会直接宿主到该Task中，如果不存在则重新创建Task。</p>
<p>写一个应用，包含两个Activity：Activity1的taskAffinity为<code>com.hearing.task</code>，Activity2为入口，且点击Activity2会以FLAG_ACTIVITY_NEW_TASK启动Activity1。再写一个应用MyActivity，它包含一个Activity（MyActivity），其taskAffinity为<code>com.hearing.task</code>。</p>
<p>首先启动MyActivity，然后Home回桌面，然后打开Activity2，点击Activity2，进入Activity1。然后按返回键。进入Activity的顺序为Activity2-&gt;Activity1，而返回时顺序为Activity1-&gt;MyActivity。这就说明了一个问题，Activity1在启动时，重新宿主到了MyActivity所在的Task中去了。</p>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul>
<li>当一个应用程序加载一个singleTask模式的Activity时，首先该Activity会检查是否存在与它的taskAffinity相同的Task。如果存在，那么检查是否实例化，如果已经实例化，那么销毁在该Activity以上的Activity并调用onNewIntent。如果没有实例化，那么该Activity实例化并入栈。如果不存在，那么就重新创建Task，并入栈。</li>
<li>当一个应用程序加载一个singleInstance模式的Activity时，如果该Activity没有被实例化，那么就重新创建一个Task，并入栈，如果已经被实例化，那么就调用该Activity的onNewIntent.singleInstance的Activity所在的Task不允许存在其他Activity，任何从该Activity加载的其它Activity（假设为Activity2）都会被放入其它的Task中，如果存在与Activity2相同affinity的Task，则在该Task内创建Activity2。如果不存在，则重新生成新的Task并入栈。</li>
</ul>
<h2 id="onSaveInstanceState与onRestoreInstanceState方法"><a href="#onSaveInstanceState与onRestoreInstanceState方法" class="headerlink" title="onSaveInstanceState与onRestoreInstanceState方法"></a>onSaveInstanceState与onRestoreInstanceState方法</h2><p>onSaveInstanceState主要是用于保存一些临时数据，当Activity恢复时，可以恢复对应的数据，onRestoreInstanceState当Activity被重新创建时调用，可以从该 方法中恢复一些之前保存过的数据。</p>
<p>onSaveInstanceState一般是在Activity被“打断”的情况下被调用，例如被覆盖，包括全覆盖或者部分覆盖，或者按home退到后台，或者灭屏。另外一种情况就是Activity被重新创建会调用，例如用户在当前Activity旋转屏幕，或者用户调用recreate方法。点击返回键该方法不会被调用。onSaveInstanceState的调用顺序是在onPause之后，onStop之前。</p>
<p>onRestoreInstanceState一般是在Activty被重新创建恢复时会被调用，例如用户切换横竖屏。用户将Activty挂后台，切换系统设置，然后再启动该Activity。</p>
<h2 id="启动方式的问题"><a href="#启动方式的问题" class="headerlink" title="启动方式的问题"></a>启动方式的问题</h2><p>MainActivity是SingleTask或者SingleInstance模式，启动TestActivity，TestActivity马上跳转到MainActivity，这种情况下，MainActivity的onResume会回调两次。日志如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onCreate</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onStart</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">TestActivity onCreate</span><br><span class="line">TestActivity onStart</span><br><span class="line">TestActivity onResume</span><br><span class="line">TestActivity onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onNewIntent</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">TestActivity onStop</span><br></pre></td></tr></table></figure>

<p>适当延时500ms再跳转回MainActivity可以解决这个问题（可能由于业务场景不同，会带来新的问题）。</p>
<p>在<a href="https://stackoverflow.com/questions/11092101/startactivity-on-foreground-application-causes-onpause-onresume" target="_blank" rel="noopener">stackoverflow</a>上也有人发现过类似的问题。</p>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>普通广播（Normal Broadcast）</li>
<li>系统广播（System Broadcast）</li>
<li>有序广播（Ordered Broadcast）</li>
<li>粘性广播（Sticky Broadcast）（已弃用）</li>
<li>App应用内广播（Local Broadcast）</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="BroadcastReceiver-1"><a href="#BroadcastReceiver-1" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><ul>
<li>继承BroadcastReceivre基类</li>
<li>必须复写抽象方法onReceive()方法</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><ul>
<li>常驻：不受任何组件声明周期影响</li>
<li>耗电，占内存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    //此<span class="attr">broadcastReceiver</span>能否接收其他<span class="attr">App</span>的发出的广播</span></span><br><span class="line"><span class="tag">    //默认值是由<span class="attr">receiver</span>中有无<span class="attr">intent-filter</span>决定的：如果有<span class="attr">intent-filter</span>，默认值为<span class="attr">true</span>，否则为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    //继承<span class="attr">BroadcastReceiver</span>子类的类名</span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".mBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">    //具有相应权限的广播发送者发送的广播才能被此<span class="attr">BroadcastReceiver</span>所接收；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">BroadcastReceiver</span>运行所处的进程</span></span><br><span class="line"><span class="tag">    //默认为<span class="attr">app</span>的进程，可以指定独立的进程</span></span><br><span class="line"><span class="tag">    //注：<span class="attr">Android</span>四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    //用于指定此广播接收器将接收的广播类型</span><br><span class="line">    //本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><ul>
<li>非常驻，灵活</li>
<li>手动释放</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">    mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> mBroadcastReceiver();</span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中</span></span><br><span class="line"><span class="comment">// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</li>
<li>假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>生命周期:</p>
<ol>
<li><p>startService()</p>
<ul>
<li>作用：启动Service服务</li>
<li>手动调用startService()后，自动调用内部方法：onCreate()、onStartCommand() </li>
<li>如果一个service被startService多次启动，onCreate()只会调用一次 </li>
<li>onStartCommand()调用次数=startService()次数</li>
</ul>
</li>
<li><p>stopService()</p>
<ul>
<li>作用：关闭Service服务 </li>
<li>手动调用stopService()后，自动调用内部方法：onDestory() </li>
<li>如果一个service被启动且被绑定，如果没有在绑定的前提下stopService()是无法停止服务的。</li>
</ul>
</li>
<li><p>bindService()</p>
<ul>
<li>作用：绑定Service服务 </li>
<li>手动调用bindService()后，自动调用内部方法：onCreate()、onBind()</li>
</ul>
</li>
<li><p>unbindService()</p>
<ul>
<li>作用：解绑Service服务 </li>
<li>手动调用unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory()</li>
</ul>
</li>
</ol>
<p>接口函数：</p>
<ul>
<li>onStartCommand()：当其他组件调用startService()方法请求启动Service时，该方法被回调。一旦Service启动，它会在后台独立运行。当Service执行完以后，需调用stopSelf() 或 stopService()方法停止Service。（若您只希望bind Service，则无需调用这些方法）</li>
<li>onBind()：当其他组件调用bindService()方法请求绑定Service时，该方法被回调。该方法返回一个IBinder接口，该接口是Service与绑定的组件进行交互的桥梁。若Service未绑定其他组件，该方法应返回null。</li>
<li>onCreate()：当Service第一次创建时，回调该方法。该方法只被回调一次，并在onStartCommand() 或 onBind()方法被回调之前执行。若Service处于运行状态，该方法不会回调。</li>
<li>onDestroy()：当Service被销毁时回调，在该方法中应清除一些占用的资源，如停止线程、接触绑定注册的监听器或broadcast receiver 等。该方法是Service中的最后一个回调。</li>
</ul>
<p>启动方式：</p>
<ul>
<li>Started：其他组件调用startService()方法启动一个Service。一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。通常，一个被start的Service会在后台执行单独的操作，也并不给启动它的组件返回结果。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</li>
<li>Bound：其他组件调用bindService()方法绑定一个Service。通过绑定方式启动的Service是一个client-server结构，该Service可以与绑定它的组件进行交互。一个bound service仅在有组件与其绑定时才会运行（A bound service runs only as long as another application component is bound to it），多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。</li>
</ul>
<p>注意：</p>
<ul>
<li>Service运行在主线程中（A service runs in the main thread of its hosting process），Service并不是一个新的线程，也不是新的进程。也就是说，若您需要在Service中执行较为耗时的操作（如播放音乐、执行网络请求等），需要在Service中创建一个新的线程。这可以防止ANR的发生，同时主线程可以执行正常的UI操作。</li>
<li>如果某个组件通过调用startService()启动了Service（系统会回调onStartCommand()方法），那么直到在Service中手动调用stopSelf()方法、或在其他组件中手动调用stopService()方法，该Service才会停止。</li>
<li>如果某个组件通过调用bindService()绑定了Service（系统不会回调onStartCommand()方法），只要该组件与Service处于绑定状态，Service就会一直运行，当Service不再与组件绑定时，该Service将被destroy。</li>
<li>当系统内存低时，系统将强制停止Service的运行；若Service绑定了正在与用户交互的activity，那么该Service将不大可能被系统kill（ less likely to be killed）。如果创建的是前台Service，那么该Service几乎不会被kill（almost never be killed）。否则，当创建了一个长时间在后台运行的Service后，系统会降低该Service在后台任务栈中的级别——这意味着它容易被kill（lower its position in the list of background tasks over time and the service will become highly susceptible to killing），所以在开发Service时，需要使Service变得容易被restart，因为一旦Service被kill，再restart它需要其资源可用时才行</li>
</ul>
<h2 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.servicetest.MyService"</span> &gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承IntentService类"><a href="#继承IntentService类" class="headerlink" title="继承IntentService类"></a>继承IntentService类</h2><ul>
<li>默认在子线程中处理回传到onStartCommand()方法中的Intent；</li>
<li>在重写的onHandleIntent()方法中处理按时间排序的Intent队列，所以不用担心多线程（multi-threading）带来的问题。</li>
<li>当所有请求处理完成后，自动停止service，无需手动调用stopSelf()方法；</li>
<li>默认实现了onBind()方法，并返回null；</li>
<li>默认实现了onStartCommand()方法，并将回传的Intent以序列的形式发送给onHandleIntent()，只需重写该方法并处理Intent即可。</li>
</ul>
<h2 id="继承Service类"><a href="#继承Service类" class="headerlink" title="继承Service类"></a>继承Service类</h2><p>如果需要在Service中执行多线程而不是处理一个请求队列，那么需要继承Service类，分别处理每个Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Log.d(TAG, <span class="string">"onCreate() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">		Log.d(TAG, <span class="string">"onStartCommand() executed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">		Log.d(TAG, <span class="string">"onDestroy() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mBinder;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="string">"TAG"</span>, <span class="string">"startDownload() executed"</span>);</span><br><span class="line">			<span class="comment">// 执行具体的下载任务</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onStartCommand()返回一个整形变量，该变量必须是下列常量之一：</p>
<ul>
<li>START_NOT_STICKY：若执行完onStartCommand()方法后，系统就kill了service，不要再重新创建service，除非系统回传了一个pending intent。这避免了在不必要的时候运行service，您的应用也可以restart任何未完成的操作。</li>
<li>START_STICKY：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()。dangerous不要重新传递最后一个Intent（do not redeliver the last intent）。相反，系统回调onStartCommand()时回传一个空的Intent，除非有 pending intents传递，否则Intent将为null。该模式适合做一些类似播放音乐的操作。</li>
<li>START_REDELIVER_INTENT：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()并将最后一个Intent回传至该方法。任何 pending intents都会被轮流传递。该模式适合做一些类似下载文件的操作。</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>startService(intent)方法将立即返回，并回调onStartCommand()（请不要手动调用该方法），若该Service未处于运行状态，系统将首先回调onCreate()，接着再回调onStartCommand()。若您希望Service可以返回结果，那么需要通过调用getBroadcast 返回的PendingIntent启动Service（将PendingIntent包装为Intent），service可使用broadcast 传递结果。</p>
<p>多个启动Service的请求可能导致onStartCommand()多次调用，但只需调用stopSelf() 、 stopService()这两个方法之一，就可停止该服务。</p>
<h2 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h2><ul>
<li>通过其他组件调用bindService()方法可以绑定一个Service以保持长连接（long-standing connection），这时一般不允许其他组件调用startService()启动Service。</li>
<li>当其他组件需要与Service交互或者需要跨进程通信时，可以创建一个bound Service。</li>
<li>为创建一个bound Service，必须重写onBind()回调，该方法返回一个IBinder接口。该接口时组件与Service通信的桥梁。组件调用bindService()与Service绑定，该组件可获取IBinder接口，一旦获取该接口，就可以调用Service中的方法。一旦没有组件与Service绑定，系统将destroy它，您不必手动停止它。</li>
<li>为创建一个bound Service，必须定义一个接口 ，该接口指定组件与Service如何通信。定义的接口在组件与Service之间，且必须实现IBinder接口。这正是onBind()的返回值。一旦组件接收了IBinder，组件与Service便可以开始通信。</li>
<li>多个组件可同时与Service绑定，当组件与Service交互结束后，可调用unbindService()方法解绑。bound Service比start Service要复杂，故我将在后续单独翻译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyService.MyBinder myBinder;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">			myBinder = (MyService.MyBinder) service;</span><br><span class="line">			myBinder.startDownload();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.start_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			startService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">			Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			stopService(stopIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">			Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">			unbindService(connection);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行前台Service"><a href="#运行前台Service" class="headerlink" title="运行前台Service"></a>运行前台Service</h2><ul>
<li>前台Service用于动态通知消息，如天气预报。该Service不易被kill。前台Service必须提供status bar，只有前台Service被destroy后，status bar才能消失。</li>
<li>举例来说，一个播放音乐的Service必须是前台Service，只有这样用户才能确知其运行状态。为前台Service提供的status bar可以显示当前音乐的播放状态，并可以启动播放音乐的Activity。</li>
<li>调用startForeground()可以启动前台Service。该方法接收两个参数，参数一是一个int型变量，用户指定该通知的唯一性标识，而参数而是一个Notification用于配置status bar</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ContentProvider为不同的应用之间数据共享提供统一的接口，Android系统中应用内部的数据是对外隔离的，要想让其它应用能够访问自己的数据，可以使用ContentProvider，其底层采用Binder机制实现跨进程共享数据。</p>
<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p>Uri的四个组成部分：content://contacts/people/5</p>
<ul>
<li>schema：已由Android固定设置为content://</li>
<li>authority：ContentProvider权限，在AndroidMenifest中设置权限</li>
<li>path：要操作的数据库表</li>
<li>id：查询的关键字（可选字段）</li>
</ul>
<p>Uri匹配模式：Uri的匹配表示要查询的数据，对于单个数据查询，可直接使用Uri定位具体的资源位置，但当范围查询时就需要结合通配符的使用，Uri提供以下两种通配符：</p>
<ul>
<li><code>*</code>：匹配由任意长度的任何有效字符组成的字符串</li>
<li><code>#</code>：匹配由任意长度的数字字符组成的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table2/*  //多数据查询</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/#</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/6  //单数据查询</span></span><br></pre></td></tr></table></figure>

<p>Uri的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(“content:<span class="comment">//contacts/people/5")</span></span><br></pre></td></tr></table></figure>

<p>Uri创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过将 ID 值追加到 URI 末尾来访问表中的单个行</span></span><br><span class="line">Uri singleUri = ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ContentUris"><a href="#ContentUris" class="headerlink" title="ContentUris"></a>ContentUris</h2><p>核心方法有两个：</p>
<ul>
<li>withAppendedId()：向Uri追加一个id</li>
<li>parseId()：从Uri中获取id</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>)</span><br><span class="line"><span class="comment">// 生成的Uri为：content://cn.scu.myprovider/user/7</span></span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user/7"</span>)</span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>

<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p>UriMatcher的作用：</p>
<ul>
<li>在ContentProvider 中注册Uri</li>
<li>根据 Uri 匹配 ContentProvider 中对应的数据表</li>
</ul>
<p>使用步骤：</p>
<ol>
<li>初始化UriMatcher对象</li>
<li>在ContentProvider 中注册URI（addURI()）</li>
<li>根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match()）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line"><span class="comment">// 常量UriMatcher.NO_MATCH：不匹配任何路径的返回码</span></span><br><span class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI</span></span><br><span class="line"><span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user1"</span>, URI_CODE_a); </span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user2"</span>, URI_CODE_b); </span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a</span></span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(matcher.match(uri)) &#123;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_a:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser1;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_b:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentProvider-1"><a href="#ContentProvider-1" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>ContentProvider主要以表格的形式组织数据，同时也支持文件数据。它一般配合数据库共同使用，实现对外共享数据的目的，所以它需要对数据库的增删改查操作，ContentProvider也为我们提供了相应的操作方法，使用时只需实现即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后或打开系统后其它进程第一次访问该ContentProvider时由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前 Uri 所代表数据的MIME类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>上述CRUD方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</li>
<li>存在多线程并发访问，需要实现线程同步<ul>
<li>若ContentProvider的数据存储方式是使用一个SQLite，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</li>
<li>若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</li>
</ul>
</li>
</ol>
<h2 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a>ContentResolver</h2><p>外部进程通过 ContentResolver类，从而与ContentProvider类进行交互。一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大，所以在ContentProvider类上加多了一个 ContentResolver类对所有的ContentProvider进行统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.hearing.provider.myprovider/tablename"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条记录</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">values.put(<span class="string">"age"</span>, <span class="number">26</span>);</span><br><span class="line">resolver.insert(uri, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tablename表中所有记录</span></span><br><span class="line">Cursor cursor = resolver.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"tablename data"</span>);</span><br><span class="line"><span class="keyword">while</span>(cursor.moveToNext()) &#123;</span><br><span class="line">   Log.i(<span class="string">"ContentTest"</span>, <span class="string">"tablename_id="</span>+ cursor.getInt(<span class="number">0</span>)+ <span class="string">", name="</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把id为1的记录的name字段值更改新为zhang1</span></span><br><span class="line">ContentValues updateValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">updateValues.put(<span class="string">"name"</span>, <span class="string">"zhang1"</span>);</span><br><span class="line">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.update(updateIdUri, updateValues, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除id为2的记录，即字段age</span></span><br><span class="line">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.delete(deleteIdUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>com.hearing.provider.myprovider需要在 AndroidManifest.xml 中进行注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"com.hearing.provider.myprovider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ContentObserver"><a href="#ContentObserver" class="headerlink" title="ContentObserver"></a>ContentObserver</h2><p>观察者模式：当ContentProvider中指定Uri中的数据变化时通知外界。</p>
<p>自定义ContentObserver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, myOberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">        db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values); </span><br><span class="line">        getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line">getContentResolver().unregisterContentObserver(myOberver);</span><br></pre></td></tr></table></figure>

<h2 id="MimeType"><a href="#MimeType" class="headerlink" title="MimeType"></a>MimeType</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>ContentProvider 类具有两个返回 MIME 类型的方法：</p>
<ul>
<li>getType()：任何ContentProvider程序都需要实现的方法</li>
<li>getStreamTypes()：当ContentProvider程序提供文件时要求实现</li>
</ul>
<h3 id="table的-MIME-类型"><a href="#table的-MIME-类型" class="headerlink" title="table的 MIME 类型"></a>table的 MIME 类型</h3><p>getType() 方法会返回一个 MIME 格式的 String，后者描述内容 URI 参数返回的数据类型。Uri 参数可以是pattern，而不是特定 URI；在这种情况下应该返回与匹配该模式的内容 URI 关联的数据类型。</p>
<p>对于文本、HTML 或 JPEG 等常见数据类型，getType() 应该为该数据返回标准 MIME 类型。</p>
<p>对于指向一个或多个表数据行的内容 URI，getType() 应该以 Android 供应商特有 MIME 格式返回 MIME 类型：</p>
<ol>
<li>类型部分：vnd</li>
<li>子类型部分：<ul>
<li>如果 URI 模式用于单个行：android.cursor.item/</li>
<li>如果 URI 模式用于多个行：android.cursor.dir/</li>
</ul>
</li>
<li>程序特有部分：<code>vnd.&lt;name&gt;.&lt;type&gt;</code><br> <code>&lt;name&gt;</code>值应具有全局唯一性，<type> 值应在对应的 URI pattern 中具有唯一性。通常使用包名或者公司域名作为<code>&lt;name&gt;</code>。适合选择 URI 关联表的标识字符串作为<code>&lt;type&gt;</code>。</li>
</ol>
<p>例如，如果ContentProvider的authority是 com.example.app.provider，并且它公开了一个名为 table1 的表，则 table1 中多个行的 MIME 类型是：<code>vnd.android.cursor.dir/vnd.com.example.provider.table1</code>；对于 table1 的单个行，MIME 类型是：<code>vnd.android.cursor.item/vnd.com.example.provider.table1</code>。</p>
<h3 id="文件的-MIME-类型"><a href="#文件的-MIME-类型" class="headerlink" title="文件的 MIME 类型"></a>文件的 MIME 类型</h3><p>如果 ContentProvider 程序提供文件，则需要实现 getStreamTypes()。该方法返回一个 MIME 类型的 String 数组，表示给定的 URI 返回的文件类型。</p>
<p>例如，假设提供程序以 .jpg、.png 和 .gif 格式文件形式提供照片图像。如果应用调用 ContentResolver.getStreamTypes() 时使用了过滤器字符串 image/*，则 ContentProvider.getStreamTypes() 方法应返回数组：<code>{ &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;}</code></p>
<p>如果应用只对 .jpg 文件感兴趣，则可以在调用 ContentResolver.getStreamTypes() 时使用过滤器字符串 */jpeg，ContentProvider.getStreamTypes() 应返回：<code>{&quot;image/jpeg&quot;}</code></p>
<p>如果程序未提供过滤器字符串中请求的任何 MIME 类型，则 getStreamTypes() 应返回 null。</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>指定其他应用访问提供程序的数据所必须具备权限的属性。</p>
<h3 id="grantUriPermssions"><a href="#grantUriPermssions" class="headerlink" title="grantUriPermssions"></a>grantUriPermssions</h3><p><code>android:grantUriPermssions</code>：表示是否可以通过临时权限访问数据，默认为false，在开发中可以只对限定的内容提供临时权限，如对照片的内容 URI 设置临时权限。</p>
<ul>
<li><p>true：系统会向整个系统授予临时权限，并替代其他设置的权限。</p>
</li>
<li><p>false：需添加<code>&lt;grant-uri-permission&gt;</code>并表明可以授权临时权限所对应的URI</p>
<ul>
<li><p>path：表示绝对路径Uri</p>
</li>
<li><p>pathPattern：表示限定完整的路径但可以使用./*通配符匹配</p>
</li>
<li><p>pathPrefix：限定路径的初始部分后面可以变化，只要初始部分符合即可授权</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:grantUriPermissions="false"</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">grant-uri-permission</span> <span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h3><ul>
<li>android:permission：统一提供程序范围读取/写入权限</li>
<li>android:readPermission：提供程序范围读取权限，优先于permission权限</li>
<li>android:writePermission：提供程序范围写入权限，优先于permission权限</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:readPermission="com.hearing.provider.permission.READ_PERMISSION"</span><br><span class="line">android:writePermission="com.hearing.provider.permission.WRITE_PERMISSION"</span><br><span class="line">android:permission="com.hearing.provider.permission.PERMISSION"</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建两个程序A和B，在程序A中使用ContentProvider保存数据，在程序B中进行查询，在开始A程序中不设置任何权限，B程序进行访问数据会报错；</li>
<li>修改A程序清单文件添加android:exported=”true”，再次访问数据访问成功；</li>
<li>在A程序的清单文件中，为Provider添加两个读写权限，添加完权限后再次在B程序中获取数据，还是会报错，也很正常因为已经对数据的访问设置了门槛，所以在B程序中声明读写权限即可。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A程序 --&gt;</span></span><br><span class="line">android:writePermission="com.alex.kotlin.job.provider.WRITE"</span><br><span class="line">android:readPermission="com.alex.kotlin.job.provider.READ"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- B程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.READ"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.WRITE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="系统ContentProvider"><a href="#系统ContentProvider" class="headerlink" title="系统ContentProvider"></a>系统ContentProvider</h2><p>举几个实例：铃声，联系人部分操作。</p>
<h3 id="铃声"><a href="#铃声" class="headerlink" title="铃声"></a>铃声</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改系统铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File sdFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    values.put(MediaStore.MediaColumns.DATA, sdFile.getAbsolutePath());</span><br><span class="line">    values.put(MediaStore.MediaColumns.TITLE, sdFile.getName());</span><br><span class="line">    values.put(MediaStore.MediaColumns.MIME_TYPE, <span class="string">"audio/*"</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_RINGTONE, <span class="keyword">true</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_NOTIFICATION, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_ALARM, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_MUSIC, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Uri uri = MediaStore.Audio.Media.getContentUriForPath(sdFile.getAbsolutePath());</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"uri is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String delete = MediaStore.MediaColumns.DATA + <span class="string">"=\""</span> + sdFile.getAbsolutePath() + <span class="string">"\""</span>;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + delete);</span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + context.getContentResolver().delete(uri, delete, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    Uri newUri = context.getContentResolver().insert(uri, values);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"uri = "</span> + uri);</span><br><span class="line">    Log.d(TAG, <span class="string">"new uri = "</span> + newUri);</span><br><span class="line"></span><br><span class="line">    RingtoneManager.setActualDefaultRingtoneUri(context, RingtoneManager.TYPE_RINGTONE, newUri);</span><br><span class="line">    Toast.makeText(context, <span class="string">"设置来电铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定电话号码的来电铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, number);</span><br><span class="line">    <span class="keyword">final</span> String[] projection = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            ContactsContract.Contacts._ID, ContactsContract.Contacts.LOOKUP_KEY</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> Cursor data = context.getContentResolver().query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.moveToFirst()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> contactId = data.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> String lookupKey = data.getString(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> Uri contactUri = ContactsContract.Contacts.getLookupUri(contactId, lookupKey);</span><br><span class="line">            <span class="keyword">if</span> (contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Invalid arguments"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">final</span> String value = Uri.fromFile(file).toString();</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"uri = "</span> + contactUri);</span><br><span class="line">            Log.d(TAG, <span class="string">"value = "</span> + value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ContentValues values = <span class="keyword">new</span> ContentValues(<span class="number">1</span>);</span><br><span class="line">            values.put(ContactsContract.Contacts.CUSTOM_RINGTONE, value);</span><br><span class="line">            context.getContentResolver().update(contactUri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Toast.makeText(context, <span class="string">"设置联系人铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联系人"><a href="#联系人" class="headerlink" title="联系人"></a>联系人</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据uri查询指定联系人电话(uri可以通过跳转联系人页面返回得到：intent.getData())</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContacts</span><span class="params">(Context context, Uri contactUri)</span> </span>&#123;</span><br><span class="line">    String phoneNumber = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor cursor = context.getContentResolver().query(contactUri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        String id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));</span><br><span class="line">        Cursor phones = context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,</span><br><span class="line">                <span class="keyword">null</span>, ContactsContract.CommonDataKinds.Phone.CONTACT_ID</span><br><span class="line">                        + <span class="string">"="</span> + id, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (phones != <span class="keyword">null</span> &amp;&amp; phones.moveToNext()) &#123;</span><br><span class="line">            phoneNumber = phones.getString(phones.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">            phones.close();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, <span class="string">"number = "</span> + phoneNumber);</span><br><span class="line">    <span class="keyword">return</span> phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据电话获取联系人名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContactName</span><span class="params">(Context context, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">    Uri lookupUri;</span><br><span class="line">    String[] projection = <span class="keyword">new</span> String[]&#123;ContactsContract.PhoneLookup._ID, ContactsContract.PhoneLookup.DISPLAY_NAME&#125;;</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));</span><br><span class="line">        cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lookupUri = Uri.withAppendedPath(android.provider.Contacts.Phones.CONTENT_FILTER_URL,</span><br><span class="line">                    Uri.encode(number));</span><br><span class="line">            cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = context.getResources().getString(R.string.unknown_contract);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.getCount() &gt; <span class="number">0</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        ret = cursor.getString(<span class="number">1</span>);</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h2><h3 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"finch.db"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_TABLE_NAME = <span class="string">"job"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 数据库版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DATABASE_NAME, <span class="keyword">null</span>, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个表格:用户表 和职业表</span></span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" name TEXT)"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + JOB_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" job TEXT)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义ContentProvider"><a href="#自定义ContentProvider" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    DBHelper mDbHelper = <span class="keyword">null</span>;</span><br><span class="line">    SQLiteDatabase db = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOHORITY = <span class="string">"cn.scu.myprovider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> User_Code = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Job_Code = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UriMatcher类使用:在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher mMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        mMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        mMatcher.addURI(AUTOHORITY,<span class="string">"user"</span>, User_Code);</span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">"job"</span>, Job_Code);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化ContentProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">// 在ContentProvider创建时对数据库进行初始化，不能做耗时操作，此处仅作展示</span></span><br><span class="line">        mDbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(1,'Carson');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(2,'Kobe');"</span>);</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from job"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(1,'Android');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(2,'iOS');"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">return</span> db.query(table,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> User_Code:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Job_Code:</span><br><span class="line">                tableName = DBHelper.JOB_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册ContentProvider"><a href="#注册ContentProvider" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"cn.scu.myprovider"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="访问ContentProvider的数据"><a href="#访问ContentProvider的数据" class="headerlink" title="访问ContentProvider的数据"></a>访问ContentProvider的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Iverson"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user, values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://cn.scu.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程1"><a href="#进程1" class="headerlink" title="进程1"></a>进程1</h3><h4 id="创建数据库类-1"><a href="#创建数据库类-1" class="headerlink" title="创建数据库类"></a>创建数据库类</h4><p>同上。</p>
<h4 id="自定义ContentProvider-1"><a href="#自定义ContentProvider-1" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h4><p>同上。</p>
<h4 id="注册ContentProvider-1"><a href="#注册ContentProvider-1" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"scut.carson_ho.myprovider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"scut.carson_ho.PROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span> = <span class="string">"scut.carson_ho.Read"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:writePermission</span> = <span class="string">"scut.carson_ho.Write"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="进程2"><a href="#进程2" class="headerlink" title="进程2"></a>进程2</h3><h4 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="访问ContentProvider"><a href="#访问ContentProvider" class="headerlink" title="访问ContentProvider"></a>访问ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Jordan"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user,values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>对于面向Android 7.0及以上的应用，Android禁止在应用外部公开<code>file://url</code>。如果一项包含文件URI的intent离开应用，则应用会抛出FileUriExposedException异常。</p>
<p>解决方案：要在应用间共享文件，应发送一项content://URI，并授予URI临时访问权限。进行此授权的最简单方式是使用FileProvider类。FileProvider是ContentProvider的一个特殊的子类，它让应用间共享文件变得更加容易，其通过创建一个Content URI来代替File URI。</p>
<h3 id="注册FileProvider"><a href="#注册FileProvider" class="headerlink" title="注册FileProvider"></a>注册FileProvider</h3><p>由于FileProvider中已经包含了为file生成Content URI的基本代码了，所以开发者不必再去定义一个FileProvider的子类。你可以在XML文件中指定一个FileProvider：在manifest中使用<code>&lt;provider&gt;</code>标签来指定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.hearing.fileprovider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name的值一般都固定为android.support.v4.content.FileProvider。如果开发者继承了FileProvider，则可以写上其绝对路径。</li>
<li>authorities字段的值用来表明使用的使用者，在FileProvider的函数getUriForFile需要传入该参数。</li>
<li>exported 的值为false，表示该FileProvider只能本应用使用，不是public的。</li>
<li>grantUriPermissions 的值为true，表示允许赋予临时权限。</li>
</ul>
<h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>只有事先指定了目录，一个FileProvider才可以为文件生成一个对应的Content URI。要指定一个路径，需要在XML文件中指定其存储的路径。使用<code>&lt;paths&gt;</code>标签。例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/files/path/</code></li>
<li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalFilesDir(null) + &quot;/path/&quot;</code>，<code>/storage/emulated/0/Android/data/&lt;package_name&gt;/files/path/</code></li>
<li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalCacheDir() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/Android/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Environment.getExternalStorageDirectory() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/path/</code></li>
</ul>
<p>在res目录下新建xml目录，然后新建文件file_paths.xml，根据上述内容编写。</p>
<h3 id="获取Content-Uri"><a href="#获取Content-Uri" class="headerlink" title="获取Content Uri"></a>获取Content Uri</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">Uri data;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    data = FileProvider.getUriForFile(mContext, <span class="string">"com.hearing.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋予临时权限"><a href="#赋予临时权限" class="headerlink" title="赋予临时权限"></a>赋予临时权限</h3><p>两种方法：（通常使用第2种）</p>
<ol>
<li>Context.grantUriPermission(package, Uri, mode_flags)</li>
<li>Intent.setFlags()：<code>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);</code></li>
</ol>
<p>Flag意义如下：</p>
<ul>
<li>FLAG_GRANT_READ_URI_PERMISSION：表示读取权限； </li>
<li>FLAG_GRANT_WRITE_URI_PERMISSION：表示写入权限。</li>
</ul>
<h3 id="分享文件URI"><a href="#分享文件URI" class="headerlink" title="分享文件URI"></a>分享文件URI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"shareFile: "</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="string">"com.hearing.fileproviderclient"</span>,</span><br><span class="line">            <span class="string">"com.hearing.fileproviderclient.MainActivity"</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">    Uri data;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        data = FileProvider.getUriForFile(mContext, FILE_PROVIDER_AUTHORITIES, file);</span><br><span class="line">        <span class="comment">// 给目标应用一个临时授权</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">    intent.setData(data);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>安全</p>
<p>  ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据根据需求开放给 其他应用进行增、删、改、查，而不用担心因为直接开放数据库权限而带来的安全问题</p>
</li>
<li><p>访问简单 &amp; 高效</p>
</li>
</ul>
<h1 id="Mime-Type"><a href="#Mime-Type" class="headerlink" title="Mime Type"></a>Mime Type</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>MIME：多用途互联网邮件扩展（Multipurpose Internet Mail Extensions）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。</p>
<p>MIME TYPE一般以这种形式出现：<code>[type]/[subtype]</code></p>
<p>type标识内容type，有下面的形式：</p>
<ul>
<li>Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</li>
<li>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</li>
<li>Application：用于传输应用程序数据或者二进制数据；</li>
<li>Message：用于包装一个E-mail消息；</li>
<li>Image：用于传输静态图片数据；</li>
<li>Audio：用于传输音频或者音声数据；</li>
<li>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。</li>
</ul>
<p>subtype用于指定type的详细形式。<code>content-type/subtype</code>配对的集合和与此相关的参数，将随着时间而增长。为了确保这些值在一个有序而且公开的状态下开发，MIME使用Internet Assigned Numbers Authority (IANA)作为中心的注册机制来管理这些值。常用的subtype值如下所示：</p>
<ul>
<li>text/plain（纯文本）</li>
<li>text/html（HTML文档）</li>
<li>application/xhtml+xml（XHTML文档）</li>
<li>image/gif（GIF图像）</li>
<li>image/jpeg（JPEG图像）</li>
<li>image/png（PNG图像）</li>
<li>video/mpeg（MPEG动画）</li>
<li>application/octet-stream（任意的二进制数据）</li>
<li>application/pdf（PDF文档）</li>
<li>application/msword（Microsoft Word文件）</li>
<li>message/rfc822（RFC 822形式）</li>
<li>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）</li>
<li>application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）</li>
<li>multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>当Android系统接收到一个隐式Intent要启动一个Activity(或其他组件)时，Android会根据以下三个信息比较Intent的信息与注册的组件的intent-filter的信息，从而为该Intent选择出最匹配的Activity(或其他组件)：</p>
<ul>
<li>intent中的action</li>
<li>intent中的category</li>
<li>intent中的data（包含Uri以及data的MIME类型）</li>
</ul>
<p>也就是隐式intent对象要满足要启动的目标组件中注册的intent-filter中的<code>&lt;action/&gt;</code>、<code>&lt;category/&gt;</code>、<code>&lt;data/&gt;</code>三个标签中的信息，即要分别通过action测试、category测试以及data测试。</p>
<p>MINI类型即在data中指定。</p>
<h1 id="Intent和Intent-filter"><a href="#Intent和Intent-filter" class="headerlink" title="Intent和Intent-filter"></a>Intent和Intent-filter</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Intent 是一个消息传递对象，可以用来从其他应用组件请求操作，尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ol>
<li>启动 Activity：通过将 Intent 传递给 startActivity()，可以启动新的 Activity 实例，Intent 用于描述要启动的 Activity，并携带任何必要的数据。</li>
<li>启动 Service：使用 Android 5.0（API 级别 21）及更高版本，可以启动包含 JobScheduler 的服务。对于 Android 5.0（API 级别 21）之前的版本，可以使用 Service 类的方法来启动服务，通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 用于描述要启动的服务，并携带任何必要的数据。如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，可以从其他组件绑定到此服务。</li>
<li>传递 BroadCast：广播是任何应用均可接收的消息，系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播，通过将 Intent 传递给 sendBroadcast() 或 sendOrderedBroadcast()，可以将广播传递给其他应用。</li>
</ol>
<h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><ul>
<li>显式 Intent：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。例如，启动应用内的新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li>隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent-filter进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent-filter匹配，则系统将启动该组件，并向其传递 Intent 对象。如果多个 Intent-filter兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</li>
</ul>
<p>Intent-filter是应用清单文件中的一个表达式，用于指定该组件要接收的 Intent 类型。例如，通过为 Activity 声明 Intent-filter，可以使其他应用能够直接使用某一特定类型的 Intent 启动 Activity。同样，如果您没有为 Activity 声明任何 Intent-filter，则 Activity 只能通过显式 Intent 启动。</p>
<p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent-filter。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p>
<h2 id="构建Intent"><a href="#构建Intent" class="headerlink" title="构建Intent"></a>构建Intent</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>如Component name，Action，Data以及Category，这些属性（组件名称、操作、数据和category）表示 Intent 的既定特征。通过读取这些属性，Android 系统能够解析应当启动哪个应用组件。但是，Intent 也有可能会携带一些不影响其如何解析为应用组件的信息。Intent 还可以提供以下信息：Extras和Flags。</p>
<h4 id="Component-name"><a href="#Component-name" class="headerlink" title="Component name"></a>Component name</h4><p>这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。如果没有组件名称，则 Intent 则为隐式，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和category）决定哪个组件应当接收 Intent。如需在应用中启动特定的组件，则应指定该组件的名称。</p>
<p>启动 Service 时，应始终指定组件名称。否则无法确定哪项服务会响应 Intent，且用户无法看到哪项服务已启动。</p>
<p>Intent 的这一字段是 ComponentName 对象，可以使用目标组件的完全限定类名指定此对象，其中包括应用的软件包名称。例如，com.example.ExampleActivity，可以使用 setComponent()、setClass()、setClassName()，或 Intent 构造函数设置组件名称。</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>指定要执行的通用操作（例如，查看或选取）的字符串。</p>
<p>对于广播 Intent，这是指已发生且正在报告的操作。action会在很大程度上决定其余 Intent 的构成，特别是 data 和 extra 中包含的内容。可以指定自己的操作，供 Intent 在您的应用内使用（或者供其他应用在您的应用中调用组件）。但是，您通常应该使用由Intent 类或其他框架类定义的操作常量。以下是一些用于启动 Activity 的常见操作：</p>
<ol>
<li>ACTION_VIEW：如果您拥有一些某项 Activity 可向用户显示的信息（例如，要使用图库应用查看的照片；或者要使用地图应用查看的地址），请通过 Intent 将此操作与 startActivity() 结合使用。</li>
<li>ACTION_SEND：这也称为共享 Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此操作与 startActivity() 结合使用。</li>
</ol>
<p>可以使用 setAction() 或 Intent 构造函数为 Intent 指定操作。</p>
<p>如以下示例所示，如果定义自己的操作，请确保加入应用的软件包名称作为前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ACTION_TIMETRAVEL = <span class="string">"com.example.action.TIMETRAVEL"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。</p>
<p>创建 Intent 时，除了指定 URI 以外，指定数据类型（MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件。但有时 MIME 类型可以从 URI 中推断得出，特别当数据是 content:URI 时尤其如此。content:URI 表明数据位于设备中，且由 ContentProvider 控制，这使得数据 MIME 类型对系统可见。</p>
<p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，您可以使用 setDataAndType() 同时显式设置二者。</p>
<p>注意：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType() 同时设置 URI 和 MIME 类型。</p>
<h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的Category放入一个 Intent 中，但大多数 Intent 均不需要 Category。以下是一些常见category：</p>
<ul>
<li>CATEGORY_BROWSABLE：目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。</li>
<li>CATEGORY_LAUNCHER：该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</li>
<li>CATEGORY_HOME：桌面应用需要声明。</li>
<li>CATEGORY_DEFAULT：通过隐式启动Activity时，Android会默认加上一个CATEGORY_DEFAULT，所以如果Activity要支持隐式启动的话，除了默认LaunchActivity，其余都需要加上CATEGORY_DEFAULT。</li>
</ul>
<p>可以使用 addCategory() 指定category。</p>
<h4 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h4><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。可以使用各种 putExtra() 方法添加 extra 数据，每种方法均接受两个参数：键名和值。还可以创建一个包含所有 extra 数据的 Bundle 对象，然后使用 putExtras() 将 Bundle 插入 Intent 中。</p>
<p>例如，使用 ACTION_SEND 创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL 键指定目标收件人，并使用 EXTRA_SUBJECT 键指定主题。</p>
<p>Intent 类将为标准化的数据类型指定多个 EXTRA_* 常量。如需声明自己的 extra 键（对于应用接收的 Intent），请确保将应用的软件包名称作为前缀，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_GIGAWATTS = <span class="string">"com.example.EXTRA_GIGAWATTS"</span>;</span><br></pre></td></tr></table></figure>

<p>注意：在发送您希望另一个应用接收的 Intent 时，请勿使用 Parcelable 或 Serializable 数据。如果某个应用尝试访问 Bundle 对象中的数据，但没有对打包或序列化类的访问权限，则系统将提出一个 RuntimeException。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><p>Flags 在 Intent 类中定义，充当 Intent 的元数据。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理（例如，Activity 是否属于最近的 Activity 列表）。</p>
<p>可以使用 setFlags() 方法添加Flags。</p>
<h3 id="显式-Intent-示例"><a href="#显式-Intent-示例" class="headerlink" title="显式 Intent 示例"></a>显式 Intent 示例</h3><p>显式 Intent 是指用于启动某个特定应用组件（例如，应用中的某个特定 Activity 或服务）的 Intent，要创建显式 Intent，需要为 Intent 对象定义组件名称，Intent 的所有其他属性均为可选属性。</p>
<p>例如，如果在应用中构建一个名为 DownloadService、旨在从网页下载文件的服务，则可使用以下代码启动该服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed in an Activity, so 'this' is the Context</span></span><br><span class="line"><span class="comment">// The fileUrl is a string URL, such as "http://www.example.com/image.png"</span></span><br><span class="line">Intent downloadIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DownloadService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">downloadIntent.setData(Uri.parse(fileUrl));</span><br><span class="line">startService(downloadIntent);</span><br></pre></td></tr></table></figure>

<p>Intent(Context, Class) 构造函数分别为应用和组件提供 Context 和 Class 对象。因此，此 Intent 将显式启动该应用中的 DownloadService 类。</p>
<h3 id="隐式-Intent-示例"><a href="#隐式-Intent-示例" class="headerlink" title="隐式 Intent 示例"></a>隐式 Intent 示例</h3><p>隐式 Intent 指定能够在可以执行相应操作的设备上调用任何应用的操作。如果您的应用无法执行该操作而其他应用可以，且您希望用户选取要使用的应用，则使用隐式 Intent 非常有用。例如，如果您希望用户与他人分享您的内容，请使用 ACTION_SEND 操作创建 Intent，并添加指定共享内容的 extra。使用该 Intent 调用 startActivity() 时，用户可以选取分享内容所使用的应用。</p>
<p>注意：用户可能没有任何应用处理您发送到 startActivity() 的隐式 Intent。或者，由于配置文件限制或管理员执行的设置，可能无法访问应用。如果发生这样的情况，调用失败，应用也会崩溃。要验证 Activity 是否会接收 Intent，请对 Intent 对象调用 resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，并且可以安全调用 startActivity()。如果结果为空，不要使用该 Intent。以下示例说明如何验证 Intent 是否解析为 Activity。此示例没有使用 URI，但已声明 Intent 的数据类型，用于指定 extra 携带的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the text message with a string</span></span><br><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</span><br><span class="line">sendIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the intent will resolve to an activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(sendIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 startActivity() 时，系统将检查已安装的所有应用，确定哪些应用能够处理这种 Intent（即：含 ACTION_SEND 操作并携带“text/plain”数据的 Intent）。如果只有一个应用能够处理，则该应用将立即打开并为其提供 Intent。如果多个 Activity 接受 Intent，则系统将显示一个对话框，使用户能够选取要使用的应用。</p>
<h3 id="强制使用应用选择器"><a href="#强制使用应用选择器" class="headerlink" title="强制使用应用选择器"></a>强制使用应用选择器</h3><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。如果用户可能希望每次使用相同的应用执行某项操作（例如，打开网页时，用户往往倾向于仅使用一种网络浏览器），则选择默认选项的功能十分有用。</p>
<p>但是，如果多个应用可以响应 Intent，且用户可能希望每次使用不同的应用，则应采用显式方式显示选择器对话框。选择器对话框会要求用户选择用于操作的应用（用户无法为该操作选择默认应用）。例如，当应用使用 ACTION_SEND 操作执行“共享”时，用户根据目前的状况可能需要使用另一不同的应用，因此应当始终使用选择器对话框。</p>
<p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()，如下例所示。此示例将显示一个对话框，其中有响应传递给 createChooser() 方法的 Intent 的应用列表，并且将提供的文本用作对话框标题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always use string resources for UI text.</span></span><br><span class="line"><span class="comment">// This says something like "Share this photo with"</span></span><br><span class="line">String title = getResources().getString(R.string.chooser_title);</span><br><span class="line"><span class="comment">// Create intent to show the chooser dialog</span></span><br><span class="line">Intent chooser = Intent.createChooser(sendIntent, title);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the original intent will resolve to at least one activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><h3 id="接收隐式-Intent-1"><a href="#接收隐式-Intent-1" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，请在 Manifest 文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent-filter。每个 Intent-filter均根据 Intent 的操作、数据和category指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent-filter之一传递时，系统才会将该 Intent 传递给应用组件。</p>
<p>请注意：显式 Intent 始终会传递给其目标，无论组件声明的 Intent-filter如何均是如此。</p>
<p>应用组件应当为自身可执行的每个独特作业声明单独的filter。例如，图像库应用中的一个 Activity 可能会有两个filter，分别用于查看图像和编辑图像。当 Activity 启动时，将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。</p>
<p>每个 Intent-filter均由应用Manifest文件中的 <code>&lt;intent-filter&gt;</code> 元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code> 元素）中。在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<ul>
<li><code>&lt;action&gt;</code>：在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。</li>
<li><code>&lt;data&gt;</code>：使用一个或多个指定数据 URI（scheme、host、port、path）各个方面和 MIME 类型的属性，声明接受的数据类型。</li>
<li><code>&lt;category&gt;</code>：在 name 属性中，声明接受的 Intent category。该值必须是操作的文本字符串值，而不是类常量。</li>
</ul>
<p>请注意：要接收隐式 Intent，必须将 CATEGORY_DEFAULT category包括在 Intent-filter中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT category的方式处理所有 Intent。如果未在 Intent-filter中声明此category，则隐式 Intent 不会解析为您的 Activity。</p>
<p>例如，以下是一个使用包含 Intent-filter的 Activity 声明，当数据类型为文本时，系统将接收 ACTION_SEND Intent ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您可以创建一个包括多个 <code>&lt;action&gt;</code>、<code>&lt;data&gt;</code> 或 <code>&lt;category&gt;</code> 实例的filtet。创建时，需确定组件能够处理这些filter元素的任何及所有组合。</p>
<p>如需仅以操作、数据和类别类型的特定组合来处理多种 Intent，则需创建多个 Intent-filter。</p>
<p>系统通过将 Intent 与所有这三个元素进行比较，根据filter测试隐式 Intent。隐式 Intent 若要传递给组件，必须通过所有这三项测试。如果 Intent 无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件。但是，由于一个组件可能有多个 Intent-filter，因此未能通过某一组件filter的 Intent 可能会通过另一filter。</p>
<p>注意：使用 Intent-filter时，无法安全地防止其他应用启动组件。尽管 Intent-filter将组件限制为仅响应特定类型的隐式 Intent，但如果开发者确定您的组件名称，则其他应用有可能通过使用显式 Intent 启动您的应用组件。如果必须确保只有您自己的应用才能启动您的某一组件，请勿在您的清单中声明 Intent-filter，将该组件的 exported 属性设置为 “false”。</p>
<p>同样，为了避免无意中运行不同应用的 Service，请始终使用显式 Intent 启动您自己的服务。</p>
<p>请注意：对于所有 Activity，您必须在清单文件中声明 Intent-filter。但是，广播接收器的filter可以通过调用 registerReceiver() 动态注册。这样一来，应用便可仅在应用运行时的某一指定时间段内侦听特定的广播。</p>
<h3 id="filter示例"><a href="#filter示例" class="headerlink" title="filter示例"></a>filter示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity is the main entry, should appear in app launcher --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity handles "SEND" actions with text data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND_MULTIPLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.google.panorama360+jpg"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开：</p>
<ul>
<li>ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。</li>
<li>CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。如果 <code>&lt;activity&gt;</code> 元素未使用 icon 指定图标，则系统将使用 <code>&lt;application&gt;</code> 元素中的图标。</li>
</ul>
<p>这两个元素必须配对使用，Activity 才会显示在应用启动器中。</p>
<p>第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent-filter之一匹配）的另一应用中直接进入 ShareActivity。</p>
<h2 id="使用PendingIntent"><a href="#使用PendingIntent" class="headerlink" title="使用PendingIntent"></a>使用PendingIntent</h2><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p>
<p>PendingIntent 的主要用例包括：</p>
<ul>
<li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用您的应用微件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li>
</ul>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建 PendingIntent。使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent 时，您必须声明所需的组件类型：</p>
<ul>
<li>PendingIntent.getActivity()，适用于启动 Activity 的 Intent。</li>
<li>PendingIntent.getService()，适用于启动 Service 的 Intent。</li>
<li>PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。</li>
</ul>
<p>除非您的应用正在从其他应用中接收待定 Intent，否则上述用于创建 PendingIntent 的方法可能是您所需的唯一 PendingIntent 方法。</p>
<p>每种方法均会提取当前的应用 Context、您要封装的 Intent 以及一个或多个指定应如何使用该 Intent 的标志（例如，是否可以多次使用该 Intent）。</p>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该 Intent 与 Intent-filter进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Action</li>
<li>Data（URI 和数据类型）。</li>
<li>Category</li>
</ul>
<h3 id="Action测试"><a href="#Action测试" class="headerlink" title="Action测试"></a>Action测试</h3><p>要指定接受的 Intent action，Intent-filter既可以不声明任何 <code>&lt;action&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.EDIT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要通过此filter，Intent 中指定的action必须与filter中列出的某一action匹配。</p>
<h3 id="Category测试"><a href="#Category测试" class="headerlink" title="Category测试"></a>Category测试</h3><p>要指定接受的 Intent category，Intent-filter既可以不声明任何 <code>&lt;category&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若要使 Intent 通过category测试，则 Intent 中的每个category均必须与filter中的category匹配。Intent-filter声明的category可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。因此，不含category的 Intent 应当始终会通过此测试，无论filter中声明何种category均是如此。</p>
<p>请注意：Android 会自动将 CATEGORY_DEFAULT category应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent。如需 Activity 接收显示 Intent，则必须将 “android.intent.category.DEFAULT” 的category包括在其 Intent-filter中。</p>
<h3 id="Data测试"><a href="#Data测试" class="headerlink" title="Data测试"></a>Data测试</h3><p>要指定接受的 Intent 数据，Intent-filter既可以不声明任何 <code>&lt;data&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：scheme、host、port 和 path：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>在 <code>&lt;data&gt;</code> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p>
<ul>
<li>如果未指定scheme，则会忽略host。</li>
<li>如果未指定host，则会忽略port。</li>
<li>如果未指定scheme和host，则会忽略path。</li>
</ul>
<p>将 Intent 中的 URI 与filter中的 URI 规范进行比较时，它仅与filter中包含的部分 URI 进行比较。例如：</p>
<ul>
<li>如果filter仅指定scheme，则具有该scheme的所有 URI 均与该filter匹配。</li>
<li>如果filter指定scheme和host，但未指定path，则具有相同scheme和host的所有 URI 都会通过filter，无论其path如何均是如此。</li>
<li>如果filter指定scheme、host和path，则仅具有相同scheme、host和path的 URI 才会通过filter。</li>
</ul>
<p>请注意：path规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。</p>
<p>数据测试会将 Intent 中的 URI 和 MIME 类型与filter中指定的 URI 和 MIME 类型进行比较。规则如下：</p>
<ul>
<li>仅当filter未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与filter的 URI 格式匹配、且filter同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当filter列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与filter中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与filter中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且filter未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果filter只是列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<p>请注意：如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <code>&lt;intent-filter&gt;</code> 中没有 <code>&lt;data&gt;</code> 元素时失败。</p>
<p>最后一条规则反映出对组件能够从文件中或内容提供程序处获得本地数据的预期。因此，其filter只能列出数据类型，不需要显式命名 content: 和 file: scheme。以下是一个典型示例，说明 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从内容提供程序处获得并显示图像数据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于大部分可用数据均由内容提供程序分发，因此指定数据类型（而非 URI）的filter也许最为常见。</p>
<p>另一常见的配置是具有scheme和数据类型的filter。例如，下文中的 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从网络中检索视频数据以执行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent-filter匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。例如，主页应用通过使用指定 ACTION_MAIN action和 CATEGORY_LAUNCHER category的 Intent-filter查找所有 Activity，以此填充应用启动器。如 IntentFilter 类文档所述，只有当 Intent 中的操作和category与filter匹配时，匹配才会成功。</p>
<p>您的应用可以使用类似于主页应用的方式使用 Intent 匹配。PackageManager 提供一整套 query…() 方法来返回所有能够接受特定 Intent 的组件。此外，还会提供一系列类似的 resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities() 将返回能够执行作为参数传递的 Intent 中列出的所有 Activity，而 queryIntentServices() 则可返回类似的一系列服务。这两种方法均不会激活组件；而只是列出能够响应的组件。对于广播接收器，有一种类似的方法：queryBroadcastReceivers()。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">啃碎并发（四）：Java线程Dump分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 10:26:46 / 修改时间：15:33:08" itemprop="dateCreated datePublished" datetime="2020-06-01T10:26:46+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-Thread-Dump介绍"><a href="#1-Thread-Dump介绍" class="headerlink" title="1 Thread Dump介绍"></a>1 Thread Dump介绍</h4><h5 id="1-1-什么是Thread-Dump"><a href="#1-1-什么是Thread-Dump" class="headerlink" title="1.1 什么是Thread Dump"></a>1.1 什么是Thread Dump</h5><p>Thread Dump是非常有用的诊断Java应用问题的工具。<strong>每一个Java虚拟机都有及时生成所有线程在某一点状态的thread-dump的能力，</strong>虽然各个 Java虚拟机打印的thread dump略有不同，但是<strong>大多都提供了当前活动线程的快照，及JVM中所有Java线程的堆栈跟踪信息，堆栈信息一般包含完整的类名及所执行的方法，</strong>如果可能的话还有源代码的行数。</p>
<h5 id="1-2-Thread-Dump特点"><a href="#1-2-Thread-Dump特点" class="headerlink" title="1.2 Thread Dump特点"></a>1.2 Thread Dump特点</h5><blockquote>
<p>1.能在各种操作系统下使用；<br>2.能在各种Java应用服务器下使用；<br>3.能在生产环境下使用而不影响系统的性能；<br>4.能将问题直接定位到应用程序的代码行上；</p>
</blockquote>
<h5 id="1-3-Thread-Dump抓取"><a href="#1-3-Thread-Dump抓取" class="headerlink" title="1.3 Thread Dump抓取"></a>1.3 Thread Dump抓取</h5><p><strong>一般当服务器挂起，崩溃或者性能低下时，</strong>就需要抓取服务器的线程堆栈（Thread Dump）用于后续的分析。在实际运行中，往往一次 dump的信息，还不足以确认问题。为了反映线程状态的动态变化，<strong>需要接连多次做thread dump，每次间隔10-20s，建议至少产生三次 dump信息，</strong>如果每次 dump都指向同一个问题，我们才确定问题的典型性。</p>
<p><strong>1. 操作系统命令获取ThreadDump</strong></p>
<blockquote>
<p>1.ps –ef | grep java<br>2.kill -3 <pid></p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>一定要谨慎, 一步不慎就可能让服务器进程被杀死。kill -9 命令会杀死进程。</p>
</blockquote>
<p><strong>2. JVM 自带的工具获取线程堆栈</strong></p>
<blockquote>
<ol>
<li>jps 或 ps –ef | grep java （获取PID）</li>
<li>jstack [-l ] <pid> | tee -a jstack.log（获取ThreadDump）</li>
</ol>
</blockquote>
<h4 id="2-Thread-Dump分析"><a href="#2-Thread-Dump分析" class="headerlink" title="2 Thread Dump分析"></a>2 Thread Dump分析</h4><h5 id="2-1-Thread-Dump信息"><a href="#2-1-Thread-Dump信息" class="headerlink" title="2.1 Thread Dump信息"></a>2.1 Thread Dump信息</h5><p><strong>1. 头部信息：时间，JVM信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-11-02 19:05:06  </span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (16.3-b01 mixed mode):</span><br></pre></td></tr></table></figure>

<p><strong>2. 线程INFO信息块：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;Timer-0&quot; daemon prio&#x3D;10 tid&#x3D;0xac190c00 nid&#x3D;0xaef in Object.wait() [0xae77d000] </span><br><span class="line"># 线程名称：Timer-0；线程类型：daemon；优先级: 10，默认是5；</span><br><span class="line"># JVM线程id：tid&#x3D;0xac190c00，JVM内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现）。</span><br><span class="line"># 对应系统线程id（NativeThread ID）：nid&#x3D;0xaef，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）</span><br><span class="line"># 线程状态：in Object.wait()；</span><br><span class="line"># 起始栈地址：[0xae77d000]，对象的内存地址，通过JVM内存查看工具，能够看出线程是在哪儿个对象上等待；</span><br><span class="line">2.  java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">3.  at java.lang.Object.wait(Native Method)</span><br><span class="line">4.  -waiting on &lt;0xb3885f60&gt; (a java.util.TaskQueue)     # 继续wait </span><br><span class="line">5.  at java.util.TimerThread.mainLoop(Timer.java:509)</span><br><span class="line">6.  -locked &lt;0xb3885f60&gt; (a java.util.TaskQueue)         # 已经locked</span><br><span class="line">7.  at java.util.TimerThread.run(Timer.java:462)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java thread statck trace：是上面2-7行的信息。到目前为止这是最重要的数据，Java stack trace提供了大部分信息来精确定位问题根源。</p>
</blockquote>
<p><strong>3. Java thread statck trace详解：</strong></p>
<p><strong>堆栈信息应该逆向解读：</strong>程序先执行的是第7行，然后是第6行，依次类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- locked &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br><span class="line">- waiting on &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br></pre></td></tr></table></figure>

<p><strong>也就是说对象先上锁，锁住对象0xb3885f60，然后释放该对象锁，进入waiting状态。</strong>为啥会出现这样的情况呢？看看下面的java代码示例，就会明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;  </span><br><span class="line">   .........  </span><br><span class="line">   obj.wait();  </span><br><span class="line">   .........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，线程的执行过程，先用 synchronized 获得了这个对象的 Monitor（对应于 locked &lt;0xb3885f60&gt; ）。当执行到 obj.wait()，线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on &lt;0xb3885f60&gt; ）。</p>
</blockquote>
<p><strong>在堆栈的第一行信息中，进一步标明了线程在代码级的状态，例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br></pre></td></tr></table></figure>

<p><strong>解释如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|blocked|</span><br><span class="line"></span><br><span class="line">&gt; This thread tried to enter asynchronized block, but the lock was taken by another thread. This thread isblocked until the lock gets released.</span><br><span class="line"></span><br><span class="line">|blocked (on thin lock)|</span><br><span class="line"></span><br><span class="line">&gt; This is the same state asblocked, but the lock in question is a thin lock.</span><br><span class="line"></span><br><span class="line">|waiting|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledObject.wait() on an object. The thread will remain there until some otherthread sends a notification to that object.</span><br><span class="line"></span><br><span class="line">|sleeping|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.lang.Thread.sleep().</span><br><span class="line"></span><br><span class="line">|parked|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.util.concurrent.locks.LockSupport.park().</span><br><span class="line"></span><br><span class="line">|suspended|</span><br><span class="line"></span><br><span class="line">&gt; The thread&#39;s execution wassuspended by java.lang.Thread.suspend() or a JVMTI agent call.</span><br></pre></td></tr></table></figure>

<h5 id="2-2-Thread状态分析"><a href="#2-2-Thread状态分析" class="headerlink" title="2.2 Thread状态分析"></a>2.2 Thread状态分析</h5><p>线程的状态是一个很重要的东西，因此thread dump中会显示这些状态，通过对这些状态的分析，能够得出线程的运行状况，进而发现可能存在的问题。<strong>线程的状态在Thread.State这个枚举类型中定义</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public enum State   </span><br><span class="line">&#123;  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread which has not yet started. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       NEW,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a runnable thread.  A thread in the runnable </span><br><span class="line">        * state is executing in the Java virtual machine but it may </span><br><span class="line">        * be waiting for other resources from the operating system </span><br><span class="line">        * such as processor. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       RUNNABLE,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread blocked waiting for a monitor lock. </span><br><span class="line">        * A thread in the blocked state is waiting for a monitor lock </span><br><span class="line">        * to enter a synchronized block&#x2F;method or  </span><br><span class="line">        * reenter a synchronized block&#x2F;method after calling </span><br><span class="line">        * &#123;@link Object#wait() Object.wait&#125;. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       BLOCKED,  </span><br><span class="line">     </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread. </span><br><span class="line">        * A thread is in the waiting state due to calling one of the  </span><br><span class="line">        * following methods: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *  </span><br><span class="line">        * &lt;p&gt;A thread in the waiting state is waiting for another thread to </span><br><span class="line">        * perform a particular action.   </span><br><span class="line">        * </span><br><span class="line">        * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt; </span><br><span class="line">        * on an object is waiting for another thread to call  </span><br><span class="line">        * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on  </span><br><span class="line">        * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;  </span><br><span class="line">        * is waiting for a specified thread to terminate. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       WAITING,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread with a specified waiting time. </span><br><span class="line">        * A thread is in the timed waiting state due to calling one of  </span><br><span class="line">        * the following methods with a specified positive waiting time: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;  </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TIMED_WAITING,  </span><br><span class="line">  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a terminated thread. </span><br><span class="line">        * The thread has completed execution. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TERMINATED;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. NEW：</strong></p>
<p><strong>每一个线程，在堆内存中都有一个对应的Thread对象。</strong>Thread t = new Thread();当刚刚在堆内存中创建Thread对象，还没有调用t.start()方法之前，线程就处在NEW状态。<strong>在这个状态上，线程与普通的java对象没有什么区别，就仅仅是一个堆内存中的对象。</strong></p>
<p><strong>2. RUNNABLE：</strong></p>
<p><strong>该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。</strong>这个状态的线程比较正常，但如果线程长时间停留在在这个状态就不正常了，这说明线程运行的时间很长（存在性能问题），或者是线程一直得不得执行的机会（存在线程饥饿的问题）。</p>
<p><strong>3. BLOCKED：</strong></p>
<p><strong>线程正在等待获取java对象的监视器(也叫内置锁)，即线程正在等待进入由synchronized保护的方法或者代码块。</strong>synchronized用来保证原子性，任意时刻最多只能由一个线程进入该临界区域，其他线程只能排队等待。</p>
<p><strong>4. WAITING：</strong></p>
<p><strong>处在该线程的状态，正在等待某个事件的发生，只有特定的条件满足，才能获得执行机会。</strong>而产生这个特定的事件，通常都是另一个线程。也就是说，<strong>如果不发生特定的事件，那么处在该状态的线程一直等待，不能获取执行的机会。</strong> 比如：</p>
<blockquote>
<p>1.A线程调用了obj对象的obj.wait()方法，如果没有线程调用obj.notify或obj.notifyAll，那么A线程就没有办法恢复运行；<br>2.如果A线程调用了LockSupport.park()，没有别的线程调用LockSupport.unpark(A)，那么A没有办法恢复运行。</p>
</blockquote>
<p><strong>5. TIMED_WAITING：</strong></p>
<p>J.U.C中很多与线程相关类，都提供了限时版本和不限时版本的API。 <strong>TIMED_WAITING意味着线程调用了限时版本的API，正在等待时间流逝。 **当等待时间过去后，线程一样可以恢复运行。</strong>如果线程进入了WAITING状态，一定要特定的事件发生才能恢复运行；而处在TIMED_WAITING的线程，如果特定的事件发生或者是时间流逝完毕，都会恢复运行。**</p>
<p><strong>6. TERMINATED：</strong></p>
<p><strong>线程执行完毕，执行完run方法正常返回，或者抛出了运行时异常而结束，线程都会停留在这个状态。</strong>这个时候线程只剩下Thread对象了，没有什么用了。</p>
<h5 id="2-3-关键状态分析"><a href="#2-3-关键状态分析" class="headerlink" title="2.3 关键状态分析"></a>2.3 关键状态分析</h5><ol>
<li>Wait on condition：The thread is either sleeping or waiting to be notified by another thread.<br>该状态说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(n)。</li>
</ol>
<p><strong>此时线程状态大致为以下几种：</strong></p>
<blockquote>
<p>1.java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；<br>2.java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p>
</blockquote>
<ol start="2">
<li>Waiting for Monitor Entry 和 in Object.wait()：The thread is waiting to get the lock for an object (some other thread may be holding the lock). This happens if two or more threads try to execute synchronized code. Note that the lock is always for an object and not for individual methods.</li>
</ol>
<p>在多线程的JAVA程序中，实现线程之间的同步，就要说说 Monitor。 *<em>Monitor是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者Class的锁。 *</em>每一个对象都有，也仅有一个 Monitor。下面这个图，描述了线程和 Monitor之间关系，以及线程的状态转换图：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2770d7fd4e31c5fa.png" alt="A Java Monitor And Thread"></p>
<p>如上图，每个Monitor在某个时刻，只能被一个线程拥有，*<em>该线程就是 “ActiveThread”，而其它线程都是 “Waiting Thread”，分别在两个队列“Entry Set”和“Wait Set”里等候。 *</em>在“Entry Set”中等待的线程状态是“Waiting for monitor entry”，而在“Wait Set”中等待的线程状态是“in Object.wait()”。</p>
<p><strong>先看“Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了“Entry Set”队列。</strong>对应的 code就像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;</span><br><span class="line">   .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这时有两种可能性：</strong></p>
<blockquote>
<p>1.该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码。<br>2.该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。</p>
</blockquote>
<p><strong>在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-0&quot; prio&#x3D;10 tid&#x3D;0x08222eb0 nid&#x3D;0x9 waiting for monitor entry [0xf927b000..0xf927bdb8] </span><br><span class="line">at testthread.WaitThread.run(WaitThread.java:39) </span><br><span class="line">- waiting to lock &lt;0xef63bf08&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line">at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p><strong>临界区的设置，是为了保证其内部的代码执行的原子性和完整性。</strong>但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。</p>
<p><strong>再看“Wait Set”里面的线程。</strong>当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll()，“Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;10 tid&#x3D;0x08223250 nid&#x3D;0xa in Object.wait() [0xef47a000..0xef47aa38] </span><br><span class="line"> at java.lang.Object.wait(Native Method) </span><br><span class="line"> - waiting on &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Object.wait(Object.java:474) </span><br><span class="line"> at testthread.MyWaitThread.run(MyWaitThread.java:40) </span><br><span class="line"> - locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p>综上，一般CPU很忙时，则关注runnable的线程，CPU很闲时，则关注waiting for monitor entry的线程。</p>
<ol start="3">
<li>JDK 5.0 的 Lock</li>
</ol>
<p>上面提到如果 synchronized和 monitor机制运用不当，可能会造成多线程程序的性能问题。在 JDK 5.0中，引入了 Lock机制，从而使开发者能更灵活的开发高性能的并发多线程程序，可以替代以往 JDK中的 synchronized和 Monitor的 机制。** 但是，要注意的是，因为 Lock类只是一个普通类，JVM无从得知 Lock对象的占用情况，所以在线程 DUMP中，也不会包含关于 Lock的信息，**关于死锁等问题，就不如用 synchronized的编程方式容易识别。</p>
<h5 id="2-4-关键状态示例"><a href="#2-4-关键状态示例" class="headerlink" title="2.4 关键状态示例"></a>2.4 关键状态示例</h5><p><strong>显示BLOCKED状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class BlockedState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis(); </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取object的线程会执行5分钟，这5分钟内会一直持有object的监视器，另一个线程无法执行处在B</p>
<p><strong>LOCKED状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1314 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7a800 nid&#x3D;0x1350 waiting for monitor entry [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:17)  </span><br><span class="line">     - waiting to lock &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d79400 nid&#x3D;0x1338 runnable [0x282ef000]  </span><br><span class="line"> java.lang.Thread.State: RUNNABLE  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:22)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>通过thread dump可以看到：t2线程确实处在BLOCKED (on object monitor)。waiting for monitor entry 等待进入synchronized保护的区域。</p>
<p><strong>显示WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class WaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        try  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            &#x2F;&#x2F; 进入等待的同时,会进入释放监视器  </span><br><span class="line">                            object.wait();  </span><br><span class="line">                        &#125; catch (InterruptedException e)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1734 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7e000 nid&#x3D;0x17f4 in Object.wait() [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d7d400 nid&#x3D;0x17f0 in Object.wait() [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以发现t1和t2都处在WAITING (on object monitor)，进入等待状态的原因是调用了in Object.wait()。通过J.U.C包下的锁和条件队列，也是这个效果，大家可以自己实践下。</p>
<p><strong>显示TIMED_WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">import java.util.concurrent.TimeUnit;  </span><br><span class="line">import java.util.concurrent.locks.Condition;  </span><br><span class="line">import java.util.concurrent.locks.Lock;  </span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line">public class TimedWaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    &#x2F;&#x2F; java的显示锁,类似java对象内置的监视器  </span><br><span class="line">    private static Lock lock &#x3D; new ReentrantLock();  </span><br><span class="line">    &#x2F;&#x2F; 锁关联的条件队列(类似于object.wait)  </span><br><span class="line">    private static Condition condition &#x3D; lock.newCondition();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                &#x2F;&#x2F; 加锁,进入临界区  </span><br><span class="line">                lock.lock();  </span><br><span class="line">                try  </span><br><span class="line">                &#123;  </span><br><span class="line">                    condition.await(5, TimeUnit.MINUTES);  </span><br><span class="line">                &#125; catch (InterruptedException e)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                &#x2F;&#x2F; 解锁,退出临界区  </span><br><span class="line">                lock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x169c waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7d800 nid&#x3D;0xc30 waiting on condition [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x280d0c00 nid&#x3D;0x16e0 waiting on condition [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以看到t1和t2线程都处在java.lang.Thread.State: TIMED_WAITING (parking)，这个parking代表是调用的JUC下的工具类，而不是java默认的监视器。</p>
<h4 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3 案例分析"></a>3 案例分析</h4><h5 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a>3.1 问题场景</h5><p><strong>1. CPU飙高，load高，响应很慢</strong></p>
<blockquote>
<p>1.一个请求过程中多次dump；<br>2.对比多次dump文件的runnable线程，如果执行的方法有比较大变化，说明比较正常。如果在执行同一个方法，就有一些问题了；</p>
</blockquote>
<p><strong>2. 查找占用CPU最多的线程</strong></p>
<blockquote>
<p>1.使用命令：top -H -p pid（pid为被测系统的进程号），找到导致CPU高的线程ID，对应thread dump信息中线程的nid，只不过一个是十进制，一个是十六进制；<br>2.在thread dump中，根据top命令查找的线程id，查找对应的线程堆栈信息；</p>
</blockquote>
<p><strong>3. CPU使用率不高但是响应很慢</strong></p>
<blockquote>
<p>进行dump，查看是否有很多thread struck在了i/o、数据库等地方，定位瓶颈原因；</p>
</blockquote>
<p><strong>4. 请求无法响应</strong></p>
<blockquote>
<p>多次dump，对比是否所有的runnable线程都一直在执行相同的方法，如果是的，恭喜你，锁住了！</p>
</blockquote>
<h5 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h5><p><strong>死锁经常表现为程序的停顿，或者不再响应用户的请求。</strong>从操作系统上观察，对应进程的CPU占用率为零，很快会从top或prstat的输出中消失。</p>
<p>比如在下面这个示例中，是个较为典型的死锁情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;5 tid&#x3D;0x00acc490 nid&#x3D;0xe50 waiting for monitor entry [0x02d3f000 </span><br><span class="line">..0x02d3fd68] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f18&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot; prio&#x3D;5 tid&#x3D;0x00accdb0 nid&#x3D;0xdec waiting for monitor entry [0x02cff000 </span><br><span class="line">..0x02cff9e8] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f18&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure>

<p>在 JAVA 5中加强了对死锁的检测。线程 Dump中可以直接报告出 Java级别的死锁，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock: </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">&quot;Thread-1&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f334 (object 0x22c19f18, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-0&quot; </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f314 (object 0x22c19f20, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-热锁"><a href="#3-3-热锁" class="headerlink" title="3.3 热锁"></a>3.3 热锁</h5><p>热锁，也往往是导致系统性能瓶颈的主要因素。其表现特征为：由于多个线程对临界区，或者锁的竞争，可能出现：</p>
<blockquote>
<p>1.频繁的线程的上下文切换：从操作系统对线程的调度来看，当线程在等待资源而阻塞的时候，操作系统会将之切换出来，放到等待的队列，当线程获得资源之后，调度算法会将这个线程切换进去，放到执行队列中。<br>2.大量的系统调用：因为线程的上下文切换，以及热锁的竞争，或者临界区的频繁的进出，都可能导致大量的系统调用。<br>3.大部分CPU开销用在“系统态”：线程上下文切换，和系统调用，都会导致 CPU在 “系统态 ”运行，换而言之，虽然系统很忙碌，但是CPU用在 “用户态 ”的比例较小，应用程序得不到充分的 CPU资源。<br>4.随着CPU数目的增多，系统的性能反而下降。因为CPU数目多，同时运行的线程就越多，可能就会造成更频繁的线程上下文切换和系统态的CPU开销，从而导致更糟糕的性能。</p>
</blockquote>
<p>上面的描述，都是一个 scalability（可扩展性）很差的系统的表现。从整体的性能指标看，由于线程热锁的存在，程序的响应时间会变长，吞吐量会降低。</p>
<p>那么，怎么去了解 “热锁 ”出现在什么地方呢？</p>
<blockquote>
<p>一个重要的方法是 结合操作系统的各种工具观察系统资源使用状况，以及收集Java线程的DUMP信息，看线程都阻塞在什么方法上，了解原因，才能找到对应的解决方法。</p>
</blockquote>
<h5 id="4-JVM重要线程"><a href="#4-JVM重要线程" class="headerlink" title="4 JVM重要线程"></a>4 JVM重要线程</h5><p>JVM运行过程中产生的一些比较重要的线程罗列如下：</p>
<table>
<thead>
<tr>
<th>线程名称</th>
<th align="right">所属</th>
<th align="right">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>Attach Listener</td>
<td align="right">JVM</td>
<td align="right">Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并把结果返回给发送者。通常我们会用一些命令去要求JVM给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在JVM启动的时候没有初始化，那么，则会在用户第一次执行JVM命令时，得到启动。</td>
</tr>
<tr>
<td>Signal Dispatcher</td>
<td align="right">JVM</td>
<td align="right">前面提到Attach Listener线程的职责是接收外部JVM命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部JVM命令时，进行初始化工作。</td>
</tr>
<tr>
<td>CompilerThread0</td>
<td align="right">JVM</td>
<td align="right">用来调用JITing，实时编译装卸class 。 通常，JVM会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：CompilerThread1。</td>
</tr>
<tr>
<td>Concurrent Mark-Sweep GC Thread</td>
<td align="right">JVM</td>
<td align="right">并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。ps：启用该垃圾回收器，需要在JVM启动参数中加上：-XX:+UseConcMarkSweepGC。</td>
</tr>
<tr>
<td>DestroyJavaVM</td>
<td align="right">JVM</td>
<td align="right">执行main()的线程，在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程，处于等待状态，等待其它线程（Java线程和Native线程）退出时通知它卸载JVM。每个线程退出时，都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，则通知DestroyJavaVM 线程卸载JVM。</td>
</tr>
<tr>
<td>Finalizer Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：1) 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；2) 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</td>
</tr>
<tr>
<td>Low Memory Detector</td>
<td align="right">JVM</td>
<td align="right">这个线程是负责对可使用内存进行检测，如果发现可用内存低，分配新的内存空间。</td>
</tr>
<tr>
<td>Reference Handler</td>
<td align="right">JVM</td>
<td align="right">JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</td>
</tr>
<tr>
<td>VM Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程就比较牛b了，是JVM里面的线程母体，根据hotspot源码（vmThread.hpp）里面的注释，它是一个单个的对象（最原始的线程）会产生或触发所有其他的线程，这个单个的VM线程是会被其他线程所使用来做一些VM操作（如：清扫垃圾等）。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">啃碎并发（三）：Java线程上下文切换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:37:55" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是<strong>多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</strong></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
