<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 12:56:07" itemprop="dateCreated datePublished" datetime="2020-06-03T12:56:07+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1.什么是线程"></a>1.什么是线程</h2><p><strong>基本概念</strong></p>
<p>我们先从线程的基本概念开始，给大家复习一下，不知道有多少同学是基础不太好，说什么是线程都不知道的，如果这样的话，花时间去补初级内容的课。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%87%8D%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%87%8D%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">啃碎并发（11）：内存模型之重排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 09:05:20" itemprop="dateCreated datePublished" datetime="2020-06-03T09:05:20+08:00">2020-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/%E9%87%8D%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index"><span itemprop="name">重排序</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>0 前言<br>在很多情况下，访问一个程序变量（对象实例字段，类静态字段和数组元素）可能会使用不同的顺序执行，而不是程序语义所指定的顺序执行。具体几种情况，如下：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%87%8D%E6%8E%92%E5%BA%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（10）：内存模型之内部原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 09:03:58" itemprop="dateCreated datePublished" datetime="2020-06-03T09:03:58+08:00">2020-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">内存模型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>0 前言<br>如上一篇文章所述，Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整计算机的模型，因此，这个模型自然会包含一个内存模型—又称为Java内存模型。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">啃碎并发（九）：内存模型之基础概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 09:03:19" itemprop="dateCreated datePublished" datetime="2020-06-03T09:03:19+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在并发编程中，需要解决两个关键问题：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/%E7%AE%97%E6%B3%95%20--%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/02/%E7%AE%97%E6%B3%95%20--%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">算法 -- 动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-02 19:19:17" itemprop="dateCreated datePublished" datetime="2020-06-02T19:19:17+08:00">2020-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-青蛙跳台阶"><a href="#0-青蛙跳台阶" class="headerlink" title="0. 青蛙跳台阶"></a>0. 青蛙跳台阶</h4><p>问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static int fun(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    int[] dp &#x3D; new int[n + 1];</span><br><span class="line">    dp[1] &#x3D; 1; dp[2] &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-最大连续子序列和"><a href="#1-最大连续子序列和" class="headerlink" title="1. 最大连续子序列和"></a>1. 最大连续子序列和</h4><p>给定k个整数的序列{N1,N2,…,Nk }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= k。最大连续子序列是所有连续子序中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{11,-4,13}，最大连续子序列和即为20。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 状态转移方程 dp[i] &#x3D; max&#123;dp[i-1] + A[i], A[i]&#125;</span><br><span class="line">private static int MaxSubSequence2(int[] A) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[A.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; 0;</span><br><span class="line">        if (i &#x3D;&#x3D; 0) continue;</span><br><span class="line">        if (A[i] &gt; dp[i - 1] + A[i]) &#123;</span><br><span class="line">            dp[i] &#x3D; A[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int max &#x3D; dp[0];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; dp.length; i++) &#123;</span><br><span class="line">        if (max &lt; dp[i]) max &#x3D; dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最长递增子序列（LIS）"><a href="#2-最长递增子序列（LIS）" class="headerlink" title="2. 最长递增子序列（LIS）"></a>2. 最长递增子序列（LIS）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 【最长递增子序列（LIS）】</span><br><span class="line"> * 1.若arr[i]&gt;arr[j],说明第i个元素可以接在第j个元素后面作为新的递增序列的结尾,即dp[i] &#x3D; max(dp[j])+1 &#x3D; max(dp[j] + 1)</span><br><span class="line"> * 2.若arr[i]&lt;&#x3D;arr[j],说明第i个元素比前面所有的数都小,此时以i元素作为结尾的递增序列长度为1,即dp[i] &#x3D; 1</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int LIS(int[] A) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[A.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; 1;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (A[i] &gt; A[j] &amp;&amp; dp[i] &lt; (dp[j] + 1)) &#123;</span><br><span class="line">                dp[i] &#x3D; dp[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp &#x3D; dp[0];</span><br><span class="line">    for (int m &#x3D; 0; m &lt; dp.length; m++) &#123;</span><br><span class="line">        if (temp &lt; dp[m]) &#123;</span><br><span class="line">            temp &#x3D; dp[m];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-最长公共子序列（LCS）"><a href="#3-最长公共子序列（LCS）" class="headerlink" title="3. 最长公共子序列（LCS）"></a>3. 最长公共子序列（LCS）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 【最长公共子序列（LCS）】</span><br><span class="line"> * 设序列X&#x3D;&#123;x1,x2,…,xm&#125;和Y&#x3D;&#123;y1,y2,…,yn&#125;的最长公共子序列为Z&#x3D;&#123;z1,z2,…,zk&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int LCS(int[] X, int[] Y) &#123;</span><br><span class="line">	int m &#x3D; X.length;</span><br><span class="line">	int n &#x3D; Y.length;</span><br><span class="line">	int[][] L &#x3D; new int[m][n];</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (X[i] &#x3D;&#x3D; Y[j]) &#123;</span><br><span class="line">			if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i - 1][j - 1] + 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			L[i][j] &#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; else if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">			if (L[i - 1][j] &gt; L[i][j - 1]) &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i - 1][j];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i][j - 1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return L[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-编辑距离"><a href="#4-编辑距离" class="headerlink" title="4. 编辑距离"></a>4. 编辑距离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 编辑距离</span><br><span class="line"> * 1、维护一个dp数组，其中dp[i][j]表示s1[0]---s1[i]和s2[0]--s2[j]相同需要进行的最少步骤；</span><br><span class="line"> * 2、边界条件初始化，dp[i][0]&#x3D;i，相当于将s1挨个变成空所要进行的步数，对于dp[0][j]&#x3D;j同理；</span><br><span class="line"> * 3、状态转移方程，我们要得到dp[i][j]的值，假设s1[i-1]和s2[j-1]之前的都已经相等了，那么如果s1[i]&#x3D;&#x3D;s2[j]，显然不需要进行操作，dp[i][j]&#x3D;&#x3D;dp[i-1][j-1]；如果s1[i]!&#x3D;s2[j]，那么到达dp[i][j]的就有三条路，分别从dp[i-1][j-1]、dp[i-1][j]、dp[i][j-1]，对应的含义分别是修改字符、删除字符和插入字符，在三种操作下，经历的步数都要+1，所以我们只要找三者的最小值然后+1就可以了。</span><br><span class="line">*&#x2F;</span><br><span class="line">private static int editDistance(String s1, String s2) &#123;</span><br><span class="line">    int s1_len &#x3D; s1.length();</span><br><span class="line">    int s2_len &#x3D; s2.length();</span><br><span class="line">    int[][] dp &#x3D; new int[s1_len][s2_len];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; s1_len; i++) &#123;</span><br><span class="line">        dp[i][0] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 0; j &lt; s2_len; j++) &#123;</span><br><span class="line">        dp[0][j] &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 1; i &lt; s1_len; i++)</span><br><span class="line">        for (int j &#x3D; 1; j &lt; s2_len; j++) &#123;</span><br><span class="line">            if (s1.charAt(i) &#x3D;&#x3D; s2.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i - 1][j - 1] + 1);</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i][j - 1] + 1);</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i - 1][j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    return dp[s1_len - 1][s2_len - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
<p><strong>1. 暴力破解算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">    if (s.isEmpty()) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    String res &#x3D; s.substring(0, 1);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt;&#x3D; s.length(); j++) &#123;</span><br><span class="line">            String k &#x3D; s.substring(i, j);</span><br><span class="line">            String rk &#x3D; new StringBuffer(k).reverse().toString();</span><br><span class="line">            if (k.equals(rk) &amp;&amp; k.length() &gt; res.length()) &#123;</span><br><span class="line">                res &#x3D; k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 动态规划</strong></p>
<p>创建一个二维数组，boolean[][] dp, 其中dp[i][j]表示字符串第i到j是否为回文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string longestPalindrome(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.empty()) return &quot;&quot;;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    if (len &#x3D;&#x3D; 1)return s;</span><br><span class="line">    int longest &#x3D; 1;</span><br><span class="line">    int start&#x3D;0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(len,vector&lt;int&gt;(len));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] &#x3D; 1;</span><br><span class="line">        if(i&lt;len-1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + 1] &#x3D; 1;</span><br><span class="line">                start&#x3D;i;</span><br><span class="line">                longest&#x3D;2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int l &#x3D; 3; l &lt;&#x3D; len; l++)&#x2F;&#x2F;子串长度</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i+l-1 &lt; len; i++)&#x2F;&#x2F;枚举子串的起始点</span><br><span class="line">        &#123;</span><br><span class="line">            int j&#x3D;l+i-1;&#x2F;&#x2F;终点</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[j] &amp;&amp; dp[i+1][j-1]&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] &#x3D; 1;</span><br><span class="line">                start&#x3D;i;</span><br><span class="line">                longest &#x3D; l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(start,longest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-无重复字符最长子串长度"><a href="#6-无重复字符最长子串长度" class="headerlink" title="6. 无重复字符最长子串长度"></a>6. 无重复字符最长子串长度</h4><p>dp[i]表示字符串以i结尾的中最长无重复字符的长度。 状态转移方程可以表述为：</p>
<ol>
<li>dp[i] = dp[i-1] + 1 (dp[i] 在1…i-1里面不重复）</li>
<li>dp[i] = max(d, i-1-d) </li>
</ol>
<h1 id="方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max-dp-）"><a href="#方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max-dp-）" class="headerlink" title="方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max(dp)）"></a>方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max(dp)）</h1><h1 id="状态转移："><a href="#状态转移：" class="headerlink" title="状态转移："></a>状态转移：</h1><h1 id="1-若s-j-不存在于s-j-，那么dp-j-dp-j-1-1"><a href="#1-若s-j-不存在于s-j-，那么dp-j-dp-j-1-1" class="headerlink" title="1. 若s[j]不存在于s[:j]，那么dp[j]=dp[j-1]+1;"></a>1. 若s[j]不存在于s[:j]，那么dp[j]=dp[j-1]+1;</h1><h1 id="2-若s-j-存在于s-j-中，但是s-j-和之前重复的那个元素之间的距离d-gt-dp-j-1-，那么不对当前产生影响，dp-j-dp-j-1-1，例如：s-”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；"><a href="#2-若s-j-存在于s-j-中，但是s-j-和之前重复的那个元素之间的距离d-gt-dp-j-1-，那么不对当前产生影响，dp-j-dp-j-1-1，例如：s-”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；" class="headerlink" title="2. 若s[j]存在于s[:j]中，但是s[j]和之前重复的那个元素之间的距离d&gt;dp[j-1]，那么不对当前产生影响，dp[j]=dp[j-1]+1，例如：s=”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；"></a>2. 若s[j]存在于s[:j]中，但是s[j]和之前重复的那个元素之间的距离d&gt;dp[j-1]，那么不对当前产生影响，dp[j]=dp[j-1]+1，例如：s=”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；</h1><h1 id="3-若d-lt-dp-j-1-，那么dp-j-d"><a href="#3-若d-lt-dp-j-1-，那么dp-j-d" class="headerlink" title="3. 若d&lt;dp[j-1]，那么dp[j]=d"></a>3. 若d&lt;dp[j-1]，那么dp[j]=d</h1><h4 id="7-纸牌游戏"><a href="#7-纸牌游戏" class="headerlink" title="7. 纸牌游戏"></a>7. 纸牌游戏</h4><p>有一个整型数组A，代表数值不同的纸牌排成一条线。玩家a和玩家b依次拿走每张纸牌，规定玩家a先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家a和玩家b都绝顶聪明，他们总会采用最优策略。请返回最后获胜者的分数。</p>
<p>给定纸牌序列A及序列的大小n，请返回最后分数较高者得分数(相同则返回任意一个分数)。保证A中的元素均小于等于1000。且A的大小小于等于300。</p>
<blockquote>
<p>测试样例：<br>[1,2,100,4],4<br>返回：101</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int cardGame(int[] A, int n) &#123;</span><br><span class="line">    int[][] f &#x3D; new int[n][n];</span><br><span class="line">    int[][] s &#x3D; new int[n][n];</span><br><span class="line">    &#x2F;&#x2F; 注意j，i的取值范围</span><br><span class="line">    for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">        f[j][j] &#x3D; A[j];</span><br><span class="line">        for (int i &#x3D; j - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            f[i][j] &#x3D; Math.max(A[i] + s[i + 1][j], A[j] + s[i][j - 1]);</span><br><span class="line">            s[i][j] &#x3D; Math.min(f[i + 1][j], f[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       return Math.max(f[0][n - 1], s[0][n - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-0-1背包问题"><a href="#8-0-1背包问题" class="headerlink" title="8. 0-1背包问题"></a>8. 0-1背包问题</h4><p>给定n个重量为W1、W2、W3 .. Wn , 价值为V1、V2、V3 .. Vn的物品和容量为j的背包</p>
<p>定义V(i,j)：当前背包容量j，前i个物品最佳组合对应的价值</p>
<ol>
<li>如果： j &lt; w(i)  则V(i, j) = V(i - 1, j)</li>
<li>如果： j &gt;= w(i) 则V(i, j) = max{ V(i - 1, j)，V(i - 1, j - w(i)) + v(i) ｝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 1; j &lt;&#x3D; bagV; j++) &#123;</span><br><span class="line">        if (j &lt; w[i])</span><br><span class="line">            dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">        else</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486294&idx=1&sn=dd8968700d19ea8b1db29065dc2f7b01&chksm=ce404082f937c994444393163a2bf53f32e18f9a752aad610c3d4988f31c328cae203a84809b&scene=21#wechat_redirect" target="_blank" rel="noopener">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">数据结构 -- 布隆过滤器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-02 10:14:21 / 修改时间：19:18:16" itemprop="dateCreated datePublished" datetime="2020-06-02T10:14:21+08:00">2020-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-问题情景"><a href="#1-问题情景" class="headerlink" title="1. 问题情景"></a>1. 问题情景</h4><p>如果面试官问你，一个网站有 100 亿 url 存在一个黑名单中，每条 url 平均 64 字节。问这个黑名单要怎么存？若此时随便输入一个 url，如何判断该 url 是否在这个黑名单中？</p>
<p>对于第一个问题，如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p>
<p>那该怎么办？ok，现在该介绍今天的主角了 —— 布隆过滤器就可以解决这样的问题。</p>
<blockquote>
<p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制矢量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<h4 id="2-具体介绍"><a href="#2-具体介绍" class="headerlink" title="2. 具体介绍"></a>2. 具体介绍</h4><blockquote>
<p>布隆过滤器实际上是一个很长的二进制矢量和一系列随机映射函数。</p>
</blockquote>
<p>「很长的二进制矢量」：这是一个长度很长的数组，什么类型的数组呢？bit 类型的数组，也是我们说的「位」，（1Byte = 8bit，1KB = 1024Byte）。<br>「一系列随机映射函数」：有多个哈希函数。那什么是哈希函数呢？JDK 里面有计算得到哈希值的方法，那就是一个哈希函数。<br>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p>
<h4 id="3-解决过程"><a href="#3-解决过程" class="headerlink" title="3. 解决过程"></a>3. 解决过程</h4><p>下面我说下大体的过程，细节部分可先不理解，重要的是明白流程，细节我后面补充。</p>
<p>假设，bit 类型数组的长度为 m，每个元素值为 0，有 k 个哈希函数。</p>
<p>首先，当输入一个 url 的时候，此时这个 url 会经过 k 个哈希函数处理，得到多个哈希值（v1,v2,…,vk）。之后得到这些哈希值对应在数组的下标位置，最后将这些下标的元素都置为 1。</p>
<p>那么如何判断一个 url 在黑名单里面呢？输入一条 url，它经过上述处理之后，会得到多个数组的下标位置。如果这些下标的元素值都已经为 1 了，说明该在黑名单里面，否则不在。</p>
<p>总体就是这样的流程，下面说下大家可能存在的疑问：</p>
<p>1、bit 类型的数组如何构建<br>2、得到 v1,v2,…,vk 这些哈希值后，如何得到其在数组的下标位置，并将其设置为 1 呢？</p>
<p>两个问题我一起说下，Java 里面没有 bit 这样的类型，怎么构建呢？—— 不难，我们可以使用 int，一个 int 是 32 位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建了一个 100 * 32bit 的数组</span><br><span class="line">int[] arr &#x3D; new int[100]; </span><br><span class="line">&#x2F;&#x2F; 代表 bit 数组 0-31 位的元素</span><br><span class="line">arr[0];</span><br></pre></td></tr></table></figure>

<p>因此上面再会说「分别将这些哈希值除以数组的长度 m，和对 m 取模，得到这些哈希值对应在数组的下标位置」。</p>
<p>具体我们可以拿一个哈希值 data 来举个栗子，假设 int 数组长度为 100。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Set(int data) &#123;</span><br><span class="line">       &#x2F;&#x2F; ByteNO 是表示在 table 数组中那个元素</span><br><span class="line">       int ByteNo &#x3D; data &#x2F; 32;</span><br><span class="line">       &#x2F;&#x2F; bitNo 是表示在 32 位 bit 中哪个 bit 位。</span><br><span class="line">       int BitNo &#x3D; data % 32;</span><br><span class="line">       &#x2F;&#x2F; 置 1</span><br><span class="line">       _table[ByteNo] |&#x3D; (1 &lt;&lt; BitNo); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-使用效果"><a href="#4-使用效果" class="headerlink" title="4. 使用效果"></a>4. 使用效果</h4><p>最开始我们提到，如果将 100 亿 url 放到 HashMap 中需要 640GB，那么使用布隆过滤器后又需要多少空间呢？答案是约等于 23 GB。相比之下，这个空间大小是不是就可以接受很多了。</p>
<h4 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a>5. 缺点</h4><p>布隆过滤器有宁可错杀一百，也不能放过一个的性质。讲人话就是属于黑名单的 url 一定能够正确判断它在黑名单中，但不属于黑名单中的 url 也可能会被认为在黑名单中，存在一定的失误率。</p>
<p><a href="https://juejin.im/post/5ce60f8ce51d4510bf1d65ea" target="_blank" rel="noopener">大白话布隆过滤器</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90wait&notify%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90wait&notify%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（八）：深入分析wait&notify原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 20:44:24" itemprop="dateCreated datePublished" datetime="2020-06-01T20:44:24+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>上一节讲了Synchronized关键词的原理与优化分析，而配合Synchronized使用的另外两个关键词<strong>wait&amp;notify</strong>是本章讲解的重点。最简单的东西，往往包含了最复杂的实现，因为需要为上层的存在提供一个稳定的基础，<strong>Object作为Java中所有对象的基类，其存在的价值不言而喻，其中wait&amp;notify方法的实现多线程协作提供了保证。</strong></p>
<h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1 源码"></a>1 源码</h4><p>今天我们要学习或者说分析的是<strong>Object</strong>类中的 wait&amp;notify 这两个方法，其实说是两个方法，这两个方法包括他们的重载方法一共有 5 个，而 Object 类中一共才 12 个方法，可见这 2 个方法的重要性。我们先看看 JDK 中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final native void notify();</span><br><span class="line">public final native void notifyAll();</span><br><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">&#125;</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (timeout &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                            &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 此处对于纳秒的处理不精准，只是简单增加了1毫秒，</span><br><span class="line">    if (nanos &gt; 0) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这五个方法。其中有<strong>3 个方法是 native 的，也就是由虚拟机本地的 c 代码执行的。</strong>有 2 个 wait 重载方法最终还是调用了 wait（long） 方法。</p>
<p><strong>1.wait方法：</strong>wait是要释放对象锁，进入等待池。既然是释放对象锁，那么肯定是先要获得锁。所以wait必须要写在synchronized代码块中，否则会报异常。</p>
<p><strong>2.notify方法：</strong>也需要写在synchronized代码块中，调用对象的这两个方法也需要先获得该对象的锁。 <strong>notify，notifyAll，唤醒等待该对象同步锁的线程，并放入该对象的锁池中。对象的锁池中线程可以去竞争得到对象锁，然后开始执行。</strong></p>
<blockquote>
<p>1.<strong>如果是通过notify来唤起的线程，</strong>那先进入wait的线程会先被唤起来，并非随机唤醒；<br>2.<strong>如果是通过nootifyAll唤起的线程</strong>，默认情况是最后进入的会先被唤起来，即LIFO的策略；</p>
</blockquote>
<p>另外一点比较重要，notify，notifyAll调用时并不会释放对象锁。比如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void test()</span><br><span class="line">&#123;</span><br><span class="line">    Object object &#x3D; new Object();</span><br><span class="line">    synchronized (object)&#123;</span><br><span class="line">        object.notifyAll();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然调用了notifyAll，但是紧接着进入了一个死循环。<strong>导致一直不能出临界区，一直不能释放对象锁。</strong>所以，即使它把所有在等待池中的线程都唤醒放到了对象的锁池中，<strong>但是锁池中的所有线程都不会运行，因为他们始终拿不到锁。</strong></p>
<h4 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h4><p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread A is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;thread A get lock&quot;);</span><br><span class="line">                        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                        System.out.println(&quot;thread A do wait method&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(&quot;wait end&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread B is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    System.out.println(&quot;thread B get lock&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    System.out.println(&quot;thread B do notify method&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread A is waiting to get lock</span><br><span class="line">thread A get lock</span><br><span class="line">thread B is waiting to get lock</span><br><span class="line">thread A do wait method</span><br><span class="line">thread B get lock</span><br><span class="line">thread B do notify method</span><br><span class="line">wait end</span><br></pre></td></tr></table></figure>

<p><strong>前提：必须由同一个lock对象调用wait、notify方法</strong></p>
<blockquote>
<ol>
<li>当线程A执行wait方法时，该线程会被挂起；</li>
<li>当线程B执行notify方法时，会唤醒一个被挂起的线程A；</li>
</ol>
</blockquote>
<p><strong>lock对象、线程A和线程B三者是一种什么关系？</strong>根据上面的结论，可以想象一个场景：</p>
<blockquote>
<p>1.lock对象维护了一个等待队列list；<br>2.线程A中执行lock的wait方法，把线程A保存到list中；<br>3.线程B中执行lock的notify方法，从等待队列中取出线程A继续执行；</p>
</blockquote>
<h4 id="3-相关疑问"><a href="#3-相关疑问" class="headerlink" title="3 相关疑问"></a>3 相关疑问</h4><h5 id="3-1-为何wait-amp-notify必须要加synchronized锁"><a href="#3-1-为何wait-amp-notify必须要加synchronized锁" class="headerlink" title="3.1 为何wait&amp;notify必须要加synchronized锁"></a>3.1 为何wait&amp;notify必须要加synchronized锁</h5><p>从实现上来说，这个锁至关重要，正因为这把锁，才能让整个wait/notify玩转起来，当然我觉得其实通过其他的方式也可以实现类似的机制，不过hotspot至少是完全依赖这把锁来实现wait/notify的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Sort(int [] array) &#123;</span><br><span class="line">    &#x2F;&#x2F; synchronize this operation so that some other thread can&#39;t</span><br><span class="line">    &#x2F;&#x2F; manipulate the array while we are sorting it. This assumes that other</span><br><span class="line">    &#x2F;&#x2F; threads also synchronize their accesses to the array.</span><br><span class="line">    synchronized(array) &#123;</span><br><span class="line">        &#x2F;&#x2F; now sort elements in array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized 代码块通过javap生成的字节码中包含** monitorenter 和 monitorexit **指令。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-e4d758d80ff508f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/533/format/webp" alt="javap生成的字节码"></p>
<p>执行 monitorenter 指令可以获取对象的monitor，而 lock.wait() 方法通过调用native方法wait(0)实现，其中接口注释中有这么一句：</p>
<blockquote>
<p>The current thread must own this object’s monitor.</p>
</blockquote>
<p>表示线程执行*<em>lock.wait() *</em>方法时，必须持有该lock对象的monitor，如果wait方法在synchronized代码中执行，该线程很显然已经持有了monitor。</p>
<p><strong>3.2 为什么wait方法可能抛出InterruptedException异常</strong><br>这个异常大家应该都知道，当我们调用了某个线程的interrupt方法时，对应的线程会抛出这个异常，wait方法也不希望破坏这种规则，因此就算当前线程因为wait一直在阻塞，当某个线程希望它起来继续执行的时候，它还是得从阻塞态恢复过来，因此wait方法被唤醒起来的时候会去检测这个状态，当有线程interrupt了它的时候，它就会抛出这个异常从阻塞状态恢复过来。</p>
<p>这里有两点要注意：</p>
<blockquote>
<p>1.如果被interrupt的线程只是创建了，并没有start，那等他start之后进入wait态之后也是不能会恢复的；</p>
<p>2.如果被interrupt的线程已经start了，在进入wait之前，如果有线程调用了其interrupt方法，那这个wait等于什么都没做，会直接跳出来，不会阻塞；</p>
</blockquote>
<p><strong>3.3 notify执行之后立马唤醒线程吗?</strong><br>其实hotspot里真正的实现是退出同步块的时候才会去真正唤醒对应的线程，不过这个也是个默认策略，也可以改的，在notify之后立马唤醒相关线程。</p>
<p><strong>3.4 notifyAll是怎么实现全唤起所有线程</strong><br>或许大家立马想到这个简单，一个for循环就搞定了，不过在JVM里没实现这么简单，而是借助了monitorexit，上面提到了当某个线程从wait状态恢复出来的时候，要先获取锁，然后再退出同步块，所以notifyAll的实现是调用notify的线程在退出其同步块的时候唤醒起最后一个进入wait状态的线程，然后这个线程退出同步块的时候继续唤醒其倒数第二个进入wait状态的线程，依次类推，同样这这是一个策略的问题，JVM里提供了挨个直接唤醒线程的参数，不过都很罕见就不提了。</p>
<p><strong>3.5 wait的线程是否会影响load</strong><br>这个或许是大家比较关心的话题，因为关乎系统性能问题，wait/nofity 是通过JVM里的 park/unpark 机制来实现的，在Linux下这种机制又是通过<br>pthread_cond_wait/pthread_cond_signal 来玩的，因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。</p>
<p>4 其他资料<br>1.<a href="https://blog.csdn.net/boling_cavalry/article/details/77793224" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之一：JVM源码分析</a><br>2.<a href="https://blog.csdn.net/boling_cavalry/article/details/77897108" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之二：修改JVM源码看参数</a><br>3.<a href="https://blog.csdn.net/boling_cavalry/article/details/77995069" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之三：修改JVM源码控制抢锁顺序</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（七）：深入分析Synchronized原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 20:44:03" itemprop="dateCreated datePublished" datetime="2020-06-01T20:44:03+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/Synchronized/" itemprop="url" rel="index"><span itemprop="name">Synchronized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">啃碎并发（六）：Java线程同步与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:30:50 / 修改时间：20:43:38" itemprop="dateCreated datePublished" datetime="2020-06-01T20:30:50+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p><strong>为何要使用Java线程同步？</strong> Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时，将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<p><strong>但其并发编程的根本，就是使线程间进行正确的通信。</strong>其中两个比较重要的关键点，如下：</p>
<blockquote>
<p>1.线程通信：重点关注线程同步的几种方式；<br>2.正确通信：重点关注是否有线程安全问题；</p>
</blockquote>
<p>Java中提供了很多线程同步操作，比如：<strong>synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</strong>本文主要说明一下这几种同步方式的使用及优劣。</p>
<h4 id="1-ReentrantLock可重入锁"><a href="#1-ReentrantLock可重入锁" class="headerlink" title="1 ReentrantLock可重入锁"></a>1 ReentrantLock可重入锁</h4><p>自JDK5开始，新增了Lock接口以及它的一个实现类ReentrantLock。ReentrantLock可重入锁是J.U.C包内置的一个锁对象，可以用来实现同步，基本使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line">    private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000l);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest &#x3D; new ReentrantLockTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子表示 同一时间段只能有1个线程执行execute方法，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br></pre></td></tr></table></figure>
<p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起。</strong>可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1。</p>
<p>举个例子再次说明一下可重入的意思：在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用(调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void anotherLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">Thread-0 invoke anotherLock</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br><span class="line">Thread-1 invoke anotherLock</span><br></pre></td></tr></table></figure>

<h5 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 synchronized</h5><p>synchronized跟ReentrantLock一样，也支持可重入锁。但是它是 一个关键字，是一种语法级别的同步方式，称为内置锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedKeyWordTest &#123;</span><br><span class="line">    public synchronized void execute() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void anotherLock() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynchronizedKeyWordTest reentrantLockTest &#x3D; new SynchronizedKeyWordTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果跟ReentrantLock一样，这个例子说明内置锁可以作用在方法上。synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p>
<p>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p>
<p><strong>synchronized跟ReentrantLock相比，有几点局限性：</strong></p>
<blockquote>
<p>1.加锁的时候不能设置超时。ReentrantLock有提供tryLock方法，可以设置超时时间，如果超过了这个时间并且没有获取到锁，就会放弃，而synchronized却没有这种功能；<br>2.ReentrantLock可以使用多个Condition，而synchronized却只能有1个<br>3.不能中断一个试图获得锁的线程；<br>4.ReentrantLock可以选择公平锁和非公平锁；<br>5.ReentrantLock可以获得正在等待线程的个数，计数器等；</p>
</blockquote>
<p>所以，Lock的操作与synchronized相比，灵活性更高，而且Lock提供多种方式获取锁，有Lock、ReadWriteLock接口，以及实现这两个接口的ReentrantLock类、ReentrantReadWriteLock类。</p>
<p><strong>关于Lock对象和synchronized关键字选择的考量：</strong></p>
<blockquote>
<p>1.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。<br>2.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码。<br>3.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁。</p>
</blockquote>
<p>在性能考量上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h5 id="3-Condition条件对象"><a href="#3-Condition条件对象" class="headerlink" title="3 Condition条件对象"></a>3 Condition条件对象</h5><p>Condition条件对象的意义在于 对于一个已经获取Lock锁的线程，如果还需要等待其他条件才能继续执行的情况下，才会使用Condition条件对象。</p>
<p>Condition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。</p>
<p>为什么方法名不直接叫wait()/notify()/nofityAll()？因为Object的这几个方法是final的，不可重写！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">        Condition condition &#x3D; lock.newCondition();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中thread1执行到condition.await()时，当前线程会被挂起，直到thread2调用了condition.signalAll()方法之后，thread1才会重新被激活执行。</p>
<p>这里需要注意的是thread1调用Condition的await方法之后，thread1线程释放锁，然后马上加入到Condition的等待队列，由于thread1释放了锁，thread2获得锁并执行，thread2执行signalAll方法之后，Condition中的等待队列thread1被取出并加入到AQS中，接下来thread2执行完毕之后释放锁，由于thread1已经在AQS的等待队列中，所以thread1被唤醒，继续执行。</p>
<p>传统线程的通信方式，Condition都可以实现。Condition的强大之处在于它可以为多个线程间建立不同的Condition。</p>
<p>注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<h5 id="4-wait-amp-notify-notifyAll方式"><a href="#4-wait-amp-notify-notifyAll方式" class="headerlink" title="4 wait&amp;notify/notifyAll方式"></a>4 wait&amp;notify/notifyAll方式</h5><p>Java线程的状态转换图与相关方法，如下：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2fb881c9f4656c80.png" alt="线程状态转换图"></p>
<p>在图中，红框标识的部分方法，可以认为已过时，不再使用。上图中的方法能够参与到线程同步中的方法，如下：</p>
<p><strong>1. wait、notify、notifyAll方法：线程中通信可以使用的方法。线程中调用了wait方法，则进入阻塞状态，只有等另一个线程调用与wait同一个对象的notify方法。这里有个特殊的地方，调用wait或者notify，前提是需要获取锁，也就是说，需要在同步块中做以上操作。</strong></p>
<blockquote>
<p>wait/notifyAll方式跟ReentrantLock/Condition方式的原理是一样的。</p>
<p>Java中每个对象都拥有一个内置锁，在内置锁中调用wait，notify方法相当于调用锁的Condition条件对象的await和signalAll方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyAllTest &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">            this.notifyAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WaitNotifyAllTest waitNotifyAllTest &#x3D; new WaitNotifyAllTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doNotify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 调用wait/notifyAll方法的时候一定要获得当前线程的锁，否则会发生IllegalMonitorStateException异常。</p>
<p><strong>2.join方法：该方法主要作用是在该线程中的run方法结束后，才往下执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.thread.simple;</span><br><span class="line">public class ThreadJoin &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread&#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                   System.err.println(&quot;线程&quot;+Thread.currentThread().getId()+&quot; 打印信息&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">     </span><br><span class="line">        try &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;主线程打印信息&quot;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. yield方法：线程本身的调度方法，使用时线程可以在run方法执行完毕时，调用该方法，告知线程已可以出让CPU资源。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. sleep方法：通过sleep(millis)</strong>使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法告诉操作系统 至少在指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。实际上，调用sleep方法时并不要求持有任何锁。</p>
<p>所以，sleep方法并不需要持有任何形式的锁，也就不需要包裹在synchronized中。</p>
<h5 id="5-ThreadLocal"><a href="#5-ThreadLocal" class="headerlink" title="5 ThreadLocal"></a>5 ThreadLocal</h5><p>ThreadLocal是一种把变量放到线程本地的方式来实现线程同步的。比如：SimpleDateFormat不是一个线程安全的类，可以使用ThreadLocal实现同步，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal &#x3D; new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为何SimpleDateFormat不是线程安全的类？具体请参考：</strong></p>
<p><a href="https://blog.csdn.net/zdp072/article/details/41044059" target="_blank" rel="noopener">https://blog.csdn.net/zdp072/article/details/41044059</a><br><a href="https://blog.csdn.net/zq602316498/article/details/40263083" target="_blank" rel="noopener">https://blog.csdn.net/zq602316498/article/details/40263083</a></p>
<p>ThreadLocal与同步机制的对比选择：</p>
<blockquote>
<p>ThreadLocal与同步机制都是 为了解决多线程中相同变量的访问冲突问题。<br>前者采用以 “空间换时间” 的方法，后者采用以 “时间换空间” 的方式。</p>
</blockquote>
<h5 id="6-volatile修饰变量"><a href="#6-volatile修饰变量" class="headerlink" title="6 volatile修饰变量"></a>6 volatile修饰变量</h5><p>volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只给出要修改的代码，其余代码与上同</span><br><span class="line">public class Bank &#123;</span><br><span class="line">    &#x2F;&#x2F;需要同步的变量加上volatile</span><br><span class="line">    private volatile int account &#x3D; 100;</span><br><span class="line">    public int getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这里不再需要synchronized </span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account +&#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</p>
<h5 id="7-Semaphore信号量"><a href="#7-Semaphore信号量" class="headerlink" title="7 Semaphore信号量"></a>7 Semaphore信号量</h5><p>Semaphore信号量被用于控制特定资源在同一个时间被访问的个数。类似连接池的概念，保证资源可以被合理的使用。可以使用构造器初始化资源个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">    private static Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date());</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-0 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-3 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-2 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-4 Mon Apr 18 18:03:56 CST 2016</span><br></pre></td></tr></table></figure>

<h5 id="8-并发包下的工具类"><a href="#8-并发包下的工具类" class="headerlink" title="8 并发包下的工具类"></a>8 并发包下的工具类</h5><h5 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h5><p>CountDownLatch是一个计数器，它的构造方法中需要设置一个数值，用来设定计数的次数。每次调用countDown()方法之后，这个计数器都会减去1，CountDownLatch会一直阻塞着调用await()方法的线程，直到计数器的值变为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;all thread over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-2 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-3 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-4 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-0 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-1 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">all thread over</span><br></pre></td></tr></table></figure>

<h5 id="8-2-CyclicBarrier"><a href="#8-2-CyclicBarrier" class="headerlink" title="8.2 CyclicBarrier"></a>8.2 CyclicBarrier</h5><p>CyclicBarrier阻塞调用的线程，直到条件满足时，阻塞的线程同时被打开。</p>
<p>调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>在CyclicBarrier的构造方法中，还可以设置一个barrierAction。在所有的屏障都到达之后，会启动一个线程来运行这里面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int secs &#x3D; random.nextInt(5);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run, sleep &quot; + secs + &quot; secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(secs * 1000);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; runs over&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比CountDownLatch，CyclicBarrier是可以被循环使用的，而且遇到线程中断等情况时，还可以利用reset()方法，重置计数器，从这些方面来说，CyclicBarrier会比CountDownLatch更加灵活一些。</p>
<h5 id="9-使用原子变量实现线程同步"><a href="#9-使用原子变量实现线程同步" class="headerlink" title="9 使用原子变量实现线程同步"></a>9 使用原子变量实现线程同步</h5><p>有时需要使用线程同步的根本原因在于 对普通变量的操作不是原子的。那么什么是原子操作呢？</p>
<p>原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作<br>即-这几种行为要么同时完成，要么都不完成。</p>
<p>在java.util.concurrent.atomic包中提供了创建原子类型变量的工具类，使用该类可以简化线程同步。比如：其中AtomicInteger以原子方式更新int的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line">    private AtomicInteger account &#x3D; new AtomicInteger(100);</span><br><span class="line"></span><br><span class="line">    public AtomicInteger getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account.addAndGet(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-AbstractQueuedSynchronizer"><a href="#10-AbstractQueuedSynchronizer" class="headerlink" title="10 AbstractQueuedSynchronizer"></a>10 AbstractQueuedSynchronizer</h5><p>AQS是很多同步工具类的基础，比如：ReentrantLock里的公平锁和非公平锁，Semaphore里的公平锁和非公平锁，CountDownLatch里的锁等他们的底层都是使用AbstractQueuedSynchronizer完成的。</p>
<p>基于AbstractQueuedSynchronizer自定义实现一个独占锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class MySynchronizer extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">        if(compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryRelease(int arg) &#123;</span><br><span class="line">        setState(0);</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MySynchronizer mySynchronizer &#x3D; new MySynchronizer();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; will sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-使用阻塞队列实现线程同步"><a href="#11-使用阻塞队列实现线程同步" class="headerlink" title="11 使用阻塞队列实现线程同步"></a>11 使用阻塞队列实现线程同步</h5><p>前面几种同步方式都是基于底层实现的线程同步，但是在实际开发当中，应当尽量远离底层结构。本节主要是使用LinkedBlockingQueue<E>来实现线程的同步。</p>
<p>LinkedBlockingQueue<E>是一个基于链表的队列，先进先出的顺序（FIFO），范围任意的blocking queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.xhj.thread;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BlockingSynchronizedThread &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个阻塞队列用来存储生产出来的商品</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LinkedBlockingQueue&lt;Integer&gt; queue &#x3D; new LinkedBlockingQueue&lt;Integer&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义生产商品个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final int size &#x3D; 10;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int flag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private class LinkBlockThread implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int new_flag &#x3D; flag++;</span><br><span class="line">            System.out.println(&quot;启动线程 &quot; + new_flag);</span><br><span class="line">            if (new_flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    int b &#x3D; new Random().nextInt(255);</span><br><span class="line">                    System.out.println(&quot;生产商品：&quot; + b + &quot;号&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(b);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size &#x2F; 2; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int n &#x3D; queue.take();</span><br><span class="line">                        System.out.println(&quot;消费者买去了&quot; + n + &quot;号商品&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO: handle exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingSynchronizedThread bst &#x3D; new BlockingSynchronizedThread();</span><br><span class="line">        LinkBlockThread lbt &#x3D; bst.new LinkBlockThread();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(lbt);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(lbt);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">啃碎并发（五）：Java线程安全特性与问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:09:11 / 修改时间：20:30:20" itemprop="dateCreated datePublished" datetime="2020-06-01T20:09:11+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在单线程中不会出现线程安全问题，而在多线程编程中，有可能会出现同时访问同一个<strong>共享、可变资源</strong>的情况，这种资源可以是：<strong>一个变量、一个对象、一个文件等。</strong>特别注意两点：</p>
<blockquote>
<p>1.共享： 意味着该资源可以由多个线程同时访问；<br>2.可变： 意味着该资源可以在其生命周期内被修改；</p>
</blockquote>
<p>简单的说，<strong>如果你的代码在单线程下执行和在多线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</strong>那么，当进行多线程编程时，我们又会面临哪些线程安全的要求呢？又是要如何去解决的呢？</p>
<h4 id="1-线程安全特性"><a href="#1-线程安全特性" class="headerlink" title="1 线程安全特性"></a>1 线程安全特性</h4><h5 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h5><p>跟数据库事务的原子性概念差不多，<strong>即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。</strong></p>
<p>关于原子性，一个非常经典的例子就是银行转账问题：</p>
<blockquote>
<p>比如：A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p>
</blockquote>
<h5 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a>1.2 可见性</h5><p>可见性是指，<strong>当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。</strong>可见性问题是好多人忽略或者理解错误的一点。</p>
<p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。<strong>每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。</strong>此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p><strong>这一点是操作系统或者说是硬件层面的机制，</strong>所以很多应用开发人员经常会忽略。</p>
<h5 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3 有序性"></a>1.3 有序性</h5><p>有序性指的是，<strong>程序执行的顺序按照代码的先后顺序执行。</strong>以下面这段代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean started &#x3D; false; &#x2F;&#x2F; 语句1</span><br><span class="line">long counter &#x3D; 0L; &#x2F;&#x2F; 语句2</span><br><span class="line">counter &#x3D; 1; &#x2F;&#x2F; 语句3</span><br><span class="line">started &#x3D; true; &#x2F;&#x2F; 语句4</span><br></pre></td></tr></table></figure>

<p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p>
<p><strong>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</strong></p>
<p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，<strong>CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</strong></p>
<h4 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2 线程安全问题"></a>2 线程安全问题</h4><h5 id="2-1-竞态条件与临界区"><a href="#2-1-竞态条件与临界区" class="headerlink" title="2.1 竞态条件与临界区"></a>2.1 竞态条件与临界区</h5><p>线程之间共享堆空间，在编程的时候就要格外注意避免竞态条件。危险在于多个线程同时访问相同的资源并进行读写操作。<strong>当其中一个线程需要根据某个变量的状态来相应执行某个操作的之前，该变量很可能已经被其它线程修改。</strong></p>
<blockquote>
<p>也就是说，当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在<strong>竞态条件</strong>。导致竟态条件发生的代码称作<strong>临界区</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 以下这段代码就存在竞态条件，其中return ++count就是临界区。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Obj &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public int incr()&#123;</span><br><span class="line">        return ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-死锁"><a href="#2-2-死锁" class="headerlink" title="2.2 死锁"></a>2.2 死锁</h5><p>死锁：<strong>指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</strong>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>关于死锁发生的条件：</strong></p>
<blockquote>
<p><strong>1.互斥条件：</strong>线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。<br><strong>2.请求和保持条件：</strong>线程T1至少已经保持了一个资源R1占用，但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。<br><strong>3.不剥夺条件：</strong>线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。<br><strong>4.环路等待条件：</strong>在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn}，进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。<strong>（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）。</strong></p>
</blockquote>
<h5 id="2-3-活锁"><a href="#2-3-活锁" class="headerlink" title="2.3 活锁"></a>2.3 活锁</h5><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。<strong>这样你让我，我让你，最后两个线程都无法使用资源。</strong></p>
<p><strong>关于“死锁与活锁”的比喻：</strong></p>
<blockquote>
<p><strong>死锁：</strong>迎面开来的汽车A和汽车B过马路，汽车A得到了半条路的资源（满足死锁发生条件1：资源访问是排他性的，我占了路你就不能上来，除非你爬我头上去），汽车B占了汽车A的另外半条路的资源，A想过去必须请求另一半被B占用的道路（死锁发生条件2：必须整条车身的空间才能开过去，我已经占了一半，尼玛另一半的路被B占用了），B若想过去也必须等待A让路，A是辆兰博基尼，B是开奇瑞QQ的屌丝，A素质比较低开窗对B狂骂：快给老子让开，B很生气，你妈逼的，老子就不让（死锁发生条件3：在未使用完资源前，不能被其他线程剥夺），于是两者相互僵持一个都走不了（死锁发生条件4：环路等待条件），而且导致整条道上的后续车辆也走不了。</p>
<p><strong>活锁：</strong>马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。</p>
</blockquote>
<h5 id="2-4-饥饿"><a href="#2-4-饥饿" class="headerlink" title="2.4 饥饿"></a>2.4 饥饿</h5><p>饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，<strong>T2可能永远等待。</strong></p>
<p>也就是，如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，<strong>这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</strong></p>
<p><strong>关于“饥饿”的比喻：</strong></p>
<blockquote>
<p>在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的却没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p>
</blockquote>
<p>在Java中，下面三个常见的原因会导致线程饥饿，如下：</p>
<p><strong>1.高优先级线程吞噬所有的低优先级线程的CPU时间</strong></p>
<blockquote>
<p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。</p>
</blockquote>
<p><strong>2.线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问</strong></p>
<blockquote>
<p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>
</blockquote>
<p><strong>3.线程在等待一个本身（在其上调用wait()）也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒</strong></p>
<blockquote>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
</blockquote>
<h5 id="2-5-公平"><a href="#2-5-公平" class="headerlink" title="2.5 公平"></a>2.5 公平</h5><p><strong>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。</strong>在Java中实现公平性方案，需要：</p>
<blockquote>
<p>1.使用锁，而不是同步块；<br>2.使用公平锁；<br>3.注意性能方面；</p>
</blockquote>
<p>在Java中实现公平性，虽Java不可能实现100%的公平性，依然可以通过同步结构在线程间实现公平性的提高。</p>
<p>首先来学习一段简单的同步态代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    public synchronized void doSynchronized () &#123;</span><br><span class="line">        &#x2F;&#x2F; do a lot of work which takes a long time</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。</p>
<p>改为 使用锁方式替代同步块，为了提高等待线程的公平性，我们使用锁方式来替代同步块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line">    public void doSynchronized() throws InterruptedException&#123;</span><br><span class="line">        this.lock.lock();</span><br><span class="line">        &#x2F;&#x2F;critical section, do a lot of work which takes a long time</span><br><span class="line">        this.lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。下面是用Lock类做的一个实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Lock&#123;</span><br><span class="line"></span><br><span class="line">    private boolean isLocked      &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException&#123;</span><br><span class="line">        while(isLocked)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; true;</span><br><span class="line">        lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。</p>
<p>这回看下doSynchronized()，你会注意到在lock()和unlock()之间的注释：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。</p>
<p>在早些时候提到过，同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。</p>
<p>但我们能够改变这种情况，如下：</p>
<blockquote>
<p>当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
</blockquote>
<p>下面将上面Lock类转变为公平锁FairLock。你会注意到新的实现和之前的Lock类中的同步和wait()/notify()稍有不同。重点是，每一个调用lock()的线程都会进入一个队列，当解锁时，只有队列里的第一个线程被允许锁住FairLock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class FairLock &#123;</span><br><span class="line">    private boolean isLocked &#x3D; false;</span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line">    private List&lt;QueueObject&gt; waitingThreads &#x3D; new ArrayList&lt;QueueObject&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() throws InterruptedException&#123;</span><br><span class="line">        &#x2F;&#x2F; 当前线程创建“令牌”</span><br><span class="line">        QueueObject queueObject &#x3D; new QueueObject();</span><br><span class="line">        boolean isLockedForThisThread &#x3D; true;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            &#x2F;&#x2F; 所有线程的queueObject令牌，入队</span><br><span class="line">            waitingThreads.add(queueObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(isLockedForThisThread)&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                &#x2F;&#x2F; 1. 判断是否已被锁住：是否已有线程获得锁，正在执行同步代码块</span><br><span class="line">                &#x2F;&#x2F; 2. 判断头部令牌与当前线程令牌是否一致：也就是只锁住头部令牌对应的线程；</span><br><span class="line">                isLockedForThisThread &#x3D; isLocked || waitingThreads.get(0) !&#x3D; queueObject;</span><br><span class="line">                if(!isLockedForThisThread)&#123;</span><br><span class="line">                    isLocked &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; 移除头部令牌</span><br><span class="line">                    waitingThreads.remove(queueObject);</span><br><span class="line">                    lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                &#x2F;&#x2F; 其他线程执行doWait()，进行等待</span><br><span class="line">                queueObject.doWait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        if(waitingThreads.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 唤醒头部令牌对应的线程，可以执行</span><br><span class="line">            waitingThreads.get(0).doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QueueObject &#123;</span><br><span class="line">    private boolean isNotified &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() throws InterruptedException &#123;</span><br><span class="line">        while(!isNotified)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.isNotified &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        this.isNotified &#x3D; true;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        return this &#x3D;&#x3D; o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先注意到lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。</p>
<blockquote>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队操作。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p>
</blockquote>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个线程调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。</p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p>
<h4 id="3-如何确保线程安全特性"><a href="#3-如何确保线程安全特性" class="headerlink" title="3 如何确保线程安全特性"></a>3 如何确保线程安全特性</h4><h5 id="3-1-如何确保原子性"><a href="#3-1-如何确保原子性" class="headerlink" title="3.1 如何确保原子性"></a>3.1 如何确保原子性</h5><h5 id="3-1-1-锁和同步"><a href="#3-1-1-锁和同步" class="headerlink" title="3.1.1 锁和同步"></a>3.1.1 锁和同步</h5><p>常用的保证Java操作原子性的工具是 锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    synchronized (anyObject)&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论使用锁还是synchronized，本质都是一样，通过锁或同步来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</p>
<h5 id="3-1-2-CAS（compare-and-swap）"><a href="#3-1-2-CAS（compare-and-swap）" class="headerlink" title="3.1.2 CAS（compare and swap）"></a>3.1.2 CAS（compare and swap）</h5><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line">for(int b &#x3D; 0; b &lt; numThreads; b++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for(int a &#x3D; 0; a &lt; iteration; a++) &#123;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-如何确保可见性"><a href="#3-2-如何确保可见性" class="headerlink" title="3.2 如何确保可见性"></a>3.2 如何确保可见性</h5><p>Java提供了volatile关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它线程缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
<p>volatile适用场景：volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isRunning &#x3D; false;</span><br><span class="line">public void start () &#123;</span><br><span class="line">    new Thread( () -&gt; &#123;</span><br><span class="line">        while(isRunning) &#123;</span><br><span class="line">            someOperation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">public void stop () &#123;</span><br><span class="line">    isRunning &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用stop()方法将isRunning设置为false，循环也不一定会立即结束。可以通过volatile关键字，保证while循环及时得到isRunning最新的状态从而及时停止循环，结束线程。</p>
<h5 id="3-3-如何确保有序性"><a href="#3-3-如何确保有序性" class="headerlink" title="3.3 如何确保有序性"></a>3.3 如何确保有序性</h5><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p>
<blockquote>
<p>Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。</p>
</blockquote>
<p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p>
<p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p>
<p>happens-before原则（先行发生原则），如下：</p>
<blockquote>
<p><strong>1.传递规则：</strong>如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性。<br><strong>2.锁定规则：</strong>一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取。<br><strong>3.volatile变量规则：</strong>对一个被volatile修饰的写操作先发生于后面对该变量的读操作。<br><strong>4.程序次序规则：</strong>一个线程内，按照代码顺序执行。<br><strong>5.线程启动规则：</strong>Thread对象的start()方法先发生于此线程的其它动作。<br><strong>6.线程终结原则：</strong>线程的终止检测后发生于线程中其它的所有操作。<br><strong>7.线程中断规则： *<em>对线程interrupt()方法的调用先发生于对该中断异常的获取。<br>*</em>8.对象终结规则：</strong>一个对象构造先于它的finalize发生。</p>
</blockquote>
<h5 id="4-关于线程安全的几个为什么"><a href="#4-关于线程安全的几个为什么" class="headerlink" title="4 关于线程安全的几个为什么"></a>4 关于线程安全的几个为什么</h5><p><strong>1.平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？</strong></p>
<blockquote>
<p>锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。</p>
</blockquote>
<p><strong>2.锁和synchronized为何能保证可见性？</strong></p>
<blockquote>
<p>根据JDK 7的Java doc中对concurrent包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由happen-before原则推断出在读操作之前发生。</p>
</blockquote>
<p><strong>3.既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？</strong></p>
<blockquote>
<p>synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</p>
</blockquote>
<p><strong>4.既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？</strong></p>
<blockquote>
<p>锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。</p>
</blockquote>
<p><strong>5.还有没有别的办法保证线程安全？</strong></p>
<blockquote>
<p>有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。</p>
</blockquote>
<p><strong>6.synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？</strong></p>
<blockquote>
<p>synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
