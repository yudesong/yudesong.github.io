<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/18%20Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/18%20Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">18 Activity布局绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是承接上一篇文章(Android布局加载流程：<a href="http://blog.csdn.net/qq_23547831/article/details/51284556" target="_blank" rel="noopener">android源码解析（十七）–&gt;Activity布局加载流程</a>)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Activity对象也就可以说是一个窗口对象，而Window只是控制着界面布局文件的加载过程，那么界面布局文件的绘制流程是如何的呢？这篇文章主要就是顺着上篇文章的思路，看一下在android系统中Activity的布局文件是如何绘制的。</p>
<p>顺便在这里多说几句，android中所有能显示的东西都是通过Window对象实现了，无论Activity，Dialog，PopupWindow，Toast等。后期我可能也会讲一下Dialog，PopupWindow，Toast等组件的显示过程。</p>
<p>前面有一篇文章中我们介绍过Activity的启动流程，可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">android源码解析之（十四）–&gt;Activity启动流程</a><br>在执行ActivityThread的handleLauncherActivity方法中通过Window对象控制了布局文件的加载流程，而Android体系在执行Activity的onResume方法之前会回调ActivityThread的handleResumeActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide, boolean isForward, boolean reallyResume) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window &#x3D; r.activity.getWindow();</span><br><span class="line">                View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                a.mDecor &#x3D; decor;</span><br><span class="line">                l.type &#x3D; WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |&#x3D; forwardBit;</span><br><span class="line">                if (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded &#x3D; true;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the window has already been added, but during resume</span><br><span class="line">            &#x2F;&#x2F; we started another activity, then don&#39;t yet make the</span><br><span class="line">            &#x2F;&#x2F; window visible.</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; The window is now visible if it has been added, we are not</span><br><span class="line">            &#x2F;&#x2F; simply finishing, and we are not starting another activity.</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor !&#x3D; null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                if (r.newConfig !&#x3D; null) &#123;</span><br><span class="line">                    r.tmpConfig.setTo(r.newConfig);</span><br><span class="line">                    if (r.overrideConfig !&#x3D; null) &#123;</span><br><span class="line">                        r.tmpConfig.updateFrom(r.overrideConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                            + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);</span><br><span class="line">                    performConfigurationChanged(r.activity, r.tmpConfig);</span><br><span class="line">                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</span><br><span class="line">                    r.newConfig &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward&#x3D;&quot;</span><br><span class="line">                        + isForward);</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                if ((l.softInputMode</span><br><span class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                        !&#x3D; forwardBit) &#123;</span><br><span class="line">                    l.softInputMode &#x3D; (l.softInputMode</span><br><span class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                            | forwardBit;</span><br><span class="line">                    if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                        ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                        View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                        wm.updateViewLayout(decor, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mVisibleFromServer &#x3D; true;</span><br><span class="line">                mNumVisibleActivities++;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!r.onlyLocalRequest) &#123;</span><br><span class="line">                r.nextIdle &#x3D; mNewActivities;</span><br><span class="line">                mNewActivities &#x3D; r;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">                Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">            &#125;</span><br><span class="line">            r.onlyLocalRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have resumed.</span><br><span class="line">            if (reallyResume) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在在获取了Activity的Window相关参数之后执行了r.activity.makeVisible()方法，看样子这个就是Activity的显示方法，这里我们来具体看一下makeVisible方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void makeVisible() &#123;</span><br><span class="line">        if (!mWindowAdded) &#123;</span><br><span class="line">            ViewManager wm &#x3D; getWindowManager();</span><br><span class="line">            wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">            mWindowAdded &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断成员变量mWindowAdded是否为true，可以发现mWindowAdded成员变量只有在执行之后才能赋值为true，所以这里的代码的主要逻辑是该if分支只能执行一次。</p>
<p>这里的ViewManager对象是通过getWindowManager()方法获取的，我们来看一下getWindowManager()方法的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManager getWindowManager() &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，原来就是返回的Activity的mWindowManager的成员变量，那么这个mWindowManager的成员变量是什么时候赋值的呢？上一篇文章我们在Activity的attach方法方法中初始化了Activity的相关成员变量，这里也包括了mWindowManager，我们来看一下mWindowManager的赋值过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager &#x3D; mWindow.getWindowManager();</span><br></pre></td></tr></table></figure>
<p>好吧，这里的Window.getWindowManager()方法是具体如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManager getWindowManager() &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么这里的Window对象的mWindowManager成员变量是具体如何赋值的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void setWindowManager(WindowManager wm, IBinder appToken, String appName,</span><br><span class="line">            boolean hardwareAccelerated) &#123;</span><br><span class="line">        mAppToken &#x3D; appToken;</span><br><span class="line">        mAppName &#x3D; appName;</span><br><span class="line">        mHardwareAccelerated &#x3D; hardwareAccelerated</span><br><span class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);</span><br><span class="line">        if (wm &#x3D;&#x3D; null) &#123;</span><br><span class="line">            wm &#x3D; (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，可以发现mWindowManager = ((WindowManagerImpl)vm).createLocalWindowManager(this)原来是在这里赋值的，所以一个Activity对应这一个新的Window，而这个Window对象内部会对应着一个新的WindowManager对象，我们接着往下看，那么createLoclWindowManager方法是如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123;</span><br><span class="line">        return new WindowManagerImpl(mDisplay, parentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，原来是new出了一个WindowManagerImpl对象，所以回到我们的Activity的makeVisible方法，ViewManager获取的是一个WindowManagerImpl对象，所以Window对象内部的WindowManager对象其实都是一个WindowManagerImpl的实例，都是而且从继承关系上可以看到：</p>
<p>WindowManagerImpl –&gt; WindowManager –&gt; ViewManager;</p>
<p>继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wm.addView(mDecor, getWindow().getAttributes());</span><br></pre></td></tr></table></figure>
<p>这里的mDector成员变量，通过上一篇文章的介绍，我们知道，它是Activity的界面根View，而getWindow.getAttrbutes方法是windowManager中定义的Params内部类，该内部类定义了许多的Window类型，由于这里的vm是WindowManagerImpl的实例，我们来看一下这里的addView的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们具体看一下mGlobal.addView方法，这里的mGlobal是一个WindowManagerGlobal的单例对象，WindowManagerGlobal是Window处理的工具类，那么WindowManagerGlobal的addView具体是如何实现的呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        View panelParentView &#x3D; null;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            &#x2F;&#x2F; Start watching for system property changes.</span><br><span class="line">            if (mSystemPropertyUpdater &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mSystemPropertyUpdater &#x3D; new Runnable() &#123;</span><br><span class="line">                    @Override public void run() &#123;</span><br><span class="line">                        synchronized (mLock) &#123;</span><br><span class="line">                            for (int i &#x3D; mRoots.size() - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">                                mRoots.get(i).loadSystemProperties();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int index &#x3D; findViewLocked(view, false);</span><br><span class="line">            if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                if (mDyingViews.contains(view)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue.</span><br><span class="line">                    mRoots.get(index).doDie();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;View &quot; + view</span><br><span class="line">                            + &quot; has already been added to the window manager.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; The previous removeView() had not completed executing. Now it has.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If this is a panel window, then find the window it is being</span><br><span class="line">            &#x2F;&#x2F; attached to for future reference.</span><br><span class="line">            if (wparams.type &gt;&#x3D; WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                    wparams.type &lt;&#x3D; WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">                final int count &#x3D; mViews.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">                    if (mRoots.get(i).mWindow.asBinder() &#x3D;&#x3D; wparams.token) &#123;</span><br><span class="line">                        panelParentView &#x3D; mViews.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root &#x3D; new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; do this last because it fires off messages to start doing things</span><br><span class="line">        try &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">            synchronized (mLock) &#123;</span><br><span class="line">                final int index &#x3D; findViewLocked(view, false);</span><br><span class="line">                if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                    removeViewLocked(index, true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在WindowManagerGlobal中存在着三个数据列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;View&gt; mViews &#x3D; new ArrayList&lt;View&gt;();</span><br><span class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots &#x3D; new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams &#x3D;</span><br><span class="line">            new ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br></pre></td></tr></table></figure>
<p>其中mViews主要用于保存Activity的mDector也就是Activity的根View，而mRoots主要用于保存ViewRootImpl，mParams主要用于保存Window的LayoutParams，WindowManagerGlobal主要作为WindowManagerImpl的辅助方法类，用于操作View组件。</p>
<p>最后我们调用了root.setView方法，这个方法很重要我们就是在这里实现了我们的root与ViewRootImpl的关联的，除了实现了mDector与ViewRootImpl的相互关联，我们还调用了requestLayout方法，这里我们看一下setView方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        ...</span><br><span class="line">        requestLayout();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在方法体中又调用了requestLayout方法，这个方法其实就是调用执行重绘的请求，我们来看一下这个requestLayout方法具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void requestLayout() &#123;</span><br><span class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested &#x3D; true;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里有一个checkThread方法，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">        if (mThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new CalledFromWrongThreadException(</span><br><span class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相信大家平时在编程的过程中肯定会遇到过这个错误，ViewRootImpl是具体更新View的管理类，所有关于View的更新操作都是在这里执行的，自然而然的对于更新线程的检测是在这个类中添加的，一般在更新UI的时候都会调用这个方法用于检测当前执行更新UI的线程是否是UI线程，否则就会抛出这个异常。</p>
<p>继续回到我们的requestLayout方法，这里又调用了scheduleTraversales方法，我们来看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">        if (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; true;</span><br><span class="line">            mTraversalBarrier &#x3D; mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">            if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里mChoreographer.postCallback，内部会调用一个异步消息，用于执行mTraversalRunnable的run方法，这个mTraversalRunnable是一个Runnable对象，我们来看一下mTraversalRunnable类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在TraversalRunnable类的run方法中调用了doTraversal方法，我们来看一下这个方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void doTraversal() &#123;</span><br><span class="line">        if (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; false;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            if (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(&quot;ViewAncestor&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            if (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，其内部又回调了方法performTraversals方法，这个方法就是整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作之后就可以展示在界面中了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 执行View组件的onMeasure方法，主要用于测量View</span><br><span class="line">            if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">                boolean focusChangedDueToTouchMode &#x3D; ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) !&#x3D; 0);</span><br><span class="line">                if (focusChangedDueToTouchMode || mWidth !&#x3D; host.getMeasuredWidth()</span><br><span class="line">                        || mHeight !&#x3D; host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">                    int childWidthMeasureSpec &#x3D; getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    int childHeightMeasureSpec &#x3D; getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed!  mWidth&#x3D;&quot;</span><br><span class="line">                            + mWidth + &quot; measuredWidth&#x3D;&quot; + host.getMeasuredWidth()</span><br><span class="line">                            + &quot; mHeight&#x3D;&quot; + mHeight</span><br><span class="line">                            + &quot; measuredHeight&#x3D;&quot; + host.getMeasuredHeight()</span><br><span class="line">                            + &quot; coveredInsetsChanged&#x3D;&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                     &#x2F;&#x2F; Ask host how big it wants to be</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Implementation of weights from WindowManager.LayoutParams</span><br><span class="line">                    &#x2F;&#x2F; We just grow the dimensions as needed and re-measure if</span><br><span class="line">                    &#x2F;&#x2F; needs be</span><br><span class="line">                    int width &#x3D; host.getMeasuredWidth();</span><br><span class="line">                    int height &#x3D; host.getMeasuredHeight();</span><br><span class="line">                    boolean measureAgain &#x3D; false;</span><br><span class="line"></span><br><span class="line">                    if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        width +&#x3D; (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                        childWidthMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        height +&#x3D; (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                        childHeightMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (measureAgain) &#123;</span><br><span class="line">                        if (DEBUG_LAYOUT) Log.v(TAG,</span><br><span class="line">                                &quot;And hey let&#39;s measure once more: width&#x3D;&quot; + width</span><br><span class="line">                                + &quot; height&#x3D;&quot; + height);</span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">		&#x2F;&#x2F; 主要用于测量View组件的位置</span><br><span class="line">		...</span><br><span class="line">        final boolean didLayout &#x3D; layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener &#x3D; didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">            performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; By this point all views have been sized and positioned</span><br><span class="line">            &#x2F;&#x2F; We can compute the transparent area</span><br><span class="line"></span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; start out transparent</span><br><span class="line">                &#x2F;&#x2F; TODO: AVOID THAT CALL BY CACHING THE RESULT?</span><br><span class="line">                host.getLocationInWindow(mTmpLocation);</span><br><span class="line">                mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                        mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                        mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">                host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">                if (mTranslator !&#x3D; null) &#123;</span><br><span class="line">                    mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                    mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                    mFullRedrawNeeded &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; reconfigure window manager</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DBG) &#123;</span><br><span class="line">                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">                System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">                host.debug();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 主要用于View的绘制过程</span><br><span class="line">        ...</span><br><span class="line">        if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            if (!skipDraw || mReportNextDraw) &#123;</span><br><span class="line">                if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                        mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingTransitions.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                performDraw();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (viewVisibility &#x3D;&#x3D; View.VISIBLE) &#123;</span><br><span class="line">                &#x2F;&#x2F; Try again</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">            &#125; else if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsInTraversal &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法performTraversals方法，我们调用了performMeasure，performLayout，performDraw三个方法，这几个方法主要用于测量View组件的大小，测量View组件的位置，绘制View组件；</p>
<p>即：测量大小 –&gt; 测量位置 –&gt; 绘制组件</p>
<p>好吧，这里我们调用了performMeasure方法，我们先看一下performMeasure方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在performMeasure方法中我们又调用了mView的measure方法，这里的mView就是我们一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        ...</span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在View的measure方法中，又调用了onMeasure方法，由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">        final boolean measureMatchParentChildren &#x3D;</span><br><span class="line">                MeasureSpec.getMode(widthMeasureSpec) !&#x3D; MeasureSpec.EXACTLY ||</span><br><span class="line">                MeasureSpec.getMode(heightMeasureSpec) !&#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">        mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">        int maxHeight &#x3D; 0;</span><br><span class="line">        int maxWidth &#x3D; 0;</span><br><span class="line">        int childState &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child &#x3D; getChildAt(i);</span><br><span class="line">            if (mMeasureAllChildren || child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">                final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line">                maxWidth &#x3D; Math.max(maxWidth,</span><br><span class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">                maxHeight &#x3D; Math.max(maxHeight,</span><br><span class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                childState &#x3D; combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">                if (measureMatchParentChildren) &#123;</span><br><span class="line">                    if (lp.width &#x3D;&#x3D; LayoutParams.MATCH_PARENT ||</span><br><span class="line">                            lp.height &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                        mMatchParentChildren.add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Account for padding too</span><br><span class="line">        maxWidth +&#x3D; getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">        maxHeight +&#x3D; getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check against our minimum height and width</span><br><span class="line">        maxHeight &#x3D; Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">        maxWidth &#x3D; Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check against our foreground&#39;s minimum height and width</span><br><span class="line">        final Drawable drawable &#x3D; getForeground();</span><br><span class="line">        if (drawable !&#x3D; null) &#123;</span><br><span class="line">            maxHeight &#x3D; Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">            maxWidth &#x3D; Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">        count &#x3D; mMatchParentChildren.size();</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">                final View child &#x3D; mMatchParentChildren.get(i);</span><br><span class="line">                final MarginLayoutParams lp &#x3D; (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                final int childWidthMeasureSpec;</span><br><span class="line">                if (lp.width &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    final int width &#x3D; Math.max(0, getMeasuredWidth()</span><br><span class="line">                            - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                            - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                    childWidthMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            width, MeasureSpec.EXACTLY);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    childWidthMeasureSpec &#x3D; getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                            lp.leftMargin + lp.rightMargin,</span><br><span class="line">                            lp.width);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeightMeasureSpec;</span><br><span class="line">                if (lp.height &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    final int height &#x3D; Math.max(0, getMeasuredHeight()</span><br><span class="line">                            - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                            - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                    childHeightMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            height, MeasureSpec.EXACTLY);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    childHeightMeasureSpec &#x3D; getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                            getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                            lp.topMargin + lp.bottomMargin,</span><br><span class="line">                            lp.height);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法，这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法，我们来看一下View的onMeasure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法中调用了setMeasuredDimension方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        boolean optical &#x3D; isLayoutModeOptical(this);</span><br><span class="line">        if (optical !&#x3D; isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets &#x3D; getOpticalInsets();</span><br><span class="line">            int opticalWidth  &#x3D; insets.left + insets.right;</span><br><span class="line">            int opticalHeight &#x3D; insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">            measuredWidth  +&#x3D; optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">            measuredHeight +&#x3D; optical ? opticalHeight : -opticalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体里面又调用了setMeasuredDimensionRaw方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        mMeasuredWidth &#x3D; measuredWidth;</span><br><span class="line">        mMeasuredHeight &#x3D; measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |&#x3D; PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中。</p>
<p>继续回到我们的performTransles方法，然后我们继续看performLayout方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">            int desiredWindowHeight) &#123;</span><br><span class="line">        mLayoutRequested &#x3D; false;</span><br><span class="line">        mScrollMayChange &#x3D; true;</span><br><span class="line">        mInLayout &#x3D; true;</span><br><span class="line"></span><br><span class="line">        final View host &#x3D; mView;</span><br><span class="line">        if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">            Log.v(TAG, &quot;Laying out &quot; + host + &quot; to (&quot; +</span><br><span class="line">                    host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">            mInLayout &#x3D; false;</span><br><span class="line">            int numViewsRequestingLayout &#x3D; mLayoutRequesters.size();</span><br><span class="line">            if (numViewsRequestingLayout &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; requestLayout() was called during layout.</span><br><span class="line">                &#x2F;&#x2F; If no layout-request flags are set on the requesting views, there is no problem.</span><br><span class="line">                &#x2F;&#x2F; If some requests are still pending, then we need to clear those flags and do</span><br><span class="line">                &#x2F;&#x2F; a full request&#x2F;measure&#x2F;layout pass to handle this situation.</span><br><span class="line">                ArrayList&lt;View&gt; validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        false);</span><br><span class="line">                if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Set this flag to indicate that any further requests are happening during</span><br><span class="line">                    &#x2F;&#x2F; the second pass, which may result in posting those requests to the next</span><br><span class="line">                    &#x2F;&#x2F; frame instead</span><br><span class="line">                    mHandlingLayoutInLayoutRequest &#x3D; true;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Process fresh layout requests, then measure and layout</span><br><span class="line">                    int numValidRequests &#x3D; validLayoutRequesters.size();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                        final View view &#x3D; validLayoutRequesters.get(i);</span><br><span class="line">                        Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                                &quot; during layout: running second layout pass&quot;);</span><br><span class="line">                        view.requestLayout();</span><br><span class="line">                    &#125;</span><br><span class="line">                    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                    mInLayout &#x3D; true;</span><br><span class="line">                    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                    mHandlingLayoutInLayoutRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Check the valid requests again, this time without checking&#x2F;clearing the</span><br><span class="line">                    &#x2F;&#x2F; layout flags, since requests happening during the second pass get noop&#39;d</span><br><span class="line">                    validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters, true);</span><br><span class="line">                    if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                        final ArrayList&lt;View&gt; finalRequesters &#x3D; validLayoutRequesters;</span><br><span class="line">                        &#x2F;&#x2F; Post second-pass requests to the next frame</span><br><span class="line">                        getRunQueue().post(new Runnable() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void run() &#123;</span><br><span class="line">                                int numValidRequests &#x3D; finalRequesters.size();</span><br><span class="line">                                for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                    final View view &#x3D; finalRequesters.get(i);</span><br><span class="line">                                    Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                                            &quot; during second layout pass: posting in next frame&quot;);</span><br><span class="line">                                    view.requestLayout();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        mInLayout &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中，我们看到该方法执行了layout方法，我们看一下该layout方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL &#x3D; mLeft;</span><br><span class="line">        int oldT &#x3D; mTop;</span><br><span class="line">        int oldB &#x3D; mBottom;</span><br><span class="line">        int oldR &#x3D; mRight;</span><br><span class="line"></span><br><span class="line">        boolean changed &#x3D; isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">            if (li !&#x3D; null &amp;&amp; li.mOnLayoutChangeListeners !&#x3D; null) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy &#x3D;</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners &#x3D; listenersCopy.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |&#x3D; PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法体中执行了onLayout方法，这个方法就是具体执行测量位置的方法了，由于我们的mDector是一个FrameLayout，所以跟measure类似的，我们看一下FrameLayout的onLayout方法的实现：</p>
<p>我们看到我们定义了一个循环逻辑，获取所有的validLayoutRequesters也就是需要执行Layout方法的View的集合，通过循环执行view的requestLayout方法。这里我们来看一下requestLayout方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, false &#x2F;* no force left gravity *&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了layoutChildren方法，让我们来看一下layoutChildren方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom,</span><br><span class="line">                                  boolean forceLeftGravity) &#123;</span><br><span class="line">        final int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">        final int parentLeft &#x3D; getPaddingLeftWithForeground();</span><br><span class="line">        final int parentRight &#x3D; right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        final int parentTop &#x3D; getPaddingTopWithForeground();</span><br><span class="line">        final int parentBottom &#x3D; bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child &#x3D; getChildAt(i);</span><br><span class="line">            if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">                final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">                final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                int childLeft;</span><br><span class="line">                int childTop;</span><br><span class="line"></span><br><span class="line">                int gravity &#x3D; lp.gravity;</span><br><span class="line">                if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                    gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">                final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.RIGHT:</span><br><span class="line">                        if (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    case Gravity.LEFT:</span><br><span class="line">                    default:</span><br><span class="line">                        childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                switch (verticalGravity) &#123;</span><br><span class="line">                    case Gravity.TOP:</span><br><span class="line">                        childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.BOTTOM:</span><br><span class="line">                        childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跟measure类似的，这里也是遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法，好吧，我们看一下View的layout的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL &#x3D; mLeft;</span><br><span class="line">        int oldT &#x3D; mTop;</span><br><span class="line">        int oldB &#x3D; mBottom;</span><br><span class="line">        int oldR &#x3D; mRight;</span><br><span class="line"></span><br><span class="line">        boolean changed &#x3D; isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">            if (li !&#x3D; null &amp;&amp; li.mOnLayoutChangeListeners !&#x3D; null) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy &#x3D;</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners &#x3D; listenersCopy.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |&#x3D; PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中。</p>
<p>好吧，经过了测量大小与测量位置的逻辑之后，我们最后看一下performTraversals方法中的performDraw方法，这个方法的作用就是执行View组件的绘制逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void performDraw() &#123;</span><br><span class="line">        ...</span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了ViewRootImpl的draw方法，然后我们看一下draw方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">			...</span><br><span class="line">            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">               return;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里又调用了drawSoftware方法，看名字这里应该就是调用执行绘制的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">            boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        ...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了mView的draw方法，这里的mView是我们的mDector，好吧，看一下draw方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">        final int privateFlags &#x3D; mPrivateFlags;</span><br><span class="line">        final boolean dirtyOpaque &#x3D; (privateFlags &amp; PFLAG_DIRTY_MASK) &#x3D;&#x3D; PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo &#x3D;&#x3D; null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        mPrivateFlags &#x3D; (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">         * in the appropriate order:</span><br><span class="line">         *</span><br><span class="line">         *      1. Draw the background</span><br><span class="line">         *      2. If necessary, save the canvas&#39; layers to prepare for fading</span><br><span class="line">         *      3. Draw view&#39;s content</span><br><span class="line">         *      4. Draw children</span><br><span class="line">         *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">         *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 1, draw the background, if needed</span><br><span class="line">        int saveCount;</span><br><span class="line"></span><br><span class="line">        if (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">        final int viewFlags &#x3D; mViewFlags;</span><br><span class="line">        boolean horizontalEdges &#x3D; (viewFlags &amp; FADING_EDGE_HORIZONTAL) !&#x3D; 0;</span><br><span class="line">        boolean verticalEdges &#x3D; (viewFlags &amp; FADING_EDGE_VERTICAL) !&#x3D; 0;</span><br><span class="line">        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            &#x2F;&#x2F; Step 3, draw the content</span><br><span class="line">            if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Step 4, draw the children</span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Overlay is part of the content and draws beneath Foreground</span><br><span class="line">            if (mOverlay !&#x3D; null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; we&#39;re done...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Here we do the full fledged routine...</span><br><span class="line">         * (this is an uncommon case where speed matters less,</span><br><span class="line">         * this is why we repeat some of the tests that have been</span><br><span class="line">         * done above)</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        boolean drawTop &#x3D; false;</span><br><span class="line">        boolean drawBottom &#x3D; false;</span><br><span class="line">        boolean drawLeft &#x3D; false;</span><br><span class="line">        boolean drawRight &#x3D; false;</span><br><span class="line"></span><br><span class="line">        float topFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float bottomFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float leftFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float rightFadeStrength &#x3D; 0.0f;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 2, save the canvas&#39; layers</span><br><span class="line">        int paddingLeft &#x3D; mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        final boolean offsetRequired &#x3D; isPaddingOffsetRequired();</span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            paddingLeft +&#x3D; getLeftPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left &#x3D; mScrollX + paddingLeft;</span><br><span class="line">        int right &#x3D; left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">        int top &#x3D; mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">        int bottom &#x3D; top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            right +&#x3D; getRightPaddingOffset();</span><br><span class="line">            bottom +&#x3D; getBottomPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ScrollabilityCache scrollabilityCache &#x3D; mScrollCache;</span><br><span class="line">        final float fadeHeight &#x3D; scrollabilityCache.fadingEdgeLength;</span><br><span class="line">        int length &#x3D; (int) fadeHeight;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; clip the fade length if top and bottom fades overlap</span><br><span class="line">        &#x2F;&#x2F; overlapping fades produce odd-looking artifacts</span><br><span class="line">        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">            length &#x3D; (bottom - top) &#x2F; 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; also clip horizontal fades if necessary</span><br><span class="line">        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">            length &#x3D; (right - left) &#x2F; 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (verticalEdges) &#123;</span><br><span class="line">            topFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</span><br><span class="line">            drawTop &#x3D; topFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            bottomFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</span><br><span class="line">            drawBottom &#x3D; bottomFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (horizontalEdges) &#123;</span><br><span class="line">            leftFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</span><br><span class="line">            drawLeft &#x3D; leftFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            rightFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</span><br><span class="line">            drawRight &#x3D; rightFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        saveCount &#x3D; canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">        int solidColor &#x3D; getSolidColor();</span><br><span class="line">        if (solidColor &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final int flags &#x3D; Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">            if (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawBottom) &#123;</span><br><span class="line">                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawLeft) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, left + length, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawRight) &#123;</span><br><span class="line">                canvas.saveLayer(right - length, top, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 3, draw the content</span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 5, draw the fade effect and restore layers</span><br><span class="line">        final Paint p &#x3D; scrollabilityCache.paint;</span><br><span class="line">        final Matrix matrix &#x3D; scrollabilityCache.matrix;</span><br><span class="line">        final Shader fade &#x3D; scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">        if (drawTop) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * topFadeStrength);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawBottom) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * bottomFadeStrength);</span><br><span class="line">            matrix.postRotate(180);</span><br><span class="line">            matrix.postTranslate(left, bottom);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawLeft) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * leftFadeStrength);</span><br><span class="line">            matrix.postRotate(-90);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawRight) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * rightFadeStrength);</span><br><span class="line">            matrix.postRotate(90);</span><br><span class="line">            matrix.postTranslate(right, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Overlay is part of the content and draws beneath Foreground</span><br><span class="line">        if (mOverlay !&#x3D; null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整个View的绘制流程还是比较清楚的，整个执行逻辑还有相应的注释，一共大概需要六步，并且在执行draw方法的过程中，如果包含子View，那么也会执行子View的draw方法，好吧，经过这样一系列的执行逻辑之后，mDector以及子View就被绘制出来了。</p>
<p>总结：</p>
<ul>
<li><p>Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。</p>
</li>
<li><p>View的绘制流程包含了测量大小，测量位置，绘制三个流程；</p>
</li>
<li><p>Activty的界面绘制是从mDector即根View开始的，也就是从mDector的测量大小，测量位置，绘制三个流程；</p>
</li>
<li><p>View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的；</p>
</li>
<li><p>View的测量大小流程:performMeasure –&gt; measure –&gt; onMeasure等方法;</p>
</li>
<li><p>View的测量位置流程：performLayout –&gt; layout –&gt; onLayout等方法；</p>
</li>
<li><p>View的绘制流程：onDraw等方法；</p>
</li>
<li><p>View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑；</p>
</li>
<li><p>Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/17%20Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/17%20Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">17 Activity布局加载流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好吧，终于要开始讲讲Activity的布局加载流程了，大家都知道在Android体系中Activity扮演了一个界面展示的角色，这也是它与android中另外一个很重要的组件Service最大的不同，但是这个展示的界面的功能是Activity直接控制的么？界面的布局文件是如何加载到内存并被Activity管理的？android中的View是一个怎样的概念？加载到内存中的布局文件是如何绘制出来的？</p>
<p>要想回答这些问题，我们就需要对android的界面加载与绘制流程有所了解，这里我们先来学习一下Activity的布局加载的流程。而至于Acitivty的布局绘制流程我们在下一篇中在做介绍。</p>
<p>其实Activity对界面布局的管理是都是通过Window对象来实现的，Window对象，顾名思义就是一个窗口对象，而Activity从用户角度就是一个个的窗口实例，因此不难想象每个Activity中都对应着一个Window对象，而这个Window对象就是负责加载显示界面的。至于window对象是如何展示不同的界面的，那是通过定义不同的View组件实现不同的界面展示。</p>
<p>废话不多说了，不知道大家是否还记得我们讲过的Activity的启动流程么？不熟悉的童鞋可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener"> android源码解析之（十四）–&gt;Activity启动流程</a> ，在文章中我们介绍到当ActivityManagerService接收到启动Activity的请求之后会通过IApplicationThread进程间通讯告知ApplicationThread并执行handleLauncherActivity方法，这里我们可以下其具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        &#x2F;&#x2F; If we are getting ready to gc after going to the background, well</span><br><span class="line">        &#x2F;&#x2F; we are back active so skip it.</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line"></span><br><span class="line">        if (r.profilerInfo !&#x3D; null) &#123;</span><br><span class="line">            mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">            mProfiler.startProfiling();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Make sure we are running with the most recent config.</span><br><span class="line">        handleConfigurationChanged(null, null);</span><br><span class="line"></span><br><span class="line">        if (localLOGV) Slog.v(</span><br><span class="line">            TAG, &quot;Handling launch of &quot; + r);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initialize before creating the activity</span><br><span class="line">        WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">        Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">        if (a !&#x3D; null) &#123;</span><br><span class="line">            r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState &#x3D; r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line"></span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">                &#x2F;&#x2F; The activity manager actually wants this one to start out</span><br><span class="line">                &#x2F;&#x2F; paused, because it needs to be visible but isn&#39;t in the</span><br><span class="line">                &#x2F;&#x2F; foreground.  We accomplish this by going through the</span><br><span class="line">                &#x2F;&#x2F; normal startup (because activities expect to go through</span><br><span class="line">                &#x2F;&#x2F; onResume() the first time they run, before their window</span><br><span class="line">                &#x2F;&#x2F; is displayed), and then pausing it.  However, in this case</span><br><span class="line">                &#x2F;&#x2F; we do -not- need to do the full pause cycle (of freezing</span><br><span class="line">                &#x2F;&#x2F; and such) because the activity manager assumes it can just</span><br><span class="line">                &#x2F;&#x2F; retain the current state it has.</span><br><span class="line">                try &#123;</span><br><span class="line">                    r.activity.mCalled &#x3D; false;</span><br><span class="line">                    mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">                    &#x2F;&#x2F; We need to keep around the original state, in case</span><br><span class="line">                    &#x2F;&#x2F; we need to be created again.  But we only do this</span><br><span class="line">                    &#x2F;&#x2F; for pre-Honeycomb apps, which always save their state</span><br><span class="line">                    &#x2F;&#x2F; when pausing, so we can not have them save their state</span><br><span class="line">                    &#x2F;&#x2F; when restarting from a paused state.  For HC and later,</span><br><span class="line">                    &#x2F;&#x2F; we want to (and can) let the state be saved as the normal</span><br><span class="line">                    &#x2F;&#x2F; part of stopping the activity.</span><br><span class="line">                    if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                        r.state &#x3D; oldState;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!r.activity.mCalled) &#123;</span><br><span class="line">                        throw new SuperNotCalledException(</span><br><span class="line">                            &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                            &quot; did not call through to super.onPause()&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">                    throw e;</span><br><span class="line"></span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                        throw new RuntimeException(</span><br><span class="line">                                &quot;Unable to pause activity &quot;</span><br><span class="line">                                + r.intent.getComponent().toShortString()</span><br><span class="line">                                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.paused &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If there was an error, for any reason, tell the activity</span><br><span class="line">            &#x2F;&#x2F; manager to stop us.</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null, false);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里的handleLauncherActivity方法内部调用了performLaunchActivity方法，这个方法也是具体启动Activity的方法，我们来看一下它的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity activity &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();</span><br><span class="line">            activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state !&#x3D; null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		...</span><br><span class="line">            Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">            if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r);</span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, r + &quot;: app&#x3D;&quot; + app</span><br><span class="line">                    + &quot;, appName&#x3D;&quot; + app.getPackageName()</span><br><span class="line">                    + &quot;, pkg&#x3D;&quot; + r.packageInfo.getPackageName()</span><br><span class="line">                    + &quot;, comp&#x3D;&quot; + r.intent.getComponent().toShortString()</span><br><span class="line">                    + &quot;, dir&#x3D;&quot; + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                Context appContext &#x3D; createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title &#x3D; r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config &#x3D; new Configuration(mCompatConfiguration);</span><br><span class="line">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                        + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到这里是通过反射的机制创建的Activity，并调用了Activity的attach方法，那么这里的attach方法是做什么的呢？我们继续来看一下attach方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">            Instrumentation instr, IBinder token, int ident,</span><br><span class="line">            Application application, Intent intent, ActivityInfo info,</span><br><span class="line">            CharSequence title, Activity parent, String id,</span><br><span class="line">            NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">            Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">        mFragments.attachHost(null &#x2F;*parent*&#x2F;);</span><br><span class="line"></span><br><span class="line">        mWindow &#x3D; new PhoneWindow(this);</span><br><span class="line">        mWindow.setCallback(this);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">        mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">        if (info.softInputMode !&#x3D; WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">            mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">        &#125;</span><br><span class="line">        if (info.uiOptions !&#x3D; 0) &#123;</span><br><span class="line">            mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        mUiThread &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        mMainThread &#x3D; aThread;</span><br><span class="line">        mInstrumentation &#x3D; instr;</span><br><span class="line">        mToken &#x3D; token;</span><br><span class="line">        mIdent &#x3D; ident;</span><br><span class="line">        mApplication &#x3D; application;</span><br><span class="line">        mIntent &#x3D; intent;</span><br><span class="line">        mReferrer &#x3D; referrer;</span><br><span class="line">        mComponent &#x3D; intent.getComponent();</span><br><span class="line">        mActivityInfo &#x3D; info;</span><br><span class="line">        mTitle &#x3D; title;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">        mEmbeddedID &#x3D; id;</span><br><span class="line">        mLastNonConfigurationInstances &#x3D; lastNonConfigurationInstances;</span><br><span class="line">        if (voiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            if (lastNonConfigurationInstances !&#x3D; null) &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) !&#x3D; 0);</span><br><span class="line">        if (mParent !&#x3D; null) &#123;</span><br><span class="line">            mWindow.setContainer(mParent.getWindow());</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; mWindow.getWindowManager();</span><br><span class="line">        mCurrentConfig &#x3D; config;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在attach方法这里初始化了一些Activity的成员变量，主要是mWindow对象，并且mWindow的成员实例是PhoneWindow实例，这样也从侧面说明了一个Activity对应着一个Window对象。除了window对象还初始化了一些Activity的其他成员变量，这里不再做讨论，继续回到我们的performLaunchActivity方法，在调用了Activity的attach方法之后又调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInstrumentation.callActivityOnCreate(activity, r.state);</span><br></pre></td></tr></table></figure>
<p>这里的mInstrumentation是类Instrumentation，每个应用进程对应着一个Instrumentation和一个ActivityThread，Instrumentation就是具体操作Activity回调其生命周期方法的，我们这里看一下它的callActivityOnCreate方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里代码比较简洁，preOerformCreate方法和postPerformCreate方法我们这里暂时不管，主要的执行逻辑是调用了activity.performCreate方法，我们来看一下Activity的performCreate方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line">        performCreateCommon();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>原来onCreate的生命周期方法是在这里回调的，其实这里的逻辑在前面几篇文章中有讲述，也可以参考前面的文章。</p>
<p>至此我们就回调到了我们Activity的onCreate方法，大家平时在重写onCreate方法的时候，怎么加载布局文件的呢？这里看一下我们的onCreate方法的典型写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>无论我们怎么变化，我们的onCreate方法一般都是会调用这两句话的吧？那么这里的两段代码分辨是什么含义呢？我们首先看一下super.onCreate方法的实现逻辑，由于我们的Activity类继承与Activity，所以这里的super.onCreate方法，就是调用的Activity.onCreate方法，好吧，既然这样我们来看一下Activity的onCreate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState);</span><br><span class="line">        if (mLastNonConfigurationInstances !&#x3D; null) &#123;</span><br><span class="line">            mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mActivityInfo.parentActivityName !&#x3D; null) &#123;</span><br><span class="line">            if (mActionBar &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mEnableDefaultActionBarUp &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mActionBar.setDefaultDisplayHomeAsUpEnabled(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (savedInstanceState !&#x3D; null) &#123;</span><br><span class="line">            Parcelable p &#x3D; savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">            mFragments.restoreAllState(p, mLastNonConfigurationInstances !&#x3D; null</span><br><span class="line">                    ? mLastNonConfigurationInstances.fragments : null);</span><br><span class="line">        &#125;</span><br><span class="line">        mFragments.dispatchCreate();</span><br><span class="line">        getApplication().dispatchActivityCreated(this, savedInstanceState);</span><br><span class="line">        if (mVoiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            mVoiceInteractor.attachActivity(this);</span><br><span class="line">        &#125;</span><br><span class="line">        mCalled &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，Activity的onCreate方法主要是做了一些Acitivty的初始化操作，那么如果我们不在自己的Activity调用super.onCreate方法呢？好吧，尝试之后，AndroidStudio在打开的Acitivty的onCreate方法中如果不调用super.onCreate方法的话，会报错。。。有木有搞错。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FATAL EXCEPTION: main                                                              Process: com.example.aaron.helloworld, PID: 18001                                                                 android.util.SuperNotCalledException: Activity &#123;com.example.aaron.helloworld&#x2F;com.example.aaron.helloworld.SecondActivity&#125; did not call through to super.onCreate()                                                                    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2422)                                                                            at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2528)                                                                               at android.app.ActivityThread.access$800(ActivityThread.java:169)                                                                              at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421)                                                                             at android.os.Handler.dispatchMessage(Handler.java:111)                                                                            at android.os.Looper.loop(Looper.java:194)                                                                           at android.app.ActivityThread.main(ActivityThread.java:5552)                                                                        at java.lang.reflect.Method.invoke(Native Method)                                                                        at java.lang.reflect.Method.invoke(Method.java:372)                                                                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)                                                                       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759)</span><br></pre></td></tr></table></figure>
<p>可以看到如果不调用super.onCreate方法的话，会在Activity的performLaunchActivity中报错，我们知道这里的performLaunchActivity方法就是我们启动Activity的时候回回调的方法，我们找找方法体实现中throws的Exception。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">activity.mCalled &#x3D; false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>在Activity的performLaunchActivity方法中，我们在调用了Activity的onCreate方法之后会执行一个判断逻辑，若Activity的mCalled为false，则会抛出我们刚刚捕获的异常，那么这个mCalled成员变量是在什么时候被赋值的呢？好吧，就是在Activity的onCreate方法赋值的，所以我们在实现自己的Activity的时候只有调用了super.onCreate方法才不会抛出这个异常，反过来说，我们实现自己的Actiivty，那么一定要在onCreate方法中调用super.onCreate方法。</p>
<p>然后我们在看一下onCreate中的setContentView方法，这里的参数就是一个Layout布局文件，可以发现这里的setContentView方法就是Acitivty中的setContentView，好吧我们来看一下Activity中setContentView的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">        getWindow().setContentView(layoutResID);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的getWindow方法就是获取Acitivty的mWindow成员变量，从刚刚我们在Activity.attach方法我们知道这里的mWindow的实例是PhoneWindow，所以这里调用的其实是PhoneWindow的setConentView方法，然后我们看一下PhoneWindow的setContentView是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void setContentView(int layoutResID) &#123;</span><br><span class="line">        &#x2F;&#x2F; Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">        &#x2F;&#x2F; decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">        &#x2F;&#x2F; before this happens.</span><br><span class="line">        if (mContentParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            final Scene newScene &#x3D; Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                    getContext());</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        final Callback cb &#x3D; getCallback();</span><br><span class="line">        if (cb !&#x3D; null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mContentParent对象是一个View对象，由于第一次mContentParent为空，所以执行installerDector方法，这里我们看一下installerDector方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">        if (mDecor &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mDecor &#x3D; generateDecor();</span><br><span class="line">            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">            mDecor.setIsRootNamespace(true);</span><br><span class="line">            if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures !&#x3D; 0) &#123;</span><br><span class="line">                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mDector是一个DectorView对象，而DectorView继承与FrameLayout，所以这里的mDector其实就是一个FrameLayout对象，并通过调用generateDector()方法初始化，我们继续看一下generateDector方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DecorView generateDecor() &#123;</span><br><span class="line">        return new DecorView(getContext(), -1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，就是通过new的方式创建了一个DectorView对象，然后我们继续看installDector方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (mContentParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mContentParent &#x3D; generateLayout(mDecor);</span><br></pre></td></tr></table></figure>
<p>这里初始化了mContentParent对象，这是一个View对象，我们调用了generateLayout方法，好吧，来看一下generateLayout方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Inflate the window decor.</span><br><span class="line"></span><br><span class="line">        int layoutResource;</span><br><span class="line">        int features &#x3D; getLocalFeatures();</span><br><span class="line">        &#x2F;&#x2F; System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features));</span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) !&#x3D; 0) &#123;</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_swipe_dismiss;</span><br><span class="line">        &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) !&#x3D; 0) &#123;</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res &#x3D; new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogTitleIconsDecorLayout, res, true);</span><br><span class="line">                layoutResource &#x3D; res.resourceId;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource &#x3D; R.layout.screen_title_icons;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; XXX Remove this once action bar supports these features.</span><br><span class="line">            removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Title Icons!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) !&#x3D; 0</span><br><span class="line">                &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Special case for a window with only a progress bar (and title).</span><br><span class="line">            &#x2F;&#x2F; XXX Need to have a no-title version of embedded windows.</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_progress;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Progress!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; Special case for a window with a custom title.</span><br><span class="line">            &#x2F;&#x2F; If the window is floating, we need a dialog layout</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res &#x3D; new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogCustomTitleDecorLayout, res, true);</span><br><span class="line">                layoutResource &#x3D; res.resourceId;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource &#x3D; R.layout.screen_custom_title;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; XXX Remove this once action bar supports these features.</span><br><span class="line">            removeFeature(FEATURE_ACTION_BAR);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; If no other features and not embedded, only need a title.</span><br><span class="line">            &#x2F;&#x2F; If the window is floating, we need a dialog layout</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                TypedValue res &#x3D; new TypedValue();</span><br><span class="line">                getContext().getTheme().resolveAttribute(</span><br><span class="line">                        R.attr.dialogTitleDecorLayout, res, true);</span><br><span class="line">                layoutResource &#x3D; res.resourceId;</span><br><span class="line">            &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) !&#x3D; 0) &#123;</span><br><span class="line">                layoutResource &#x3D; a.getResourceId(</span><br><span class="line">                        R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                        R.layout.screen_action_bar);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                layoutResource &#x3D; R.layout.screen_title;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Title!&quot;);</span><br><span class="line">        &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) !&#x3D; 0) &#123;</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Embedded, so no decoration is needed.</span><br><span class="line">            layoutResource &#x3D; R.layout.screen_simple;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;Simple!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecor.startChanging();</span><br><span class="line"></span><br><span class="line">        View in &#x3D; mLayoutInflater.inflate(layoutResource, null);</span><br><span class="line">        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        mContentRoot &#x3D; (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">        ViewGroup contentParent &#x3D; (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">        if (contentParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Window couldn&#39;t find content container view&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) !&#x3D; 0) &#123;</span><br><span class="line">            ProgressBar progress &#x3D; getCircularProgressBar(false);</span><br><span class="line">            if (progress !&#x3D; null) &#123;</span><br><span class="line">                progress.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) !&#x3D; 0) &#123;</span><br><span class="line">            registerSwipeCallbacks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Remaining setup -- of background and title -- that only applies</span><br><span class="line">        &#x2F;&#x2F; to top-level windows.</span><br><span class="line">        if (getContainer() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            final Drawable background;</span><br><span class="line">            if (mBackgroundResource !&#x3D; 0) &#123;</span><br><span class="line">                background &#x3D; getContext().getDrawable(mBackgroundResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                background &#x3D; mBackgroundDrawable;</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setWindowBackground(background);</span><br><span class="line"></span><br><span class="line">            final Drawable frame;</span><br><span class="line">            if (mFrameResource !&#x3D; 0) &#123;</span><br><span class="line">                frame &#x3D; getContext().getDrawable(mFrameResource);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                frame &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setWindowFrame(frame);</span><br><span class="line"></span><br><span class="line">            mDecor.setElevation(mElevation);</span><br><span class="line">            mDecor.setClipToOutline(mClipToOutline);</span><br><span class="line"></span><br><span class="line">            if (mTitle !&#x3D; null) &#123;</span><br><span class="line">                setTitle(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mTitleColor &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                mTitleColor &#x3D; mTextColor;</span><br><span class="line">            &#125;</span><br><span class="line">            setTitleColor(mTitleColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">        return contentParent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里就是通过调用LayoutInflater.inflate方法来加载布局文件到内存中，关于LayoutInflater.inflater是如何加载布局文件的，并且，通过对代码的分析，我们发现PhoneWindow中的几个成员变量：mDector，mContentRoot，mContentParent的关系<br>mDector –&gt; mContentRoot –&gt; mContentParent（包含）<br>并且我们来看一下典型的布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:fitsSystemWindows&#x3D;&quot;true&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot;&gt;</span><br><span class="line">    &lt;ViewStub android:id&#x3D;&quot;@+id&#x2F;action_mode_bar_stub&quot;</span><br><span class="line">              android:inflatedId&#x3D;&quot;@+id&#x2F;action_mode_bar&quot;</span><br><span class="line">              android:layout&#x3D;&quot;@layout&#x2F;action_mode_bar&quot;</span><br><span class="line">              android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">              android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">              android:theme&#x3D;&quot;?attr&#x2F;actionBarTheme&quot; &#x2F;&gt;</span><br><span class="line">    &lt;FrameLayout</span><br><span class="line">         android:id&#x3D;&quot;@android:id&#x2F;content&quot;</span><br><span class="line">         android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">         android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">         android:foregroundInsidePadding&#x3D;&quot;false&quot;</span><br><span class="line">         android:foregroundGravity&#x3D;&quot;fill_horizontal|top&quot;</span><br><span class="line">         android:foreground&#x3D;&quot;?android:attr&#x2F;windowContentOverlay&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>这里就是整个Activity加载的跟布局文件：screen_simple.xml，其中ViewStub对应着Activity中的titleBar而这里的FrameLayout里面主要用于填充内容。</p>
<p>然后我们具体看一下LayoutInflater.inflater方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;</span><br><span class="line">        return inflate(resource, root, root !&#x3D; null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了inflate的重载方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">        synchronized (mConstructorArgs) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line"></span><br><span class="line">            final Context inflaterContext &#x3D; mContext;</span><br><span class="line">            final AttributeSet attrs &#x3D; Xml.asAttributeSet(parser);</span><br><span class="line">            Context lastContext &#x3D; (Context) mConstructorArgs[0];</span><br><span class="line">            mConstructorArgs[0] &#x3D; inflaterContext;</span><br><span class="line">            View result &#x3D; root;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Look for the root node.</span><br><span class="line">                int type;</span><br><span class="line">                while ((type &#x3D; parser.next()) !&#x3D; XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                        type !&#x3D; XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Empty</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (type !&#x3D; XmlPullParser.START_TAG) &#123;</span><br><span class="line">                    throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                            + &quot;: No start tag found!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final String name &#x3D; parser.getName();</span><br><span class="line">                </span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                    System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                            + name);</span><br><span class="line">                    System.out.println(&quot;**************************&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                    if (root &#x3D;&#x3D; null || !attachToRoot) &#123;</span><br><span class="line">                        throw new InflateException(&quot;&lt;merge &#x2F;&gt; can be used only with a valid &quot;</span><br><span class="line">                                + &quot;ViewGroup root and attachToRoot&#x3D;true&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; Temp is the root view that was found in the xml</span><br><span class="line">                    final View temp &#x3D; createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                    ViewGroup.LayoutParams params &#x3D; null;</span><br><span class="line"></span><br><span class="line">                    if (root !&#x3D; null) &#123;</span><br><span class="line">                        if (DEBUG) &#123;</span><br><span class="line">                            System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                    root);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; Create layout params that match root, if supplied</span><br><span class="line">                        params &#x3D; root.generateLayoutParams(attrs);</span><br><span class="line">                        if (!attachToRoot) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Set the layout params for temp if we are not</span><br><span class="line">                            &#x2F;&#x2F; attaching. (If we are, we use addView, below)</span><br><span class="line">                            temp.setLayoutParams(params);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Inflate all children under temp against its context.</span><br><span class="line">                    rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; We are supposed to attach all the views we found (int temp)</span><br><span class="line">                    &#x2F;&#x2F; to root. Do that now.</span><br><span class="line">                    if (root !&#x3D; null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                        root.addView(temp, params);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Decide whether to return the root that was passed in or the</span><br><span class="line">                    &#x2F;&#x2F; top view found in xml.</span><br><span class="line">                    if (root &#x3D;&#x3D; null || !attachToRoot) &#123;</span><br><span class="line">                        result &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">                InflateException ex &#x3D; new InflateException(e.getMessage());</span><br><span class="line">                ex.initCause(e);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                InflateException ex &#x3D; new InflateException(</span><br><span class="line">                        parser.getPositionDescription()</span><br><span class="line">                                + &quot;: &quot; + e.getMessage());</span><br><span class="line">                ex.initCause(e);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t retain static reference on context.</span><br><span class="line">                mConstructorArgs[0] &#x3D; lastContext;</span><br><span class="line">                mConstructorArgs[1] &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析源码，不难发现，主要是通过循环解析xml文件并将信息解析到内存View对象，布局文件中定义的一个个组件都被顺序的解析到了内存中并被父子View的形式组织起来，这样通过给定的一个root View就可以将整个布局文件中定义的组件全部解析。分析完解析布局文件，回到我们的setContentVIew方法，在调用了installDector方法之后，又调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);</span><br></pre></td></tr></table></figure>
<p>这个方法的含义就是将我们传递的客户端的layoutId对应的布局文件作为mContentParent的子View加载到内存中，这样我们的layoutId作为mContentParent的子View，而mContentParent又是mContentRoot的子View，mContentRoot又是mDector的子View，通过LayoutInflater的inflate方法逐步加载到了内存中，而我们的Activity又持有自身的PhoneWindow的引用，这就相当于我们的Activity持有了我们定义的布局文件的引用，因而Activity的布局文件被加载到了内存中。</p>
<p>总结：</p>
<ul>
<li><p>Activity的展示界面的特性是通过Window对象来控制的；</p>
</li>
<li><p>每个Activity对象都对应这个一个Window对象，并且Window对象的初始化在启动Activity的时候完成，在执行Activity的onCreate方法之前；</p>
</li>
<li><p>每个Window对象内部都存在一个FrameLayout类型的mDector对象，它是Acitivty界面的root view；</p>
</li>
<li><p>Activity中的window对象的实例是PhoneWindow对象，PhoneWindow对象中的几个成员变量mDector，mContentRoot，mContentParent都是View组件，它们的关系是：mDector –&gt; mContentRoot –&gt; mContentParent –&gt; 自定义layoutView</p>
</li>
<li><p>LayoutInflater.inflate主要用于将布局文件加载到内存View组件中，也可以设定加载到某一个父组件中；</p>
</li>
<li><p>典型的Activity的onCreate方法中需要调用super.onCreate方法和setContentView方法，若不调用super.onCreate方法，执行启动该Activity的逻辑会报错，若不执行setContentView的方法，该Activity只会显示一个空页面。</p>
</li>
</ul>
<p>好了，关于Activity的布局加载流程我们暂时介绍这么多，下一篇文章，我们将介绍一下Activity的布局显示流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/16%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/16%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">16 应用进程Context创建流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天讲讲应用进程Context的创建流程，相信大家平时在开发过程中经常会遇到对Context对象的使用，Application是Context，Activity是Context，Service也是Context，所以有一个经典的问题是一个App中一共有多少个Context？</p>
<p>这个问题的答案是Application + N个Activity + N个Service。</p>
<p>还有就是我们平时在使用Context过程中许多时候由于使用不当，可能会造成内存泄露的情况等等，这个也是需要我们注意的。这里有篇不错的文章：<br><a href="http://blog.csdn.net/feiduclear_up/article/details/47356289" target="_blank" rel="noopener"> Android Context 是什么？</a></p>
<p>好吧，什么叫应用进程Context呢？这是指的是Application所代表的Context的创建流程，还记得我们前几篇写的应用进程创建流程么？<br><a href="http://blog.csdn.net/qq_23547831/article/details/51119333" target="_blank" rel="noopener"> android源码解析之（十一）–&gt;应用进程启动流程</a><br>最后我们得出结论，应用进程的起始方法是ActivityThread.main方法，好吧，</p>
<p>由于还未讲解Service相关知识，这里暂时讲解一下Activity与Application中Context对象的创建过程。</p>
<p>首先我们就从ActivityThread.main方法开始看一下Application的创建流程。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现在方法体中我们创建了一个ActivityThread对象并执行了attach方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">        sCurrentActivityThread &#x3D; this;</span><br><span class="line">        mSystemThread &#x3D; system;</span><br><span class="line">        if (!system) &#123;</span><br><span class="line">            ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    ensureJitEnabled();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            final IActivityManager mgr &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Watch for getting close to heap limit.</span><br><span class="line">            BinderInternal.addGcWatcher(new Runnable() &#123;</span><br><span class="line">                @Override public void run() &#123;</span><br><span class="line">                    if (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Runtime runtime &#x3D; Runtime.getRuntime();</span><br><span class="line">                    long dalvikMax &#x3D; runtime.maxMemory();</span><br><span class="line">                    long dalvikUsed &#x3D; runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                    if (dalvikUsed &gt; ((3*dalvikMax)&#x2F;4)) &#123;</span><br><span class="line">                        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max&#x3D;&quot; + (dalvikMax&#x2F;1024)</span><br><span class="line">                                + &quot; total&#x3D;&quot; + (runtime.totalMemory()&#x2F;1024)</span><br><span class="line">                                + &quot; used&#x3D;&quot; + (dalvikUsed&#x2F;1024));</span><br><span class="line">                        mSomeActivitiesChanged &#x3D; false;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          ...  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里看一下重点实现，我们可以发现在方法体中调用了ActivityManagerNative.getDefault().attachApplication(mAppThread)<br>看过我的前几篇文章的童鞋应该知道这里就是一个Binder进程间通讯，其实上执行的是ActivityManagerService.attachApplication方法，具体的可以参考前几篇文章的介绍，好吧，既然这样我们看一下ActivityManagerService.attachApplication方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后这里面又调用了attachApplicationLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread 	  thread, int pid) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat,</span><br><span class="line">getCommonServicesLocked(app.isolated),</span><br><span class="line">mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>可以看到这里面又调用了IApplication.bindApplication，从方法名称中我们可以看出这里应该是绑定Application的方法，跟上面的ActivityManangerNative类似的，前面几篇文章中我们已经做过介绍，IApplicationThread是ActivityThread中ApplicationThread binder对象的客户端，所以这里最终调用的是ApplicationThread的bindApplication方法，既然这样，我们来看一下ApplicationThread的bindApplication的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">                IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">                IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,</span><br><span class="line">                Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span><br><span class="line">                Bundle coreSettings) &#123;</span><br><span class="line"></span><br><span class="line">            if (services !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Setup the service cache in the ServiceManager</span><br><span class="line">                ServiceManager.initServiceCache(services);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Two possible indications that this package could be</span><br><span class="line">             * sharing its runtime with other packages:</span><br><span class="line">             *</span><br><span class="line">             * 1.) the sharedUserId attribute is set in the manifest,</span><br><span class="line">             *     indicating a request to share a VM with other</span><br><span class="line">             *     packages with the same sharedUserId.</span><br><span class="line">             *</span><br><span class="line">             * 2.) the application element of the manifest has an</span><br><span class="line">             *     attribute specifying a non-default process name,</span><br><span class="line">             *     indicating the desire to run in another packages VM.</span><br><span class="line">             *</span><br><span class="line">             * If sharing is enabled we do not have a unique application</span><br><span class="line">             * in a process and therefore cannot rely on the package</span><br><span class="line">             * name inside the runtime.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            IPackageManager pm &#x3D; getPackageManager();</span><br><span class="line">            android.content.pm.PackageInfo pi &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                pi &#x3D; pm.getPackageInfo(appInfo.packageName, 0, UserHandle.myUserId());</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pi !&#x3D; null) &#123;</span><br><span class="line">                boolean sharedUserIdSet &#x3D; (pi.sharedUserId !&#x3D; null);</span><br><span class="line">                boolean processNameNotDefault &#x3D;</span><br><span class="line">                (pi.applicationInfo !&#x3D; null &amp;&amp;</span><br><span class="line">                 !appInfo.packageName.equals(pi.applicationInfo.processName));</span><br><span class="line">                boolean sharable &#x3D; (sharedUserIdSet || processNameNotDefault);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Tell the VMRuntime about the application, unless it is shared</span><br><span class="line">                &#x2F;&#x2F; inside a process.</span><br><span class="line">                if (!sharable) &#123;</span><br><span class="line">                    VMRuntime.registerAppInfo(appInfo.packageName, appInfo.dataDir,</span><br><span class="line">                                            appInfo.processName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AppBindData data &#x3D; new AppBindData();</span><br><span class="line">            data.processName &#x3D; processName;</span><br><span class="line">            data.appInfo &#x3D; appInfo;</span><br><span class="line">            data.providers &#x3D; providers;</span><br><span class="line">            data.instrumentationName &#x3D; instrumentationName;</span><br><span class="line">            data.instrumentationArgs &#x3D; instrumentationArgs;</span><br><span class="line">            data.instrumentationWatcher &#x3D; instrumentationWatcher;</span><br><span class="line">            data.instrumentationUiAutomationConnection &#x3D; instrumentationUiConnection;</span><br><span class="line">            data.debugMode &#x3D; debugMode;</span><br><span class="line">            data.enableOpenGlTrace &#x3D; enableOpenGlTrace;</span><br><span class="line">            data.restrictedBackupMode &#x3D; isRestrictedBackupMode;</span><br><span class="line">            data.persistent &#x3D; persistent;</span><br><span class="line">            data.config &#x3D; config;</span><br><span class="line">            data.compatInfo &#x3D; compatInfo;</span><br><span class="line">            data.initProfilerInfo &#x3D; profilerInfo;</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，最后调用了ActivityThread.sendMessage()…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj) &#123;</span><br><span class="line">        sendMessage(what, obj, 0, 0, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看一下其sendMessage的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">        Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.what &#x3D; what;</span><br><span class="line">        msg.obj &#x3D; obj;</span><br><span class="line">        msg.arg1 &#x3D; arg1;</span><br><span class="line">        msg.arg2 &#x3D; arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里调用了mH的sendMessage方法，最后通过Handler的异步消息机制被mH的handleMessage方法处理，然后根据Message.what选择处理分支，最终调用了ActivityThread的handleBindApplication方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 创建Instrumentation</span><br><span class="line">        if (data.instrumentationName !&#x3D; null) &#123;</span><br><span class="line">            InstrumentationInfo ii &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                ii &#x3D; appContext.getPackageManager().</span><br><span class="line">                    getInstrumentationInfo(data.instrumentationName, 0);</span><br><span class="line">            &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (ii &#x3D;&#x3D; null) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to find instrumentation info for: &quot;</span><br><span class="line">                    + data.instrumentationName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInstrumentationPackageName &#x3D; ii.packageName;</span><br><span class="line">            mInstrumentationAppDir &#x3D; ii.sourceDir;</span><br><span class="line">            mInstrumentationSplitAppDirs &#x3D; ii.splitSourceDirs;</span><br><span class="line">            mInstrumentationLibDir &#x3D; ii.nativeLibraryDir;</span><br><span class="line">            mInstrumentedAppDir &#x3D; data.info.getAppDir();</span><br><span class="line">            mInstrumentedSplitAppDirs &#x3D; data.info.getSplitAppDirs();</span><br><span class="line">            mInstrumentedLibDir &#x3D; data.info.getLibDir();</span><br><span class="line"></span><br><span class="line">            ApplicationInfo instrApp &#x3D; new ApplicationInfo();</span><br><span class="line">            instrApp.packageName &#x3D; ii.packageName;</span><br><span class="line">            instrApp.sourceDir &#x3D; ii.sourceDir;</span><br><span class="line">            instrApp.publicSourceDir &#x3D; ii.publicSourceDir;</span><br><span class="line">            instrApp.splitSourceDirs &#x3D; ii.splitSourceDirs;</span><br><span class="line">            instrApp.splitPublicSourceDirs &#x3D; ii.splitPublicSourceDirs;</span><br><span class="line">            instrApp.dataDir &#x3D; ii.dataDir;</span><br><span class="line">            instrApp.nativeLibraryDir &#x3D; ii.nativeLibraryDir;</span><br><span class="line">            LoadedApk pi &#x3D; getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                    appContext.getClassLoader(), false, true, false);</span><br><span class="line">            ContextImpl instrContext &#x3D; ContextImpl.createAppContext(this, pi);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                java.lang.ClassLoader cl &#x3D; instrContext.getClassLoader();</span><br><span class="line">                mInstrumentation &#x3D; (Instrumentation)</span><br><span class="line">                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                    + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInstrumentation.init(this, instrContext, appContext,</span><br><span class="line">                   new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher,</span><br><span class="line">                   data.instrumentationUiAutomationConnection);</span><br><span class="line"></span><br><span class="line">            if (mProfiler.profileFile !&#x3D; null &amp;&amp; !ii.handleProfiling</span><br><span class="line">                    &amp;&amp; mProfiler.profileFd &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mProfiler.handlingProfiling &#x3D; true;</span><br><span class="line">                File file &#x3D; new File(mProfiler.profileFile);</span><br><span class="line">                file.getParentFile().mkdirs();</span><br><span class="line">                Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		&#x2F; If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">            &#x2F;&#x2F; a restricted environment with the base application class.</span><br><span class="line">            Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">            mInitialApplication &#x3D; app;</span><br><span class="line">		...</span><br><span class="line">        try &#123;</span><br><span class="line">           mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception e) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Exception thrown in onCreate() of &quot;</span><br><span class="line">                    + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                        + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的方法体比较长，我们挑重点的看，可以看到方法体中系统通过反射机制创建了Instrumentation对象，并执行了init方法，执行了Insrtumentation对象的初始化。然后我们调用了LockedApk.makeApplication方法创建了Application对象，我们来看一下其具体的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">            Instrumentation instrumentation) &#123;</span><br><span class="line">        if (mApplication !&#x3D; null) &#123;</span><br><span class="line">            return mApplication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Application app &#x3D; null;</span><br><span class="line"></span><br><span class="line">        String appClass &#x3D; mApplicationInfo.className;</span><br><span class="line">        if (forceDefaultAppClass || (appClass &#x3D;&#x3D; null)) &#123;</span><br><span class="line">            appClass &#x3D; &quot;android.app.Application&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; getClassLoader();</span><br><span class="line">            if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">                initializeJavaContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">            ContextImpl appContext &#x3D; ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">            app &#x3D; mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mActivityThread.mAllApplications.add(app);</span><br><span class="line">        mApplication &#x3D; app;</span><br><span class="line"></span><br><span class="line">        if (instrumentation !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                instrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                if (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                        + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Rewrite the R &#39;constants&#39; for all library apks.</span><br><span class="line">        SparseArray&lt;String&gt; packageIdentifiers &#x3D; getAssets(mActivityThread)</span><br><span class="line">                .getAssignedPackageIdentifiers();</span><br><span class="line">        final int N &#x3D; packageIdentifiers.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">            final int id &#x3D; packageIdentifiers.keyAt(i);</span><br><span class="line">            if (id &#x3D;&#x3D; 0x01 || id &#x3D;&#x3D; 0x7f) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里也是以反射的机制创建了Application对象，并创建了一个ContextImpl对象，并将Application与ContextImpl建立关联。。。</p>
<p>继续回到我们的ActivityThread的handleBindApplication方法，在创建了Application对象之后我们调用了Instrumentation的onCreate方法，然后调用了Instrumentation的callApplicationOnCreate方法，我们来看一下其具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callApplicationOnCreate(Application app) &#123;</span><br><span class="line">        app.onCreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>咋样？原来Application的onCreate生命周期方法是在这里回调滴啊。</p>
<p>这样我们整个Application的创建执行流程就讲解完了。</p>
<p>总结：</p>
<ul>
<li><p>应用进程启动 –&gt; 创建Instrumentation –&gt; 创建Application对象 –&gt; 创建Application相关的ContextImpl对象；</p>
</li>
<li><p>ActivityThread.main方法–&gt; ActivityManagerService.bindApplication方法 –&gt; ActivityThread.handleBindApplication –&gt; 创建Instrumentation，创建Application；</p>
</li>
<li><p>每个应用进程对应一个Instrumentation，对应一个Application；</p>
</li>
<li><p>Instrumentation与Application都是通过java反射机制创建；</p>
</li>
<li><p>Application创建过程中会同时创建一个ContextImpl对象，并建立关联；</p>
</li>
</ul>
<p><br><br><br><br>接下来我们来看一下Acitivty中的Context创建流程，大家都知道我们Activity的具体创建过程是在ActivityThread的performLaunchActivity,可参见：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener"> android源码解析之（十四）–&gt;Activity启动流程</a>，这里我们看一下其具体的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Activity activity &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();</span><br><span class="line">            activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state !&#x3D; null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">			...</span><br><span class="line">            if (activity !&#x3D; null) &#123;</span><br><span class="line">                Context appContext &#x3D; createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title &#x3D; r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config &#x3D; new Configuration(mCompatConfiguration);</span><br><span class="line">                if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</span><br><span class="line">                        + r.activityInfo.name + &quot; with config &quot; + config);</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">                if (customIntent !&#x3D; null) &#123;</span><br><span class="line">                    activity.mIntent &#x3D; customIntent;</span><br><span class="line">                &#125;</span><br><span class="line">                r.lastNonConfigurationInstances &#x3D; null;</span><br><span class="line">                activity.mStartedActivity &#x3D; false;</span><br><span class="line">                int theme &#x3D; r.activityInfo.getThemeResource();</span><br><span class="line">                if (theme !&#x3D; 0) &#123;</span><br><span class="line">                    activity.setTheme(theme);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.mCalled &#x3D; false;</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!activity.mCalled) &#123;</span><br><span class="line">                    throw new SuperNotCalledException(</span><br><span class="line">                        &quot;Activity &quot; + r.intent.getComponent().toShortString() +</span><br><span class="line">                        &quot; did not call through to super.onCreate()&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity &#x3D; activity;</span><br><span class="line">                r.stopped &#x3D; true;</span><br><span class="line">                if (!r.activity.mFinished) &#123;</span><br><span class="line">                    activity.performStart();</span><br><span class="line">                    r.stopped &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!r.activity.mFinished) &#123;</span><br><span class="line">                    if (r.isPersistable()) &#123;</span><br><span class="line">                        if (r.state !&#x3D; null || r.persistentState !&#x3D; null) &#123;</span><br><span class="line">                            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                                    r.persistentState);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else if (r.state !&#x3D; null) &#123;</span><br><span class="line">                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里简要说明一下，Activity也是系统通过反射机制创建的，然后我们通过LockedApk.makeApplication创建一个Application，通过查看源码我们知道若这时候LockedApk中的mApplication不为空则直接返回当前的mApplication又因为当我们创建应用进程的时候Application已经被创建，所以当创建Activity的时候这时候Application肯定不为空，所以这时候返回的就是应用进程创建的时候创建的Application，这也从侧面说明了一个应用进程对应着一个Application。然后我们通过createBaseContextForActivity创建了一个ContextImpl对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123;</span><br><span class="line">        int displayId &#x3D; Display.DEFAULT_DISPLAY;</span><br><span class="line">        try &#123;</span><br><span class="line">            displayId &#x3D; ActivityManagerNative.getDefault().getActivityDisplayId(r.token);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ContextImpl appContext &#x3D; ContextImpl.createActivityContext(</span><br><span class="line">                this, r.packageInfo, displayId, r.overrideConfig);</span><br><span class="line">        appContext.setOuterContext(activity);</span><br><span class="line">        Context baseContext &#x3D; appContext;</span><br><span class="line"></span><br><span class="line">        final DisplayManagerGlobal dm &#x3D; DisplayManagerGlobal.getInstance();</span><br><span class="line">        &#x2F;&#x2F; For debugging purposes, if the activity&#39;s package name contains the value of</span><br><span class="line">        &#x2F;&#x2F; the &quot;debug.use-second-display&quot; system property as a substring, then show</span><br><span class="line">        &#x2F;&#x2F; its content on a secondary display if there is one.</span><br><span class="line">        String pkgName &#x3D; SystemProperties.get(&quot;debug.second-display.pkg&quot;);</span><br><span class="line">        if (pkgName !&#x3D; null &amp;&amp; !pkgName.isEmpty()</span><br><span class="line">                &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) &#123;</span><br><span class="line">            for (int id : dm.getDisplayIds()) &#123;</span><br><span class="line">                if (id !&#x3D; Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                    Display display &#x3D;</span><br><span class="line">                            dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id));</span><br><span class="line">                    baseContext &#x3D; appContext.createDisplayContext(display);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return baseContext;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里创建了一个ContextImpl对象，并通过ContextImpl的setOuterContext方法，让该ContextImpl持有了Activity的引用，继续往下看，我们调用了activity.attach方法，查看一下该方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">            Instrumentation instr, IBinder token, int ident,</span><br><span class="line">            Application application, Intent intent, ActivityInfo info,</span><br><span class="line">            CharSequence title, Activity parent, String id,</span><br><span class="line">            NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">            Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">        mFragments.attachHost(null &#x2F;*parent*&#x2F;);</span><br><span class="line"></span><br><span class="line">        mWindow &#x3D; new PhoneWindow(this);</span><br><span class="line">        mWindow.setCallback(this);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">        mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">        if (info.softInputMode !&#x3D; WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">            mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">        &#125;</span><br><span class="line">        if (info.uiOptions !&#x3D; 0) &#123;</span><br><span class="line">            mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        mUiThread &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        mMainThread &#x3D; aThread;</span><br><span class="line">        mInstrumentation &#x3D; instr;</span><br><span class="line">        mToken &#x3D; token;</span><br><span class="line">        mIdent &#x3D; ident;</span><br><span class="line">        mApplication &#x3D; application;</span><br><span class="line">        mIntent &#x3D; intent;</span><br><span class="line">        mReferrer &#x3D; referrer;</span><br><span class="line">        mComponent &#x3D; intent.getComponent();</span><br><span class="line">        mActivityInfo &#x3D; info;</span><br><span class="line">        mTitle &#x3D; title;</span><br><span class="line">        mParent &#x3D; parent;</span><br><span class="line">        mEmbeddedID &#x3D; id;</span><br><span class="line">        mLastNonConfigurationInstances &#x3D; lastNonConfigurationInstances;</span><br><span class="line">        if (voiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            if (lastNonConfigurationInstances !&#x3D; null) &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mVoiceInteractor &#x3D; new VoiceInteractor(voiceInteractor, this, this,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">                mToken, mComponent.flattenToString(),</span><br><span class="line">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) !&#x3D; 0);</span><br><span class="line">        if (mParent !&#x3D; null) &#123;</span><br><span class="line">            mWindow.setContainer(mParent.getWindow());</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; mWindow.getWindowManager();</span><br><span class="line">        mCurrentConfig &#x3D; config;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>除了一下初始化操作之外，还调用了attachBaseContext方法，让Activity持有了ContextImpl的引用，这样就相当于Activity与ContextImpl对象相互持有了对方的引用，并且Activity是继承与Context。</p>
<p>总结：</p>
<ul>
<li><p>Activity中创建ContextImpl对象的具体实现在ActivityThread的performLauncherAcitivty方法中；</p>
</li>
<li><p>Activity的创建伴随着ContextImpl的创建，二者相互持有对方的引用；</p>
</li>
<li><p>创建Activity –&gt; 创建Activity相关ContextImpl对象；</p>
</li>
<li><p>创建应用进程 –&gt; 创建Application –&gt; 创建Application相关ContextImpl对象；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/15%20activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/15%20activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">15 activity销毁流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>继续我们的源码解析，上一篇文章我们介绍了Activity的启动流程，一个典型的场景就是Activity a 启动了一个Activity b，他们的生命周期回调方法是：<br>onPause(a) –&gt; onCreate(b) –&gt; onStart(b) –&gt; onResume(b) –&gt; onStop(a)<br>而我们根据源码也验证了这样的生命周期调用序列，那么Activity的销毁流程呢？它的生命周期的调用顺序又是这样的呢？</p>
<p>这里我们我做一个简单的demo，让一个Activity a启动Activity b，然后在b中调用finish()方法，它们的生命周期执行顺序是：</p>
<blockquote>
<p>onPause(b)<br>onRestart(a)<br>onStart(a)<br>onResume(a)<br>onStop(b)<br>onDestory(b)</p>
</blockquote>
<p>好吧，根据我们测试的生命周期方法的回调过程开始对Activity销毁流程的分析，一般而言当我们需要销毁Activity的时候都会调用其自身的finish方法，所以我们的流程开始是以finish方法开始的。</p>
<p><br><strong><font size="6">一：请求销毁当前Activity</p>
<blockquote>
<font color="red">
MyActivity.finish()
Activity.finish()
ActivityManagerNative.getDefault().finishActivity()
ActivityManagerService.finishActivity()
ActivityStack.requestFinishActivityLocked()
ActivityStack.finishActivityLocked()
ActivityStack.startPausingLocked()
</font>
</blockquote>
<p>首先我们在自己的Activity调用了finish方法，它实际上调用的是Activity的finish方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void finish() &#123;</span><br><span class="line">    finish(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以发现其调用了finish方法的重载方法，并且传递了一个参数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void finish(boolean finishTask) &#123;</span><br><span class="line">        if (mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            int resultCode;</span><br><span class="line">            Intent resultData;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                resultCode &#x3D; mResultCode;</span><br><span class="line">                resultData &#x3D; mResultData;</span><br><span class="line">            &#125;</span><br><span class="line">            if (false) Log.v(TAG, &quot;Finishing self: token&#x3D;&quot; + mToken);</span><br><span class="line">            try &#123;</span><br><span class="line">                if (resultData !&#x3D; null) &#123;</span><br><span class="line">                    resultData.prepareToLeaveProcess();</span><br><span class="line">                &#125;</span><br><span class="line">                if (ActivityManagerNative.getDefault()</span><br><span class="line">                        .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;</span><br><span class="line">                    mFinished &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; Empty</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mParent.finishFromChild(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这个参数值似乎并没什么用。。。这里就不在讨论了，然后调用了ActivityManagerNative.getDefault().finishActivity方法，好吧，根据上一篇文章的介绍，我们知道了ActivityManagerNative是一个Binder对象，这里调用的方法最终会被ActivityManagerService执行，所以这了的finishActivity最终被执行的是ActivityManagerService.finishActivity方法，好吧，我们来看一下ActivityManagerService的finishActivity方法的执行逻辑。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, boolean finishTask) &#123;</span><br><span class="line">     ...</span><br><span class="line">     res &#x3D; tr.stack.requestFinishActivityLocked(token, resultCode,resultData, &quot;app-request&quot;, true);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以发现，经过一系列逻辑判断之后，最终调用了ActivityStack的requestFinishActivityLocked方法，这里应该就是执行finish Activity的逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final boolean requestFinishActivityLocked(IBinder token, int resultCode,</span><br><span class="line">            Intent resultData, String reason, boolean oomAdj) &#123;</span><br><span class="line">        ActivityRecord r &#x3D; isInStackLocked(token);</span><br><span class="line">        if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                &quot;Finishing activity token&#x3D;&quot; + token + &quot; r&#x3D;&quot;</span><br><span class="line">                + &quot;, result&#x3D;&quot; + resultCode + &quot;, data&#x3D;&quot; + resultData</span><br><span class="line">                + &quot;, reason&#x3D;&quot; + reason);</span><br><span class="line">        if (r &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finishActivityLocked(r, resultCode, resultData, reason, oomAdj);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法体里面又调用了finishActivityLocked方法，那我们继续看一下finishActivityLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData,</span><br><span class="line">            String reason, boolean oomAdj) &#123;</span><br><span class="line">        ...</span><br><span class="line">        startPausingLocked(false, false, false, false);</span><br><span class="line">		...</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，在这里调用了startPausingLocked方法，看名字应该是开始要执行Activity的onPause方法请求了，然后我们看一下startPausingLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) &#123;</span><br><span class="line">       ...</span><br><span class="line">            try &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</span><br><span class="line">                        prev.userId, System.identityHashCode(prev),</span><br><span class="line">                        prev.shortComponentName);</span><br><span class="line">                mService.updateUsageStats(prev, false);</span><br><span class="line">                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                        userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore exception, if process died other code will cleanup.</span><br><span class="line">                Slog.w(TAG, &quot;Exception thrown during pause&quot;, e);</span><br><span class="line">                mPausingActivity &#x3D; null;</span><br><span class="line">                mLastPausedActivity &#x3D; null;</span><br><span class="line">                mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样从应用程序调用finish方法，ActivityManagerService接收请求并执行startPausingLocked方法。</p>
<p><br><strong><font size="6">二：执行当前Activity的onPause方法</p>
<blockquote>
<font color="red">
IApplicationThread.schedulePauseActivity()
ActivityThread.schedulePauseActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handlePauseActivity()
ActivityThread.performPauseActivity()
Instrumentation.callActivityOnPause()
Activity.performPause()
Activity.onPause()
ActivityManagerNative.getDefault().activityPaused()
ActivityManagerService.activityPaused()
ActivityStack.activityPausedLocked()
ActivityStack.completePauseLocked()
</font>
</blockquote>
<p>在方法startPausingLocked中我们调用了：prev.app.thread.schedulePauseActivity这里实际上调用的是IApplicationThread的schedulePauseActivity方法，IApplicationThread也是一个Binder对象，它是ActivityThread中ApplicationThread的Binder client端，所以最终会调用的是ApplicationThread的schedulePauseActivity方法，好吧我们看一下ActivityThread的schedulePauseActivity方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">   sendMessage(</span><br><span class="line">       finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">       token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0),</span><br><span class="line">                    configChanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了ActivityThread的sendMessage方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2) &#123;</span><br><span class="line">        sendMessage(what, obj, arg1, arg2, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后又回调了sendMessage的重载方法。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">        Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.what &#x3D; what;</span><br><span class="line">        msg.obj &#x3D; obj;</span><br><span class="line">        msg.arg1 &#x3D; arg1;</span><br><span class="line">        msg.arg2 &#x3D; arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用mH发送异步消息，然后在mH的handleMessge方法中处理异步消息并调用handlePauseActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;Slog.v(TAG, &quot;userLeaving&#x3D;&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里回调了performPauseActivity方法，上篇文章中我们已经分析过了这段代码：</p>
<blockquote>
<p>performPauseActivity()<br>Instrumentation.callActivityOnPause()<br>Activity.performPause()<br>Activity.onPause()</p>
</blockquote>
<p>这样我们就回调了第一个生命周期方法：onPause。。。</p>
<p>在handlePauseActivity方法中我们调用了ActivityManagerNative.getDefault().activityPaused(token)方法，好吧又是回调ActivityManagerService的方法，这样最终会调用ActivityManagerService的activityPaused方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityPaused(IBinder token) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                stack.activityPausedLocked(token, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们继续看一下activityPausedLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void activityPausedLocked(IBinder token, boolean timeout) &#123;</span><br><span class="line">        ...</span><br><span class="line">        completePauseLocked(true);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面又经过一系列的逻辑判断之后，开始执行completePauseLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void completePauseLocked(boolean resumeNext) &#123;</span><br><span class="line">	...                   mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null);</span><br><span class="line">	...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样栈顶Activity的onPause操作就执行完成了，接下来就就是开始执行上一个Activity的onResume操作了。。。</p>
<p></br><strong><font size="6">三：执行上一个Activity的onResume操作</font></strong><br>这样调用了ActivityStackSupervisor.resumeTopActivitiesLocked方法。。，又开始调用这个方法，通过上一篇文章的介绍，我们知道这个方法实际上是执行Activity的初始化，我们看一下其具体的调用过程：</p>
<blockquote>
<font color="red">
ActivityStack.resumeTopActivityLocked()
ActivityStack.resumeTopInnerLocked()
IApplicationThread.scheduleResumeActivity()
ActivityThread.scheduleResumeActivity()
ActivityThread.sendMessage()
ActivityTherad.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.H.handleResumeMessage()
Activity.performResume()
Activity.performRestart()
Instrumentation.callActivityOnRestart()
Activity.onRestart()
Activity.performStart()
Instrumentation.callActivityOnStart()
Activity.onStart()
Instrumentation.callActivityOnResume()
Activity.onResume()
</font>
</blockquote>
<p>好吧，这个过程其实上一篇文章中已经做了介绍，这里不做过多的分析了，通过这样调用过程我们最终执行了当前栈顶Activity上一个Activity的onRestart方法，onStart方法，onResume方法等，下面我们将调用栈顶Activity的onStop方法，onDestory方法。</p>
<p></br><strong><font size="6">四：执行栈顶Activity的销毁操作</p>
<blockquote>
<font color="red">
Looper.myQueue().addIdleHandler(new Idler())
ActivityManagerNative.getDefault().activityIdle()
ActivityManagerService.activityIdle()
ActivityStackSupervisor.activityIdleInternalLocked()
ActivityStack.destroyActivityLocked()
IApplicationThread.scheduleDestoryActivity()
ActivityThread.scheduleDestoryActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handleDestoryActivity()
ActivityThread.performDestoryActivity()
Activity.performStop()
Instrumentation.callActivityOnStop()
Activity.onStop()
Instrumentation.callActivityOnDestory()
Activity.performDestory()
Acitivity.onDestory()
ActivityManagerNative.getDefault().activityDestoryed()
ActivityManagerService.activityDestoryed()
ActivityStack.activityDestoryedLocked()
</font>
</blockquote>
<p>我们在ActivityThread.handleResumeActivity方法中调用了Looper.myQueue().addIdleHandler(new Idler())，下面看一下这个方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean queueIdle() &#123;</span><br><span class="line">            ActivityClientRecord a &#x3D; mNewActivities;</span><br><span class="line">            boolean stopProfiling &#x3D; false;</span><br><span class="line">            if (mBoundApplication !&#x3D; null &amp;&amp; mProfiler.profileFd !&#x3D; null</span><br><span class="line">                    &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">                stopProfiling &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a !&#x3D; null) &#123;</span><br><span class="line">                mNewActivities &#x3D; null;</span><br><span class="line">                IActivityManager am &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">                ActivityClientRecord prev;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (localLOGV) Slog.v(</span><br><span class="line">                        TAG, &quot;Reporting idle of &quot; + a +</span><br><span class="line">                        &quot; finished&#x3D;&quot; +</span><br><span class="line">                        (a.activity !&#x3D; null &amp;&amp; a.activity.mFinished));</span><br><span class="line">                    if (a.activity !&#x3D; null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                            a.createdConfig &#x3D; null;</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Ignore</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev &#x3D; a;</span><br><span class="line">                    a &#x3D; a.nextIdle;</span><br><span class="line">                    prev.nextIdle &#x3D; null;</span><br><span class="line">                &#125; while (a !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (stopProfiling) &#123;</span><br><span class="line">                mProfiler.stopProfiling();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>内部有一个queueIdle的回调方法，当它被添加到MessageQueue之后就会回调该方法，我们可以发现在这个方法体中调用了ActivityManagerNative.getDefault.activityIdle方法，通过上一篇文章以及上面的讲解，我们应该知道这了最终调用的是ActivityManagerService.activityIdle方法，好吧，这里看一下activityIdle方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                ActivityRecord r &#x3D;</span><br><span class="line">                        mStackSupervisor.activityIdleInternalLocked(token, false, config);</span><br><span class="line">                if (stopProfiling) &#123;</span><br><span class="line">                    if ((mProfileProc &#x3D;&#x3D; r.app) &amp;&amp; (mProfileFd !&#x3D; null)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            mProfileFd.close();</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        clearProfilerLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里又调用了ActivityStackSupervisor.activityIdleInternalLocked方法，然后我们看一下activityIdleInternalLocked方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123;</span><br><span class="line">    ....   </span><br><span class="line">    stack.destroyActivityLocked(r, true, &quot;finish-idle&quot;);</span><br><span class="line">    ....    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用ActivityStack.destroyActivityLocked方法，可以看一下其具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) &#123;</span><br><span class="line">      ...</span><br><span class="line">      r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags);</span><br><span class="line">      ...      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里又开始执行IApplicationThread.scheduleDestoryActivity方法，上文已经做了说明这里最终调用的是ActivityThread.scheduleDestroyActivity方法，好吧，看一下ActivityThread.scheduleDestryActivity方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleDestroyActivity(IBinder token, boolean finishing, int configChanges) &#123;</span><br><span class="line">    sendMessage(H.DESTROY_ACTIVITY, token, finishing ? 1 : 0,</span><br><span class="line">                    configChanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有开始执行sendMessage方法，通过一系列的调用sendMessage方法最终调用了handleDestroyActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private void handleDestroyActivity(IBinder token, boolean finishing,</span><br><span class="line">            int configChanges, boolean getNonConfigInstance) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; performDestroyActivity(token, finishing,</span><br><span class="line">                configChanges, getNonConfigInstance);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            cleanUpPendingRemoveWindows(r);</span><br><span class="line">            WindowManager wm &#x3D; r.activity.getWindowManager();</span><br><span class="line">            View v &#x3D; r.activity.mDecor;</span><br><span class="line">            if (v !&#x3D; null) &#123;</span><br><span class="line">                if (r.activity.mVisibleFromServer) &#123;</span><br><span class="line">                    mNumVisibleActivities--;</span><br><span class="line">                &#125;</span><br><span class="line">                IBinder wtoken &#x3D; v.getWindowToken();</span><br><span class="line">                if (r.activity.mWindowAdded) &#123;</span><br><span class="line">                    if (r.onlyLocalRequest) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Hold off on removing this until the new activity&#39;s</span><br><span class="line">                        &#x2F;&#x2F; window is being added.</span><br><span class="line">                        r.mPendingRemoveWindow &#x3D; v;</span><br><span class="line">                        r.mPendingRemoveWindowManager &#x3D; wm;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        wm.removeViewImmediate(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (wtoken !&#x3D; null &amp;&amp; r.mPendingRemoveWindow &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    WindowManagerGlobal.getInstance().closeAll(wtoken,</span><br><span class="line">                            r.activity.getClass().getName(), &quot;Activity&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mDecor &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r.mPendingRemoveWindow &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; If we are delaying the removal of the activity window, then</span><br><span class="line">                &#x2F;&#x2F; we can&#39;t clean up all windows here.  Note that we can&#39;t do</span><br><span class="line">                &#x2F;&#x2F; so later either, which means any windows that aren&#39;t closed</span><br><span class="line">                &#x2F;&#x2F; by the app will leak.  Well we try to warning them a lot</span><br><span class="line">                &#x2F;&#x2F; about leaking windows, because that is a bug, so if they are</span><br><span class="line">                &#x2F;&#x2F; using this recreate facility then they get to live with leaks.</span><br><span class="line">                WindowManagerGlobal.getInstance().closeAll(token,</span><br><span class="line">                        r.activity.getClass().getName(), &quot;Activity&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Mocked out contexts won&#39;t be participating in the normal</span><br><span class="line">            &#x2F;&#x2F; process lifecycle, but if we&#39;re running with a proper</span><br><span class="line">            &#x2F;&#x2F; ApplicationContext we need to have it tear down things</span><br><span class="line">            &#x2F;&#x2F; cleanly.</span><br><span class="line">            Context c &#x3D; r.activity.getBaseContext();</span><br><span class="line">            if (c instanceof ContextImpl) &#123;</span><br><span class="line">                ((ContextImpl) c).scheduleFinalCleanup(</span><br><span class="line">                        r.activity.getClass().getName(), &quot;Activity&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (finishing) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityDestroyed(token);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; If the system process has died, it&#39;s game over for everyone.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了performDestroyActivity方法，用来执行Avtivity的onDestroy方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing,</span><br><span class="line">            int configChanges, boolean getNonConfigInstance) &#123;</span><br><span class="line">       ...     </span><br><span class="line">       r.activity.performStop();</span><br><span class="line">       ...</span><br><span class="line">       mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">	   ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了Activity.performStop()方法，查看performStop方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performStop() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mInstrumentation.callActivityOnStop(this);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了Instrumentation.callActivityOnStop()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnStop(Activity activity) &#123;</span><br><span class="line">        activity.onStop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，终于调用了Activity的onStop方法。。。</p>
<p>我们继续看一下Instrumentation.callActivityOnDestroy()。。。。又是通过Instrumentation来调用Activity的onDestroy方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnDestroy(Activity activity) &#123;</span><br><span class="line">    ...</span><br><span class="line">    activity.performDestroy();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下Activity的performDestroy()方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final void performDestroy() &#123;</span><br><span class="line">        mDestroyed &#x3D; true;</span><br><span class="line">        mWindow.destroy();</span><br><span class="line">        mFragments.dispatchDestroy();</span><br><span class="line">        onDestroy();</span><br><span class="line">        mFragments.doLoaderDestroy();</span><br><span class="line">        if (mVoiceInteractor !&#x3D; null) &#123;</span><br><span class="line">            mVoiceInteractor.detachActivity();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，终于回调了Activity的onDestroy方法。。。。</p>
<p></br></br></br><br><strong><font size="5">总结：</p>
<ul>
<li><p>Activity的销毁流程是从finish方法开始的</p>
</li>
<li><p>Activity销毁过程是：onPause –&gt; onRestart –&gt; onStart –&gt; onResume –&gt; onStop –&gt; onDestroy</p>
</li>
<li><p>Activity的销毁流程是ActivityThread与ActivityManagerService相互配合销毁的</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/14%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/14%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">14 activity启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等，</p>
<p>首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍：</p>
<blockquote>
<p>An activity represents a single screen with a user interface. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. Although the activities work together to form a cohesive user experience in the email application, each one is independent of the others. As such, a different application can start any one of these activities (if the email application allows it). For example, a camera application can start the activity in the email application that composes new mail, in order for the user to share a picture.</p>
</blockquote>
<p>英文不太好，这里就不献丑了，这里介绍的Activity的大概意思就是说，activity在Android系统中代表的就是一个屏幕，一个App就是由许多个不同的Acitivty组成的，并且不同进程之间的Activity是可以相互调用的。</p>
<p>在介绍Activity的启动流程之前，我们先介绍几个概念：</p>
<ul>
<li>Activity的生命周期</li>
</ul>
<blockquote>
<p>protected void onCreate(Bundle savedInstanceState);<br>protected void onRestart();<br>protected void onStart();<br>protected void onResume();<br>protected void onPause();<br>protected void onStop();<br>protected void onDestory();<br>以上为Activity生命周期中的各个时期的回调方法，在不同的方法中我们可以执行不同的逻辑。<br>关于Activity生命周期的详细介绍可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/41693807" target="_blank" rel="noopener"> Android activity的生命周期</a></p>
</blockquote>
<ul>
<li>Activity的启动模式</li>
</ul>
<blockquote>
<p>activity启动时可以设置不同的启动模式，主要是：standrand，singleTop，singleTask，instance等四种启动模式，不同的启动模式在启动Activity时会执行不同的逻辑，系统会按不同的启动模式将Activity存放到不同的activity栈中。<br>关于Activity启动模式的详细介绍，可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/46534693" target="_blank" rel="noopener"> Android任务和返回栈完全解析</a></p>
</blockquote>
<ul>
<li>Activity的启动进程</li>
</ul>
<blockquote>
<p>在Manifest.xml中定义Activity的时候，Activity默认是属于进程名称为包名的进程的，当然这时候是可以指定Activity的启动进程，所以在Activity启动时首先会检测当前Activity所属的进程是否已经启动，若进程没有启动，则首先会启动该进程，并在该进程启动之后才会执行Activity的启动过程。</p>
</blockquote>
<ul>
<li><p>Intent启动Activity的方式</p>
<blockquote>
<p>Intent启动Activity分为两种，显示启动和隐士启动，显示启动就是在初始化Intent对象的时候直接引用需要启动的Activity的字节码，显示引用的好处就是可以直接告诉Intent对象启动的Activity对象不需要执行intent filter索引需要启动哪一个Activity，但是显示引用不能启动其他进程的Activity对象，因为无法获取其他进程的Activity对象的字节码，而隐式启动则可以通过配置Intent Filter启动其他进程的Activity对象，因此在应用内，我们一般都是使用显示启动的方式启动Activity，而如果需要启动其他应用的Activity时，一般使用隐式启动的方式。</p>
</blockquote>
</li>
<li><p>Android Framework层的CS模式<br>通过前几篇文章的介绍我们知道android系统在启动过程中会执行这样的逻辑：</p>
<pre><code>Zygote进程 --&gt; SystemServer进程 --&gt; 各种系统服务 --&gt; 应用进程</code></pre><p>在Actvity启动过程中，其实是应用进程与SystemServer进程相互配合启动Activity的过程，其中应用进程主要用于执行具体的Activity的启动过程，回调生命周期方法等操作，而SystemServer进程则主要是调用其中的各种服务，将Activity保存在栈中，协调各种系统资源等操作。</p>
</li>
<li><p>Android系统进程间通讯Binder机制<br>Android系统存了Zygote进程和SystemServer进程以及各种应用进程等，为了能够实现各种进程之间的通讯，Android系统采用了自己的进程间通讯方式Binder机制。其中主要涉及到了四种角色：Binder Client，Binder Server，Binder Manager， Binder driver。各种角色之间的关系可以参考下面这张图的介绍：<br><img src="http://img.blog.csdn.net/20160423105932970" alt="这里写图片描述"></p>
</li>
</ul>
<p>好吧，前面我们介绍了一些Activity启动过程中需要的相关知识点，下面我们开始Activity启动流程的讲解。。。。</p>
<p>还记得前面我们讲过的Launcher启动流程么？可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51112031" target="_blank" rel="noopener">android源码解析之（十）–&gt;Launcher启动流程</a><br>在这篇文章中我们说Launcher启动之后会将各个应用包名和icon与app name保存起来，然后执行icon的点击事件的时候调用startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">        Intent intent &#x3D; intentForPosition(position);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected Intent intentForPosition(int position) &#123;</span><br><span class="line">        ActivityAdapter adapter &#x3D; (ActivityAdapter) mAdapter;</span><br><span class="line">        return adapter.intentForPosition(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public Intent intentForPosition(int position) &#123;</span><br><span class="line">            if (mActivitiesList &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Intent intent &#x3D; new Intent(mIntent);</span><br><span class="line">            ListItem item &#x3D; mActivitiesList.get(position);</span><br><span class="line">            intent.setClassName(item.packageName, item.className);</span><br><span class="line">            if (item.extras !&#x3D; null) &#123;</span><br><span class="line">                intent.putExtras(item.extras);</span><br><span class="line">            &#125;</span><br><span class="line">            return intent;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，我们在启动Activity的时候，执行的逻辑就是创建一个Intent对象，然后初始化Intent对象，使用隐式启动的方式启动该Acvitity，这里为什么不能使用显示启动的方式呢？</p>
<p>这是因为Launcher程序启动的Activity一般都是启动一个新的应用进程，该进程与Launcher进程不是在同一个进程中，所以也就无法引用到启动的Activity字节码，自然也就无法启动该Activity了。</p>
<p>继续，我们查看startActivity方法的具体实现：</p>
<p></br><strong><font size="6" >一:开始请求执行启动Activity</font><strong></p>
<blockquote>
<font color="red">
MyActivity.startActivity()
Activity.startActivity()
Activity.startActivityForResult
Instrumentation.execStartActivty
ActivityManagerNative.getDefault().startActivityAsUser()
</font>
</blockquote>
<p>在我们的Activity中调用startActivity方法，会执行Activity中的startActivity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        this.startActivity(intent, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在Activity中的startActivity方法体里调用了startActivity的重载方法，这里我们看一下其重载方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Note we want to go through this call for compatibility with</span><br><span class="line">            &#x2F;&#x2F; applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于在上一步骤中我们传递的Bunde对象为空，所以这里我们执行的是else分支的逻辑，所以这里调用了startActivityForResult方法，并且传递的参数为intent和-1.</p>
<p><font color="#A52A2A"><strong>注意：</strong>通过这里的代码我们可以发现，其实我们在Activity中调用startActivity的内部也是调用的startActivityForResult的。那么为什么调用startActivityForResult可以在Activity中回调onActivityResult而调用startActivity则不可以呢？可以发现其主要的区别是调用startActivity内部调用startActivityForResult传递的传输requestCode值为-1，也就是说我们在Activity调用startActivityForResult的时候传递的requestCode值为-1的话，那么onActivityResult是不起作用的。<br>实际上，经测试requestCode的值小于0的时候都是不起作用的，所以当我们调用startActivityForResult的时候需要注意这一点。</font></p>
<p>好吧，我们继续往下看，startActivityForResult方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">        if (mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar &#x3D;</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            if (ar !&#x3D; null) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            if (requestCode &gt;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; If this start is requesting a result, we can avoid making</span><br><span class="line">                &#x2F;&#x2F; the activity visible until the result is received.  Setting</span><br><span class="line">                &#x2F;&#x2F; this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br><span class="line">                &#x2F;&#x2F; activity hidden during this time, to avoid flickering.</span><br><span class="line">                &#x2F;&#x2F; This can only be done when a result is requested because</span><br><span class="line">                &#x2F;&#x2F; that guarantees we will get information back when the</span><br><span class="line">                &#x2F;&#x2F; activity is finished, no matter what happens to it.</span><br><span class="line">                mStartedActivity &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            &#x2F;&#x2F; TODO Consider clearing&#x2F;flushing other event sources and events for child windows.</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (options !&#x3D; null) &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Note we want to go through this method for compatibility with</span><br><span class="line">                &#x2F;&#x2F; existing applications that may have overridden it.</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现由于我们是第一次启动Activity，所以这里的mParent为空，所以会执行if分之，然后调用mInstrumentation.execStartActivity方法，并且这里需要注意的是，有一个判断逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (requestCode &gt;&#x3D; 0) &#123;</span><br><span class="line">	mStartedActivity &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释也验证了我们刚刚的说法即，调用startActivityForResult的时候只有requestCode的值大于等于0，onActivityResult才会被回调。</p>
<p>然后我们看一下mInstrumentation.execStartActivity方法的实现。在查看execStartActivity方法之前，我们需要对mInstrumentation对象有一个了解？什么是Instrumentation？Instrumentation是android系统中启动Activity的一个实际操作类，也就是说Activity在应用进程端的启动实际上就是Instrumentation执行的，那么为什么说是在应用进程端的启动呢？实际上acitivty的启动分为应用进程端的启动和SystemServer服务进程端的启动的，多个应用进程相互配合最终完成了Activity在系统中的启动的，而在应用进程端的启动实际的操作类就是Intrumentation来执行的，可能还是有点绕口，没关系，随着我们慢慢的解析大家就会对Instrumentation的认识逐渐加深的。</p>
<p>可以发现execStartActivity方法传递的几个参数：<br>this，为启动Activity的对象；<br>contextThread，为Binder对象，是主进程的context对象；<br>token，也是一个Binder对象，指向了服务端一个ActivityRecord对象；<br>target，为启动的Activity；<br>intent，启动的Intent对象；<br>requestCode，请求码；<br>options，参数；</p>
<p>这样就调用了Imstrument.execStartActivity方法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">            int result &#x3D; ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在这个方法中主要调用ActivityManagerNative.getDefault().startActivity方法，那么ActivityManagerNative又是个什么鬼呢？查看一下getDefault()对象的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">        return gDefault.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，相当之简单直接返回的是gDefault.get()，那么gDefault又是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        protected IActivityManager create() &#123;</span><br><span class="line">            IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder &#x3D; &quot; + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am &#x3D; asInterface(b);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service &#x3D; &quot; + am);</span><br><span class="line">            &#125;</span><br><span class="line">            return am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager in &#x3D;</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，最后直接返回一个ActivityManagerProxy对象，而ActivityManagerProxy继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的ActivityManagerProxy和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示：<br>Binder接口 –&gt; ActivityManagerNative/ActivityManagerProxy –&gt; ActivityManagerService；</p>
<p>这样，ActivityManagerNative与ActivityManagerProxy相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不同等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。</p>
<p>好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。</p>
<p>继续往下卡，我们调用的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int result &#x3D; ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br></pre></td></tr></table></figure>
<p>这里通过我们刚刚的分析，ActivityManagerNative.getDefault()方法会返回一个ActivityManagerProxy对象，那么我们看一下ActivityManagerProxy对象的startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">            String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(caller !&#x3D; null ? caller.asBinder() : null);</span><br><span class="line">        data.writeString(callingPackage);</span><br><span class="line">        intent.writeToParcel(data, 0);</span><br><span class="line">        data.writeString(resolvedType);</span><br><span class="line">        data.writeStrongBinder(resultTo);</span><br><span class="line">        data.writeString(resultWho);</span><br><span class="line">        data.writeInt(requestCode);</span><br><span class="line">        data.writeInt(startFlags);</span><br><span class="line">        if (profilerInfo !&#x3D; null) &#123;</span><br><span class="line">            data.writeInt(1);</span><br><span class="line">            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            data.writeInt(1);</span><br><span class="line">            options.writeToParcel(data, 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.readException();</span><br><span class="line">        int result &#x3D; reply.readInt();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。</p>
<p>以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。</p>
<p><br/><strong><font size="6">二：ActivityManagerService接收启动Activity的请求</font></strong></p>
<blockquote>
<font color="red">
ActivityManagerService.startActivity() 
ActvityiManagerService.startActivityAsUser() 
ActivityStackSupervisor.startActivityMayWait() 
ActivityStackSupervisor.startActivityLocked() 
ActivityStackSupervisor.startActivityUncheckedLocked() 
ActivityStackSupervisor.startActivityLocked() 
ActivityStackSupervisor.resumeTopActivitiesLocked()
ActivityStackSupervisor.resumeTopActivityInnerLocked() 
</font>
</blockquote>
<p>好吧，代码量比较大，慢慢看，首先看一下ActivityManagerService.startActivity的具体实现；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123;</span><br><span class="line">        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，该方法并没有实现什么逻辑，直接调用了startActivityAsUser方法，我们继续看一下startActivityAsUser方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">        userId &#x3D; handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">                false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">        &#x2F;&#x2F; TODO: Switch to user app stacks here.</span><br><span class="line">        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                profilerInfo, null, null, options, false, userId, null, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，下面我们来看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">            String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,</span><br><span class="line">            Bundle options, boolean ignoreTargetSecurity, int userId,</span><br><span class="line">            IActivityContainer iContainer, TaskRecord inTask) &#123;</span><br><span class="line">		    ...</span><br><span class="line"></span><br><span class="line">            int res &#x3D; startActivityLocked(caller, intent, resolvedType, aInfo,</span><br><span class="line">                    voiceSession, voiceInteractor, resultTo, resultWho,</span><br><span class="line">                    requestCode, callingPid, callingUid, callingPackage,</span><br><span class="line">                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</span><br><span class="line">                    componentSpecified, null, container, inTask);</span><br><span class="line">		    ...</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityLocked(IApplicationThread caller,</span><br><span class="line">            Intent intent, String resolvedType, ActivityInfo aInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int callingPid, int callingUid, String callingPackage,</span><br><span class="line">            int realCallingPid, int realCallingUid, int startFlags, Bundle options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            ActivityContainer container, TaskRecord inTask) &#123;</span><br><span class="line">        int err &#x3D; ActivityManager.START_SUCCESS;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        err &#x3D; startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, true, options, inTask);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,</span><br><span class="line">            boolean doResume, Bundle options, TaskRecord inTask) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);</span><br><span class="line">        targetStack.mLastPausedActivity &#x3D; null;</span><br><span class="line">        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">        if (!launchTaskBehind) &#123;</span><br><span class="line">            &#x2F;&#x2F; Don&#39;t set focus on an activity that&#39;s going to the back.</span><br><span class="line">            mService.setFocusedActivityLocked(r, &quot;startedActivity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ActivityManager.START_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>startActivityUncheckedLocked方法中只要执行了不同启动模式不同栈的处理，并最后调用了startActivityLocked的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void startActivityLocked(ActivityRecord r, boolean newTask,</span><br><span class="line">            boolean doResume, boolean keepCurTransition, Bundle options) &#123;</span><br><span class="line">		...</span><br><span class="line">        if (doResume) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个startActivityLocked方法主要执行初始化了windowManager服务，然后调用resumeTopActivitiesLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,</span><br><span class="line">            Bundle targetOptions) &#123;</span><br><span class="line">        if (targetStack &#x3D;&#x3D; null) &#123;</span><br><span class="line">            targetStack &#x3D; mFocusedStack;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Do targetStack first.</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        if (isFrontStack(targetStack)) &#123;</span><br><span class="line">            result &#x3D; targetStack.resumeTopActivityLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int displayNdx &#x3D; mActivityDisplays.size() - 1; displayNdx &gt;&#x3D; 0; --displayNdx) &#123;</span><br><span class="line">            final ArrayList&lt;ActivityStack&gt; stacks &#x3D; mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">            for (int stackNdx &#x3D; stacks.size() - 1; stackNdx &gt;&#x3D; 0; --stackNdx) &#123;</span><br><span class="line">                final ActivityStack stack &#x3D; stacks.get(stackNdx);</span><br><span class="line">                if (stack &#x3D;&#x3D; targetStack) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Already started above.</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isFrontStack(stack)) &#123;</span><br><span class="line">                    stack.resumeTopActivityLocked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现经过循环逻辑判断之后，最终调用了resumeTopActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev) &#123;</span><br><span class="line">        return resumeTopActivityLocked(prev, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line">        if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">            &#x2F;&#x2F; Don&#39;t even start recursing.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Protect against recursion.</span><br><span class="line">            mStackSupervisor.inResumeTopActivity &#x3D; true;</span><br><span class="line">            if (mService.mLockScreenShown &#x3D;&#x3D; ActivityManagerService.LOCK_SCREEN_LEAVING) &#123;</span><br><span class="line">                mService.mLockScreenShown &#x3D; ActivityManagerService.LOCK_SCREEN_HIDDEN;</span><br><span class="line">                mService.updateSleepIfNeededLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mStackSupervisor.inResumeTopActivity &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续调用resumeTopActivityInnerLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		if (mResumedActivity !&#x3D; null) &#123;</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">            pausing |&#x3D; startPausingLocked(userLeaving, false, true, dontWaitForPause);</span><br><span class="line">        &#125;        ...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。</p>
<p><br><strong><font size="6">三：执行栈顶Activity的onPause方法</p>
<blockquote>
<font color="red">
ActivityStack.startPausingLocked()
IApplicationThread.schudulePauseActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage();
ActivityThread.H.handleMessage()
ActivityThread.handlePauseActivity()
ActivityThread.performPauseActivity()
Activity.performPause()
Activity.onPause()
ActivityManagerNative.getDefault().activityPaused(token)
ActivityManagerService.activityPaused()
ActivityStack.activityPausedLocked()
ActivityStack.completePauseLocked()
ActivityStack.resumeTopActivitiesLocked()
ActivityStack.resumeTopActivityLocked()
ActivityStack.resumeTopActivityInnerLocked()
ActivityStack.startSpecificActivityLocked
</font>
</blockquote>
<p>好吧，方法比较多也比较乱，首先来看startPausingLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming,</span><br><span class="line">            boolean dontWait) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (prev.app !&#x3D; null &amp;&amp; prev.app.thread !&#x3D; null) &#123;</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev);</span><br><span class="line">            try &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</span><br><span class="line">                        prev.userId, System.identityHashCode(prev),</span><br><span class="line">                        prev.shortComponentName);</span><br><span class="line">                mService.updateUsageStats(prev, false);</span><br><span class="line">                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                        userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore exception, if process died other code will cleanup.</span><br><span class="line">                Slog.w(TAG, &quot;Exception thrown during pause&quot;, e);</span><br><span class="line">                mPausingActivity &#x3D; null;</span><br><span class="line">                mLastPausedActivity &#x3D; null;</span><br><span class="line">                mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mPausingActivity &#x3D; null;</span><br><span class="line">            mLastPausedActivity &#x3D; null;</span><br><span class="line">            mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。</p>
<p><font color="red">这里的ApplicationThread可以和ActivityManagerNative对于一下：<br>通过ActivityManagerNative –&gt;   ActivityManagerService实现了应用进程与SystemServer进程的通讯<br>通过AppicationThread          &lt;–    IApplicationThread实现了SystemServer进程与应用进程的通讯</font></p>
<p>然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished,</span><br><span class="line">                boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">            sendMessage(</span><br><span class="line">                    finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">                    token,</span><br><span class="line">                    (userLeaving ? 1 : 0) | (dontReport ? 2 : 0),</span><br><span class="line">                    configChanges);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>发送了PAUSE_ACTIVITY_FINISHING消息，然后看一下sendMessage的实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2) &#123;</span><br><span class="line">        sendMessage(what, obj, arg1, arg2, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用了其重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">        Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.what &#x3D; what;</span><br><span class="line">        msg.obj &#x3D; obj;</span><br><span class="line">        msg.arg1 &#x3D; arg1;</span><br><span class="line">        msg.arg2 &#x3D; arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                ...</span><br><span class="line">                case PAUSE_ACTIVITY_FINISHING:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);</span><br><span class="line">                    handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) !&#x3D; 0, msg.arg2,</span><br><span class="line">                            (msg.arg1&amp;1) !&#x3D; 0);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br><span class="line">				...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其调用了handlePauseActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;Slog.v(TAG, &quot;userLeaving&#x3D;&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        return r !&#x3D; null ? performPauseActivity(r, finished, saveState) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用其重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(ActivityClientRecord r, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return !r.activity.mFinished &amp;&amp; saveState ? r.state : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样回到了mInstrumentation的callActivityOnPuase方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnPause(Activity activity) &#123;</span><br><span class="line">        activity.performPause();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>呵呵，原来最终回调到了Activity的performPause方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final void performPause() &#123;</span><br><span class="line">        mDoReportFullyDrawn &#x3D; false;</span><br><span class="line">        mFragments.dispatchPause();</span><br><span class="line">        mCalled &#x3D; false;</span><br><span class="line">        onPause();</span><br><span class="line">        mResumed &#x3D; false;</span><br><span class="line">        if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;&#x3D; android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">            throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onPause()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mResumed &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。</p>
<p>然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityPaused(IBinder token) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                stack.activityPausedLocked(token, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，继续看一下activityPausedLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void activityPausedLocked(IBinder token, boolean timeout) &#123;</span><br><span class="line">	        ...</span><br><span class="line">                if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r</span><br><span class="line">                        + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;));</span><br><span class="line">                completePauseLocked(true);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行了completePauseLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void completePauseLocked(boolean resumeNext) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        if (resumeNext) &#123;</span><br><span class="line">            final ActivityStack topStack &#x3D; mStackSupervisor.getFocusedStack();</span><br><span class="line">            if (!mService.isSleepingOrShuttingDown()) &#123;</span><br><span class="line">                mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line">                ActivityRecord top &#x3D; topStack.topRunningActivityLocked(null);</span><br><span class="line">                if (top &#x3D;&#x3D; null || (prev !&#x3D; null &amp;&amp; top !&#x3D; prev)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If there are no more activities available to run,</span><br><span class="line">                    &#x2F;&#x2F; do resume anyway to start something.  Also if the top</span><br><span class="line">                    &#x2F;&#x2F; activity on the stack is not the just paused activity,</span><br><span class="line">                    &#x2F;&#x2F; we need to go ahead and resume it to ensure we complete</span><br><span class="line">                    &#x2F;&#x2F; an in-flight app switch.</span><br><span class="line">                    mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第二步中解析的方法中了，这样经过<br>resumeTopActivitiesLocked –&gt;<br>ActivityStack.resumeTopActivityLocked() –&gt;<br>resumeTopActivityInnerLocked –&gt;<br>startSpecificActivityLocked<br>好吧，我们看一下startSpecificActivityLocked的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        &#x2F;&#x2F; Is this activity&#39;s application already running?</span><br><span class="line">        ProcessRecord app &#x3D; mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) &#x3D;&#x3D; 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t add this if it is a platform component that is marked</span><br><span class="line">                    &#x2F;&#x2F; to run in multiple processes, because this is actually</span><br><span class="line">                    &#x2F;&#x2F; part of the framework so doesn&#39;t make sense to track as a</span><br><span class="line">                    &#x2F;&#x2F; separate apk in the process.</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If a dead object exception was thrown -- fall through to</span><br><span class="line">            &#x2F;&#x2F; restart the application.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。<br>这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause<br>方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。</p>
<p><br/><strong><font size="6">四：启动Activity所属的应用进程</font></strong></p>
<p>关于如何启动应用进程，前面的一篇文章已经做了介绍，可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51119333" target="_blank" rel="noopener"> android源码解析之（十一）–&gt;应用进程启动流程</a> 这里在简单的介绍一下</p>
<blockquote>
<font color="red">
ActivityManagerService.startProcessLocked()
Process.start()
ActivityThread.main()
ActivityThread.attach()
ActivityManagerNative.getDefault().attachApplication()
ActivityManagerService.attachApplication()
</font>
</blockquote>
<p>好吧，首先看一下startProcessLocked()方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app,</span><br><span class="line">            String hostingType, String hostingNameStr) &#123;</span><br><span class="line">        startProcessLocked(app, hostingType, hostingNameStr, null &#x2F;* abiOverride *&#x2F;,</span><br><span class="line">                null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后回调了其重载的startProcessLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType,</span><br><span class="line">            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">            ...</span><br><span class="line">            boolean isActivityProcess &#x3D; (entryPoint &#x3D;&#x3D; null);</span><br><span class="line">            if (entryPoint &#x3D;&#x3D; null) entryPoint &#x3D; &quot;android.app.ActivityThread&quot;;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</span><br><span class="line">                    app.processName);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">            Process.ProcessStartResult startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名“android.app.ActivityThread”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  int uid, int gid, int[] gids,</span><br><span class="line">                                  int debugFlags, int mountExternal,</span><br><span class="line">                                  int targetSdkVersion,</span><br><span class="line">                                  String seInfo,</span><br><span class="line">                                  String abi,</span><br><span class="line">                                  String instructionSet,</span><br><span class="line">                                  String appDataDir,</span><br><span class="line">                                  String[] zygoteArgs) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">        &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            Log.e(LOG_TAG,</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了startViaZygote方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult startViaZygote(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  final int uid, final int gid,</span><br><span class="line">                                  final int[] gids,</span><br><span class="line">                                  int debugFlags, int mountExternal,</span><br><span class="line">                                  int targetSdkVersion,</span><br><span class="line">                                  String seInfo,</span><br><span class="line">                                  String abi,</span><br><span class="line">                                  String instructionSet,</span><br><span class="line">                                  String appDataDir,</span><br><span class="line">                                  String[] extraArgs)</span><br><span class="line">                                  throws ZygoteStartFailedEx &#123;</span><br><span class="line">        synchronized(Process.class) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续查看一下zygoteSendArgsAndGetResult方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">            throws ZygoteStartFailedEx &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * See com.android.internal.os.ZygoteInit.readArgumentList()</span><br><span class="line">             * Presently the wire format to the zygote process is:</span><br><span class="line">             * a) a count of arguments (argc, in essence)</span><br><span class="line">             * b) a number of newline-separated argument strings equal to count</span><br><span class="line">             *</span><br><span class="line">             * After the zygote process reads these it will write the pid of</span><br><span class="line">             * the child or -1 on failure, followed by boolean to</span><br><span class="line">             * indicate whether a wrapper process was used.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">            final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">            writer.write(Integer.toString(args.size()));</span><br><span class="line">            writer.newLine();</span><br><span class="line"></span><br><span class="line">            int sz &#x3D; args.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">                String arg &#x3D; args.get(i);</span><br><span class="line">                if (arg.indexOf(&#39;\n&#39;) &gt;&#x3D; 0) &#123;</span><br><span class="line">                    throw new ZygoteStartFailedEx(</span><br><span class="line">                            &quot;embedded newlines not allowed&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(arg);</span><br><span class="line">                writer.newLine();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Should there be a timeout on this?</span><br><span class="line">            ProcessStartResult result &#x3D; new ProcessStartResult();</span><br><span class="line">            result.pid &#x3D; inputStream.readInt();</span><br><span class="line">            if (result.pid &lt; 0) &#123;</span><br><span class="line">                throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            throw new ZygoteStartFailedEx(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。</p>
<p>为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。</p>
<p>好了，这时候我们看一下ActivityThread的main方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？<br>然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">	...</span><br><span class="line">	final IActivityManager mgr &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore</span><br><span class="line">            &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚刚我们已经分析过ActivityManagerNative是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其回调了attachApplicationLocked方法，我们看一下这个方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; See if the top visible activity is waiting to run in this process...</span><br><span class="line">        if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法执行了一系列的初始化操作，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了，O(∩_∩)O哈哈~</p>
<p><br/><strong><font size="6">五：执行启动Acitivity</font></strong></p>
<blockquote>
<font color="red">
ActivityStackSupervisor.attachApplicationLocked()
ActivityStackSupervisor.realStartActivityLocked()
IApplicationThread.scheduleLauncherActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handleLauncherActivity()
ActivityThread.performLauncherActivity()
Instrumentation.callActivityOnCreate()
Activity.onCreate()
ActivityThread.handleResumeActivity()
ActivityThread.performResumeActivity()
Activity.performResume()
Instrumentation.callActivityOnResume()
Activity.onResume()
ActivityManagerNative.getDefault().activityResumed(token)
</font>
</blockquote>
<p>首先看一下attachApplicationLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">        final String processName &#x3D; app.processName;</span><br><span class="line">        boolean didSomething &#x3D; false;</span><br><span class="line">        for (int displayNdx &#x3D; mActivityDisplays.size() - 1; displayNdx &gt;&#x3D; 0; --displayNdx) &#123;</span><br><span class="line">            ArrayList&lt;ActivityStack&gt; stacks &#x3D; mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">            for (int stackNdx &#x3D; stacks.size() - 1; stackNdx &gt;&#x3D; 0; --stackNdx) &#123;</span><br><span class="line">                final ActivityStack stack &#x3D; stacks.get(stackNdx);</span><br><span class="line">                if (!isFrontStack(stack)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ActivityRecord hr &#x3D; stack.topRunningActivityLocked(null);</span><br><span class="line">                if (hr !&#x3D; null) &#123;</span><br><span class="line">                    if (hr.app &#x3D;&#x3D; null &amp;&amp; app.uid &#x3D;&#x3D; hr.info.applicationInfo.uid</span><br><span class="line">                            &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if (realStartActivityLocked(hr, app, true, true)) &#123;</span><br><span class="line">                                didSomething &#x3D; true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Exception in new application when starting activity &quot;</span><br><span class="line">                                  + hr.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                            throw e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!didSomething) &#123;</span><br><span class="line">            ensureActivitiesVisibleLocked(null, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return didSomething;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r,</span><br><span class="line">            ProcessRecord app, boolean andResume, boolean checkConfig)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">            app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),</span><br><span class="line">                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">		...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现与第三步执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLauncherActivity方法，所以真正执行的是ActivityThread中的scheduleLauncherActivity，所以我们看一下ActivityThread中的scheduleLauncherActivity的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">            ActivityClientRecord r &#x3D; new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">            r.token &#x3D; token;</span><br><span class="line">            r.ident &#x3D; ident;</span><br><span class="line">            r.intent &#x3D; intent;</span><br><span class="line">            r.referrer &#x3D; referrer;</span><br><span class="line">            r.voiceInteractor &#x3D; voiceInteractor;</span><br><span class="line">            r.activityInfo &#x3D; info;</span><br><span class="line">            r.compatInfo &#x3D; compatInfo;</span><br><span class="line">            r.state &#x3D; state;</span><br><span class="line">            r.persistentState &#x3D; persistentState;</span><br><span class="line"></span><br><span class="line">            r.pendingResults &#x3D; pendingResults;</span><br><span class="line">            r.pendingIntents &#x3D; pendingNewIntents;</span><br><span class="line"></span><br><span class="line">            r.startsNotResumed &#x3D; notResumed;</span><br><span class="line">            r.isForward &#x3D; isForward;</span><br><span class="line"></span><br><span class="line">            r.profilerInfo &#x3D; profilerInfo;</span><br><span class="line"></span><br><span class="line">            r.overrideConfig &#x3D; overrideConfig;</span><br><span class="line">            updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">            sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，还是那套逻辑，ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">        Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">        if (a !&#x3D; null) &#123;</span><br><span class="line">            r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState &#x3D; r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">Activity activity &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();</span><br><span class="line">            activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state !&#x3D; null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        activity.mCalled &#x3D; false;</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">           mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">		if (!r.activity.mFinished) &#123;</span><br><span class="line">                    activity.performStart();</span><br><span class="line">                    r.stopped &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">        ...</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里我们需要的Activity对象终于是创建出来了，而且他是以反射的机制创建的，现在还不太清楚为啥google要以反射的方式创建Activity，先不看这些，然后在代码中其调用Instrumentation的callActivityOnCreate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle,</span><br><span class="line">            PersistableBundle persistentState) &#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行activity的performCreate方法。。。。好吧，都转晕了。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line">        performCreateCommon();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，第二个生命周期方法出来了，onCreate方法。。。。</p>
<p>在回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart();方法，好吧，看一下他的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final void performStart() &#123;</span><br><span class="line">        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">        mFragments.noteStateNotSaved();</span><br><span class="line">        mCalled &#x3D; false;</span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line">        mInstrumentation.callActivityOnStart(this);</span><br><span class="line">        if (!mCalled) &#123;</span><br><span class="line">            throw new SuperNotCalledException(</span><br><span class="line">                &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                &quot; did not call through to super.onStart()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mFragments.dispatchStart();</span><br><span class="line">        mFragments.reportLoaderStart();</span><br><span class="line">        mActivityTransitionState.enterReady(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，还是通过Instrumentation调用callActivityOnStart方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnStart(Activity activity) &#123;</span><br><span class="line">        activity.onStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O哈哈~</p>
<p>还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide, boolean isForward, boolean reallyResume) &#123;</span><br><span class="line">        &#x2F;&#x2F; If we are getting ready to gc after going to the background, well</span><br><span class="line">        &#x2F;&#x2F; we are back active so skip it.</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; TODO Push resumeArgs into the activity for consideration</span><br><span class="line">        ActivityClientRecord r &#x3D; performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            final Activity a &#x3D; r.activity;</span><br><span class="line"></span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</span><br><span class="line">                a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</span><br><span class="line">                + &quot;, finished: &quot; + a.mFinished);</span><br><span class="line"></span><br><span class="line">            final int forwardBit &#x3D; isForward ?</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the window hasn&#39;t yet been added to the window manager,</span><br><span class="line">            &#x2F;&#x2F; and this guy didn&#39;t finish itself or start another activity,</span><br><span class="line">            &#x2F;&#x2F; then go ahead and add the window.</span><br><span class="line">            boolean willBeVisible &#x3D; !a.mStartedActivity;</span><br><span class="line">            if (!willBeVisible) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    willBeVisible &#x3D; ActivityManagerNative.getDefault().willActivityBeVisible(</span><br><span class="line">                            a.getActivityToken());</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window &#x3D; r.activity.getWindow();</span><br><span class="line">                View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                a.mDecor &#x3D; decor;</span><br><span class="line">                l.type &#x3D; WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |&#x3D; forwardBit;</span><br><span class="line">                if (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded &#x3D; true;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the window has already been added, but during resume</span><br><span class="line">            &#x2F;&#x2F; we started another activity, then don&#39;t yet make the</span><br><span class="line">            &#x2F;&#x2F; window visible.</span><br><span class="line">            &#125; else if (!willBeVisible) &#123;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">                r.hideForNow &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Get rid of anything left hanging around.</span><br><span class="line">            cleanUpPendingRemoveWindows(r);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; The window is now visible if it has been added, we are not</span><br><span class="line">            &#x2F;&#x2F; simply finishing, and we are not starting another activity.</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor !&#x3D; null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                if (r.newConfig !&#x3D; null) &#123;</span><br><span class="line">                    r.tmpConfig.setTo(r.newConfig);</span><br><span class="line">                    if (r.overrideConfig !&#x3D; null) &#123;</span><br><span class="line">                        r.tmpConfig.updateFrom(r.overrideConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                            + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);</span><br><span class="line">                    performConfigurationChanged(r.activity, r.tmpConfig);</span><br><span class="line">                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</span><br><span class="line">                    r.newConfig &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward&#x3D;&quot;</span><br><span class="line">                        + isForward);</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                if ((l.softInputMode</span><br><span class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                        !&#x3D; forwardBit) &#123;</span><br><span class="line">                    l.softInputMode &#x3D; (l.softInputMode</span><br><span class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                            | forwardBit;</span><br><span class="line">                    if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                        ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                        View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                        wm.updateViewLayout(decor, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mVisibleFromServer &#x3D; true;</span><br><span class="line">                mNumVisibleActivities++;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!r.onlyLocalRequest) &#123;</span><br><span class="line">                r.nextIdle &#x3D; mNewActivities;</span><br><span class="line">                mNewActivities &#x3D; r;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">                Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">            &#125;</span><br><span class="line">            r.onlyLocalRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have resumed.</span><br><span class="line">            if (reallyResume) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If an exception was thrown when trying to resume, then</span><br><span class="line">            &#x2F;&#x2F; just end this activity.</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(token, Activity.RESULT_CANCELED, null, false);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r</span><br><span class="line">                + &quot; finished&#x3D;&quot; + r.activity.mFinished);</span><br><span class="line">        if (r !&#x3D; null &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">            if (clearHide) &#123;</span><br><span class="line">                r.hideForNow &#x3D; false;</span><br><span class="line">                r.activity.mStartedActivity &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                r.activity.onStateNotSaved();</span><br><span class="line">                r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">                if (r.pendingIntents !&#x3D; null) &#123;</span><br><span class="line">                    deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">                    r.pendingIntents &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r.pendingResults !&#x3D; null) &#123;</span><br><span class="line">                    deliverResults(r, r.pendingResults);</span><br><span class="line">                    r.pendingResults &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.performResume();</span><br><span class="line"></span><br><span class="line">                EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED,</span><br><span class="line">                        UserHandle.myUserId(), r.activity.getComponentName().getClassName());</span><br><span class="line"></span><br><span class="line">                r.paused &#x3D; false;</span><br><span class="line">                r.stopped &#x3D; false;</span><br><span class="line">                r.state &#x3D; null;</span><br><span class="line">                r.persistentState &#x3D; null;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to resume activity &quot;</span><br><span class="line">                        + r.intent.getComponent().toShortString()</span><br><span class="line">                        + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中，最终调用了r.activity.performResume();方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performResume() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mInstrumentation.callActivityOnResume(this);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnResume(Activity activity) &#123;</span><br><span class="line">        activity.mResumed &#x3D; true;</span><br><span class="line">        activity.onResume();</span><br><span class="line">        </span><br><span class="line">        if (mActivityMonitors !&#x3D; null) &#123;</span><br><span class="line">            synchronized (mSync) &#123;</span><br><span class="line">                final int N &#x3D; mActivityMonitors.size();</span><br><span class="line">                for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                    final ActivityMonitor am &#x3D; mActivityMonitors.get(i);</span><br><span class="line">                    am.match(activity, activity, activity.getIntent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，第四个生命周期方法出现了，onResume方法。。。</p>
<p>终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有，哈哈，别着急。</p>
<p>有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？<br>你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，咦？对了onStop方法还没回调呢，O(∩_∩)O哈哈~，对了缺少的就是对onStop方法的回调啊。</p>
<p>好吧，具体的逻辑我们下一步再说</p>
<p><br><strong><font size="6">六：栈顶Activity执行onStop方法</p>
<blockquote>
<font color="red">
Looper.myQueue().addIdleHandler(new Idler())
Idler.queueIdle()
ActivityManagerNative.getDefault().activityIdle()
ActivityManagerService.activityIdle()
ActivityStackSupervisor.activityIdleInternalLocked()
ActivityStack.stopActivityLocked()
IApplicationThread.scheduleStopActivity()
ActivityThread.scheduleStopActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handleStopActivity()
ActivityThread.performStopActivityInner()
ActivityThread.callCallActivityOnSaveInstanceState()
Instrumentation.callActivityOnSaveInstanceState()
Activity.performSaveInstanceState()
Activity.onSaveInstanceState()
Activity.performStop()
Instrumentation.callActivityOnStop()
Activity.onStop()
</font>
</blockquote>
<p>回到我们的handleResumeActivity方法，在方法体最后有这样的一代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(new Idler());</span><br></pre></td></tr></table></figure>

<p>这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean queueIdle() &#123;</span><br><span class="line">            ActivityClientRecord a &#x3D; mNewActivities;</span><br><span class="line">            boolean stopProfiling &#x3D; false;</span><br><span class="line">            if (mBoundApplication !&#x3D; null &amp;&amp; mProfiler.profileFd !&#x3D; null</span><br><span class="line">                    &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">                stopProfiling &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a !&#x3D; null) &#123;</span><br><span class="line">                mNewActivities &#x3D; null;</span><br><span class="line">                IActivityManager am &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">                ActivityClientRecord prev;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (localLOGV) Slog.v(</span><br><span class="line">                        TAG, &quot;Reporting idle of &quot; + a +</span><br><span class="line">                        &quot; finished&#x3D;&quot; +</span><br><span class="line">                        (a.activity !&#x3D; null &amp;&amp; a.activity.mFinished));</span><br><span class="line">                    if (a.activity !&#x3D; null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                            a.createdConfig &#x3D; null;</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Ignore</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev &#x3D; a;</span><br><span class="line">                    a &#x3D; a.nextIdle;</span><br><span class="line">                    prev.nextIdle &#x3D; null;</span><br><span class="line">                &#125; while (a !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (stopProfiling) &#123;</span><br><span class="line">                mProfiler.stopProfiling();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                ActivityRecord r &#x3D;</span><br><span class="line">                        mStackSupervisor.activityIdleInternalLocked(token, false, config);</span><br><span class="line">                if (stopProfiling) &#123;</span><br><span class="line">                    if ((mProfileProc &#x3D;&#x3D; r.app) &amp;&amp; (mProfileFd !&#x3D; null)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            mProfileFd.close();</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        clearProfilerLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,</span><br><span class="line">            Configuration config) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Stop any activities that are scheduled to do so but have been</span><br><span class="line">        &#x2F;&#x2F; waiting for the next one to start.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; NS; i++) &#123;</span><br><span class="line">            r &#x3D; stops.get(i);</span><br><span class="line">            final ActivityStack stack &#x3D; r.task.stack;</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                if (r.finishing) &#123;</span><br><span class="line">                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stack.stopActivityLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在其中又调用了ActivityStack.stopActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final void stopActivityLocked(ActivityRecord r) &#123;</span><br><span class="line">        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, &quot;Stopping: &quot; + r);</span><br><span class="line">        if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) !&#x3D; 0</span><br><span class="line">                || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) !&#x3D; 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">                r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags);</span><br><span class="line">             ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleStopActivity(IBinder token, boolean showWindow,</span><br><span class="line">                int configChanges) &#123;</span><br><span class="line">           sendMessage(</span><br><span class="line">                showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE,</span><br><span class="line">                token, 0, configChanges);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopActivity(IBinder token, boolean show, int configChanges) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performStopActivityInner(r, info, show, true);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看一下performStopActivityInner的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void performStopActivityInner(ActivityClientRecord r,</span><br><span class="line">            StopInfo info, boolean keepShown, boolean saveState) &#123;</span><br><span class="line">	        ...</span><br><span class="line">            &#x2F;&#x2F; Next have the activity save its current state and managed dialogs...</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">                if (r.state &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    callCallActivityOnSaveInstanceState(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!keepShown) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; Now we are idle.</span><br><span class="line">                    r.activity.performStop();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                        throw new RuntimeException(</span><br><span class="line">                                &quot;Unable to stop activity &quot;</span><br><span class="line">                                + r.intent.getComponent().toShortString()</span><br><span class="line">                                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.stopped &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，看样子在这个方法中执行了两个逻辑，一个是执行Activity的onSaveInstance方法一个是执行Activity的onStop方法，我们先看一下callCallActivityOnSaveInstanceState的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123;</span><br><span class="line">        r.state &#x3D; new Bundle();</span><br><span class="line">        r.state.setAllowFds(false);</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">            r.persistentState &#x3D; new PersistableBundle();</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，又是通过Instrumentation来执行。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnSaveInstanceState(Activity activity, Bundle outState,</span><br><span class="line">            PersistableBundle outPersistentState) &#123;</span><br><span class="line">        activity.performSaveInstanceState(outState, outPersistentState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>又间接调用了Activity的performSaveInstanceState方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void performSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">        onSaveInstanceState(outState);</span><br><span class="line">        saveManagedDialogs(outState);</span><br><span class="line">        mActivityTransitionState.saveState(outState);</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>呵呵，这里调用到了，我们以前经常会重写的onSaveInstanceState方法。</p>
<p>然后我们看一下performStopActivityInner中调用到的Activity方法的performStop方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">final void performStop() &#123;</span><br><span class="line">        mDoReportFullyDrawn &#x3D; false;</span><br><span class="line">        mFragments.doLoaderStop(mChangingConfigurations &#x2F;*retain*&#x2F;);</span><br><span class="line"></span><br><span class="line">        if (!mStopped) &#123;</span><br><span class="line">            if (mWindow !&#x3D; null) &#123;</span><br><span class="line">                mWindow.closeAllPanels();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mToken !&#x3D; null &amp;&amp; mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">                WindowManagerGlobal.getInstance().setStoppedState(mToken, true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mFragments.dispatchStop();</span><br><span class="line"></span><br><span class="line">            mCalled &#x3D; false;</span><br><span class="line">            mInstrumentation.callActivityOnStop(this);</span><br><span class="line">            if (!mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onStop()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            synchronized (mManagedCursors) &#123;</span><br><span class="line">                final int N &#x3D; mManagedCursors.size();</span><br><span class="line">                for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                    ManagedCursor mc &#x3D; mManagedCursors.get(i);</span><br><span class="line">                    if (!mc.mReleased) &#123;</span><br><span class="line">                        mc.mCursor.deactivate();</span><br><span class="line">                        mc.mReleased &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mStopped &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        mResumed &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnStop(Activity activity) &#123;</span><br><span class="line">        activity.onStop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，最后一个生命周期方法终于出来了，onStop()…..</p>
<p><br><br><br><font size="5">总结：</font></p>
<ul>
<li><p>Activity的启动流程一般是通过调用startActivity或者是startActivityForResult来开始的</p>
</li>
<li><p>startActivity内部也是通过调用startActivityForResult来启动Activity，只不过传递的requestCode小于0</p>
</li>
<li><p>Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯</p>
</li>
<li><p>ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。</p>
</li>
<li><p>ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。</p>
</li>
<li><p>ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法；</p>
</li>
<li><p>ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发；</p>
</li>
<li><p>ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作；</p>
</li>
<li><p>ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程；</p>
</li>
<li><p>ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法；</p>
</li>
<li><p>在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作；</p>
</li>
<li><p>ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作；</p>
</li>
<li><p>ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法；</p>
</li>
<li><p>ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法；</p>
</li>
<li><p>ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread；</p>
</li>
<li><p>ActivityThread执行真正的onStop方法；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/13%20apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/13%20apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">13 apk安装流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇文章中给大家分析了一下android系统启动之后调用PackageManagerService服务并解析系统特定目录，解析apk文件并安装的过程，这个安装过期实际上是没有图形界面的，底层调用的是我们平时比较熟悉的adb命令，那么我们平时安装apk文件的时候大部分是都过图形界面安装的，那么这种方式安装apk具体的流程是怎样的呢？</p>
<p>下面我们就来具体看一下apk的具体安装过程，相信大家都知道如果我们想在代码里执行apk的安装，那么一般都是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent &#x3D; new Intent(Intent.ACTION_VIEW);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">intent.setDataAndType(Uri.parse(&quot;file:&#x2F;&#x2F;&quot; + path),&quot;application&#x2F;vnd.android.package-archive&quot;);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>这样，我们就会打开安装apk文件的程序并执行安装逻辑了，那么这段代码具体是打开那个activity呢？好吧，从这个问题开始，我们来解析apk的安装流程…</p>
<p>这里跟大姐简单介绍一下android的源码，平时我们使用的android.jar里面的java源码只是android系统源码的一部分，还有好多源码并没有打入到android.jar中，这里为大家推荐一个android源码的地址：<a href="https://github.com/android" target="_blank" rel="noopener">https://github.com/android</a><br>里面根据android系统的不同模块包含了许多android模块的源码。<br><img src="http://img.blog.csdn.net/20160421165129710" alt="这里写图片描述"></p>
<p>这里我们找到platform_packages_apps_packageinstaller库，这里面就是android系统安装程序的源码了。<br><img src="http://img.blog.csdn.net/20160421165234648" alt="这里写图片描述"></p>
<p>这里我们找到其androidManifest.xml，然后我们来看一下其具体的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">          package&#x3D;&quot;com.android.packageinstaller&quot; coreApp&#x3D;&quot;true&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;original-package android:name&#x3D;&quot;com.android.packageinstaller&quot; &#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    &lt;application android:label&#x3D;&quot;@string&#x2F;app_name&quot;</span><br><span class="line">            android:allowBackup&#x3D;&quot;false&quot;</span><br><span class="line">            android:theme&#x3D;&quot;@style&#x2F;Theme.DialogWhenLarge&quot;</span><br><span class="line">            android:supportsRtl&#x3D;&quot;true&quot;&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.PackageInstallerActivity&quot;</span><br><span class="line">                android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">                android:excludeFromRecents&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.VIEW&quot; &#x2F;&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.INSTALL_PACKAGE&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:scheme&#x3D;&quot;file&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:mimeType&#x3D;&quot;application&#x2F;vnd.android.package-archive&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.INSTALL_PACKAGE&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:scheme&#x3D;&quot;file&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:scheme&#x3D;&quot;package&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;activity&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.InstallAppProgress&quot;</span><br><span class="line">                android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">                android:exported&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.UninstallerActivity&quot;</span><br><span class="line">                android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">                android:excludeFromRecents&#x3D;&quot;true&quot;</span><br><span class="line">                android:theme&#x3D;&quot;@style&#x2F;Theme.AlertDialogActivity&quot;&gt;</span><br><span class="line">            &lt;intent-filter android:priority&#x3D;&quot;1&quot;&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.DELETE&quot; &#x2F;&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.UNINSTALL_PACKAGE&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:scheme&#x3D;&quot;package&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;activity&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.UninstallAppProgress&quot;</span><br><span class="line">                android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">                android:exported&#x3D;&quot;false&quot; &#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.permission.ui.GrantPermissionsActivity&quot;</span><br><span class="line">                android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">                android:excludeFromRecents&#x3D;&quot;true&quot;</span><br><span class="line">                android:theme&#x3D;&quot;@style&#x2F;GrantPermissions&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;activity&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.permission.ui.ManagePermissionsActivity&quot;</span><br><span class="line">                  android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">                  android:excludeFromRecents&#x3D;&quot;true&quot;</span><br><span class="line">                  android:label&#x3D;&quot;@string&#x2F;app_permissions&quot;</span><br><span class="line">                  android:theme&#x3D;&quot;@style&#x2F;Settings&quot;</span><br><span class="line">                  android:permission&#x3D;&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.MANAGE_PERMISSIONS&quot; &#x2F;&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.MANAGE_APP_PERMISSIONS&quot; &#x2F;&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.MANAGE_PERMISSION_APPS&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;activity&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.permission.ui.OverlayWarningDialog&quot;</span><br><span class="line">                android:excludeFromRecents&#x3D;&quot;true&quot;</span><br><span class="line">                android:theme&#x3D;&quot;@android:style&#x2F;Theme.DeviceDefault.Light.Dialog.NoActionBar&quot; &#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;provider android:name&#x3D;&quot;.wear.WearPackageIconProvider&quot;</span><br><span class="line">                  android:authorities&#x3D;&quot;com.google.android.packageinstaller.wear.provider&quot;</span><br><span class="line">                  android:grantUriPermissions&#x3D;&quot;true&quot;</span><br><span class="line">                  android:exported&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;activity android:name&#x3D;&quot;.permission.ui.wear.WarningConfirmationActivity&quot;</span><br><span class="line">                  android:permission&#x3D;&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot;</span><br><span class="line">                  android:theme&#x3D;&quot;@style&#x2F;Settings&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;application&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>
<p>好吧，这里我们大概看一下Activity的定义，这里我们重点看一下PackageInstallerActivity的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name&#x3D;&quot;.PackageInstallerActivity&quot;</span><br><span class="line">                android:configChanges&#x3D;&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">                android:excludeFromRecents&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.VIEW&quot; &#x2F;&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.INSTALL_PACKAGE&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:scheme&#x3D;&quot;file&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:mimeType&#x3D;&quot;application&#x2F;vnd.android.package-archive&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.INSTALL_PACKAGE&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:scheme&#x3D;&quot;file&quot; &#x2F;&gt;</span><br><span class="line">                &lt;data android:scheme&#x3D;&quot;package&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; &#x2F;&gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;activity&gt;</span><br></pre></td></tr></table></figure>
<p>恩？这里不就是我们刚刚定义的启动安装Apk activity的intent filter？好吧，所以说一开始我们调用的startActivity其实启动的就是PackageInstallerActivity，那么下面我们就看一下PackageInstellerActivity的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle icicle) &#123;</span><br><span class="line">        super.onCreate(icicle);</span><br><span class="line"></span><br><span class="line">        mPm &#x3D; getPackageManager();</span><br><span class="line">        mInstaller &#x3D; mPm.getPackageInstaller();</span><br><span class="line">        mUserManager &#x3D; (UserManager) getSystemService(Context.USER_SERVICE);</span><br><span class="line"></span><br><span class="line">        final Intent intent &#x3D; getIntent();</span><br><span class="line">        if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) &#123;</span><br><span class="line">            final int sessionId &#x3D; intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1);</span><br><span class="line">            final PackageInstaller.SessionInfo info &#x3D; mInstaller.getSessionInfo(sessionId);</span><br><span class="line">            if (info &#x3D;&#x3D; null || !info.sealed || info.resolvedBaseCodePath &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;);</span><br><span class="line">                finish();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSessionId &#x3D; sessionId;</span><br><span class="line">            mPackageURI &#x3D; Uri.fromFile(new File(info.resolvedBaseCodePath));</span><br><span class="line">            mOriginatingURI &#x3D; null;</span><br><span class="line">            mReferrerURI &#x3D; null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mSessionId &#x3D; -1;</span><br><span class="line">            mPackageURI &#x3D; intent.getData();</span><br><span class="line">            mOriginatingURI &#x3D; intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI);</span><br><span class="line">            mReferrerURI &#x3D; intent.getParcelableExtra(Intent.EXTRA_REFERRER);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean unknownSourcesAllowedByAdmin &#x3D; isUnknownSourcesAllowedByAdmin();</span><br><span class="line">        final boolean unknownSourcesAllowedByUser &#x3D; isUnknownSourcesEnabled();</span><br><span class="line"></span><br><span class="line">        boolean requestFromUnknownSource &#x3D; isInstallRequestFromUnknownSource(intent);</span><br><span class="line">        mInstallFlowAnalytics &#x3D; new InstallFlowAnalytics();</span><br><span class="line">        mInstallFlowAnalytics.setContext(this);</span><br><span class="line">        mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime());</span><br><span class="line">        mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin</span><br><span class="line">                &amp;&amp; unknownSourcesAllowedByUser);</span><br><span class="line">        mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource);</span><br><span class="line">        mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled());</span><br><span class="line">        mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled());</span><br><span class="line">        mInstallFlowAnalytics.setPackageUri(mPackageURI.toString());</span><br><span class="line"></span><br><span class="line">        if (DeviceUtils.isWear(this)) &#123;</span><br><span class="line">            showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String scheme &#x3D; mPackageURI.getScheme();</span><br><span class="line">        if (scheme !&#x3D; null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Unsupported scheme &quot; + scheme);</span><br><span class="line">            setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME);</span><br><span class="line">            finish();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PackageUtil.AppSnippet as;</span><br><span class="line">        if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</span><br><span class="line">            mInstallFlowAnalytics.setFileUri(false);</span><br><span class="line">            try &#123;</span><br><span class="line">                mPkgInfo &#x3D; mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(),</span><br><span class="line">                        PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES);</span><br><span class="line">            &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPkgInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme()</span><br><span class="line">                        + &quot; not available. Discontinuing installation&quot;);</span><br><span class="line">                showDialogInner(DLG_PACKAGE_ERROR);</span><br><span class="line">                setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK);</span><br><span class="line">                mInstallFlowAnalytics.setPackageInfoObtained();</span><br><span class="line">                mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                        InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            as &#x3D; new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo),</span><br><span class="line">                    mPm.getApplicationIcon(mPkgInfo.applicationInfo));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstallFlowAnalytics.setFileUri(true);</span><br><span class="line">            final File sourceFile &#x3D; new File(mPackageURI.getPath());</span><br><span class="line">            PackageParser.Package parsed &#x3D; PackageUtil.getPackageInfo(sourceFile);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for parse errors</span><br><span class="line">            if (parsed &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;);</span><br><span class="line">                showDialogInner(DLG_PACKAGE_ERROR);</span><br><span class="line">                setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK);</span><br><span class="line">                mInstallFlowAnalytics.setPackageInfoObtained();</span><br><span class="line">                mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                        InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mPkgInfo &#x3D; PackageParser.generatePackageInfo(parsed, null,</span><br><span class="line">                    PackageManager.GET_PERMISSIONS, 0, 0, null,</span><br><span class="line">                    new PackageUserState());</span><br><span class="line">            mPkgDigest &#x3D; parsed.manifestDigest;</span><br><span class="line">            as &#x3D; PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">        mInstallFlowAnalytics.setPackageInfoObtained();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;set view</span><br><span class="line">        setContentView(R.layout.install_start);</span><br><span class="line">        mInstallConfirm &#x3D; findViewById(R.id.install_confirm_panel);</span><br><span class="line">        mInstallConfirm.setVisibility(View.INVISIBLE);</span><br><span class="line">        PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet);</span><br><span class="line"></span><br><span class="line">        mOriginatingUid &#x3D; getOriginatingUid(intent);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Block the install attempt on the Unknown Sources setting if necessary.</span><br><span class="line">        if (!requestFromUnknownSource) &#123;</span><br><span class="line">            initiateInstall();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the admin prohibits it, or we&#39;re running in a managed profile, just show error</span><br><span class="line">        &#x2F;&#x2F; and exit. Otherwise show an option to take the user to Settings to change the setting.</span><br><span class="line">        final boolean isManagedProfile &#x3D; mUserManager.isManagedProfile();</span><br><span class="line">        if (!unknownSourcesAllowedByAdmin</span><br><span class="line">                || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) &#123;</span><br><span class="line">            showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING);</span><br><span class="line">        &#125; else if (!unknownSourcesAllowedByUser) &#123;</span><br><span class="line">            &#x2F;&#x2F; Ask user to enable setting first</span><br><span class="line">            showDialogInner(DLG_UNKNOWN_SOURCES);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            initiateInstall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们主要先看一下PackageInstallerActivity的onCreate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle icicle) &#123;</span><br><span class="line">        super.onCreate(icicle);</span><br><span class="line"></span><br><span class="line">        mPm &#x3D; getPackageManager();</span><br><span class="line">        mInstaller &#x3D; mPm.getPackageInstaller();</span><br><span class="line">        mUserManager &#x3D; (UserManager) getSystemService(Context.USER_SERVICE);</span><br><span class="line"></span><br><span class="line">        final Intent intent &#x3D; getIntent();</span><br><span class="line">        if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) &#123;</span><br><span class="line">            final int sessionId &#x3D; intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1);</span><br><span class="line">            final PackageInstaller.SessionInfo info &#x3D; mInstaller.getSessionInfo(sessionId);</span><br><span class="line">            if (info &#x3D;&#x3D; null || !info.sealed || info.resolvedBaseCodePath &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;);</span><br><span class="line">                finish();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSessionId &#x3D; sessionId;</span><br><span class="line">            mPackageURI &#x3D; Uri.fromFile(new File(info.resolvedBaseCodePath));</span><br><span class="line">            mOriginatingURI &#x3D; null;</span><br><span class="line">            mReferrerURI &#x3D; null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mSessionId &#x3D; -1;</span><br><span class="line">            mPackageURI &#x3D; intent.getData();</span><br><span class="line">            mOriginatingURI &#x3D; intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI);</span><br><span class="line">            mReferrerURI &#x3D; intent.getParcelableExtra(Intent.EXTRA_REFERRER);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean unknownSourcesAllowedByAdmin &#x3D; isUnknownSourcesAllowedByAdmin();</span><br><span class="line">        final boolean unknownSourcesAllowedByUser &#x3D; isUnknownSourcesEnabled();</span><br><span class="line"></span><br><span class="line">        boolean requestFromUnknownSource &#x3D; isInstallRequestFromUnknownSource(intent);</span><br><span class="line">        mInstallFlowAnalytics &#x3D; new InstallFlowAnalytics();</span><br><span class="line">        mInstallFlowAnalytics.setContext(this);</span><br><span class="line">        mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime());</span><br><span class="line">        mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin</span><br><span class="line">                &amp;&amp; unknownSourcesAllowedByUser);</span><br><span class="line">        mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource);</span><br><span class="line">        mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled());</span><br><span class="line">        mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled());</span><br><span class="line">        mInstallFlowAnalytics.setPackageUri(mPackageURI.toString());</span><br><span class="line"></span><br><span class="line">        if (DeviceUtils.isWear(this)) &#123;</span><br><span class="line">            showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String scheme &#x3D; mPackageURI.getScheme();</span><br><span class="line">        if (scheme !&#x3D; null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) &#123;</span><br><span class="line">            Log.w(TAG, &quot;Unsupported scheme &quot; + scheme);</span><br><span class="line">            setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME);</span><br><span class="line">            finish();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PackageUtil.AppSnippet as;</span><br><span class="line">        if (&quot;package&quot;.equals(mPackageURI.getScheme())) &#123;</span><br><span class="line">            mInstallFlowAnalytics.setFileUri(false);</span><br><span class="line">            try &#123;</span><br><span class="line">                mPkgInfo &#x3D; mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(),</span><br><span class="line">                        PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES);</span><br><span class="line">            &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPkgInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme()</span><br><span class="line">                        + &quot; not available. Discontinuing installation&quot;);</span><br><span class="line">                showDialogInner(DLG_PACKAGE_ERROR);</span><br><span class="line">                setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK);</span><br><span class="line">                mInstallFlowAnalytics.setPackageInfoObtained();</span><br><span class="line">                mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                        InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            as &#x3D; new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo),</span><br><span class="line">                    mPm.getApplicationIcon(mPkgInfo.applicationInfo));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstallFlowAnalytics.setFileUri(true);</span><br><span class="line">            final File sourceFile &#x3D; new File(mPackageURI.getPath());</span><br><span class="line">            PackageParser.Package parsed &#x3D; PackageUtil.getPackageInfo(sourceFile);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for parse errors</span><br><span class="line">            if (parsed &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;);</span><br><span class="line">                showDialogInner(DLG_PACKAGE_ERROR);</span><br><span class="line">                setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK);</span><br><span class="line">                mInstallFlowAnalytics.setPackageInfoObtained();</span><br><span class="line">                mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                        InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            mPkgInfo &#x3D; PackageParser.generatePackageInfo(parsed, null,</span><br><span class="line">                    PackageManager.GET_PERMISSIONS, 0, 0, null,</span><br><span class="line">                    new PackageUserState());</span><br><span class="line">            mPkgDigest &#x3D; parsed.manifestDigest;</span><br><span class="line">            as &#x3D; PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">        mInstallFlowAnalytics.setPackageInfoObtained();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;set view</span><br><span class="line">        setContentView(R.layout.install_start);</span><br><span class="line">        mInstallConfirm &#x3D; findViewById(R.id.install_confirm_panel);</span><br><span class="line">        mInstallConfirm.setVisibility(View.INVISIBLE);</span><br><span class="line">        PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet);</span><br><span class="line"></span><br><span class="line">        mOriginatingUid &#x3D; getOriginatingUid(intent);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Block the install attempt on the Unknown Sources setting if necessary.</span><br><span class="line">        if (!requestFromUnknownSource) &#123;</span><br><span class="line">            initiateInstall();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the admin prohibits it, or we&#39;re running in a managed profile, just show error</span><br><span class="line">        &#x2F;&#x2F; and exit. Otherwise show an option to take the user to Settings to change the setting.</span><br><span class="line">        final boolean isManagedProfile &#x3D; mUserManager.isManagedProfile();</span><br><span class="line">        if (!unknownSourcesAllowedByAdmin</span><br><span class="line">                || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) &#123;</span><br><span class="line">            showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING);</span><br><span class="line">        &#125; else if (!unknownSourcesAllowedByUser) &#123;</span><br><span class="line">            &#x2F;&#x2F; Ask user to enable setting first</span><br><span class="line">            showDialogInner(DLG_UNKNOWN_SOURCES);</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            initiateInstall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，在onCreate方法中，首先执行一些初始化操作，获取PackageManager和Installer、UserManager等对象，然后会根据当前Intent的信息最一些逻辑判断并弹出消息弹窗，我们可以看一下具体的消息弹窗类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static final int DLG_BASE &#x3D; 0;</span><br><span class="line">    private static final int DLG_UNKNOWN_SOURCES &#x3D; DLG_BASE + 1;</span><br><span class="line">    private static final int DLG_PACKAGE_ERROR &#x3D; DLG_BASE + 2;</span><br><span class="line">    private static final int DLG_OUT_OF_SPACE &#x3D; DLG_BASE + 3;</span><br><span class="line">    private static final int DLG_INSTALL_ERROR &#x3D; DLG_BASE + 4;</span><br><span class="line">    private static final int DLG_ALLOW_SOURCE &#x3D; DLG_BASE + 5;</span><br><span class="line">    private static final int DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES &#x3D; DLG_BASE + 6;</span><br><span class="line">    private static final int DLG_NOT_SUPPORTED_ON_WEAR &#x3D; DLG_BASE + 7;</span><br></pre></td></tr></table></figure>
<p>可以发现当分析Intent对象的时候，如果可以得到这样几种结果：不知道apk的来源，package信息错误，存储空间不够，安装时报，来源正确，允许未知来源的apk文件，在wear上不支持等，这样根据不同的消息类型会弹出不同的消息弹窗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Dialog onCreateDialog(int id, Bundle bundle) &#123;</span><br><span class="line">        switch (id) &#123;</span><br><span class="line">        case DLG_UNKNOWN_SOURCES:</span><br><span class="line">            return new AlertDialog.Builder(this)</span><br><span class="line">                    .setTitle(R.string.unknown_apps_dlg_title)</span><br><span class="line">                    .setMessage(R.string.unknown_apps_dlg_text)</span><br><span class="line">                    .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            Log.i(TAG, &quot;Finishing off activity so that user can navigate to settings manually&quot;);</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;&#125;)</span><br><span class="line">                    .setPositiveButton(R.string.settings, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            Log.i(TAG, &quot;Launching settings&quot;);</span><br><span class="line">                            launchSecuritySettings();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setOnCancelListener(this)</span><br><span class="line">                    .create();</span><br><span class="line">        case DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES:</span><br><span class="line">            return new AlertDialog.Builder(this)</span><br><span class="line">                    .setTitle(R.string.unknown_apps_dlg_title)</span><br><span class="line">                    .setMessage(R.string.unknown_apps_admin_dlg_text)</span><br><span class="line">                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setOnCancelListener(this)</span><br><span class="line">                    .create();</span><br><span class="line">        case DLG_PACKAGE_ERROR :</span><br><span class="line">            return new AlertDialog.Builder(this)</span><br><span class="line">                    .setTitle(R.string.Parse_error_dlg_title)</span><br><span class="line">                    .setMessage(R.string.Parse_error_dlg_text)</span><br><span class="line">                    .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setOnCancelListener(this)</span><br><span class="line">                    .create();</span><br><span class="line">        case DLG_OUT_OF_SPACE:</span><br><span class="line">            &#x2F;&#x2F; Guaranteed not to be null. will default to package name if not set by app</span><br><span class="line">            CharSequence appTitle &#x3D; mPm.getApplicationLabel(mPkgInfo.applicationInfo);</span><br><span class="line">            String dlgText &#x3D; getString(R.string.out_of_space_dlg_text,</span><br><span class="line">                    appTitle.toString());</span><br><span class="line">            return new AlertDialog.Builder(this)</span><br><span class="line">                    .setTitle(R.string.out_of_space_dlg_title)</span><br><span class="line">                    .setMessage(dlgText)</span><br><span class="line">                    .setPositiveButton(R.string.manage_applications, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            &#x2F;&#x2F;launch manage applications</span><br><span class="line">                            Intent intent &#x3D; new Intent(&quot;android.intent.action.MANAGE_PACKAGE_STORAGE&quot;);</span><br><span class="line">                            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                            startActivity(intent);</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            Log.i(TAG, &quot;Canceling installation&quot;);</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                  .setOnCancelListener(this)</span><br><span class="line">                  .create();</span><br><span class="line">        case DLG_INSTALL_ERROR :</span><br><span class="line">            &#x2F;&#x2F; Guaranteed not to be null. will default to package name if not set by app</span><br><span class="line">            CharSequence appTitle1 &#x3D; mPm.getApplicationLabel(mPkgInfo.applicationInfo);</span><br><span class="line">            String dlgText1 &#x3D; getString(R.string.install_failed_msg,</span><br><span class="line">                    appTitle1.toString());</span><br><span class="line">            return new AlertDialog.Builder(this)</span><br><span class="line">                    .setTitle(R.string.install_failed)</span><br><span class="line">                    .setNeutralButton(R.string.ok, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setMessage(dlgText1)</span><br><span class="line">                    .setOnCancelListener(this)</span><br><span class="line">                    .create();</span><br><span class="line">        case DLG_ALLOW_SOURCE:</span><br><span class="line">            CharSequence appTitle2 &#x3D; mPm.getApplicationLabel(mSourceInfo);</span><br><span class="line">            String dlgText2 &#x3D; getString(R.string.allow_source_dlg_text,</span><br><span class="line">                    appTitle2.toString());</span><br><span class="line">            return new AlertDialog.Builder(this)</span><br><span class="line">                    .setTitle(R.string.allow_source_dlg_title)</span><br><span class="line">                    .setMessage(dlgText2)</span><br><span class="line">                    .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            setResult(RESULT_CANCELED);</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;&#125;)</span><br><span class="line">                    .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            SharedPreferences prefs &#x3D; getSharedPreferences(PREFS_ALLOWED_SOURCES,</span><br><span class="line">                                    Context.MODE_PRIVATE);</span><br><span class="line">                            prefs.edit().putBoolean(mSourceInfo.packageName, true).apply();</span><br><span class="line">                            startInstallConfirm();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setOnCancelListener(this)</span><br><span class="line">                    .create();</span><br><span class="line">        case DLG_NOT_SUPPORTED_ON_WEAR:</span><br><span class="line">            return new AlertDialog.Builder(this)</span><br><span class="line">                    .setTitle(R.string.wear_not_allowed_dlg_title)</span><br><span class="line">                    .setMessage(R.string.wear_not_allowed_dlg_text)</span><br><span class="line">                    .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            setResult(RESULT_OK);</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setOnCancelListener(this)</span><br><span class="line">                    .create();</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>消息弹窗的主要作用，用于提示用户当前安装apk文件的特性。都知道android系统在android apk文件之前会解析器manifest文件，这个操作也是早onCreate方法中执行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PackageParser.Package parsed &#x3D; PackageUtil.getPackageInfo(sourceFile);</span><br></pre></td></tr></table></figure>
<p>我们具体看一下getPackageInfo方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static PackageParser.Package getPackageInfo(File sourceFile) &#123;</span><br><span class="line">        final PackageParser parser &#x3D; new PackageParser();</span><br><span class="line">        try &#123;</span><br><span class="line">            PackageParser.Package pkg &#x3D; parser.parseMonolithicPackage(sourceFile, 0);</span><br><span class="line">            parser.collectManifestDigest(pkg);</span><br><span class="line">            return pkg;</span><br><span class="line">        &#125; catch (PackageParserException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，到了这里是不是代码变得很熟悉了？parseMonolithicPackage就是我们上一节分析的android系统解析manifest文件的过程，具体的可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51203482" target="_blank" rel="noopener">http://blog.csdn.net/qq_23547831/article/details/51203482</a></p>
<p>而collectManifestDigest方法，我们这里简单的介绍一下，其主要是要争apk的签名是否正确。好吧通过这两部我们就把apk文件的manifest和签名信息都解析完成并保存在了Package中。</p>
<p>接着往下走，在所有的解析完成之后我们会在onCreate方法中执行initiateInstall();方法，刚方法的主要作用是初始化安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void initiateInstall() &#123;</span><br><span class="line">        String pkgName &#x3D; mPkgInfo.packageName;</span><br><span class="line">        &#x2F;&#x2F; Check if there is already a package on the device with this name</span><br><span class="line">        &#x2F;&#x2F; but it has been renamed to something else.</span><br><span class="line">        String[] oldName &#x3D; mPm.canonicalToCurrentPackageNames(new String[] &#123; pkgName &#125;);</span><br><span class="line">        if (oldName !&#x3D; null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] !&#x3D; null) &#123;</span><br><span class="line">            pkgName &#x3D; oldName[0];</span><br><span class="line">            mPkgInfo.packageName &#x3D; pkgName;</span><br><span class="line">            mPkgInfo.applicationInfo.packageName &#x3D; pkgName;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Check if package is already installed. display confirmation dialog if replacing pkg</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; This is a little convoluted because we want to get all uninstalled</span><br><span class="line">            &#x2F;&#x2F; apps, but this may include apps with just data, and if it is just</span><br><span class="line">            &#x2F;&#x2F; data we still want to count it as &quot;installed&quot;.</span><br><span class="line">            mAppInfo &#x3D; mPm.getApplicationInfo(pkgName,</span><br><span class="line">                    PackageManager.GET_UNINSTALLED_PACKAGES);</span><br><span class="line">            if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                mAppInfo &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NameNotFoundException e) &#123;</span><br><span class="line">            mAppInfo &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstallFlowAnalytics.setReplace(mAppInfo !&#x3D; null);</span><br><span class="line">        mInstallFlowAnalytics.setSystemApp(</span><br><span class="line">                (mAppInfo !&#x3D; null) &amp;&amp; ((mAppInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) !&#x3D; 0));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we have a session id, we&#39;re invoked to verify the permissions for the given</span><br><span class="line">        &#x2F;&#x2F; package. Otherwise, we start the install process.</span><br><span class="line">        if (mSessionId !&#x3D; -1) &#123;</span><br><span class="line">            startInstallConfirm();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            startInstall();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里面有调用了startInstallConfirm方法，然后我们看一下startInstallConfirm方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void startInstallConfirm() &#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;&#x2F;初始化安装确认界面</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这个方法的实现比较简单，主要的实现逻辑就是现实该activity的用户界面，平时我们安装某一个应用的时候会弹出一个安装确认页面，还有一个确认和取消按钮，有印象么？其实就是在这里执行的界面初始化操作。</p>
<p>好吧，一般情况下在apk安装确认页面，我们会点击确认按钮执行安装逻辑吧？那么这里我们找一下确认按钮的点击事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View v) &#123;</span><br><span class="line">        if (v &#x3D;&#x3D; mOk) &#123;</span><br><span class="line">            if (mOkCanInstall || mScrollView &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mInstallFlowAnalytics.setInstallButtonClicked();</span><br><span class="line">                if (mSessionId !&#x3D; -1) &#123;</span><br><span class="line">                    mInstaller.setPermissionsResult(mSessionId, true);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; We&#39;re only confirming permissions, so we don&#39;t really know how the</span><br><span class="line">                    &#x2F;&#x2F; story ends; assume success.</span><br><span class="line">                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(</span><br><span class="line">                            PackageManager.INSTALL_SUCCEEDED);</span><br><span class="line">                    finish();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    startInstall();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mScrollView.pageScroll(View.FOCUS_DOWN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (v &#x3D;&#x3D; mCancel) &#123;</span><br><span class="line">            &#x2F;&#x2F; Cancel and finish</span><br><span class="line">            setResult(RESULT_CANCELED);</span><br><span class="line">            if (mSessionId !&#x3D; -1) &#123;</span><br><span class="line">                mInstaller.setPermissionsResult(mSessionId, false);</span><br><span class="line">            &#125;</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_CANCELLED_BY_USER);</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很明显了，这里当我们点击确认按钮的时候会执行startInstall方法，也就是开始执行安装逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void startInstall() &#123;</span><br><span class="line">        &#x2F;&#x2F; Start subactivity to actually install the application</span><br><span class="line">        Intent newIntent &#x3D; new Intent();</span><br><span class="line">        newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,</span><br><span class="line">                mPkgInfo.applicationInfo);</span><br><span class="line">        newIntent.setData(mPackageURI);</span><br><span class="line">        newIntent.setClass(this, InstallAppProgress.class);</span><br><span class="line">        newIntent.putExtra(InstallAppProgress.EXTRA_MANIFEST_DIGEST, mPkgDigest);</span><br><span class="line">        newIntent.putExtra(</span><br><span class="line">                InstallAppProgress.EXTRA_INSTALL_FLOW_ANALYTICS, mInstallFlowAnalytics);</span><br><span class="line">        String installerPackageName &#x3D; getIntent().getStringExtra(</span><br><span class="line">                Intent.EXTRA_INSTALLER_PACKAGE_NAME);</span><br><span class="line">        if (mOriginatingURI !&#x3D; null) &#123;</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mReferrerURI !&#x3D; null) &#123;</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mOriginatingUid !&#x3D; VerificationParams.NO_UID) &#123;</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid);</span><br><span class="line">        &#125;</span><br><span class="line">        if (installerPackageName !&#x3D; null) &#123;</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME,</span><br><span class="line">                    installerPackageName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) &#123;</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true);</span><br><span class="line">            newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">        &#125;</span><br><span class="line">        if(localLOGV) Log.i(TAG, &quot;downloaded app uri&#x3D;&quot;+mPackageURI);</span><br><span class="line">        startActivity(newIntent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，点击确认按钮之后我们调用启用了一个新的Activity–&gt;InstallAppProgress，这个Activity主要用于执行apk的安装逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onCreate(Bundle icicle) &#123;</span><br><span class="line">        super.onCreate(icicle);</span><br><span class="line">        Intent intent &#x3D; getIntent();</span><br><span class="line">        mAppInfo &#x3D; intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);</span><br><span class="line">        mInstallFlowAnalytics &#x3D; intent.getParcelableExtra(EXTRA_INSTALL_FLOW_ANALYTICS);</span><br><span class="line">        mInstallFlowAnalytics.setContext(this);</span><br><span class="line">        mPackageURI &#x3D; intent.getData();</span><br><span class="line"></span><br><span class="line">        final String scheme &#x3D; mPackageURI.getScheme();</span><br><span class="line">        if (scheme !&#x3D; null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) &#123;</span><br><span class="line">            mInstallFlowAnalytics.setFlowFinished(</span><br><span class="line">                    InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME);</span><br><span class="line">            throw new IllegalArgumentException(&quot;unexpected scheme &quot; + scheme);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstallThread &#x3D; new HandlerThread(&quot;InstallThread&quot;);</span><br><span class="line">        mInstallThread.start();</span><br><span class="line">        mInstallHandler &#x3D; new Handler(mInstallThread.getLooper());</span><br><span class="line"></span><br><span class="line">        IntentFilter intentFilter &#x3D; new IntentFilter();</span><br><span class="line">        intentFilter.addAction(BROADCAST_ACTION);</span><br><span class="line">        registerReceiver(</span><br><span class="line">                mBroadcastReceiver, intentFilter, BROADCAST_SENDER_PERMISSION, null &#x2F;*scheduler*&#x2F;);</span><br><span class="line"></span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现InstallAppProcess这个Activity的onCreate方法中主要初始化了一些成员变量，并调用initView方法，我们在iniTView方法中可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void initView() &#123;</span><br><span class="line">	...</span><br><span class="line">	mInstallHandler.post(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    doPackageStage(pm, params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过一些view的初始化操作之后调用了doPackageStage方法，该方法主要是通过调用PackageInstaller执行apk文件的安装，这里就不在详细的介绍了，在apk文件安装完成之后PackageInstaller会发送一个安装完成的广播，刚刚我们在onCreate方法中注册了一个广播接收器，其可以用来接收apk安装完成的广播：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final BroadcastReceiver mBroadcastReceiver &#x3D; new BroadcastReceiver() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            final int statusCode &#x3D; intent.getIntExtra(</span><br><span class="line">                    PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE);</span><br><span class="line">            if (statusCode &#x3D;&#x3D; PackageInstaller.STATUS_PENDING_USER_ACTION) &#123;</span><br><span class="line">                context.startActivity((Intent)intent.getParcelableExtra(Intent.EXTRA_INTENT));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                onPackageInstalled(statusCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这样apk安装完成之后，这里的广播接收器会接收到广播并执行onPackageInstalled方法，执行后续的处理逻辑，那么我们来看一下onPackageInstalled方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void onPackageInstalled(int statusCode) &#123;</span><br><span class="line">        Message msg &#x3D; mHandler.obtainMessage(INSTALL_COMPLETE);</span><br><span class="line">        msg.arg1 &#x3D; statusCode;</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里是发送Handler异步消息，我们来看一下异步消息的处理逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case INSTALL_COMPLETE:</span><br><span class="line">                    mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(msg.arg1);</span><br><span class="line">                    if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) &#123;</span><br><span class="line">                        Intent result &#x3D; new Intent();</span><br><span class="line">                        result.putExtra(Intent.EXTRA_INSTALL_RESULT, msg.arg1);</span><br><span class="line">                        setResult(msg.arg1 &#x3D;&#x3D; PackageInstaller.STATUS_SUCCESS</span><br><span class="line">                                ? Activity.RESULT_OK : Activity.RESULT_FIRST_USER,</span><br><span class="line">                                        result);</span><br><span class="line">                        finish();</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; Update the status text</span><br><span class="line">                    mProgressBar.setVisibility(View.INVISIBLE);</span><br><span class="line">                    &#x2F;&#x2F; Show the ok button</span><br><span class="line">                    int centerTextLabel;</span><br><span class="line">                    int centerExplanationLabel &#x3D; -1;</span><br><span class="line">                    LevelListDrawable centerTextDrawable &#x3D;</span><br><span class="line">                            (LevelListDrawable) getDrawable(R.drawable.ic_result_status);</span><br><span class="line">                    if (msg.arg1 &#x3D;&#x3D; PackageInstaller.STATUS_SUCCESS) &#123;</span><br><span class="line">                        mLaunchButton.setVisibility(View.VISIBLE);</span><br><span class="line">                        centerTextDrawable.setLevel(0);</span><br><span class="line">                        centerTextLabel &#x3D; R.string.install_done;</span><br><span class="line">                        &#x2F;&#x2F; Enable or disable launch button</span><br><span class="line">                        mLaunchIntent &#x3D; getPackageManager().getLaunchIntentForPackage(</span><br><span class="line">                                mAppInfo.packageName);</span><br><span class="line">                        boolean enabled &#x3D; false;</span><br><span class="line">                        if(mLaunchIntent !&#x3D; null) &#123;</span><br><span class="line">                            List&lt;ResolveInfo&gt; list &#x3D; getPackageManager().</span><br><span class="line">                                    queryIntentActivities(mLaunchIntent, 0);</span><br><span class="line">                            if (list !&#x3D; null &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">                                enabled &#x3D; true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (enabled) &#123;</span><br><span class="line">                            mLaunchButton.setOnClickListener(InstallAppProgress.this);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            mLaunchButton.setEnabled(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else if (msg.arg1 &#x3D;&#x3D; PackageInstaller.STATUS_FAILURE_STORAGE)&#123;</span><br><span class="line">                        showDialogInner(DLG_OUT_OF_SPACE);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; Generic error handling for all other error codes.</span><br><span class="line">                        centerTextDrawable.setLevel(1);</span><br><span class="line">                        centerExplanationLabel &#x3D; getExplanationFromErrorCode(msg.arg1);</span><br><span class="line">                        centerTextLabel &#x3D; R.string.install_failed;</span><br><span class="line">                        mLaunchButton.setVisibility(View.INVISIBLE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (centerTextDrawable !&#x3D; null) &#123;</span><br><span class="line">                    centerTextDrawable.setBounds(0, 0,</span><br><span class="line">                            centerTextDrawable.getIntrinsicWidth(),</span><br><span class="line">                            centerTextDrawable.getIntrinsicHeight());</span><br><span class="line">                        mStatusTextView.setCompoundDrawablesRelative(centerTextDrawable, null,</span><br><span class="line">                                null, null);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mStatusTextView.setText(centerTextLabel);</span><br><span class="line">                    if (centerExplanationLabel !&#x3D; -1) &#123;</span><br><span class="line">                        mExplanationTextView.setText(centerExplanationLabel);</span><br><span class="line">                        mExplanationTextView.setVisibility(View.VISIBLE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mExplanationTextView.setVisibility(View.GONE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDoneButton.setOnClickListener(InstallAppProgress.this);</span><br><span class="line">                    mOkPanel.setVisibility(View.VISIBLE);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现，当apk安装完成之后，我们会更新UI，显示完成和打开按钮，是不是和我们平时安装apk的逻辑对应上了？这时候我们可以看一下这两个按钮的点击事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View v) &#123;</span><br><span class="line">        if(v &#x3D;&#x3D; mDoneButton) &#123;</span><br><span class="line">            if (mAppInfo.packageName !&#x3D; null) &#123;</span><br><span class="line">                Log.i(TAG, &quot;Finished installing &quot;+mAppInfo.packageName);</span><br><span class="line">            &#125;</span><br><span class="line">            finish();</span><br><span class="line">        &#125; else if(v &#x3D;&#x3D; mLaunchButton) &#123;</span><br><span class="line">            startActivity(mLaunchIntent);</span><br><span class="line">            finish();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，比较简单，点击完成按钮，直接finish掉这个activity，点击打开，则直接调用startActivity启动安装的应用，然后直接finish自身。</p>
<p><strong>总结：</strong></p>
<ul>
<li><p>代码中执行intent.setDataAndType(Uri.parse(“file://“ + path),”application/vnd.android.package-archive”);可以调起PackageInstallerActivity；</p>
</li>
<li><p>PackageInstallerActivity主要用于执行解析apk文件，解析manifest，解析签名等操作；</p>
</li>
<li><p>InstallAppProcess主要用于执行安装apk逻辑，用于初始化安装界面，用于初始化用户UI。并调用PackageInstaller执行安装逻辑；</p>
</li>
<li><p>InstallAppProcess内注册有广播，当安装完成之后接收广播，更新UI。显示apk安装完成界面；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">12 系统启动并解析Manifest的流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近有同学问我关于Manifest何时被系统解析的问题，正好也分析到这一块了，索性这一章就讲解一下android系统何时解析Manifest吧，这里的Manifest指的是android安装文件apk中的androidManifest.xml文件是何时被解析的。<br>大家应该都知道，Android系统启动之后，我们就可以在一个应用中打开另一个从未打开过的应用，或者是在一个应用中发送广播，如果另外一个应用设置了这个广播的接收器，那么这个应用进程就会被启动并接收该广播并作出相应的处理，这样的例子很多，我们可以猜测到Android系统在启动的时候就会抓取到了系统中所有安装的应用信息（应该是解析apk文件的Manifest信息），即在Android系统的启动过程中就已经解析了系统中安装应用的androidManifest.xml文件并保存起来了，那么这个过程具体是如何的呢?</p>
<p>其实android系统启动过程中解析Manifest的流程是通过PackageManagerService服务来实现的。这里我们重点分析一下PackageManagerService服务是如何解析Manifest的。</p>
<p>首先看一下在SystemServer进程启动过程中是如何启动PackageManagerService服务的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">		...</span><br><span class="line">        mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">        mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">        mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在SystemServer进程启动过程中会调用SystemServer类的startBootstrapServices方法（主要用于启动ActivityManagerService服务和PackageManagerService服务），然后会在这个方法中会调用PackageManagerService.main静态方法，这个方法主要是用来初始化PackageManagerService服务并执行相关逻辑的。下面我来看一下main方法的具体逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">            boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">        PackageManagerService m &#x3D; new PackageManagerService(context, installer,</span><br><span class="line">                factoryTest, onlyCore);</span><br><span class="line">        ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现main方法的实现逻辑主要是创建了一个PackageManagerService对象，并将这个对象添加到ServierManager中为其他组件提供服务。好吧，看来PackageManagerService的初始化操作主要是在PackageManagerService的构造方法中了，下面我们来看一下其构造方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File dataDir &#x3D; Environment.getDataDirectory();</span><br><span class="line">            mAppDataDir &#x3D; new File(dataDir, &quot;data&quot;);</span><br><span class="line">            mAppInstallDir &#x3D; new File(dataDir, &quot;app&quot;);</span><br><span class="line">            mAppLib32InstallDir &#x3D; new File(dataDir, &quot;app-lib&quot;);</span><br><span class="line">            mAsecInternalPath &#x3D; new File(dataDir, &quot;app-asec&quot;).getPath();</span><br><span class="line">            mUserAppDataDir &#x3D; new File(dataDir, &quot;user&quot;);</span><br><span class="line">            mDrmAppPrivateInstallDir &#x3D; new File(dataDir, &quot;app-private&quot;);</span><br></pre></td></tr></table></figure>
<p>PackageManagerService的构造方法代码量比较大，这里就不贴出所有的代码了，我们主要和解析Manifest相关的主要代码，在构造方法中有这样几段代码。可以发现在构造方法中，解析了系统中几个apk的安装目录，这几个目录就是系统中安装apk的目录，android系统会默认解析这几个目录下apk文件，也就是说如果我们android手机在其他的目录下存在apk文件系统是不会默认解析的，反过来说，如果我们把我们的apk文件移动到这几个目录下，那么重新启动操作系统，该apk文件就会被系统解析并执行相关的逻辑操作，具体做什么操作呢？我们看下面的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; overlay packages if they reside in VENDOR_OVERLAY_DIR.</span><br><span class="line">            File vendorOverlayDir &#x3D; new File(VENDOR_OVERLAY_DIR);</span><br><span class="line">            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Find base frameworks (resource packages without code).</span><br><span class="line">            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">                    | PackageParser.PARSE_IS_PRIVILEGED,</span><br><span class="line">                    scanFlags | SCAN_NO_DEX, 0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Collected privileged system packages.</span><br><span class="line">            final File privilegedAppDir &#x3D; new File(Environment.getRootDirectory(), &quot;priv-app&quot;);</span><br><span class="line">            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Collect ordinary system packages.</span><br><span class="line">            final File systemAppDir &#x3D; new File(Environment.getRootDirectory(), &quot;app&quot;);</span><br><span class="line">            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Collect all vendor packages.</span><br><span class="line">            File vendorAppDir &#x3D; new File(&quot;&#x2F;vendor&#x2F;app&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                vendorAppDir &#x3D; vendorAppDir.getCanonicalFile();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; failed to look up canonical path, continue with original one</span><br><span class="line">            &#125;</span><br><span class="line">            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Collect all OEM packages.</span><br><span class="line">            final File oemAppDir &#x3D; new File(Environment.getOemDirectory(), &quot;app&quot;);</span><br><span class="line">            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br></pre></td></tr></table></figure>
<p>在我们刚刚的PackageManagerService.mani方法中，解析完刚刚的几个系统目录之后系统会调用scanDirLI方法，那么这个方法主要是做什么用的呢？看它的名字应该是遍历这个系统目录。好吧，这个方法主要就是用于解析上面几个目录下的apk文件的。不信？我们看一下scanDirLI方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) &#123;</span><br><span class="line">        final File[] files &#x3D; dir.listFiles();</span><br><span class="line">        if (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line">            Log.d(TAG, &quot;No files in app dir &quot; + dir);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_PACKAGE_SCANNING) &#123;</span><br><span class="line">            Log.d(TAG, &quot;Scanning app dir &quot; + dir + &quot; scanFlags&#x3D;&quot; + scanFlags</span><br><span class="line">                    + &quot; flags&#x3D;0x&quot; + Integer.toHexString(parseFlags));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (File file : files) &#123;</span><br><span class="line">            final boolean isPackage &#x3D; (isApkFile(file) || file.isDirectory())</span><br><span class="line">                    &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">            if (!isPackage) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore entries which are not packages</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</span><br><span class="line">                        scanFlags, currentTime, null);</span><br><span class="line">            &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Failed to parse &quot; + file + &quot;: &quot; + e.getMessage());</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Delete invalid userdata apps</span><br><span class="line">                if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                        e.error &#x3D;&#x3D; PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line">                    logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + file);</span><br><span class="line">                    if (file.isDirectory()) &#123;</span><br><span class="line">                        mInstaller.rmPackageDir(file.getAbsolutePath());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        file.delete();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以放下其首先会遍历该目录下的所有文件，并判断是否是apk文件，如果是apk文件则调用scanPackageLI方法，scanPackageLI方法的名字很明显，就是用于解析这个apk文件的。</p>
<p>继续看一下scanPakcageLI方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,</span><br><span class="line">            long currentTime, UserHandle user) throws PackageManagerException &#123;</span><br><span class="line">        if (DEBUG_INSTALL) Slog.d(TAG, &quot;Parsing: &quot; + scanFile);</span><br><span class="line">        parseFlags |&#x3D; mDefParseFlags;</span><br><span class="line">        PackageParser pp &#x3D; new PackageParser();</span><br><span class="line">        pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">        pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">        pp.setDisplayMetrics(mMetrics);</span><br><span class="line"></span><br><span class="line">        if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) !&#x3D; 0) &#123;</span><br><span class="line">            parseFlags |&#x3D; PackageParser.PARSE_TRUSTED_OVERLAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final PackageParser.Package pkg;</span><br><span class="line">        try &#123;</span><br><span class="line">            pkg &#x3D; pp.parsePackage(scanFile, parseFlags);</span><br><span class="line">        &#125; catch (PackageParserException e) &#123;</span><br><span class="line">            throw PackageManagerException.from(e);</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这个方法也比较复杂，这里只是列出重点相关的代码，我们可以发现在这个方法中创建了一个PackagerParser对象，并调用了parsePackage方法，这个方法其实就是解析Manifest的主要方法，我们可以看一下其具体的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Package parsePackage(File packageFile, int flags) throws PackageParserException &#123;</span><br><span class="line">        if (packageFile.isDirectory()) &#123;</span><br><span class="line">            return parseClusterPackage(packageFile, flags);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return parseMonolithicPackage(packageFile, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，若我们解析的File对象是一个文件夹则执行调用parseClusterPackage方法，否则调用执行parseMonolithicPackage方法，很明显的因为我们这里解析的是apk文件（在上一方法中我们循环遍历得到了apk文件，这里的File对象就代表了一个个的apk文件信息），所以这里会执行parseMonolithicPackage方法，然后我们来看一下parseMonolithicPackage方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException &#123;</span><br><span class="line">        if (mOnlyCoreApps) &#123;</span><br><span class="line">            final PackageLite lite &#x3D; parseMonolithicPackageLite(apkFile, flags);</span><br><span class="line">            if (!lite.coreApp) &#123;</span><br><span class="line">                throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,</span><br><span class="line">                        &quot;Not a coreApp: &quot; + apkFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final AssetManager assets &#x3D; new AssetManager();</span><br><span class="line">        try &#123;</span><br><span class="line">            final Package pkg &#x3D; parseBaseApk(apkFile, assets, flags);</span><br><span class="line">            pkg.codePath &#x3D; apkFile.getAbsolutePath();</span><br><span class="line">            return pkg;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            IoUtils.closeQuietly(assets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里又调用了parseBaseApk方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Package parseBaseApk(File apkFile, AssetManager assets, int flags)</span><br><span class="line">			...</span><br><span class="line">            final Package pkg &#x3D; parseBaseApk(res, parser, flags, outError);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这个parseBaseApk方法调用了其重载的parseBaseApk方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line">while ((type &#x3D; parser.next()) !&#x3D; XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type !&#x3D; XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">            if (type &#x3D;&#x3D; XmlPullParser.END_TAG || type &#x3D;&#x3D; XmlPullParser.TEXT) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String tagName &#x3D; parser.getName();</span><br><span class="line">            if (tagName.equals(&quot;application&quot;)) &#123;</span><br><span class="line">                if (foundApp) &#123;</span><br><span class="line">                    if (RIGID_PARSER) &#123;</span><br><span class="line">                        outError[0] &#x3D; &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;;</span><br><span class="line">                        mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;);</span><br><span class="line">                        XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                foundApp &#x3D; true;</span><br><span class="line">                if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;overlay&quot;)) &#123;</span><br><span class="line">                pkg.mTrustedOverlay &#x3D; trustedOverlay;</span><br><span class="line"></span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestResourceOverlay);</span><br><span class="line">                pkg.mOverlayTarget &#x3D; sa.getString(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestResourceOverlay_targetPackage);</span><br><span class="line">                pkg.mOverlayPriority &#x3D; sa.getInt(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestResourceOverlay_priority,</span><br><span class="line">                        -1);</span><br><span class="line">                sa.recycle();</span><br><span class="line"></span><br><span class="line">                if (pkg.mOverlayTarget &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    outError[0] &#x3D; &quot;&lt;overlay&gt; does not specify a target package&quot;;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (pkg.mOverlayPriority &lt; 0 || pkg.mOverlayPriority &gt; 9999) &#123;</span><br><span class="line">                    outError[0] &#x3D; &quot;&lt;overlay&gt; priority must be between 0 and 9999&quot;;</span><br><span class="line">                    mParseError &#x3D;</span><br><span class="line">                        PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;key-sets&quot;)) &#123;</span><br><span class="line">                if (!parseKeySets(pkg, res, parser, attrs, outError)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;permission-group&quot;)) &#123;</span><br><span class="line">                if (parsePermissionGroup(pkg, flags, res, parser, attrs, outError) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;permission&quot;)) &#123;</span><br><span class="line">                if (parsePermission(pkg, res, parser, attrs, outError) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;permission-tree&quot;)) &#123;</span><br><span class="line">                if (parsePermissionTree(pkg, res, parser, attrs, outError) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-permission&quot;)) &#123;</span><br><span class="line">                if (!parseUsesPermission(pkg, res, parser, attrs)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-permission-sdk-m&quot;)</span><br><span class="line">                    || tagName.equals(&quot;uses-permission-sdk-23&quot;)) &#123;</span><br><span class="line">                if (!parseUsesPermission(pkg, res, parser, attrs)) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-configuration&quot;)) &#123;</span><br><span class="line">                ConfigurationInfo cPref &#x3D; new ConfigurationInfo();</span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesConfiguration);</span><br><span class="line">                cPref.reqTouchScreen &#x3D; sa.getInt(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,</span><br><span class="line">                        Configuration.TOUCHSCREEN_UNDEFINED);</span><br><span class="line">                cPref.reqKeyboardType &#x3D; sa.getInt(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,</span><br><span class="line">                        Configuration.KEYBOARD_UNDEFINED);</span><br><span class="line">                if (sa.getBoolean(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,</span><br><span class="line">                        false)) &#123;</span><br><span class="line">                    cPref.reqInputFeatures |&#x3D; ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;</span><br><span class="line">                &#125;</span><br><span class="line">                cPref.reqNavigation &#x3D; sa.getInt(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,</span><br><span class="line">                        Configuration.NAVIGATION_UNDEFINED);</span><br><span class="line">                if (sa.getBoolean(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,</span><br><span class="line">                        false)) &#123;</span><br><span class="line">                    cPref.reqInputFeatures |&#x3D; ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;</span><br><span class="line">                &#125;</span><br><span class="line">                sa.recycle();</span><br><span class="line">                pkg.configPreferences &#x3D; ArrayUtils.add(pkg.configPreferences, cPref);</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-feature&quot;)) &#123;</span><br><span class="line">                FeatureInfo fi &#x3D; parseUsesFeature(res, attrs);</span><br><span class="line">                pkg.reqFeatures &#x3D; ArrayUtils.add(pkg.reqFeatures, fi);</span><br><span class="line"></span><br><span class="line">                if (fi.name &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    ConfigurationInfo cPref &#x3D; new ConfigurationInfo();</span><br><span class="line">                    cPref.reqGlEsVersion &#x3D; fi.reqGlEsVersion;</span><br><span class="line">                    pkg.configPreferences &#x3D; ArrayUtils.add(pkg.configPreferences, cPref);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;feature-group&quot;)) &#123;</span><br><span class="line">                FeatureGroupInfo group &#x3D; new FeatureGroupInfo();</span><br><span class="line">                ArrayList&lt;FeatureInfo&gt; features &#x3D; null;</span><br><span class="line">                final int innerDepth &#x3D; parser.getDepth();</span><br><span class="line">                while ((type &#x3D; parser.next()) !&#x3D; XmlPullParser.END_DOCUMENT</span><br><span class="line">                        &amp;&amp; (type !&#x3D; XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">                    if (type &#x3D;&#x3D; XmlPullParser.END_TAG || type &#x3D;&#x3D; XmlPullParser.TEXT) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final String innerTagName &#x3D; parser.getName();</span><br><span class="line">                    if (innerTagName.equals(&quot;uses-feature&quot;)) &#123;</span><br><span class="line">                        FeatureInfo featureInfo &#x3D; parseUsesFeature(res, attrs);</span><br><span class="line">                        &#x2F;&#x2F; FeatureGroups are stricter and mandate that</span><br><span class="line">                        &#x2F;&#x2F; any &lt;uses-feature&gt; declared are mandatory.</span><br><span class="line">                        featureInfo.flags |&#x3D; FeatureInfo.FLAG_REQUIRED;</span><br><span class="line">                        features &#x3D; ArrayUtils.add(features, featureInfo);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Slog.w(TAG, &quot;Unknown element under &lt;feature-group&gt;: &quot; + innerTagName +</span><br><span class="line">                                &quot; at &quot; + mArchiveSourcePath + &quot; &quot; +</span><br><span class="line">                                parser.getPositionDescription());</span><br><span class="line">                    &#125;</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (features !&#x3D; null) &#123;</span><br><span class="line">                    group.features &#x3D; new FeatureInfo[features.size()];</span><br><span class="line">                    group.features &#x3D; features.toArray(group.features);</span><br><span class="line">                &#125;</span><br><span class="line">                pkg.featureGroups &#x3D; ArrayUtils.add(pkg.featureGroups, group);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-sdk&quot;)) &#123;</span><br><span class="line">                if (SDK_VERSION &gt; 0) &#123;</span><br><span class="line">                    sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                            com.android.internal.R.styleable.AndroidManifestUsesSdk);</span><br><span class="line"></span><br><span class="line">                    int minVers &#x3D; 0;</span><br><span class="line">                    String minCode &#x3D; null;</span><br><span class="line">                    int targetVers &#x3D; 0;</span><br><span class="line">                    String targetCode &#x3D; null;</span><br><span class="line">                    </span><br><span class="line">                    TypedValue val &#x3D; sa.peekValue(</span><br><span class="line">                            com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);</span><br><span class="line">                    if (val !&#x3D; null) &#123;</span><br><span class="line">                        if (val.type &#x3D;&#x3D; TypedValue.TYPE_STRING &amp;&amp; val.string !&#x3D; null) &#123;</span><br><span class="line">                            targetCode &#x3D; minCode &#x3D; val.string.toString();</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F; If it&#39;s not a string, it&#39;s an integer.</span><br><span class="line">                            targetVers &#x3D; minVers &#x3D; val.data;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    val &#x3D; sa.peekValue(</span><br><span class="line">                            com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);</span><br><span class="line">                    if (val !&#x3D; null) &#123;</span><br><span class="line">                        if (val.type &#x3D;&#x3D; TypedValue.TYPE_STRING &amp;&amp; val.string !&#x3D; null) &#123;</span><br><span class="line">                            targetCode &#x3D; minCode &#x3D; val.string.toString();</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F; If it&#39;s not a string, it&#39;s an integer.</span><br><span class="line">                            targetVers &#x3D; val.data;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    sa.recycle();</span><br><span class="line"></span><br><span class="line">                    if (minCode !&#x3D; null) &#123;</span><br><span class="line">                        boolean allowedCodename &#x3D; false;</span><br><span class="line">                        for (String codename : SDK_CODENAMES) &#123;</span><br><span class="line">                            if (minCode.equals(codename)) &#123;</span><br><span class="line">                                allowedCodename &#x3D; true;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!allowedCodename) &#123;</span><br><span class="line">                            if (SDK_CODENAMES.length &gt; 0) &#123;</span><br><span class="line">                                outError[0] &#x3D; &quot;Requires development platform &quot; + minCode</span><br><span class="line">                                        + &quot; (current platform is any of &quot;</span><br><span class="line">                                        + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                outError[0] &#x3D; &quot;Requires development platform &quot; + minCode</span><br><span class="line">                                        + &quot; but this is a release platform.&quot;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mParseError &#x3D; PackageManager.INSTALL_FAILED_OLDER_SDK;</span><br><span class="line">                            return null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else if (minVers &gt; SDK_VERSION) &#123;</span><br><span class="line">                        outError[0] &#x3D; &quot;Requires newer sdk version #&quot; + minVers</span><br><span class="line">                                + &quot; (current version is #&quot; + SDK_VERSION + &quot;)&quot;;</span><br><span class="line">                        mParseError &#x3D; PackageManager.INSTALL_FAILED_OLDER_SDK;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (targetCode !&#x3D; null) &#123;</span><br><span class="line">                        boolean allowedCodename &#x3D; false;</span><br><span class="line">                        for (String codename : SDK_CODENAMES) &#123;</span><br><span class="line">                            if (targetCode.equals(codename)) &#123;</span><br><span class="line">                                allowedCodename &#x3D; true;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (!allowedCodename) &#123;</span><br><span class="line">                            if (SDK_CODENAMES.length &gt; 0) &#123;</span><br><span class="line">                                outError[0] &#x3D; &quot;Requires development platform &quot; + targetCode</span><br><span class="line">                                        + &quot; (current platform is any of &quot;</span><br><span class="line">                                        + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                outError[0] &#x3D; &quot;Requires development platform &quot; + targetCode</span><br><span class="line">                                        + &quot; but this is a release platform.&quot;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mParseError &#x3D; PackageManager.INSTALL_FAILED_OLDER_SDK;</span><br><span class="line">                            return null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; If the code matches, it definitely targets this SDK.</span><br><span class="line">                        pkg.applicationInfo.targetSdkVersion</span><br><span class="line">                                &#x3D; android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        pkg.applicationInfo.targetSdkVersion &#x3D; targetVers;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;supports-screens&quot;)) &#123;</span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens);</span><br><span class="line"></span><br><span class="line">                pkg.applicationInfo.requiresSmallestWidthDp &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_requiresSmallestWidthDp,</span><br><span class="line">                        0);</span><br><span class="line">                pkg.applicationInfo.compatibleWidthLimitDp &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_compatibleWidthLimitDp,</span><br><span class="line">                        0);</span><br><span class="line">                pkg.applicationInfo.largestWidthLimitDp &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_largestWidthLimitDp,</span><br><span class="line">                        0);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; This is a trick to get a boolean and still able to detect</span><br><span class="line">                &#x2F;&#x2F; if a value was actually set.</span><br><span class="line">                supportsSmallScreens &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,</span><br><span class="line">                        supportsSmallScreens);</span><br><span class="line">                supportsNormalScreens &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,</span><br><span class="line">                        supportsNormalScreens);</span><br><span class="line">                supportsLargeScreens &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,</span><br><span class="line">                        supportsLargeScreens);</span><br><span class="line">                supportsXLargeScreens &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_xlargeScreens,</span><br><span class="line">                        supportsXLargeScreens);</span><br><span class="line">                resizeable &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,</span><br><span class="line">                        resizeable);</span><br><span class="line">                anyDensity &#x3D; sa.getInteger(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,</span><br><span class="line">                        anyDensity);</span><br><span class="line"></span><br><span class="line">                sa.recycle();</span><br><span class="line">                </span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                </span><br><span class="line">            &#125; else if (tagName.equals(&quot;protected-broadcast&quot;)) &#123;</span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Note: don&#39;t allow this value to be a reference to a resource</span><br><span class="line">                &#x2F;&#x2F; that may change.</span><br><span class="line">                String name &#x3D; sa.getNonResourceString(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);</span><br><span class="line"></span><br><span class="line">                sa.recycle();</span><br><span class="line"></span><br><span class="line">                if (name !&#x3D; null &amp;&amp; (flags&amp;PARSE_IS_SYSTEM) !&#x3D; 0) &#123;</span><br><span class="line">                    if (pkg.protectedBroadcasts &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        pkg.protectedBroadcasts &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!pkg.protectedBroadcasts.contains(name)) &#123;</span><br><span class="line">                        pkg.protectedBroadcasts.add(name.intern());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                </span><br><span class="line">            &#125; else if (tagName.equals(&quot;instrumentation&quot;)) &#123;</span><br><span class="line">                if (parseInstrumentation(pkg, res, parser, attrs, outError) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (tagName.equals(&quot;original-package&quot;)) &#123;</span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestOriginalPackage);</span><br><span class="line"></span><br><span class="line">                String orig &#x3D;sa.getNonConfigurationString(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0);</span><br><span class="line">                if (!pkg.packageName.equals(orig)) &#123;</span><br><span class="line">                    if (pkg.mOriginalPackages &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        pkg.mOriginalPackages &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">                        pkg.mRealPackage &#x3D; pkg.packageName;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pkg.mOriginalPackages.add(orig);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sa.recycle();</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                </span><br><span class="line">            &#125; else if (tagName.equals(&quot;adopt-permissions&quot;)) &#123;</span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestOriginalPackage);</span><br><span class="line"></span><br><span class="line">                String name &#x3D; sa.getNonConfigurationString(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0);</span><br><span class="line"></span><br><span class="line">                sa.recycle();</span><br><span class="line"></span><br><span class="line">                if (name !&#x3D; null) &#123;</span><br><span class="line">                    if (pkg.mAdoptPermissions &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        pkg.mAdoptPermissions &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    pkg.mAdoptPermissions.add(name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                </span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-gl-texture&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Just skip this tag</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (tagName.equals(&quot;compatible-screens&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Just skip this tag</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;supports-input&quot;)) &#123;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (tagName.equals(&quot;eat-comment&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Just skip this tag</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (RIGID_PARSER) &#123;</span><br><span class="line">                outError[0] &#x3D; &quot;Bad element under &lt;manifest&gt;: &quot;</span><br><span class="line">                    + parser.getName();</span><br><span class="line">                mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                return null;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Unknown element under &lt;manifest&gt;: &quot; + parser.getName()</span><br><span class="line">                        + &quot; at &quot; + mArchiveSourcePath + &quot; &quot;</span><br><span class="line">                        + parser.getPositionDescription());</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在这个parseBaseApk方法中有一个while循环，该循环主要就是用于解析AndroidManifest.xml文件中的节点信息。在开始解析application节点的时候，同时调用了parseBaseApplication方法，该方法解析了application节点下的activity，service，broadcast，contentprovier等组件的定义信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">while ((type &#x3D; parser.next()) !&#x3D; XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type !&#x3D; XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">            if (type &#x3D;&#x3D; XmlPullParser.END_TAG || type &#x3D;&#x3D; XmlPullParser.TEXT) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String tagName &#x3D; parser.getName();</span><br><span class="line">            if (tagName.equals(&quot;activity&quot;)) &#123;</span><br><span class="line">                Activity a &#x3D; parseActivity(owner, res, parser, attrs, flags, outError, false,</span><br><span class="line">                        owner.baseHardwareAccelerated);</span><br><span class="line">                if (a &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.activities.add(a);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;receiver&quot;)) &#123;</span><br><span class="line">                Activity a &#x3D; parseActivity(owner, res, parser, attrs, flags, outError, true, false);</span><br><span class="line">                if (a &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.receivers.add(a);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;service&quot;)) &#123;</span><br><span class="line">                Service s &#x3D; parseService(owner, res, parser, attrs, flags, outError);</span><br><span class="line">                if (s &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.services.add(s);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;provider&quot;)) &#123;</span><br><span class="line">                Provider p &#x3D; parseProvider(owner, res, parser, attrs, flags, outError);</span><br><span class="line">                if (p &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.providers.add(p);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;activity-alias&quot;)) &#123;</span><br><span class="line">                Activity a &#x3D; parseActivityAlias(owner, res, parser, attrs, flags, outError);</span><br><span class="line">                if (a &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                owner.activities.add(a);</span><br><span class="line"></span><br><span class="line">            &#125; else if (parser.getName().equals(&quot;meta-data&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F; note: application meta-data is stored off to the side, so it can</span><br><span class="line">                &#x2F;&#x2F; remain null in the primary copy (we like to avoid extra copies because</span><br><span class="line">                &#x2F;&#x2F; it can be large)</span><br><span class="line">                if ((owner.mAppMetaData &#x3D; parseMetaData(res, parser, attrs, owner.mAppMetaData,</span><br><span class="line">                        outError)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;library&quot;)) &#123;</span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestLibrary);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Note: don&#39;t allow this value to be a reference to a resource</span><br><span class="line">                &#x2F;&#x2F; that may change.</span><br><span class="line">                String lname &#x3D; sa.getNonResourceString(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestLibrary_name);</span><br><span class="line"></span><br><span class="line">                sa.recycle();</span><br><span class="line"></span><br><span class="line">                if (lname !&#x3D; null) &#123;</span><br><span class="line">                    lname &#x3D; lname.intern();</span><br><span class="line">                    if (!ArrayUtils.contains(owner.libraryNames, lname)) &#123;</span><br><span class="line">                        owner.libraryNames &#x3D; ArrayUtils.add(owner.libraryNames, lname);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-library&quot;)) &#123;</span><br><span class="line">                sa &#x3D; res.obtainAttributes(attrs,</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesLibrary);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Note: don&#39;t allow this value to be a reference to a resource</span><br><span class="line">                &#x2F;&#x2F; that may change.</span><br><span class="line">                String lname &#x3D; sa.getNonResourceString(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);</span><br><span class="line">                boolean req &#x3D; sa.getBoolean(</span><br><span class="line">                        com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,</span><br><span class="line">                        true);</span><br><span class="line"></span><br><span class="line">                sa.recycle();</span><br><span class="line"></span><br><span class="line">                if (lname !&#x3D; null) &#123;</span><br><span class="line">                    lname &#x3D; lname.intern();</span><br><span class="line">                    if (req) &#123;</span><br><span class="line">                        owner.usesLibraries &#x3D; ArrayUtils.add(owner.usesLibraries, lname);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        owner.usesOptionalLibraries &#x3D; ArrayUtils.add(</span><br><span class="line">                                owner.usesOptionalLibraries, lname);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else if (tagName.equals(&quot;uses-package&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Dependencies for app installers; we don&#39;t currently try to</span><br><span class="line">                &#x2F;&#x2F; enforce this.</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!RIGID_PARSER) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;Unknown element under &lt;application&gt;: &quot; + tagName</span><br><span class="line">                            + &quot; at &quot; + mArchiveSourcePath + &quot; &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    outError[0] &#x3D; &quot;Bad element under &lt;application&gt;: &quot; + tagName;</span><br><span class="line">                    mParseError &#x3D; PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这样，经过这里循环遍历，整个androidManifest的节点信息就被解析并保存在了Package对象中。可以看到我们平时在Manifest中定义的各种节点，其实都是在这里有所体现。当androidManifest.xml文件被解析完成之后会调用我们刚刚介绍的scanPackageLI的重载方法，将解析完成的Package对象信息保存的Setting对象中，这个对象用于保存app的安装信息，具体实现是在方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,</span><br><span class="line">            long currentTime, UserHandle user) throws PackageManagerException</span><br></pre></td></tr></table></figure>
<p>当解析完成manifest文件之后会调用其重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Note that we invoke the following method only if we are about to unpack an application</span><br><span class="line">        PackageParser.Package scannedPkg &#x3D; scanPackageLI(pkg, parseFlags, scanFlags</span><br><span class="line">                | SCAN_UPDATE_SIGNATURE, currentTime, user);</span><br></pre></td></tr></table></figure>
<p>这样，解析的manifest文件信息就会被保存到Settings中，并持久化，然后执行安装apk的操作，我们可以看一下该重载方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,</span><br><span class="line">            int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123;</span><br><span class="line">        boolean success &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            final PackageParser.Package res &#x3D; scanPackageDirtyLI(pkg, parseFlags, scanFlags,</span><br><span class="line">                    currentTime, user);</span><br><span class="line">            success &#x3D; true;</span><br><span class="line">            return res;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) !&#x3D; 0) &#123;</span><br><span class="line">                removeDataDirsLI(pkg.volumeUuid, pkg.packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其内部调用了scanPackageDirtyLI方法，这个方法就是实际实现持久化manifest信息并安装APK操作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags,</span><br><span class="line">            int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123;</span><br><span class="line">	...</span><br><span class="line">	&#x2F;&#x2F; And now re-install the app.</span><br><span class="line">    ret &#x3D; createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid,</span><br><span class="line">                  pkg.applicationInfo.seinfo);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其内部调用了createDataDirLI，该方法主要实现安装apk的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private int createDataDirsLI(String volumeUuid, String packageName, int uid, String seinfo) &#123;</span><br><span class="line">        int[] users &#x3D; sUserManager.getUserIds();</span><br><span class="line">        int res &#x3D; mInstaller.install(volumeUuid, packageName, uid, uid, seinfo);</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int user : users) &#123;</span><br><span class="line">            if (user !&#x3D; 0) &#123;</span><br><span class="line">                res &#x3D; mInstaller.createUserData(volumeUuid, packageName,</span><br><span class="line">                        UserHandle.getUid(user, uid), user, seinfo);</span><br><span class="line">                if (res &lt; 0) &#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查看该方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int install(String uuid, String name, int uid, int gid, String seinfo) &#123;</span><br><span class="line">        StringBuilder builder &#x3D; new StringBuilder(&quot;install&quot;);</span><br><span class="line">        builder.append(&#39; &#39;);</span><br><span class="line">        builder.append(escapeNull(uuid));</span><br><span class="line">        builder.append(&#39; &#39;);</span><br><span class="line">        builder.append(name);</span><br><span class="line">        builder.append(&#39; &#39;);</span><br><span class="line">        builder.append(uid);</span><br><span class="line">        builder.append(&#39; &#39;);</span><br><span class="line">        builder.append(gid);</span><br><span class="line">        builder.append(&#39; &#39;);</span><br><span class="line">        builder.append(seinfo !&#x3D; null ? seinfo : &quot;!&quot;);</span><br><span class="line">        return mInstaller.execute(builder.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>怎么样？很熟悉吧，这里的Installer其实调用的就是我们平时运行android项目很熟悉的install命令，原来android系统安装apk文件底层都是调用的adb命令。</p>
<p><strong>总结：</strong></p>
<ul>
<li><p>android系统启动之后会解析固定目录下的apk文件，并执行解析，持久化apk信息，重新安装等操作；</p>
</li>
<li><p>解析Manifest流程：Zygote进程 –&gt; SystemServer进程 –&gt; PackgeManagerService服务 –&gt; scanDirLI方法 –&gt; scanPackageLI方法 –&gt; PackageParser.parserPackage方法；</p>
</li>
<li><p>解析完成Manifest之后会将apk的Manifest信息保存在Settings对象中并持久化，然后执行重新安装的操作；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/11%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/11%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">11 应用进程启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>转载请标明出处：<a href="http://blog.csdn.net/qq_23547831/article/details/51119333" target="_blank" rel="noopener">一片枫叶的专栏</a></p>
</blockquote>
<p>在android guide中有这样的一段关于android应用程序进程的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">By default, every application runs in its own Linux process. Android starts the process when any of the application&#39;s components need to be executed, then shuts down the process when it&#39;s no longer needed or when the system must recover memory for other applications.</span><br></pre></td></tr></table></figure>
<p>每一个android应用默认都是在他自己的linux进程中运行。android操作系统会在这个android应用中的组件需要被执行的时候启动这个应用进程，并且会在这个应用进程没有任何组件执行或者是系统需要为其他应用申请更多内存的时候杀死这个应用进程。所以当我们需要启动这个应用的四大组件之一的时候如果这个应用的进程还没有启动，那么就会先启动这个应用程序进程。</p>
<p>本节主要是通过分析Activity的启动过程介绍应用程序进程的启动流程。</p>
<p>在上一篇文章中我们简要的介绍了Launcher的启动流程，在SystemServer进程执行完成，各种系统服务启动完成之后，会调用ActivityManagerService中的systemReady()方法，在systemReady（）方法中会执行Launcher启动的相关逻辑了，具体可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51112031" target="_blank" rel="noopener"> android源码解析之（十）–&gt;Launcher启动流程</a></p>
<p>Launcher应用程序在启动过程中会通过PackageManagerService服务请求查询系统所有的已安装应用的包名，图标和应用名称等信息，然后填充到Launcher中的Adapter中，这样点击某一项应用图标的时候就可以根据该图标的包名和启动Activity的类名初始化Intent对象，然后调用startActivity(Intent)启动相关的应用程序了。</p>
<p>其实android中应用进程可以通过许多方式启动，比如启动一个Activity，启动一个Service，启动一个ContentProvider或者是一个BroadcastReceiver，也就是说我们可以通过启动四大组件的方式启动应用进程，在应用进程没有启动的时候，如果我们通过启动这些组件，这时候系统会判断当前这些组件所需要的应用进程是否已经启动，若没有的话，则会启动应用进程。</p>
<p>这里我们通过Launcher简单分析一下应用进程的启动流程。通过上一篇Launcher启动流程，我们知道每一个launcher中的图标对应着一个应用报名和启动activity类名，查看LauncherActivity中的图标点击事件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">        Intent intent &#x3D; intentForPosition(position);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在通过应用包名和启动activity类名构造完成Intent之后，我们调用了startActivity方法来启动这个activity，很明显的，当前这个应用并没有启动，也就是说我们调用的startActivity方法不单单为我们启动了这个activity也同时在启动activity之前启动了这个应用进程，好了，那我们这里就以这个方法为入口分析一下应用进程的启动流程。</p>
<p>跟踪代码到Activity，发现其调用了startActivity的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        this.startActivity(intent, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Note we want to go through this call for compatibility with</span><br><span class="line">            &#x2F;&#x2F; applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很明显的我们此时传递的options为空：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode) &#123;</span><br><span class="line">        startActivityForResult(intent, requestCode, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，最后调用的还是这个重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">        if (mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar &#x3D;</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            if (ar !&#x3D; null) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            if (requestCode &gt;&#x3D; 0) &#123;</span><br><span class="line">                mStartedActivity &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            &#x2F;&#x2F; TODO Consider clearing&#x2F;flushing other event sources and events for child windows.</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (options !&#x3D; null) &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Note we want to go through this method for compatibility with</span><br><span class="line">                &#x2F;&#x2F; existing applications that may have overridden it.</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里调用了mInstrumentation.execStartActivity方法，这里先简单介绍一下Instrumentation对象，他是Android系统中应用程序端操作Activity的具体操作类，这里的操作段是相对于ActivityManagerService服务端来说的。也就是说当我们在执行对Activity的具体操作时，比如回调生命周期的各个方法都是借助于Instrumentation类来实现的。</p>
<p>好了，下面我们继续看一下Instrumentation的execStartActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">            int result &#x3D; ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要关注这个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int result &#x3D; ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br></pre></td></tr></table></figure>
<p>这断代码实际上是进程间通讯，我们可以发现ActivityManagerNative继承于Binder接口，所以ActivityManagerNative就是一个Binder对象，然后上面一节我们介绍SystemServer进程的时候对ActivityManagerService有过了解，发现其继承于ActivityManagerNative，好吧，了解过Binder机制的童鞋就知道了，ActivityManagerService就是这个Binder机制的服务器端而ActivityManagerNative就是这个Binder机制的客户端，所以我们这里调用的startActivity实际上是讲参数传递给ActivityManagerService并执行ActivityManagerService的startActivity方法。</p>
<p>既然这样，我们看一下ActivityManagerService的startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123;</span><br><span class="line">        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用了startActivityAsUser方法，然后我们继续看一下startActivityAsUser方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">        userId &#x3D; handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">                false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">        &#x2F;&#x2F; TODO: Switch to user app stacks here.</span><br><span class="line">        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                profilerInfo, null, null, options, false, userId, null, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续查看startActivityMayWait方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">            String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,</span><br><span class="line">            Bundle options, boolean ignoreTargetSecurity, int userId,</span><br><span class="line">            IActivityContainer iContainer, TaskRecord inTask) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">            int res &#x3D; startActivityLocked(caller, intent, resolvedType, aInfo,</span><br><span class="line">                    voiceSession, voiceInteractor, resultTo, resultWho,</span><br><span class="line">                    requestCode, callingPid, callingUid, callingPackage,</span><br><span class="line">                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</span><br><span class="line">                    componentSpecified, null, container, inTask);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的逻辑比较多，我们重点关注的是其调用了startActivityLocked方法，也就是说在初始化其他逻辑之后，这个方法会调用startActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, true, options, inTask);</span><br></pre></td></tr></table></figure>
<p>代码量也是比较大的，在方法体中调用了startActivityUncheckedLocked方法，然后我们继续跟进startActivityUncheckedLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br></pre></td></tr></table></figure>
<p>然后我们查看startActivityLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (doResume) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其调用了resumeTopActivitiesLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack.resumeTopActivityLocked(null);</span><br></pre></td></tr></table></figure>
<p>继续跟进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev) &#123;</span><br><span class="line">        return resumeTopActivityLocked(prev, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看一下resumeTopActivityLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br></pre></td></tr></table></figure>
<p>继续查看resumeTopActivityInnerLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br></pre></td></tr></table></figure>
<p>可以发现在方法体中执行了相关逻辑判断与初始化操作之后调用了startSpecificActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br></pre></td></tr></table></figure>
<p>可以发现在方法体中调用了startProcessLocked方法，从名字可以看出来这个方法就是启动进程的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName,</span><br><span class="line">            ApplicationInfo info, boolean knownToBeDead, int intentFlags,</span><br><span class="line">            String hostingType, ComponentName hostingName, boolean allowWhileBooting,</span><br><span class="line">            boolean isolated, boolean keepIfLarge) &#123;</span><br><span class="line">        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">                hostingName, allowWhileBooting, isolated, 0 &#x2F;* isolatedUid *&#x2F;, keepIfLarge,</span><br><span class="line">                null &#x2F;* ABI override *&#x2F;, null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;,</span><br><span class="line">                null &#x2F;* crashHandler *&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看startProcessLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;);</span><br><span class="line">        startProcessLocked(</span><br><span class="line">                app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">        checkTime(startTime, &quot;startProcess: done starting proc!&quot;);</span><br></pre></td></tr></table></figure>
<p>查看startProcessLocked方法的具体实现；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">            Process.ProcessStartResult startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br></pre></td></tr></table></figure>
<p> 查看关键代码，这里调用了Process.start方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  int uid, int gid, int[] gids,</span><br><span class="line">                                  int debugFlags, int mountExternal,</span><br><span class="line">                                  int targetSdkVersion,</span><br><span class="line">                                  String seInfo,</span><br><span class="line">                                  String abi,</span><br><span class="line">                                  String instructionSet,</span><br><span class="line">                                  String appDataDir,</span><br><span class="line">                                  String[] zygoteArgs) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">        &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            Log.e(LOG_TAG,</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的processClass就是要启动的进程的名称，这里传递的就是ActivityThread：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;android.app.ActivityThread&quot;</span><br></pre></td></tr></table></figure>
<p>具体的Process启动进程的Native层代码这里不做过多的分析，这个方法就是启动了AcitivtyThread进程并执行了ActivityThread的main方法，所以我们经常说的进程的启动方法就是ActivityThread的main方法就是这里体现的。</p>
<p>总结：</p>
<ul>
<li><p>android应用进程会在需要启动其组件的时候启动，当没有任何组件运行或者是系统内存较低的时候应用进程会被杀死。</p>
</li>
<li><p>在启动应用四大组件的时候若发现当前应用的进程没有启动，则会首先启动应用程序的进程。</p>
</li>
<li><p>我们可以为应用程序配置多个进程，每个进程都有自己的JVM和运行环境，各个进程之间的通讯需要通过Binder机制。</p>
</li>
<li><p>Launcher启动的过程也是先启动Launcher进程再启动其Activity组件。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/10%20Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/10%20Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">10 Launcher启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Launcher程序就是我们平时看到的桌面程序，它其实也是一个android应用程序，只不过这个应用程序是系统默认第一个启动的应用程序，这里我们就简单的分析一下Launcher应用的启动流程。</p>
<p>不同的手机厂商定制android操作系统的时候都会更改Launcher的源代码，我们这里以android23的源码为例大致的分析一下Launcher的启动流程。</p>
<p>通过上一篇文章，我们知道SystemServer进程主要用于启动系统的各种服务，二者其中就包含了负责启动Launcher的服务，LauncherAppService。具体关于SystenServer的启动流程可以参见：<a href="http://blog.csdn.net/qq_23547831/article/details/51105171" target="_blank" rel="noopener"> android源码解析之（九）–&gt;SystemServer进程启动流程</a></p>
<p>在SystemServer进程的启动过程中会调用其main静态方法，开始执行整个SystemServer的启动流程，在其中通过调用三个内部方法分别启动boot service、core service和other service。在调用startOtherService方法中就会通过调用mActivityManagerService.systemReady()方法，那么我们看一下其具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; We now tell the activity manager it is okay to run third party</span><br><span class="line">        &#x2F;&#x2F; code.  It will call back into us once it has gotten to the state</span><br><span class="line">        &#x2F;&#x2F; where third party code can really run (but before it has actually</span><br><span class="line">        &#x2F;&#x2F; started launching the initial applications), for us to complete our</span><br><span class="line">        &#x2F;&#x2F; initialization.</span><br><span class="line">        mActivityManagerService.systemReady(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Making services ready&quot;);</span><br><span class="line">                mSystemServiceManager.startBootPhase(</span><br><span class="line">                        SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;observing native crashes&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Slog.i(TAG, &quot;WebViewFactory preparation&quot;);</span><br><span class="line">                WebViewFactory.prepareWebViewInSystemServer();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    startSystemUi(context);</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;starting System UI&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkScoreF !&#x3D; null) networkScoreF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Network Score Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkManagementF !&#x3D; null) networkManagementF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Network Managment Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkStatsF !&#x3D; null) networkStatsF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Network Stats Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkPolicyF !&#x3D; null) networkPolicyF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Network Policy Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (connectivityF !&#x3D; null) connectivityF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;making Connectivity Service ready&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (audioServiceF !&#x3D; null) audioServiceF.systemReady();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying AudioService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                Watchdog.getInstance().start();</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; It is now okay to let the various system services start their</span><br><span class="line">                &#x2F;&#x2F; third party code...</span><br><span class="line">                mSystemServiceManager.startBootPhase(</span><br><span class="line">                        SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    if (wallpaperF !&#x3D; null) wallpaperF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying WallpaperService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (immF !&#x3D; null) immF.systemRunning(statusBarF);</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying InputMethodService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (locationF !&#x3D; null) locationF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying Location Service running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (countryDetectorF !&#x3D; null) countryDetectorF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying CountryDetectorService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (networkTimeUpdaterF !&#x3D; null) networkTimeUpdaterF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying NetworkTimeService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (commonTimeMgmtServiceF !&#x3D; null) &#123;</span><br><span class="line">                        commonTimeMgmtServiceF.systemRunning();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying CommonTimeManagementService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (textServiceManagerServiceF !&#x3D; null)</span><br><span class="line">                        textServiceManagerServiceF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying TextServicesManagerService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (atlasF !&#x3D; null) atlasF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying AssetAtlasService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; TODO(BT) Pass parameter to input manager</span><br><span class="line">                    if (inputManagerF !&#x3D; null) inputManagerF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying InputManagerService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (telephonyRegistryF !&#x3D; null) telephonyRegistryF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying TelephonyRegistry running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (mediaRouterF !&#x3D; null) mediaRouterF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying MediaRouterService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    if (mmsServiceF !&#x3D; null) mmsServiceF.systemRunning();</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    reportWtf(&quot;Notifying MmsService running&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>可以发现这个方法传递了一个Runnable参数，里面执行了各种其他服务的systemReady方法，这里不是我们关注的重点，我们看一下在ActivityManagerService中systemReady方法的具体实现，方法体比较长，我就不在这里贴出代码了，主要的逻辑就是做一些ActivityManagerService的ready操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void systemReady(final Runnable goingCallback) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Start up initial activity.</span><br><span class="line">        mBooting &#x3D; true;</span><br><span class="line">        startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;);</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重点是在这个方法体中调用了startHomeActivityLocked方法，看其名字就是说开始执行启动homeActivity的操作，好了，既然如此，我们再看一下startHomeActivityLocked的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">boolean startHomeActivityLocked(int userId, String reason) &#123;</span><br><span class="line">        if (mFactoryTest &#x3D;&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">                &amp;&amp; mTopAction &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; We are running in factory test mode, but unable to find</span><br><span class="line">            &#x2F;&#x2F; the factory test app, so just sit around displaying the</span><br><span class="line">            &#x2F;&#x2F; error message and don&#39;t try to start anything.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Intent intent &#x3D; getHomeIntent();</span><br><span class="line">        ActivityInfo aInfo &#x3D;</span><br><span class="line">            resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">        if (aInfo !&#x3D; null) &#123;</span><br><span class="line">            intent.setComponent(new ComponentName(</span><br><span class="line">                    aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">            &#x2F;&#x2F; Don&#39;t do this if the home app is currently being</span><br><span class="line">            &#x2F;&#x2F; instrumented.</span><br><span class="line">            aInfo &#x3D; new ActivityInfo(aInfo);</span><br><span class="line">            aInfo.applicationInfo &#x3D; getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">            ProcessRecord app &#x3D; getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                    aInfo.applicationInfo.uid, true);</span><br><span class="line">            if (app &#x3D;&#x3D; null || app.instrumentationClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">                intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                mStackSupervisor.startHomeActivity(intent, aInfo, reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先是调用getHomeIntent()方法，看一下getHomeIntent是如何实现构造Intent对象的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Intent getHomeIntent() &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(mTopAction, mTopData !&#x3D; null ? Uri.parse(mTopData) : null);</span><br><span class="line">        intent.setComponent(mTopComponent);</span><br><span class="line">        if (mFactoryTest !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">            intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">        &#125;</span><br><span class="line">        return intent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，启动Launcher的Intent对象中添加了Intent.CATEGORY_HOME常量，这个其实是一个launcher的标志，一般系统的启动页面Activity都会在androidmanifest.xml中配置这个标志。比如我们在github中的android launcher源码中查看其androidmanifest.xml文件：<br><img src="http://img.blog.csdn.net/20160410171414711" alt="这里写图片描述"><br>可以发现其Activity的定义intentfilter中就是定义了这样的category。不同的手机厂商可能会修改Launcher的源码，但是这个category一般是不会更改的。</p>
<p>继续回到我们的startHomeActivityLocked方法，我们发现经过一系列的判断逻辑之后最后调用了mStackSupervisor.startHomeActivity方法，然后我们可以查看一下该方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason) &#123;</span><br><span class="line">        moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason);</span><br><span class="line">        startActivityLocked(null &#x2F;* caller *&#x2F;, intent, null &#x2F;* resolvedType *&#x2F;, aInfo,</span><br><span class="line">                null &#x2F;* voiceSession *&#x2F;, null &#x2F;* voiceInteractor *&#x2F;, null &#x2F;* resultTo *&#x2F;,</span><br><span class="line">                null &#x2F;* resultWho *&#x2F;, 0 &#x2F;* requestCode *&#x2F;, 0 &#x2F;* callingPid *&#x2F;, 0 &#x2F;* callingUid *&#x2F;,</span><br><span class="line">                null &#x2F;* callingPackage *&#x2F;, 0 &#x2F;* realCallingPid *&#x2F;, 0 &#x2F;* realCallingUid *&#x2F;,</span><br><span class="line">                0 &#x2F;* startFlags *&#x2F;, null &#x2F;* options *&#x2F;, false &#x2F;* ignoreTargetSecurity *&#x2F;,</span><br><span class="line">                false &#x2F;* componentSpecified *&#x2F;,</span><br><span class="line">                null &#x2F;* outActivity *&#x2F;, null &#x2F;* container *&#x2F;,  null &#x2F;* inTask *&#x2F;);</span><br><span class="line">        if (inResumeTopActivity) &#123;</span><br><span class="line">            &#x2F;&#x2F; If we are in resume section already, home activity will be initialized, but not</span><br><span class="line">            &#x2F;&#x2F; resumed (to avoid recursive resume) and will stay that way until something pokes it</span><br><span class="line">            &#x2F;&#x2F; again. We need to schedule another resume.</span><br><span class="line">            scheduleResumeTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>发现其调用的是scheduleResumeTopActivities()方法，这个方法其实是关于Activity的启动流程的逻辑了，这里我们不在详细的说明，关于Activity的启动流程我们在下面的文章中会介绍。</p>
<p>因为我们的Launcher启动的Intent是一个隐士的Intent，所以我们会启动在androidmanifest.xml中配置了相同catogory的activity，android M中配置的这个catogory就是LauncherActivity。</p>
<p>LauncherActivity继承与ListActivity，我们看一下其Layout布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    &gt;</span><br><span class="line"></span><br><span class="line">    &lt;ListView</span><br><span class="line">        android:id&#x3D;&quot;@android:id&#x2F;list&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@android:id&#x2F;empty&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:gravity&#x3D;&quot;center&quot;</span><br><span class="line">        android:text&#x3D;&quot;@string&#x2F;activity_list_empty&quot;</span><br><span class="line">        android:visibility&#x3D;&quot;gone&quot;</span><br><span class="line">        android:textAppearance&#x3D;&quot;?android:attr&#x2F;textAppearanceMedium&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;FrameLayout&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到我们现实的桌面其实就是一个ListView控件，然后看一下其onCreate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle icicle) &#123;</span><br><span class="line">        super.onCreate(icicle);</span><br><span class="line">        </span><br><span class="line">        mPackageManager &#x3D; getPackageManager();</span><br><span class="line"></span><br><span class="line">        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) &#123;</span><br><span class="line">            requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);</span><br><span class="line">            setProgressBarIndeterminateVisibility(true);</span><br><span class="line">        &#125;</span><br><span class="line">        onSetContentView();</span><br><span class="line"></span><br><span class="line">        mIconResizer &#x3D; new IconResizer();</span><br><span class="line">        </span><br><span class="line">        mIntent &#x3D; new Intent(getTargetIntent());</span><br><span class="line">        mIntent.setComponent(null);</span><br><span class="line">        mAdapter &#x3D; new ActivityAdapter(mIconResizer);</span><br><span class="line"></span><br><span class="line">        setListAdapter(mAdapter);</span><br><span class="line">        getListView().setTextFilterEnabled(true);</span><br><span class="line"></span><br><span class="line">        updateAlertTitle();</span><br><span class="line">        updateButtonText();</span><br><span class="line"></span><br><span class="line">        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) &#123;</span><br><span class="line">            setProgressBarIndeterminateVisibility(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在LauncherActivity的onCreate方法中初始化了一个PackageManager，其主要作用就是从中查询出系统所有已经安装的应用列表，应用包名，应用图标等信息。然后将这些信息注入到Adapter中，这样就可以将系统应用图标和名称显示出来了。<br>在系统的回调方法onListItemClick中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">        Intent intent &#x3D; intentForPosition(position);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这也就是为什么我们点击了某一个应用图标之后可以启动某一项应用的原因了，我们看一下这里的intentForPosition是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected Intent intentForPosition(int position) &#123;</span><br><span class="line">        ActivityAdapter adapter &#x3D; (ActivityAdapter) mAdapter;</span><br><span class="line">        return adapter.intentForPosition(position);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了adapter的intentForPosition方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Intent intentForPosition(int position) &#123;</span><br><span class="line">            if (mActivitiesList &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Intent intent &#x3D; new Intent(mIntent);</span><br><span class="line">            ListItem item &#x3D; mActivitiesList.get(position);</span><br><span class="line">            intent.setClassName(item.packageName, item.className);</span><br><span class="line">            if (item.extras !&#x3D; null) &#123;</span><br><span class="line">                intent.putExtras(item.extras);</span><br><span class="line">            &#125;</span><br><span class="line">            return intent;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到由于adapter的每一项中都保存了应用的包名可启动Activity名称，所以这里在初始化Intent的时候，直接将这些信息注入到Intent中，然后调用startActivity，就将这些应用启动了（关于startActivity是如何启动的下面的文章中我将介绍）。</p>
<p>总结：</p>
<p>Launcher的启动流程</p>
<ul>
<li><p>Zygote进程 –&gt; SystemServer进程 –&gt; startOtherService方法 –&gt; ActivityManagerService的systemReady方法 –&gt; startHomeActivityLocked方法 –&gt; ActivityStackSupervisor的startHomeActivity方法 –&gt; 执行Activity的启动逻辑，执行scheduleResumeTopActivities()方法。。。。</p>
</li>
<li><p>因为是隐士的启动Activity，所以启动的Activity就是在AndroidManifest.xml中配置catogery的值为：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String CATEGORY_HOME &#x3D; &quot;android.intent.category.HOME&quot;;</span><br></pre></td></tr></table></figure>
<p>可以发现android M中在androidManifest.xml中配置了这个catogory的activity是LauncherActivity，所以我们就可以将这个Launcher启动起来了</p>
<ul>
<li>LauncherActivity中是以ListView来显示我们的应用图标列表的，并且为每个Item保存了应用的包名和启动Activity类名，这样点击某一项应用图标的时候就可以根据应用包名和启动Activity名称启动我们的App了。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/9%20SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/9%20SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">9 SystemServer进程启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>转载请标明出处：<a href="http://blog.csdn.net/qq_23547831/article/details/51105171" target="_blank" rel="noopener">一片枫叶的专栏</a></p>
</blockquote>
<p>上面一文中我们讲过android系统中比较重要的几个进程：init进程，Zygote进程，SystemServer进程已经各种应用进程，其中Zygote进程是整个android系统的根进程，包含SystemServer进程已经各种应用进程在内的进程都是通过Zygote进程fork出来的，具体可参见：<a href="http://blog.csdn.net/qq_23547831/article/details/51104873" target="_blank" rel="noopener"> android源码解析之（八）–&gt;Zygote进程启动流程</a><br>那么SystemServer进程是做什么用的呢？</p>
<p>其实SystemServer进程主要的作用是在这个进程中启动各种系统服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务，以及各种系统性的服务其实都是在SystemServer进程中启动的，而当我们的应用需要使用各种系统服务的时候其实也是通过与SystemServer进程通讯获取各种服务对象的句柄的。</p>
<p>由上一篇文章我们知道SystemServer进程其实也是有Zygote进程fork出来的，并且执行其main方法，那么这里我们以android23的源码为例，看一下SystemServer的main方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * The main entry point from zygote.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SystemServer().run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里比较简单，只是new出一个SystemServer对象并执行其run方法，查看SystemServer类的定义我们知道其实final类型的，所以我们一般不能重写或者继承。</p>
<p>然后我们查看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">private void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; If a device&#39;s clock is before 1970 (before 0), a lot of</span><br><span class="line">        &#x2F;&#x2F; APIs crash dealing with negative numbers, notably</span><br><span class="line">        &#x2F;&#x2F; java.io.File#setLastModified, so instead we fake it and</span><br><span class="line">        &#x2F;&#x2F; hope that time from cell towers or NTP fixes it shortly.</span><br><span class="line">        if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</span><br><span class="line">            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the system has &quot;persist.sys.language&quot; and friends set, replace them with</span><br><span class="line">        &#x2F;&#x2F; &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated</span><br><span class="line">        &#x2F;&#x2F; using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by</span><br><span class="line">        &#x2F;&#x2F; AndroidRuntime using the same set of system properties, but only the system_server</span><br><span class="line">        &#x2F;&#x2F; and system apps are allowed to set them.</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; NOTE: Most changes made here will need an equivalent change to</span><br><span class="line">        &#x2F;&#x2F; core&#x2F;jni&#x2F;AndroidRuntime.cpp</span><br><span class="line">        if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</span><br><span class="line">            final String languageTag &#x3D; Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">            SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Here we go!</span><br><span class="line">        Slog.i(TAG, &quot;Entered the Android system server!&quot;);</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; In case the runtime switched since last boot (such as when</span><br><span class="line">        &#x2F;&#x2F; the old runtime was removed in an OTA), set the system</span><br><span class="line">        &#x2F;&#x2F; property so that it is in sync. We can&#39;t do this in</span><br><span class="line">        &#x2F;&#x2F; libnativehelper&#39;s JniInvocation::Init code where we already</span><br><span class="line">        &#x2F;&#x2F; had to fallback to a different runtime because it is</span><br><span class="line">        &#x2F;&#x2F; running as root and we need to be the system user to set</span><br><span class="line">        &#x2F;&#x2F; the property. http:&#x2F;&#x2F;b&#x2F;11463182</span><br><span class="line">        SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Enable the sampling profiler.</span><br><span class="line">        if (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">            SamplingProfilerIntegration.start();</span><br><span class="line">            mProfilerSnapshotTimer &#x3D; new Timer();</span><br><span class="line">            mProfilerSnapshotTimer.schedule(new TimerTask() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Mmmmmm... more memory!</span><br><span class="line">        VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The system server has to run all of the time, so it needs to be</span><br><span class="line">        &#x2F;&#x2F; as efficient as possible with its memory usage.</span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Some devices rely on runtime fingerprint generation, so make sure</span><br><span class="line">        &#x2F;&#x2F; we&#39;ve defined it before booting further.</span><br><span class="line">        Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Within the system server, it is an error to access Environment paths without</span><br><span class="line">        &#x2F;&#x2F; explicitly specifying a user.</span><br><span class="line">        Environment.setUserRequired(true);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Ensure binder calls into the system always run at foreground priority.</span><br><span class="line">        BinderInternal.disableBackgroundScheduling(true);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Prepare the main looper thread (this thread).</span><br><span class="line">        android.os.Process.setThreadPriority(</span><br><span class="line">                android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        android.os.Process.setCanSelfBackground(false);</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initialize native services.</span><br><span class="line">        System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check whether we failed to shut down last time we tried.</span><br><span class="line">        &#x2F;&#x2F; This call may not return.</span><br><span class="line">        performPendingShutdown();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initialize the system context.</span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create the system service manager.</span><br><span class="line">        mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start services.</span><br><span class="line">        try &#123;</span><br><span class="line">            startBootstrapServices();</span><br><span class="line">            startCoreServices();</span><br><span class="line">            startOtherServices();</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; For debug builds, log event loop stalls to dropbox for analysis.</span><br><span class="line">        if (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Loop forever.</span><br><span class="line">        Looper.loop();</span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，代码比较多，慢慢看。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</span><br><span class="line">            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断系统当前时间，若当前时间小于1970年1月1日，则一些初始化操作可能会处所，所以当系统的当前时间小于1970年1月1日的时候，设置系统当前时间为该时间点。</p>
<p>然后代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</span><br><span class="line">            final String languageTag &#x3D; Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">            SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</span><br><span class="line">            SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>主要是设置系统的语言环境等；<br>下面的主要是设置虚拟机运行内存，加载运行库，设置SystemServer的异步消息，具体的异步消息机制可参见：<a href="http://blog.csdn.net/qq_23547831/article/details/50751687" target="_blank" rel="noopener"> android源码解析之（二）–&gt;异步消息机制</a></p>
<p>然后下面的代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Initialize the system context.</span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create the system service manager.</span><br><span class="line">        mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start services.</span><br><span class="line">        try &#123;</span><br><span class="line">            startBootstrapServices();</span><br><span class="line">            startCoreServices();</span><br><span class="line">            startOtherServices();</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先调用createSystemContext()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void createSystemContext() &#123;</span><br><span class="line">        ActivityThread activityThread &#x3D; ActivityThread.systemMain();</span><br><span class="line">        mSystemContext &#x3D; activityThread.getSystemContext();</span><br><span class="line">        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在SystemServer进程中也存在着Context对象，并且是通过ActivityThread.systemMain方法创建context的，这一部分的逻辑以后会通过介绍Activity的启动流程来介绍，这里就不在扩展，只知道在SystemServer进程中也需要创建Context对象。</p>
<p>然后通过SystemServiceManager的构造方法创建了一个新的SystemServiceManager对象，我们知道SystemServer进程主要是用来构建系统各种service服务的，而SystemServiceManager就是这些服务的管理对象。</p>
<p>然后调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br></pre></td></tr></table></figure>
<p>是将SystemServiceManager对象保存SystemServer进程中的一个数据结构中。</p>
<p>最后开始执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Start services.</span><br><span class="line">        try &#123;</span><br><span class="line">            startBootstrapServices();</span><br><span class="line">            startCoreServices();</span><br><span class="line">            startOtherServices();</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>里面主要涉及了是三个方法：<br>startBootstrapServices() 主要用于启动系统Boot级服务<br>startCoreServices() 主要用于启动系统核心的服务<br>startOtherServices() 主要用于启动一些非紧要或者是非需要及时启动的服务</p>
<p>下面我们重点介绍这三个启动服务的方法，包括启动那些系统服务已经如何启动系统服务等。</p>
<p>首先看一下startBootstrapServices方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">        &#x2F;&#x2F; Wait for installd to finish starting up so that it has a chance to</span><br><span class="line">        &#x2F;&#x2F; create critical directories such as &#x2F;data&#x2F;user with the appropriate</span><br><span class="line">        &#x2F;&#x2F; permissions.  We need this to complete before we initialize other services.</span><br><span class="line">        Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Activity manager runs the show.</span><br><span class="line">        mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">                ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">        mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Power manager needs to be started early because other services need it.</span><br><span class="line">        &#x2F;&#x2F; Native daemons may be watching for it to be registered so it must be ready</span><br><span class="line">        &#x2F;&#x2F; to handle incoming binder calls immediately (including being able to verify</span><br><span class="line">        &#x2F;&#x2F; the permissions for those calls).</span><br><span class="line">        mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Now that the power manager has been started, let the activity manager</span><br><span class="line">        &#x2F;&#x2F; initialize power management features.</span><br><span class="line">        mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Manages LEDs and display backlight so we need it to bring up the display.</span><br><span class="line">        mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Display manager is needed to provide display metrics before package manager</span><br><span class="line">        &#x2F;&#x2F; starts up.</span><br><span class="line">        mDisplayManagerService &#x3D; mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; We need the default display before we can initialize the package manager.</span><br><span class="line">        mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Only run &quot;core&quot; apps if we&#39;re encrypting the device.</span><br><span class="line">        String cryptState &#x3D; SystemProperties.get(&quot;vold.decrypt&quot;);</span><br><span class="line">        if (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;);</span><br><span class="line">            mOnlyCore &#x3D; true;</span><br><span class="line">        &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;);</span><br><span class="line">            mOnlyCore &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start the package manager.</span><br><span class="line">        Slog.i(TAG, &quot;Package Manager&quot;);</span><br><span class="line">        mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">        mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">        mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, &quot;User Service&quot;);</span><br><span class="line">        ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initialize attribute cache used to cache resources from packages.</span><br><span class="line">        AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Set up the Application instance for the system process and get started.</span><br><span class="line">        mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The sensor service needs access to package manager service, app ops</span><br><span class="line">        &#x2F;&#x2F; service, and permissions service, therefore we start it after them.</span><br><span class="line">        startSensorService();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br></pre></td></tr></table></figure>
<p>mSystemServiceManager是系统服务管理对象，在main方法中已经创建完成，这里我们看一下其startService方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123;</span><br><span class="line">        final String name &#x3D; serviceClass.getName();</span><br><span class="line">        Slog.i(TAG, &quot;Starting &quot; + name);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create the service.</span><br><span class="line">        if (!SystemService.class.isAssignableFrom(serviceClass)) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failed to create &quot; + name</span><br><span class="line">                    + &quot;: service must extend &quot; + SystemService.class.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        final T service;</span><br><span class="line">        try &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor &#x3D; serviceClass.getConstructor(Context.class);</span><br><span class="line">            service &#x3D; constructor.newInstance(mContext);</span><br><span class="line">        &#125; catch (InstantiationException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">                    + &quot;: service could not be instantiated&quot;, ex);</span><br><span class="line">        &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">                    + &quot;: service must have a public constructor with a Context argument&quot;, ex);</span><br><span class="line">        &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">                    + &quot;: service must have a public constructor with a Context argument&quot;, ex);</span><br><span class="line">        &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">                    + &quot;: service constructor threw an exception&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Register it.</span><br><span class="line">        mServices.add(service);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start it.</span><br><span class="line">        try &#123;</span><br><span class="line">            service.onStart();</span><br><span class="line">        &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failed to start service &quot; + name</span><br><span class="line">                    + &quot;: onStart threw an exception&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return service;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们通过反射器构造方法创建出服务类，然后添加到SystemServiceManager的服务列表数据中，最后调用了service.onStart()方法，因为我们传递的是Installer.class，我们这里我们查看一下Installer的onStart方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">        Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;);</span><br><span class="line">        mInstaller.waitForConnection();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很简单就是执行了mInstaller的waitForConnection方法，这里简单介绍一下Installer类，该类是系统安装apk时的一个服务类，继承SystemService（系统服务的一个抽象接口），我们需要在启动完成Installer服务之后才能启动其他的系统服务。<br>然后查看waitForConnection（）方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void waitForConnection() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (execute(&quot;ping&quot;) &gt;&#x3D; 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Slog.w(TAG, &quot;installd not ready&quot;);</span><br><span class="line">            SystemClock.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过追踪代码可以发现，其在不断的通过ping命令连接Zygote进程（SystemServer和Zygote进程通过socket方式通讯，其他进程通过Binder方式通讯）；</p>
<p><strong>总结：</strong><br>在开始执行启动服务之前总是会先尝试通过socket方式连接Zygote进程，在成功连接之后才会开始启动其他服务。</p>
<p>继续来看startBootstrapServices方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Activity manager runs the show.</span><br><span class="line">        mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">                ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">        mActivityManagerService.setInstaller(installer);</span><br></pre></td></tr></table></figure>
<p>这段代码主要是用于启动ActivityManagerService服务，并为其设置SysServiceManager和Installer。ActivityManagerService是系统中一个非常重要的服务，Activity，service，Broadcast，contentProvider都需要通过其余系统交互。</p>
<p>首先看一下Lifecycle类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static final class Lifecycle extends SystemService &#123;</span><br><span class="line">        private final ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">        public Lifecycle(Context context) &#123;</span><br><span class="line">            super(context);</span><br><span class="line">            mService &#x3D; new ActivityManagerService(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onStart() &#123;</span><br><span class="line">            mService.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ActivityManagerService getService() &#123;</span><br><span class="line">            return mService;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实ActivityManagerService的一个静态内部类，在其构造方法中会创建一个ActivityManagerService，通过刚刚对Installer服务的分析我们知道，SystemServiceManager的startService方法会调用服务的onStart()方法，而在Lifecycle类的定义中我们看到其onStart（）方法直接调用了mService.start()方法，mService是Lifecycle类中对ActivityManagerService的引用，所以我们可以看一下ActivityManagerService的start方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void start() &#123;</span><br><span class="line">        Process.removeAllProcessGroups();</span><br><span class="line">        mProcessCpuThread.start();</span><br><span class="line"></span><br><span class="line">        mBatteryStatsService.publish(mContext);</span><br><span class="line">        mAppOpsService.publish(mContext);</span><br><span class="line">        Slog.d(&quot;AppOps&quot;, &quot;AppOpsService published&quot;);</span><br><span class="line">        LocalServices.addService(ActivityManagerInternal.class, new LocalService());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于ActivityManagerService的创建过程比较复杂这里不做过多的分析了，主要是在其构造方法中初始化了一些变量。</p>
<p>然后是启动PowerManagerService服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br></pre></td></tr></table></figure>
<p>启动方式跟上面的ActivityManagerService服务相似都会调用其构造方法和onStart方法，PowerManagerService主要用于计算系统中和Power相关的计算，然后决策系统应该如何反应。同时协调Power如何与系统其它模块的交互，比如没有用户活动时，屏幕变暗等等。</p>
<p>然后是启动LightsService服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager.startService(LightsService.class);</span><br></pre></td></tr></table></figure>
<p>主要是手机中关于闪光灯，LED等相关的服务；也是会调用LightsService的构造方法和onStart方法；</p>
<p>然后是启动DisplayManagerService服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDisplayManagerService &#x3D; mSystemServiceManager.startService(DisplayManagerService.class);</span><br></pre></td></tr></table></figure>
<p>主要是手机显示方面的服务；</p>
<p>然后是启动PackageManagerService，该服务也是android系统中一个比较重要的服务，包括多apk文件的安装，解析，删除，卸载等等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Slog.i(TAG, &quot;Package Manager&quot;);</span><br><span class="line">        mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">        mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">        mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br></pre></td></tr></table></figure>
<p>可以看到PackageManagerService服务的启动方式与其他服务的启动方式有一些区别，直接调用了PackageManagerService的静态main方法，这里我们看一下其main方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">            boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">        PackageManagerService m &#x3D; new PackageManagerService(context, installer,</span><br><span class="line">                factoryTest, onlyCore);</span><br><span class="line">        ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到也是直接使用new的方式创建了一个PackageManagerService对象，并在其构造方法中初始化相关变量，最后调用了ServiceManager.addService方法，主要是通过Binder机制与JNI层交互，这里不再扩展。</p>
<p>然后启动UserManagerService和SensorService，至此startBootstrapServices方法执行完成。</p>
<p>然后查看startCoreServices方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">        &#x2F;&#x2F; Tracks the battery level.  Requires LightService.</span><br><span class="line">        mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Tracks application usage stats.</span><br><span class="line">        mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">        mActivityManagerService.setUsageStatsManager(</span><br><span class="line">                LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line">        &#x2F;&#x2F; Update after UsageStatsService is available, needed before performBootDexOpt.</span><br><span class="line">        mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Tracks whether the updatable WebView is in a ready state and watches for update installs.</span><br><span class="line">        mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里启动了BatteryService（电池相关服务），UsageStatsService，WebViewUpdateService服务等。</p>
<p>最后看一下startOtherServices方法，主要用于启动系统中其他的服务，代码很多，这里就不贴代码了，启动的流程和ActivityManagerService的流程类似，会调用服务的构造方法与onStart方法初始化变量。</p>
<p>总结：</p>
<ul>
<li><p>SystemServer进程是android中一个很重要的进程由Zygote进程启动；</p>
</li>
<li><p>SystemServer进程主要用于启动系统中的服务；</p>
</li>
<li><p>SystemServer进程启动服务的启动函数为main函数；</p>
</li>
<li><p>SystemServer在执行过程中首先会初始化一些系统变量，加载类库，创建Context对象，创建SystemServiceManager对象等之后才开始启动系统服务；</p>
</li>
<li><p>SystemServer进程将系统服务分为三类：boot服务，core服务和other服务，并逐步启动</p>
</li>
<li><p>SertemServer进程在尝试启动服务之前会首先尝试与Zygote建立socket通讯，只有通讯成功之后才会开始尝试启动服务；</p>
</li>
<li><p>创建的系统服务过程中主要通过SystemServiceManager对象来管理，通过调用服务对象的构造方法和onStart方法初始化服务的相关变量；</p>
</li>
<li><p>服务对象都有自己的异步消息对象，并运行在单独的线程中；</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
