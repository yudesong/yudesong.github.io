<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/17/AOP%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/17/AOP%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">AOP技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-17 19:36:30" itemprop="dateCreated datePublished" datetime="2020-07-17T19:36:30+08:00">2020-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>AOP从实现原理上可以分为运行时AOP和编译时AOP，对于Android来讲运行时AOP的实现主要是hook某些关键方法，编译时AOP主要是在Apk打包过程中对class文件的字节码进行扫描更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache &#x3D; new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());</span><br><span class="line"></span><br><span class="line">    public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                            Class&lt;?&gt;[] interfaces,</span><br><span class="line">                            InvocationHandler h) throws IllegalArgumentException &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        final Class&lt;?&gt;[] intfs &#x3D; interfaces.clone();</span><br><span class="line">        &#x2F;&#x2F; 权限检查</span><br><span class="line">        final SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">        if (sm !&#x3D; null) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 字节码生成Proxy0类</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Android-removed: SecurityManager &#x2F; permission checks.</span><br><span class="line">            &#x2F;*</span><br><span class="line">            if (sm !&#x3D; null) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            *&#x2F;</span><br><span class="line"></span><br><span class="line">            final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih &#x3D; h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                &#x2F;&#x2F; BEGIN Android-changed: Excluded AccessController.doPrivileged call.</span><br><span class="line">                &#x2F;*</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                *&#x2F;</span><br><span class="line"></span><br><span class="line">                cons.setAccessible(true);</span><br><span class="line">                &#x2F;&#x2F; END Android-removed: Excluded AccessController.doPrivileged call.</span><br><span class="line">            &#125;</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t &#x3D; e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        if (interfaces.length &gt; 65535) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<p>Linux中fd_set的内部实现:<a href="https://zhuanlan.zhihu.com/p/122182639" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/122182639</a></p>
<p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。<br>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p>通过nativePollOnce()函数学习epoll机制</p>
<p>static const int EPOLL_SIZE_HINT = 8; //每个epoll实例默认的文件描述符个数<br>static const int EPOLL_MAX_EVENTS = 16; //轮询事件的文件描述符的个数上限</p>
<p>mWakeEventFd = eventfd(0, EFD_NONBLOCK); //构造唤醒事件的fd</p>
<p>void Looper::rebuildEpollLocked() {<br>    if (mEpollFd &gt;= 0) {<br>        close(mEpollFd); //关闭旧的epoll实例<br>    }<br>    mEpollFd = epoll_create(EPOLL_SIZE_HINT); //创建新的epoll实例，并注册wake管道<br>    struct epoll_event eventItem;<br>    memset(&amp; eventItem, 0, sizeof(epoll_event)); //把未使用的数据区域进行置0操作<br>    eventItem.events = EPOLLIN; //可读事件<br>    eventItem.data.fd = mWakeEventFd;<br>    //将唤醒事件(mWakeEventFd)添加到epoll实例(mEpollFd)<br>    int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</p>
<pre><code>for (size_t i = 0; i &lt; mRequests.size(); i++) {
    const Request&amp; request = mRequests.valueAt(i);
    struct epoll_event eventItem;
    request.initEventItem(&amp;eventItem);
    //将request队列的事件，分别添加到epoll实例
    int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);
}</code></pre><p>}</p>
<p>Looper对象中的mWakeEventFd添加到epoll监控，以及mRequests也添加到epoll的监控范围内。</p>
<p>Android Linux内核相关概念：<br>0. Android进程创建Zygote的fork机制</p>
<ol>
<li>Binder进程间通信采用了mmap内存映射机制、MMKV同样也是采用了mmap机制</li>
</ol>
<p>———–Linux进程管理、进程地址空间、进程上下文切换、</p>
<ol start="2">
<li>Handler native层采用了epoll IO多路复用机制</li>
<li>native crash 捕获涉及到Linux中断、信号量</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E5%8E%86%E5%8F%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6%E5%8E%86%E5%8F%B2/" class="post-title-link" itemprop="url">插件化框架历史</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 11:22:02" itemprop="dateCreated datePublished" datetime="2020-07-16T11:22:02+08:00">2020-07-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、插件化框架历史<br>整个插件化框架历史部分参考了包建强在 2016GMTC 全球开发大会上的演讲<br>2012 年 AndroidDynamicLoader 给予 Fragment 实现了插件化框架，可以动态加载插件中的 Fragment 实现页面的切换。<br>2013 年 23Code 提供了一个壳，可以在壳里动态化下载插件然后运行。<br>2013 年 阿里技术沙龙上，伯奎做了 Atlas 插件化框架的分享，说明那时候阿里已经在做插件化的运用和开发了。<br>2014 年 任玉刚开源了 dynamic-load-apk，通过代理分发的方式实现了动态化，如果看过 Android 开发艺术探索这本书，应该会对这个方式有了解。<br>2015 年 张勇 发布了 DroidPlugin，使用 hook 系统方式实现插件化。<br>2015 年 携程发布 DynamicApk<br>2015 - 2016 之间（这块时间不太确定），Lody 发布了 VirtualApp，可以直接运行未安装的 apk，基本上还是使用 hook 系统的方式实现的，不过里面的实现要精致很多，实现了自己的一套 AMS 来管理插件 Activity 等等。<br>2017 年阿里推出 Atlas<br>2017 年 360 推出 RePlugin<br>2017 年滴滴推出 VirtualApk<br>2019 年腾讯推出了 Shadow，号称是零反射，并且框架自身也可实现动态化，看了代码以后发现，其实本质上还是使用了代理分发生命周期实现四大组件动态化，然后抽象接口来实现框架的动态化。后面有机会可以对其做一下分析。</p>
<p>这基本上就是插件化框架的历史，从 2012 至今，可以说插件化技术基本成型了，主要就是代理和 hook 系统两种方式（这里没有统计热修复的发展，热修复其实和插件化还是有些想通的地方，后面的文章会对热修复进行介绍）。如果看未来的话，斗胆预测，插件化技术的原理，应该不会有太大的变动了。</p>
<p>二、名词解释<br>在插件化中有一些专有名词，如果是第一次接触可能不太了解，这里解释一下。<br>宿主<br>负责加载插件的apk，一般来说就是已经安装的应用本身。<br>StubActivity<br>宿主中的占位 Activity，注册在宿主 Manifest 文件中，负责加载插件 Activity。<br>PluginActivity<br>插件 Activity，在插件 apk 中，没有注册在 Manifest 文件中，需要 StubActivity 来加载。</p>
<p>三、使用 gradle 简化插件开发流程<br>在学习和开发插件化的时候，我们需要动态去加载插件 apk，所以开发过程中一般需要有两个 apk，一个是宿主 apk，一个是插件 apk，对应的就需要有宿主项目和插件项目。<br>在 CommonTec 这里创建了 app 作为宿主项目，plugin 为插件项目。为了方便，我们直接把生成的插件 apk 放到宿主 apk 中的 assets 中，apk 启动时直接放到内部存储空间中方便加载。<br>这样的项目结构，我们调试问题时的流程就是下面这样：<br>修改插件项目 -&gt; 编译生成插件 apk -&gt; 拷贝插件 apk 到宿主 assets -&gt; 修改宿主项目 -&gt; 编译生成宿主 apk -&gt; 安装宿主 apk -&gt; 验证问题<br>如果每次我们修改一个很小的问题，都经历这么长的流程，那么耐心很快就耗尽了。最好是可以直接编译宿主 apk 的时候自动打包插件 apk 并拷贝到宿主 assets 目录下，这样我们不管修改什么，都直接编译宿主项目就好了。如何实现呢？还记得我们之前讲解过的 gradle 系列么？现在就是学以致用的时候了。<br>首先在 plugin 项目的 build.gradle 添加下面的代码：</p>
<p>project.afterEvaluate {<br>    project.tasks.each {<br>        if (it.name == “assembleDebug”) {<br>            it.doLast {<br>                copy {<br>                    from new File(project.getBuildDir(), ‘outputs/apk/debug/plugin-debug.apk’).absolutePath<br>                    into new File(project.getRootProject().getProjectDir(), ‘app/src/main/assets’)<br>                    rename ‘plugin-debug.apk’, ‘plugin.apk’<br>                }<br>            }<br>        }<br>    }<br>}<br>这段代码是在 afterEvaluate 的时候，遍历项目的 task，找到打包 task 也就是 assembleDebug，然后在打包之后，把生成的 apk 拷贝到宿主项目的 assets 目录下，并且重命名为 plugin.apk。 然后在 app 项目的 build.gradle 添加下面的代码：</p>
<p>project.afterEvaluate {<br>    project.tasks.each {<br>        if (it.name == ‘mergeDebugAssets’) {<br>            it.dependsOn ‘:plugin:assembleDebug’<br>        }<br>    }<br>}<br>找到宿主打包的 mergeDebugAssets 任务，依赖插件项目的打包，这样每次编译宿主项目的时候，会先编译插件项目，然后拷贝插件 apk 到宿主 apk 的 assets 目录下，以后每次修改，只要编译宿主项目就可以了。</p>
<p>四、ClassLoader<br>ClassLoader 是插件化中必须要掌握的，因为插件是未安装的 apk，系统不会处理其中的类，所以需要我们自己来处理。</p>
<p>4.1 java 中的 ClassLoader<br>BootstrapClassLoader<br>负责加载 JVM 运行时的核心类，比如 JAVA_HOME/lib/rt.jar 等等</p>
<p>ExtensionClassLoader<br>负责加载 JVM 的扩展类，比如 JAVA_HOME/lib/ext 下面的 jar 包</p>
<p>AppClassLoader<br>负责加载 classpath 里的 jar 包和目录</p>
<p>4.2 android 中的 ClassLoader<br>在这里，我们统称 dex 文件，包含 dex 的 apk 文件以及 jar 文件为 dex 文件 PathClassLoader 用来加载系统类和应用程序类，可以加载已经安装的 apk 目录下的 dex 文件</p>
<p>DexClassLoader 用来加载 dex 文件，可以从存储空间加载 dex 文件。</p>
<p>我们在插件化中一般使用的是 DexClassLoader。</p>
<p>4.3 双亲委派机制<br>每一个 ClassLoader 中都有一个 parent 对象，代表的是父类加载器，在加载一个类的时候，会先使用父类加载器去加载，如果在父类加载器中没有找到，自己再进行加载，如果 parent 为空，那么就用系统类加载器来加载。通过这样的机制可以保证系统类都是由系统类加载器加载的。 下面是 ClassLoader 的 loadClass 方法的具体实现。</p>
<p>protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);<br>            if (c == null) {<br>                try {<br>                    if (parent != null) {<br>                        // 先从父类加载器中进行加载<br>                        c = parent.loadClass(name, false);<br>                    } else {<br>                        c = findBootstrapClassOrNull(name);<br>                    }<br>                } catch (ClassNotFoundException e) {<br>                    // ClassNotFoundException thrown if class not found<br>                    // from the non-null parent class loader<br>                }</p>
<pre><code>            if (c == null) {
                // 没有找到，再自己加载
                c = findClass(name);
            }
        }
        return c;
}</code></pre><p>4.4 如何加载插件中的类<br>要加载插件中的类，我们首先要创建一个 DexClassLoader，先看下 DexClassLoader 的构造函数需要那些参数。</p>
<p>public class DexClassLoader extends BaseDexClassLoader {<br>    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) {<br>        // …<br>    }<br>}<br>构造函数需要四个参数：<br>dexPath 是需要加载的 dex / apk / jar 文件路径<br>optimizedDirectory 是 dex 优化后存放的位置，在 ART 上，会执行 oat 对 dex 进行优化，生成机器码，这里就是存放优化后的 odex 文件的位置<br>librarySearchPath 是 native 依赖的位置<br>parent 就是父类加载器，默认会先从 parent 加载对应的类</p>
<p>创建出 DexClassLaoder 实例以后，只要调用其 loadClass(className) 方法就可以加载插件中的类了。具体的实现在下面：</p>
<p>// 从 assets 中拿出插件 apk 放到内部存储空间<br>    private fun extractPlugin() {<br>        var inputStream = assets.open(“plugin.apk”)<br>        File(filesDir.absolutePath, “plugin.apk”).writeBytes(inputStream.readBytes())<br>    }</p>
<pre><code>private fun init() {
    extractPlugin()
    pluginPath = File(filesDir.absolutePath, &quot;plugin.apk&quot;).absolutePath
    nativeLibDir = File(filesDir, &quot;pluginlib&quot;).absolutePath
    dexOutPath = File(filesDir, &quot;dexout&quot;).absolutePath
    // 生成 DexClassLoader 用来加载插件类
    pluginClassLoader = DexClassLoader(pluginPath, dexOutPath, nativeLibDir, this::class.java.classLoader)
}</code></pre><p>五、插件化需要解决的难点<br>插件化，就是从插件中加载我们想要的类并运行，如果这个类是一个普通类，那么使用上面说到的 DexClassLoader 就可以直接加载了，如果这个类是特殊的类，比如说 Activity 等四大组件，那么就需要一些特殊的处理，因为四大组件是需要和系统进行交互的。插件化中，四大组件需要解决的难点如下：</p>
<p>Activity<br>生命周期如何调用<br>如何使用插件中的资源<br>Service<br>生命周期如何调用<br>BroadcastReceiver<br>静态广播和动态广播的注册<br>ContentProvider<br>如何注册插件 Provider 到系统</p>
<p>六、Activity 的插件化实现<br>6.1 难点分析<br>我们之前说到 Activity 插件化的难点，我们先来理顺一下为什么会有这两个问题。<br>因为插件是动态加载的，所以插件的四大组件不可能注册到宿主的 Manifest 文件中，而没有在 Manifest 中注册的四大组件是不能和系统直接进行交互的。<br>可能有些同学会问，那为什么不能直接把插件的 Activity 注册到宿主 Manifest 里呢？这样是可以，不过就失去了插件化的动态特性，如果每次插件中新增 Activity 都要修改宿主 Manifest 并且重新打包，那就和直接写在宿主中没什么区别了。<br>我们再来说一下为什么没有注册的 Activity 不能和系统交互<br>这里的不能直接交互的含义有两个</p>
<p>系统会检测 Activity 是否注册 如果我们启动一个没有在 Manifest 中注册的 Activity，会发现报如下 error：<br>android.content.ActivityNotFoundException: Unable to find explicit activity class {com.zy.commontec/com.zy.plugin.PluginActivity}; have you declared this activity in your AndroidManifest.xml?<br>这个 log 在 Instrumentation 的 checkStartActivityResult 方法中可以看到：</p>
<p>public class Instrumentation {<br>    public static void checkStartActivityResult(int res, Object intent) {<br>        if (!ActivityManager.isStartResultFatalError(res)) {<br>            return;<br>        }</p>
<pre><code>    switch (res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null)
                throw new ActivityNotFoundException(
                        &quot;Unable to find explicit activity class &quot;
                        + ((Intent)intent).getComponent().toShortString()
                        + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;);
            throw new ActivityNotFoundException(
                    &quot;No Activity found to handle &quot; + intent);
            ...
    }
}</code></pre><p>}<br>Activity 的生命周期无法被调用 其实一个 Activity 主要的工作，都是在其生命周期方法中调用了，既然上一步系统检测了 Manifest 注册文件，启动 Activity 被拒绝，那么其生命周期方法也肯定不会被调用了。从而插件 Activity 也就不能正常运行了。<br>其实上面两个问题，最终都指向同一个难点，那就是插件中的 Activity 的生命周期如何被调用。 解决问题之前我们先看一下正常系统是如何启动一个 Activity 的。<br>这里对 Activity 的启动流程进行一些简单的介绍，具体的流程代码就不分析了，因为分析的话大概又能写一篇文章了，而且其实关于 Activity 的启动过程也有不少文章有分析了。这里放一张简图说明一下：</p>
<p>整个调用路径如下：</p>
<p>Activity.startActivity -&gt; Instrumentation.execStartActivity -&gt; Binder -&gt; AMS.startActivity -&gt; ActivityStarter.startActivityMayWait -&gt; startActivityLocked -&gt; startActivityUnChecked -&gt; ActivityStackSupervisor.resumeFocusedStackTopActivityLocked -&gt; ActivityStatk.resumeTopAcitivityUncheckLocked -&gt; resumeTopActivityInnerLocked -&gt; ActivityStackSupervisor.startSpecificActivityLocked -&gt; realStartActivityLocked -&gt; Binder -&gt; ApplictionThread.scheduleLauchActivity -&gt; H -&gt; ActivityThread.scheduleLauchActivity -&gt; handleLaunchActivity -&gt; performLaunchActivity -&gt; Instrumentation.newActivity 创建 Activity -&gt; callActivityOnCreate 一系列生命周期<br>其实我们可以把 AMS 理解为一个公司的背后大 Boss，Activity 相当于小职员，没有权限直接和大 Boss 说话，想做什么事情都必须经过秘书向上汇报，然后秘书再把大 Boss AMS 的命令传达下来。而且大 Boss 那里有所有职员的名单，如果想要混入非法职员时不可能的。而我们想让没有在大 Boss 那里注册的编外人员执行任务，只有两种方法，一种是正式职员领取任务，再分发给编外人员，另一种就是欺骗 Boss，让 Boss 以为这个职员是已经注册的。</p>
<p>对应到实际的解决方法就是：</p>
<p>我们手动去调用插件 Activity 的生命周期<br>欺骗系统，让系统以为 Activity 是注册在 Manifest 中的<br>说完生命周期的问题，再来看一下资源的问题<br>在 Activity 中，基本上都会展示界面，而展示界面基本上都要用到资源。<br>在 Activity 中，有一个 mResources 变量，是 Resources 类型。这个变量可以理解为代表了整个 apk 的资源。</p>
<p>在宿主中调用的 Activity，mResources 自然代表了宿主的资源，所以需要我们对插件的资源进行特殊的处理。<br>我们先看一下如何生成代表插件资源的 Resources 类。<br>首先要生成一个 AssetManager 实例，然后通过其 addAssetPath 方法添加插件的路径，这样 AssetManager 中就包含了插件的资源。然后通过 Resources 构造函数生成插件资源。具体代码如下：</p>
<p>private fun handleResources() {<br>    try {<br>        // 首先通过反射生成 AssetManager 实例<br>        pluginAssetManager = AssetManager::class.java.newInstance()<br>        // 然后调用其 addAssetPath 把插件的路径添加进去。<br>        val addAssetPathMethod = pluginAssetManager?.javaClass?.getMethod(“addAssetPath”, String::class.java)<br>        addAssetPathMethod?.invoke(pluginAssetManager, pluginPath)<br>    } catch (e: Exception) {<br>    }<br>    // 调用 Resources 构造函数生成实例<br>    pluginResources = Resources(pluginAssetManager, super.getResources().displayMetrics, super.getResources().configuration)<br>}<br>前期准备的知识点差不多介绍完了，我们接着就看看具体的实现方法。</p>
<p>6.2 手动调用 Activity 生命周期<br>手动调用生命周期原理如下图：</p>
<p>我们手动调用插件 Activity 生命周期时，需要在正确的时机去调用，如何在正确的时机调用呢？那就是启动一个真正的 Activity，我们俗称占坑 Activity（StubActivity），然后在 StubActivity 的生命周期里调用插件 Activity 对应的生命周期，这样就间接的启动了插件 Activity。<br>在 StubActivity 中调用 插件 Activity 生命周期的方法有两种，一种是直接反射其生命周期方法，粗暴简单，唯一的缺点就是反射的效率问题。另外一种方式就是生成一个接口，接口里对应的是生命周期方法，让插件 Activity 实现这个接口，在 StubActivity 里就能直接调用接口方法了，从而避免了反射的效率低下问题。</p>
<p>具体的代码实现在CommonTec项目里可以找到，这里贴一下主要的实现（这里的实现和 CommonTec 里的可能会有些区别，CommonTec 里有些代码做了一些封装，这里主要做原理的解释）。</p>
<p>6.2.1 通过反射调用 Activity 生命周期<br>具体的实现见 反射调用生命周期，下面列出了重点代码。</p>
<p>class StubReflectActivity : Activity() {<br>    protected var activityClassLoader: ClassLoader? = null<br>    protected var activityName = “”<br>    private var pluginPath = “”<br>    private var nativeLibDir: String? = null<br>    private var dexOutPath: String? = null</p>
<pre><code>override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    nativeLibDir = File(filesDir, &quot;pluginlib&quot;).absolutePath
    dexOutPath = File(filesDir, &quot;dexout&quot;).absolutePath
    pluginPath = intent.getStringExtra(&quot;pluginPath&quot;)
    activityName = intent.getStringExtra(&quot;activityName&quot;)
    // 创建插件 ClassLoader
    activityClassLoader = DexClassLoader(pluginPath, dexOutPath, nativeLibDir, this::class.java.classLoader)
}

// 以 onCreate 方法为例，其他 onStart 等生命周期方法类似
fun onCreate(savedInstanceState: Bundle?) {
    // 获取插件 Activity 的 onCreate 方法并调用
    getMethod(&quot;onCreate&quot;, Bundle::class.java)?.invoke(activity, savedInstanceState)
}

fun getMethod(methodName: String, vararg params: Class&lt;*&gt;): Method? {
    return activityClassLoader?.loadClass(activity)?.getMethod(methodName, *params)
}</code></pre><p>}<br>6.2.2 通过接口调用 Activity 生命周期<br>具体的实现见 接口调用生命周期，下面列出了重点代码。 通过接口调用 Activity 生命周期的前提是要定义一个接口 IPluginActivity</p>
<p>interface IPluginActivity {<br>    fun attach(proxyActivity: Activity)<br>    fun onCreate(savedInstanceState: Bundle?)<br>    fun onStart()<br>    fun onResume()<br>    fun onPause()<br>    fun onStop()<br>    fun onDestroy()<br>}<br>然后在插件 Activity 中实现这个接口</p>
<p>open class BasePluginActivity : Activity(), IPluginActivity {<br>    var proxyActivity: Activity? = null</p>
<pre><code>override fun attach(proxyActivity: Activity) {
    this.proxyActivity = proxyActivity
}

override fun onCreate(savedInstanceState: Bundle?) {
    if (proxyActivity == null) {
        super.onCreate(savedInstanceState)
    }
}
// ...</code></pre><p>}<br>在 StubActivity 通过接口调用插件 Activity 生命周期</p>
<p>class StubInterfaceActivity : StubBaseActivity() {<br>    protected var activityClassLoader: ClassLoader? = null<br>    protected var activityName = “”<br>    private var pluginPath = “”</p>
<pre><code>private var activity: IPluginActivity? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    nativeLibDir = File(filesDir, &quot;pluginlib&quot;).absolutePath
    dexOutPath = File(filesDir, &quot;dexout&quot;).absolutePath
    pluginPath = intent.getStringExtra(&quot;pluginPath&quot;)
    activityName = intent.getStringExtra(&quot;activityName&quot;)
    // 生成插件 ClassLoader
    activityClassLoader = DexClassLoader(pluginPath, dexOutPath, nativeLibDir, this::class.java.classLoader)
    // 加载插件 Activity 类并转化成 IPluginActivity 接口
    activity = activityClassLoader?.loadClass(activityName)?.newInstance() as IPluginActivity?
    activity?.attach(this)
    // 通过接口直接调用对应的生命周期方法
    activity?.onCreate(savedInstanceState)
}</code></pre><p>}<br>6.2.3 资源处理方式</p>
<p>由于手动调用生命周期的方式，会重写大量的 Activity 生命周期方法，所以我们只要重写 getResources 方法，返回插件的资源实例就可以了。下面是具体代码。</p>
<p>open class StubBaseActivity : Activity() {</p>
<pre><code>protected var activityClassLoader: ClassLoader? = null
protected var activityName = &quot;&quot;
private var pluginPath = &quot;&quot;
private var pluginAssetManager: AssetManager? = null
private var pluginResources: Resources? = null
private var pluginTheme: Resources.Theme? = null
private var nativeLibDir: String? = null
private var dexOutPath: String? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    nativeLibDir = File(filesDir, &quot;pluginlib&quot;).absolutePath
    dexOutPath = File(filesDir, &quot;dexout&quot;).absolutePath
    pluginPath = intent.getStringExtra(&quot;pluginPath&quot;)
    activityName = intent.getStringExtra(&quot;activityName&quot;)
    activityClassLoader = DexClassLoader(pluginPath, dexOutPath, nativeLibDir, this::class.java.classLoader)
    handleResources()
}

override fun getResources(): Resources? {
    // 这里返回插件的资源，这样插件 Activity 中使用的就是插件资源了
    return pluginResources ?: super.getResources()
}

override fun getAssets(): AssetManager {
    return pluginAssetManager ?: super.getAssets()
}

override fun getClassLoader(): ClassLoader {
    return activityClassLoader ?: super.getClassLoader()
}

private fun handleResources() {
    try {
        // 生成 AssetManager
        pluginAssetManager = AssetManager::class.java.newInstance()
        // 添加插件 apk 路径
        val addAssetPathMethod = pluginAssetManager?.javaClass?.getMethod(&quot;addAssetPath&quot;, String::class.java)
        addAssetPathMethod?.invoke(pluginAssetManager, pluginPath)
    } catch (e: Exception) {
    }
    // 生成插件资源
    pluginResources = Resources(pluginAssetManager, super.getResources().displayMetrics, super.getResources().configuration)
}</code></pre><p>}<br>6.3 hook 系统相关实现的方式欺骗系统，让系统调用生命周期<br>6.3.1 hook Instrumentation<br>上面讲了如何通过手动调用插件 Activity 的生命周期方法来启动插件 Activity，现在来看一下欺骗系统的方法。<br>上面简单介绍了 Activity 的启动流程，我们可以看到，其实 Android 系统的运行是很巧妙的，AMS 是系统服务，应用通过 Binder 和 AMS 进行交互，其实和我们日常开发中客户端和服务端交互有些类似，只不过这里使用了 Binder 做为交互方式，关于 Binder，可以简单看看这篇文章。我们暂时只要知道通过 Binder 应用可以和 AMS 进行对话就行。<br>这种架构的设计方式，也为我们提供了一些机会。理论上来说，我们只要在启动 Activity 的消息到达 AMS 之前把 Activity 的信息就行修改，然后再消息回来以后再把信息恢复，就可以达到欺骗系统的目的了。<br>在这个流程里，有很多 hook 点可以进行，而且不同的插件化框架对于 hook 点的选择也不同，这里我们选择 hook Instrumentation 的方式进行介绍（原因是个人感觉这种方式要简单一点）。<br>简化以后的流程如下：</p>
<p>Instrumentation 相当于 Activity 的管理者，Activity 的创建，以及生命周期的调用都是 AMS 通知以后通过 Instrumentation 来调用的。<br>我们上面说到，AMS 相当于一个公司的背后大 Boss，而 Instrumentation 相当于秘书，Activity 相当于小职员，没有权限直接和大 Boss 说话，想做什么事情都必须经过秘书向上汇报，然后 Instrumentation 再把大 Boss AMS 的命令传达下来。而且大 Boss 那里有所有职员的名单，如果想要混入非法职员时不可能的。不过在整个过程中，由于 java 的语言特性，大 Boss 在和秘书 Instrumentation 对话时，不会管秘书到底是谁，只会确认这个人是不是秘书（是否是 Instrumentation 类型）。我们加载插件中的 Activity，相当于让一个不在 Boss 名单上的编外职员去申请执行任务。在正常情况下，大 Boss 会检查职员的名单，确认职员的合法性，一定是通过不了的。但是上有政策，下有对策，我们悄悄的替换了秘书，在秘书和 Boss 汇报时，把职员名字改成大 Boss 名单中的职员，在 Boss 安排工作以后，秘书再把名字换回来，让编外职员去执行任务。<br>而我们 hook 的方式就是替换调 Instrumentation，修改 Activity 类名，达到隐瞒 AMS 的效果。</p>
<p>hook 方式原理图</p>
<p>接下来看看具体的代码实现。 具体的实现见 hook 实现插件化，下面主要讲解重点代码。<br>替换 Instrumentation 之前，首先我们要实现一个我们自己的 Instrumentation，具体实现如下：</p>
<p>class AppInstrumentation(var realContext: Context, var base: Instrumentation, var pluginContext: PluginContext) :<br>    Instrumentation() {<br>    private val KEY_COMPONENT = “commontec_component”</p>
<pre><code>companion object {
    fun inject(activity: Activity, pluginContext: PluginContext) {
        // hook 系统，替换 Instrumentation 为我们自己的 AppInstrumentation，Reflect 是从 VirtualApp 里拷贝的反射工具类，使用很流畅~
        var reflect = Reflect.on(activity)
        var activityThread = reflect.get&lt;Any&gt;(&quot;mMainThread&quot;)
        var base = Reflect.on(activityThread).get&lt;Instrumentation&gt;(&quot;mInstrumentation&quot;)
        var appInstrumentation = AppInstrumentation(activity, base, pluginContext)
        Reflect.on(activityThread).set(&quot;mInstrumentation&quot;, appInstrumentation)
        Reflect.on(activity).set(&quot;mInstrumentation&quot;, appInstrumentation)
    }
}

override fun newActivity(cl: ClassLoader, className: String, intent: Intent): Activity? {
    // 创建 Activity 的时候会调用这个方法，在这里需要返回插件 Activity 的实例
    val componentName = intent.getParcelableExtra&lt;ComponentName&gt;(KEY_COMPONENT)
    var clazz = pluginContext.classLoader.loadClass(componentName.className)
    intent.component = componentName
    return clazz.newInstance() as Activity?
}

private fun injectIntent(intent: Intent?) {
    var component: ComponentName? = null
    var oldComponent = intent?.component
    if (component == null || component.packageName == realContext.packageName) {
        // 替换 intent 中的类名为占位 Activity 的类名，这样系统在 Manifest 中查找的时候就可以找到 Activity
        component = ComponentName(&quot;com.zy.commontec&quot;, &quot;com.zy.commontec.activity.hook.HookStubActivity&quot;)
        intent?.component = component
        intent?.putExtra(KEY_COMPONENT, oldComponent)
    }
}

fun execStartActivity(
    who: Context,
    contextThread: IBinder,
    token: IBinder,
    target: Activity,
    intent: Intent,
    requestCode: Int
): Instrumentation.ActivityResult? {
    // 启动 activity 的时候会调用这个方法，在这个方法里替换 Intent 中的 ClassName 为已经注册的宿主 Activity
    injectIntent(intent)
    return Reflect.on(base)
        .call(&quot;execStartActivity&quot;, who, contextThread, token, target, intent, requestCode).get()
}
// ...</code></pre><p>}<br>在 AppInstrumentation 中有两个关键点，execStartActivity 和 newActivity。<br>execStartActivity 是在启动 Activity 的时候必经的一个过程，这时还没有到达 AMS，所以，在这里把 Activity 替换成宿主中已经注册的 StubActivity，这样 AMS 在检测 Activity 的时候就认为已经注册过了。newActivity 是创建 Activity 实例，这里要返回真正需要运行的插件 Activity，这样后面系统就会基于这个 Activity 实例来进行对应的生命周期的调用。</p>
<p>6.3.2 hook 系统的资源处理方式<br>因为我们 hook 了 Instrumentation 的实现，还是把 Activity 生命周期的调用交给了系统，所以我们的资源处理方式和手动调用生命周期不太一样，这里我们生成 Resources 以后，直接反射替换掉 Activity 中的 mResource 变量即可。下面是具体代码。</p>
<p>class AppInstrumentation(var realContext: Context, var base: Instrumentation, var pluginContext: PluginContext) : Instrumentation() {<br>    private fun injectActivity(activity: Activity?) {<br>        val intent = activity?.intent<br>        val base = activity?.baseContext<br>        try {<br>            // 反射替换 mResources 资源<br>            Reflect.on(base).set(“mResources”, pluginContext.resources)<br>            Reflect.on(activity).set(“mResources”, pluginContext.resources)<br>            Reflect.on(activity).set(“mBase”, pluginContext)<br>            Reflect.on(activity).set(“mApplication”, pluginContext.applicationContext)<br>            // for native activity<br>            val componentName = intent!!.getParcelableExtra<ComponentName>(KEY_COMPONENT)<br>            val wrapperIntent = Intent(intent)<br>            wrapperIntent.setClassName(componentName.packageName, componentName.className)<br>            activity.intent = wrapperIntent<br>        } catch (e: Exception) {<br>        }<br>    }</p>
<pre><code>override fun callActivityOnCreate(activity: Activity?, icicle: Bundle?) {
    // 在这里进行资源的替换
    injectActivity(activity)
    super.callActivityOnCreate(activity, icicle)
}</code></pre><p>}</p>
<p>public class PluginContext extends ContextWrapper {<br>    private void generateResources() {<br>        try {<br>            // 反射生成 AssetManager 实例<br>            assetManager = AssetManager.class.newInstance();<br>            // 调用 addAssetPath 添加插件路径<br>            Method method = assetManager.getClass().getMethod(“addAssetPath”, String.class);<br>            method.invoke(assetManager, pluginPath);<br>            // 生成 Resources 实例<br>            resources = new Resources(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());<br>        } catch (Exception e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br>讲完上面两种方法，我们这里对比一下这两种方法的优缺点：</p>
<p>实现方法优点缺点手动调用1. 比较稳定，不需要 hook 系统实现 2. 实现相对简单，不需要对系统内部实现做过多了解通过反射效率太低，通过接口需要实现的方法数量很多hook 系统1. 不需要实现大量接口方法 2. 由于最终还是交给系统去处理，各种处理相对比较完整1. 需要适配不同的系统及设备 2. 对开发者要求比较高，需要对系统实现有深入的了解</p>
<p>七、Service 的插件化实现<br>Service 比起 Activity 要简单不少，Service 没有太复杂的生命周期需要处理，类似的 onCreate 或者 onStartCommand 可以直接通过代理分发。可以直接在宿主 app 里添加一个占位 Service，然后在对应的生命周期里调用插件 Service 的生命周期方法即可。</p>
<p>class StubService : Service() {<br>    var serviceName: String? = null<br>    var pluginService: Service? = null</p>
<pre><code>companion object {
    var pluginClassLoader: ClassLoader? = null
    fun startService(context: Context, classLoader: ClassLoader, serviceName: String) {
        pluginClassLoader = classLoader
        val intent = Intent(context, StubService::class.java)
        intent.putExtra(&quot;serviceName&quot;, serviceName)
        context.startService(intent)
    }
}

override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    val res = super.onStartCommand(intent, flags, startId)
    serviceName = intent?.getStringExtra(&quot;serviceName&quot;)
    pluginService = pluginClassLoader?.loadClass(serviceName)?.newInstance() as Service
    pluginService?.onCreate()
    return pluginService?.onStartCommand(intent, flags, startId) ?: res
}

override fun onDestroy() {
    super.onDestroy()
    pluginService?.onDestroy()
}

override fun onBind(intent: Intent?): IBinder? {
    return null
}</code></pre><p>}<br>八、BroadcastReceiver 的插件化实现<br>动态广播的处理也比较简单，也没有复杂的生命周期，也不需要在 Manifest 中进行注册，使用的时候直接注册即可。所以只要通过 ClassLoader 加载插件 apk 中的广播类然后直接注册就好。</p>
<p>class BroadcastUtils {<br>    companion object {<br>        private val broadcastMap = HashMap&lt;String, BroadcastReceiver&gt;()</p>
<pre><code>    fun registerBroadcastReceiver(context: Context, classLoader: ClassLoader, action: String, broadcastName: String) {
        val receiver = classLoader.loadClass(broadcastName).newInstance() as BroadcastReceiver
        val intentFilter = IntentFilter(action)
        context.registerReceiver(receiver, intentFilter)
        broadcastMap[action] = receiver
    }

    fun unregisterBroadcastReceiver(context: Context, action: String) {
        val receiver = broadcastMap.remove(action)
        context.unregisterReceiver(receiver)
    }
}</code></pre><p>}<br>静态广播稍微麻烦一点，这里可以解析 Manifest 文件找到其中静态注册的 Broadcast 并进行动态注册，这里就不对 Manifest 进行解析了，知道其原理即可。</p>
<p>九、ContentProvider 的插件化实现<br>其实在日常开发中对于插件化中的 ContentProvider 使用还是比较少的，这里只介绍一种比较简单的 ContentProvider 插件化实现方法，就是类似 Service，在宿主 app 中注册占位 ContentProvider，然后转发相应的操作到插件 ContentProvider 中。代码如下：</p>
<p>class StubContentProvider : ContentProvider() {</p>
<pre><code>private var pluginProvider: ContentProvider? = null
private var uriMatcher: UriMatcher? = UriMatcher(UriMatcher.NO_MATCH)

override fun insert(uri: Uri?, values: ContentValues?): Uri? {
    loadPluginProvider()
    return pluginProvider?.insert(uri, values)
}

override fun query(uri: Uri?, projection: Array&lt;out String&gt;?, selection: String?, selectionArgs: Array&lt;out String&gt;?, sortOrder: String?): Cursor? {
    loadPluginProvider()
    if (isPlugin1(uri)) {
        return pluginProvider?.query(uri, projection, selection, selectionArgs, sortOrder)
    }
    return null
}

override fun onCreate(): Boolean {
    uriMatcher?.addURI(&quot;com.zy.stubprovider&quot;, &quot;plugin1&quot;, 0)
    uriMatcher?.addURI(&quot;com.zy.stubprovider&quot;, &quot;plugin2&quot;, 0)
    return true
}

override fun update(uri: Uri?, values: ContentValues?, selection: String?, selectionArgs: Array&lt;out String&gt;?): Int {
    loadPluginProvider()
    return pluginProvider?.update(uri, values, selection, selectionArgs) ?: 0
}

override fun delete(uri: Uri?, selection: String?, selectionArgs: Array&lt;out String&gt;?): Int {
    loadPluginProvider()
    return pluginProvider?.delete(uri, selection, selectionArgs) ?: 0
}

override fun getType(uri: Uri?): String {
    loadPluginProvider()
    return pluginProvider?.getType(uri) ?: &quot;&quot;
}

private fun loadPluginProvider() {
    if (pluginProvider == null) {
        pluginProvider = PluginUtils.classLoader?.loadClass(&quot;com.zy.plugin.PluginContentProvider&quot;)?.newInstance() as ContentProvider?
    }
}

private fun isPlugin1(uri: Uri?): Boolean {
    if (uriMatcher?.match(uri) == 0) {
        return true
    }
    return false
}</code></pre><p>}<br>这里面需要处理的就是，如何转发对应的 Uri 到正确的插件 Provider 中呢，解决方案是在 Uri 中定义不同的插件路径，比如 plugin1 的 Uri 对应就是 content://com.zy.stubprovider/plugin1，plugin2 对应的 uri 就是 content://com.zy.stubprovider/plugin2，然后在 StubContentProvider 中根据对应的 plugin 分发不同的插件 Provider。</p>
<p>十、总结<br>本文介绍了插件化的相关实现，主要集中在 Activity 的实现上。重点如下：</p>
<p>最后推荐大家在学习插件化的同时，也去学习一些四大组件以及 Binder 的系统实现~</p>
<p>推荐学习资料<br>插件化历史<br><a href="https://www.infoq.cn/article/android-plug-ins-from-entry-to-give-up/" target="_blank" rel="noopener">https://www.infoq.cn/article/android-plug-ins-from-entry-to-give-up/</a><br>Activity 启动流程<br><a href="https://blog.csdn.net/AndrLin/article/details/79523935" target="_blank" rel="noopener">https://blog.csdn.net/AndrLin/article/details/79523935</a><br><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">http://gityuan.com/2016/03/12/start-activity/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/ANR%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/ANR%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">ANR原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 11:21:45" itemprop="dateCreated datePublished" datetime="2020-07-16T11:21:45+08:00">2020-07-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、概述<br>二、ANR触发时机<br>2.1 Service Timeout<br>2.2 BroadcastQueue Timeout<br>2.3 ContentProvider Timeout<br>2.4 inputDispatching Timeout<br>2.5 keyDispatching Timeout<br>三、ANR工作<br>3.1 appNotResponding<br>四、其他<br>导致ANR常见情形：<br>避免ANR:<br>五、遇到ANR怎么分析<br>导出trace文件<br>trace文件格式解析<br>通过分析trace文件得到ANR信息<br>trace文件顶部的线程一般是ANR的元凶<br>注意死锁和等待<br>Android ANR源码原理分析</p>
<p>ANR即Application Not Responding，顾名思义就是应用程序无响应。在Android中，一般情况下，四大组件均是工作在主线程中的，Android中的Activity Manager和Window Manager会随时监控应用程序的响应情况，如果因为一些耗时操作（网络请求或者IO操作）造成主线程阻塞一定时间（例如造成5s内不能响应用户事件或者BroadcastReceiver的onReceive方法执行时间超过10s），那么系统就会显示ANR对话框提示用户对应的应用处于无响应状态。</p>
<p>虽然每个程序员都不想ANR发生在自己的头上，因此，你需要严格遵守Google提供的一系列建议（看这里），简单总结就是以下两点：</p>
<ol>
<li>不要让主线程干耗时的工作</li>
<li>不要让其他线程阻塞主线程的执行<br>因此，要尽量保证主线程执行工作干净利落，一个消息循环执行时间最好不超过100ms到200ms，对于一些脏活累活可以交给AsyncTask、HandlerThread、IntentService或者另外起的新线程来完成，这样应用程序就能够及时响应用户的操作而不会给用户带来卡顿的感觉。</li>
</ol>
<p>一、概述<br>ANR(Application Not responding)，是指应用程序未响应，Android系统对于一些事件需要在一定的时间范围内完成，如果超过预定时间能未能得到有效响应或者响应时间过长，都会造成ANR。一般地，这时往往会弹出一个提示框，告知用户当前xxx未响应，用户可选择继续等待或者Force Close。</p>
<p>那么哪些场景会造成ANR呢？</p>
<p>Service Timeout:服务在20s内未执行完成；<br>BroadcastQueue Timeout：比如前台广播在10s内执行完成<br>ContentProvider Timeout：内容提供者执行超时<br>inputDispatching Timeout: 输入事件分发超时5s，包括按键分发事件的超时。<br>二、ANR触发时机<br>2.1 Service Timeout<br>Service Timeout触发时机，简单说就是AMS中的mHandler收到SERVICE_TIMEOUT_MSG消息时触发。</p>
<p>在前面文章startService流程分析详细介绍Service启动流程，在Service所在进程attach到system_server进程的过程中会调用realStartServiceLocked()方法</p>
<p>2.1.1 realStartServiceLocked</p>
<p>[-&gt; ActiveServices.java]</p>
<p>private final void realStartServiceLocked(ServiceRecord r,<br>        ProcessRecord app, boolean execInFg) throws RemoteException {<br>    …<br>    //发送delay消息(SERVICE_TIMEOUT_MSG)，【见小节2.1.2】<br>    bumpServiceExecutingLocked(r, execInFg, “create”);<br>    try {<br>        …<br>        //最终执行服务的onCreate()方法<br>        app.thread.scheduleCreateService(r, r.serviceInfo,<br>                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),<br>                app.repProcState);</p>
<pre><code>    } catch (DeadObjectException e) {
        ...
} finally {
    if (!created) {
        //当service启动完毕，则remove SERVICE_TIMEOUT_MSG消息【见小节2.1.3】
        serviceDoneExecutingLocked(r, inDestroying, inDestroying);
        ...
    }
}</code></pre><p>}<br>2.1.2 bumpServiceExecutingLocked</p>
<p>该方法的主要工作发送delay消息(SERVICE_TIMEOUT_MSG)</p>
<p>private final void bumpServiceExecutingLocked(ServiceRecord r, boolean fg, String why) {<br>    …<br>    scheduleServiceTimeoutLocked(r.app);<br>}<br>void scheduleServiceTimeoutLocked(ProcessRecord proc) {<br>    if (proc.executingServices.size() == 0 || proc.thread == null) {<br>        return;<br>    }<br>    long now = SystemClock.uptimeMillis();<br>    Message msg = mAm.mHandler.obtainMessage(<br>            ActivityManagerService.SERVICE_TIMEOUT_MSG);<br>    msg.obj = proc;<br>    //当超时后仍没有remove该SERVICE_TIMEOUT_MSG消息，则执行service Timeout流程【见2.1.4】<br>    mAm.mHandler.sendMessageAtTime(msg,<br>            proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));<br>}<br>对于前台服务，则超时为SERVICE_TIMEOUT，即timeout=20s；<br>对于后台服务，则超时为SERVICE_BACKGROUND_TIMEOUT，即timeout=200s；<br>2.1.3 serviceDoneExecutingLocked</p>
<p>该方法的主要工作是当service启动完成，则移除service Timeout消息。</p>
<p>private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying,<br>            boolean finishing) {<br>    …<br>    if (r.executeNesting &lt;= 0) {<br>        if (r.app != null) {<br>            r.app.execServicesFg = false;<br>            r.app.executingServices.remove(r);<br>            if (r.app.executingServices.size() == 0) {<br>                //当前服务所在进程中没有正在执行的service<br>                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);<br>        …<br>    }<br>    …<br>}<br>2.1.4 SERVICE_TIMEOUT_MSG</p>
<p>到此不难理解，当SERVICE_TIMEOUT_MSG消息成功发送时，则AMS中的mHandler收到该消息则触发调用serviceTimeout。</p>
<p>final class MainHandler extends Handler {<br>    public void handleMessage(Message msg) {<br>        switch (msg.what) {<br>            case SERVICE_TIMEOUT_MSG: {<br>                …<br>                //【见小节2.1.5】<br>                mServices.serviceTimeout((ProcessRecord)msg.obj);<br>            } break;<br>            …<br>        }<br>        …<br>    }<br>}<br>2.1.5 serviceTimeout</p>
<p>[-&gt; ActiveServices.java]</p>
<p>void serviceTimeout(ProcessRecord proc) {<br>    String anrMessage = null;</p>
<pre><code>synchronized(mAm) {
    if (proc.executingServices.size() == 0 || proc.thread == null) {
        return;
    }
    final long now = SystemClock.uptimeMillis();
    final long maxTime =  now -
            (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);
    ServiceRecord timeout = null;
    long nextTime = 0;
    for (int i=proc.executingServices.size()-1; i&gt;=0; i--) {
        ServiceRecord sr = proc.executingServices.valueAt(i);
        if (sr.executingStart &lt; maxTime) {
            timeout = sr;
            break;
        }
        if (sr.executingStart &gt; nextTime) {
            nextTime = sr.executingStart;
        }
    }
    if (timeout != null &amp;&amp; mAm.mLruProcesses.contains(proc)) {
        Slog.w(TAG, &quot;Timeout executing service: &quot; + timeout);
        StringWriter sw = new StringWriter();
        PrintWriter pw = new FastPrintWriter(sw, false, 1024);
        pw.println(timeout);
        timeout.dump(pw, &quot;    &quot;);
        pw.close();
        mLastAnrDump = sw.toString();
        mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);
        mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);
        anrMessage = &quot;executing service &quot; + timeout.shortName;
    }
}

if (anrMessage != null) {
    //当存在timeout的service，则执行appNotResponding【见小节3.1】
    mAm.appNotResponding(proc, null, null, false, anrMessage);
}</code></pre><p>}<br>其中anrMessage的内容为”executing service [发送超时serviceRecord信息]”;</p>
<p>2.2 BroadcastQueue Timeout<br>BroadcastQueue Timeout触发时机，简单说就是BroadcastQueue中的mHandler收到BROADCAST_TIMEOUT_MSG消息时触发。</p>
<p>在前面文章Android Broadcast广播机制分析详细介绍广播启动流程，在发送广播过程中会执行scheduleBroadcastsLocked方法来处理相关的广播，然后会调用到processNextBroadcast方法来处理下一条广播。</p>
<p>processNextBroadcast执行过程分4步骤：</p>
<p>step1. 处理并行广播<br>step2. 处理当前有序广播<br>step3. 获取下条有序广播<br>step4. 处理下条有序广播<br>2.2.1 processNextBroadcast</p>
<p>[-&gt; BroadcastQueue.java]</p>
<p>final void processNextBroadcast(boolean fromMsg) {<br>    synchronized(mService) {<br>        …<br>        //step 2: 处理当前有序广播<br>        do {<br>            r = mOrderedBroadcasts.get(0);<br>            //获取所有该广播所有的接收者<br>            int numReceivers = (r.receivers != null) ? r.receivers.size() : 0;<br>            if (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) {<br>                long now = SystemClock.uptimeMillis();<br>                if ((numReceivers &gt; 0) &amp;&amp;<br>                        (now &gt; r.dispatchTime + (2<em>mTimeoutPeriod</em>numReceivers))) {<br>                    //当广播处理时间超时，则强制结束这条广播【见小节2.2.5】<br>                    broadcastTimeoutLocked(false);<br>                    …<br>                }<br>            }<br>            if (r.receivers == null || r.nextReceiver &gt;= numReceivers<br>                    || r.resultAbort || forceReceive) {<br>                if (r.resultTo != null) {<br>                    //处理广播消息消息<br>                    performReceiveLocked(r.callerApp, r.resultTo,<br>                        new Intent(r.intent), r.resultCode,<br>                        r.resultData, r.resultExtras, false, false, r.userId);<br>                    r.resultTo = null;<br>                }<br>                //取消BROADCAST_TIMEOUT_MSG消息【见小节2.2.3】<br>                cancelBroadcastTimeoutLocked();<br>            }<br>        } while (r == null);<br>        …</p>
<pre><code>    //step 3: 获取下条有序广播
    r.receiverTime = SystemClock.uptimeMillis();
    if (!mPendingBroadcastTimeoutMessage) {
        long timeoutTime = r.receiverTime + mTimeoutPeriod;
        //设置广播超时时间，发送BROADCAST_TIMEOUT_MSG【见小节2.2.2】
        setBroadcastTimeoutLocked(timeoutTime);
    }
    ...
}</code></pre><p>}<br>对于广播超时处理时机：</p>
<p>首先在step3的过程中setBroadcastTimeoutLocked(timeoutTime) 设置超时广播消息；<br>然后在step2根据广播处理情况来处理：<br>当广播接收者等待时间过长，则调用broadcastTimeoutLocked(false);<br>当，cancelBroadcastTimeoutLocked<br>2.2.2 setBroadcastTimeoutLocked</p>
<p>final void setBroadcastTimeoutLocked(long timeoutTime) {<br>    if (! mPendingBroadcastTimeoutMessage) {<br>        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);<br>        mHandler.sendMessageAtTime(msg, timeoutTime);<br>        mPendingBroadcastTimeoutMessage = true;<br>    }<br>}<br>设置定时广播BROADCAST_TIMEOUT_MSG，即当前往后推mTimeoutPeriod时间广播还没处理完毕，则进入广播超时流程。</p>
<p>对于前台广播，则超时为BROADCAST_FG_TIMEOUT，即timeout=10s；<br>对于后台广播，则超时为BROADCAST_BG_TIMEOUT，即timeout=60s。<br>2.2.3 cancelBroadcastTimeoutLocked</p>
<p>final void cancelBroadcastTimeoutLocked() {<br>    if (mPendingBroadcastTimeoutMessage) {<br>        mHandler.removeMessages(BROADCAST_TIMEOUT_MSG, this);<br>        mPendingBroadcastTimeoutMessage = false;<br>    }<br>}<br>移除广播超时消息BROADCAST_TIMEOUT_MSG</p>
<p>2.2.4 BROADCAST_TIMEOUT_MSG</p>
<p>到此不难理解，当BROADCAST_TIMEOUT_MSG消息成功发送时，则AMS中的mHandler收到该消息则触发调用serviceTimeout。</p>
<p>private final class BroadcastHandler extends Handler {<br>    public void handleMessage(Message msg) {<br>        switch (msg.what) {<br>            case BROADCAST_TIMEOUT_MSG: {<br>                synchronized (mService) {<br>                    //【见小节2.2.5】<br>                    broadcastTimeoutLocked(true);<br>                }<br>            } break;<br>            …<br>        }<br>        …<br>    }<br>}<br>2.2.5 broadcastTimeoutLocked</p>
<p>[-&gt; BroadcastRecord.java]</p>
<p>final void broadcastTimeoutLocked(boolean fromMsg) {<br>    if (fromMsg) {<br>        mPendingBroadcastTimeoutMessage = false;<br>    }</p>
<pre><code>if (mOrderedBroadcasts.size() == 0) {
    return;
}

long now = SystemClock.uptimeMillis();
BroadcastRecord r = mOrderedBroadcasts.get(0);
if (fromMsg) {
    if (mService.mDidDexOpt) {
        //延迟timeouts直到dexopt结束
        mService.mDidDexOpt = false;
        long timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod;
        setBroadcastTimeoutLocked(timeoutTime);
        return;
    }
    if (!mService.mProcessesReady) {
        //当系统还没有准备就绪时，广播处理流程中不存在广播超时
        return;
    }

    long timeoutTime = r.receiverTime + mTimeoutPeriod;
    if (timeoutTime &gt; now) {
        //过早的timeout，重新设置广播超时
        setBroadcastTimeoutLocked(timeoutTime);
        return;
    }
}

BroadcastRecord br = mOrderedBroadcasts.get(0);
if (br.state == BroadcastRecord.WAITING_SERVICES) {
    //广播已经处理完成，但需要等待已启动service执行完成。当等待足够时间，则处理下一条广播。
    br.curComponent = null;
    br.state = BroadcastRecord.IDLE;
    processNextBroadcast(false);
    return;
}

r.receiverTime = now;
//当前BroadcastRecord的anr次数执行加1操作
r.anrCount++;

if (r.nextReceiver &lt;= 0) {
    return;
}

ProcessRecord app = null;
String anrMessage = null;

Object curReceiver = r.receivers.get(r.nextReceiver-1);
//根据情况记录广播接收者丢弃的EventLog
logBroadcastReceiverDiscardLocked(r);
if (curReceiver instanceof BroadcastFilter) {
    BroadcastFilter bf = (BroadcastFilter)curReceiver;
    if (bf.receiverList.pid != 0
            &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) {
        synchronized (mService.mPidsSelfLocked) {
            app = mService.mPidsSelfLocked.get(
                    bf.receiverList.pid);
        }
    }
} else {
    app = r.curApp;
}

if (app != null) {
    anrMessage = &quot;Broadcast of &quot; + r.intent.toString();
}

if (mPendingBroadcast == r) {
    mPendingBroadcast = null;
}

//继续移动到下一个广播接收者
finishReceiverLocked(r, r.resultCode, r.resultData,
        r.resultExtras, r.resultAbort, false);
scheduleBroadcastsLocked();

if (anrMessage != null) {
    //【见小节2.2.6】
    mHandler.post(new AppNotResponding(app, anrMessage));
}</code></pre><p>}<br>2.2.6 AppNotResponding</p>
<p>[-&gt; BroadcastQueue.java]</p>
<p>private final class AppNotResponding implements Runnable {<br>    …<br>    public void run() {<br>        //【见小节3.1】<br>        mService.appNotResponding(mApp, null, null, false, mAnnotation);<br>    }<br>}<br>2.3 ContentProvider Timeout<br>2.3.1 AMS.appNotRespondingViaProvider</p>
<p>public void appNotRespondingViaProvider(IBinder connection) {<br>    enforceCallingPermission(<br>            android.Manifest.permission.REMOVE_TASKS, “appNotRespondingViaProvider()”);</p>
<pre><code>final ContentProviderConnection conn = (ContentProviderConnection) connection;
if (conn == null) {
    return;
}

final ProcessRecord host = conn.provider.proc;
//无法找到provider所处的进程
if (host == null) {
    return;
}

final long token = Binder.clearCallingIdentity();
try {
    //【见小节3.1】
    appNotResponding(host, null, null, false, &quot;ContentProvider not responding&quot;);
} finally {
    Binder.restoreCallingIdentity(token);
}</code></pre><p>}<br>Timeout时间20s</p>
<p>调用链：</p>
<p>ContentProviderClient.NotRespondingRunnable.run<br>    ContextImpl.ApplicationContentResolver.appNotRespondingViaProvider<br>        ActivityThread.appNotRespondingViaProvider<br>            AMP.appNotRespondingViaProvider<br>                AMS.appNotRespondingViaProvider</p>
<p>2.4 inputDispatching Timeout<br>在native层InputDispatcher.cpp中经过层层调用，此处先省略过程，后续再展开，从native层com_android_server_input_InputManagerService调用到java层InputManagerService。</p>
<p>2.4.1 IMS.notifyANR</p>
<p>[-&gt; InputManagerService.java]</p>
<p>private long notifyANR(InputApplicationHandle inputApplicationHandle,<br>        InputWindowHandle inputWindowHandle, String reason) {<br>    //【见小节2.4.2】<br>    return mWindowManagerCallbacks.notifyANR(<br>            inputApplicationHandle, inputWindowHandle, reason);<br>}<br>mWindowManagerCallbacks为InputMonitor对象</p>
<p>2.4.2 notifyANR</p>
<p>[-&gt; InputMonitor.java]</p>
<p>public long notifyANR(InputApplicationHandle inputApplicationHandle,<br>        InputWindowHandle inputWindowHandle, String reason) {<br>    AppWindowToken appWindowToken = null;<br>    WindowState windowState = null;<br>    boolean aboveSystem = false;<br>    synchronized (mService.mWindowMap) {<br>        if (inputWindowHandle != null) {<br>            windowState = (WindowState) inputWindowHandle.windowState;<br>            if (windowState != null) {<br>                appWindowToken = windowState.mAppToken;<br>            }<br>        }<br>        if (appWindowToken == null &amp;&amp; inputApplicationHandle != null) {<br>            appWindowToken = (AppWindowToken)inputApplicationHandle.appWindowToken;<br>        }<br>        //输出input事件分发超时log<br>        if (windowState != null) {<br>            Slog.i(WindowManagerService.TAG, “Input event dispatching timed out “<br>                    + “sending to “ + windowState.mAttrs.getTitle()<br>                    + “.  Reason: “ + reason);<br>            int systemAlertLayer = mService.mPolicy.windowTypeToLayerLw(<br>                    WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);<br>            aboveSystem = windowState.mBaseLayer &gt; systemAlertLayer;<br>        } else if (appWindowToken != null) {<br>            Slog.i(WindowManagerService.TAG, “Input event dispatching timed out “<br>                    + “sending to application “ + appWindowToken.stringName<br>                    + “.  Reason: “ + reason);<br>        } else {<br>            Slog.i(WindowManagerService.TAG, “Input event dispatching timed out “<br>                    + “.  Reason: “ + reason);<br>        }<br>        mService.saveANRStateLocked(appWindowToken, windowState, reason);<br>    }</p>
<pre><code>if (appWindowToken != null &amp;&amp; appWindowToken.appToken != null) {
    //【见小节2.5.1】
    boolean abort = appWindowToken.appToken.keyDispatchingTimedOut(reason);
    if (! abort) {
        return appWindowToken.inputDispatchingTimeoutNanos;
    }
} else if (windowState != null) {
    //AMP经过binder，最终调用到AMS【见小节2.4.3】
    long timeout = ActivityManagerNative.getDefault().inputDispatchingTimedOut(
            windowState.mSession.mPid, aboveSystem, reason);
    if (timeout &gt;= 0) {
        return timeout * 1000000L; //转化为纳秒
    }
}
return 0;</code></pre><p>}<br>2.4.3 AMS.inputDispatchingTimedOut</p>
<p>public long inputDispatchingTimedOut(int pid, final boolean aboveSystem, String reason) {<br>    …<br>    ProcessRecord proc;<br>    long timeout;<br>    synchronized (this) {<br>        synchronized (mPidsSelfLocked) {<br>            proc = mPidsSelfLocked.get(pid); //根据pid查看进程record<br>        }<br>        timeout = getInputDispatchingTimeoutLocked(proc);<br>    }<br>    //【见小节2.4.4】<br>    if (!inputDispatchingTimedOut(proc, null, null, aboveSystem, reason)) {<br>        return -1;<br>    }</p>
<pre><code>return timeout;</code></pre><p>}<br>inputDispatching的超时为KEY_DISPATCHING_TIMEOUT，即timeout = 5s</p>
<p>2.4.4 AMS.inputDispatchingTimedOut</p>
<p>public boolean inputDispatchingTimedOut(final ProcessRecord proc,<br>        final ActivityRecord activity, final ActivityRecord parent,<br>        final boolean aboveSystem, String reason) {<br>    …<br>    final String annotation;<br>    if (reason == null) {<br>        annotation = “Input dispatching timed out”;<br>    } else {<br>        annotation = “Input dispatching timed out (“ + reason + “)”;<br>    }</p>
<pre><code>if (proc != null) {
    ...
    mHandler.post(new Runnable() {
        public void run() {
            //【见小节3.1】
            appNotResponding(proc, activity, parent, aboveSystem, annotation);
        }
    });
}
return true;</code></pre><p>}<br>调用链：</p>
<p>InputManagerService.notifyANR<br>    InputMonitor.notifyANR<br>        AMP.inputDispatchingTimedOut<br>            AMS.inputDispatchingTimedOut<br>2.5 keyDispatching Timeout<br>keyDispatching timout与inputDispatching Timeout流畅基本一致。</p>
<p>调用链：</p>
<p>InputManagerService.notifyANR<br>    InputMonitor.notifyANR<br>        ActivityRecord.Token.keyDispatchingTimedOut<br>            AMS.inputDispatchingTimedOut<br>Token.keyDispatchingTimedOut</p>
<p>[-&gt; ActivityRecord.java]</p>
<p>final class ActivityRecord {<br>    static class Token extends IApplicationToken.Stub {<br>        public boolean keyDispatchingTimedOut(String reason) {<br>            ActivityRecord r;<br>            ActivityRecord anrActivity;<br>            ProcessRecord anrApp;<br>            synchronized (mService) {<br>                r = tokenToActivityRecordLocked(this);<br>                if (r == null) {<br>                    return false;<br>                }<br>                anrActivity = r.getWaitingHistoryRecordLocked();<br>                anrApp = r != null ? r.app : null;<br>            }<br>            return mService.inputDispatchingTimedOut(anrApp, anrActivity, r, false, reason);<br>        }<br>        …<br>    }<br>}<br>对于keyDispatching Timeout的ANR，当触发该类型ANR时，如果不再有输入事件，则不会弹出ANR对话框；只有在下一次input事件产生后5s才弹出ANR提示框。</p>
<p>三、ANR工作<br>3.1 appNotResponding<br>[-&gt; ActivityManagerService.java]</p>
<p>final void appNotResponding(ProcessRecord app, ActivityRecord activity,<br>        ActivityRecord parent, boolean aboveSystem, final String annotation) {<br>    ArrayList<Integer> firstPids = new ArrayList<Integer>(5);<br>    SparseArray<Boolean> lastPids = new SparseArray<Boolean>(20);</p>
<pre><code>if (mController != null) {
    try {
        // 0 == continue, -1 = kill process immediately
        int res = mController.appEarlyNotResponding(app.processName, app.pid, annotation);
        if (res &lt; 0 &amp;&amp; app.pid != MY_PID) {
            app.kill(&quot;anr&quot;, true);
        }
    } catch (RemoteException e) {
        mController = null;
        Watchdog.getInstance().setActivityController(null);
    }
}

long anrTime = SystemClock.uptimeMillis();
if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
}

synchronized (this) {
    // PowerManager.reboot() 会阻塞很长时间，因此忽略关机时的ANR
    if (mShuttingDown) {
        Slog.i(TAG, &quot;During shutdown skipping ANR: &quot; + app + &quot; &quot; + annotation);
        return;
    } else if (app.notResponding) {
        Slog.i(TAG, &quot;Skipping duplicate ANR: &quot; + app + &quot; &quot; + annotation);
        return;
    } else if (app.crashing) {
        Slog.i(TAG, &quot;Crashing app skipping ANR: &quot; + app + &quot; &quot; + annotation);
        return;
    }

    app.notResponding = true;

    //记录ANR
    EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,
            app.processName, app.info.flags, annotation);

    // Dump thread traces as quickly as we can, starting with &quot;interesting&quot; processes.
    firstPids.add(app.pid);

    int parentPid = app.pid;
    if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid &gt; 0) parentPid = parent.app.pid;
    if (parentPid != app.pid) firstPids.add(parentPid);

    if (MY_PID != app.pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);

    for (int i = mLruProcesses.size() - 1; i &gt;= 0; i--) {
        ProcessRecord r = mLruProcesses.get(i);
        if (r != null &amp;&amp; r.thread != null) {
            int pid = r.pid;
            if (pid &gt; 0 &amp;&amp; pid != app.pid &amp;&amp; pid != parentPid &amp;&amp; pid != MY_PID) {
                if (r.persistent) {
                    firstPids.add(pid);
                } else {
                    lastPids.put(pid, Boolean.TRUE);
                }
            }
        }
    }
}

//输出ANR到main log.
StringBuilder info = new StringBuilder();
info.setLength(0);
info.append(&quot;ANR in &quot;).append(app.processName);
if (activity != null &amp;&amp; activity.shortComponentName != null) {
    info.append(&quot; (&quot;).append(activity.shortComponentName).append(&quot;)&quot;);
}
info.append(&quot;\n&quot;);
info.append(&quot;PID: &quot;).append(app.pid).append(&quot;\n&quot;);
if (annotation != null) {
    info.append(&quot;Reason: &quot;).append(annotation).append(&quot;\n&quot;);
}
if (parent != null &amp;&amp; parent != activity) {
    info.append(&quot;Parent: &quot;).append(parent.shortComponentName).append(&quot;\n&quot;);
}

final ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(true);
//dump栈信息
File tracesFile = dumpStackTraces(true, firstPids, processCpuTracker, lastPids,
        NATIVE_STACKS_OF_INTEREST);

String cpuInfo = null;
if (MONITOR_CPU_USAGE) {
    updateCpuStatsNow();
    synchronized (mProcessCpuTracker) {
        //输出各个进程的CPU使用情况
        cpuInfo = mProcessCpuTracker.printCurrentState(anrTime);
    }
    //输出CPU负载
    info.append(processCpuTracker.printCurrentLoad());
    info.append(cpuInfo);
}

info.append(processCpuTracker.printCurrentState(anrTime));

Slog.e(TAG, info.toString());
if (tracesFile == null) {
    //发送signal 3来dump栈信息
    Process.sendSignal(app.pid, Process.SIGNAL_QUIT);
}
//将anr信息添加到dropbox
addErrorToDropBox(&quot;anr&quot;, app, app.processName, activity, parent, annotation,
        cpuInfo, tracesFile, null);

if (mController != null) {
    try {
        // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately
        int res = mController.appNotResponding(app.processName, app.pid, info.toString());
        if (res != 0) {
            if (res &lt; 0 &amp;&amp; app.pid != MY_PID) {
                app.kill(&quot;anr&quot;, true);
            } else {
                synchronized (this) {
                    mServices.scheduleServiceTimeoutLocked(app);
                }
            }
            return;
        }
    } catch (RemoteException e) {
        mController = null;
        Watchdog.getInstance().setActivityController(null);
    }
}

boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(),
        Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;

synchronized (this) {
    mBatteryStatsService.noteProcessAnr(app.processName, app.uid);

    if (!showBackground &amp;&amp; !app.isInterestingToUserLocked() &amp;&amp; app.pid != MY_PID) {
        app.kill(&quot;bg anr&quot;, true);
        return;
    }

    // Set the app&apos;s notResponding state, and look up the errorReportReceiver
    makeAppNotRespondingLocked(app,
            activity != null ? activity.shortComponentName : null,
            annotation != null ? &quot;ANR &quot; + annotation : &quot;ANR&quot;,
            info.toString());

    //弹出ANR对话框
    Message msg = Message.obtain();
    HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
    msg.what = SHOW_NOT_RESPONDING_MSG;
    msg.obj = map;
    msg.arg1 = aboveSystem ? 1 : 0;
    map.put(&quot;app&quot;, app);
    if (activity != null) {
        map.put(&quot;activity&quot;, activity);
    }

    mUiHandler.sendMessage(msg);
}</code></pre><p>}<br>主要发送ANR， 则会输出</p>
<p>各个进程的CPU使用情况；<br>CPU负载；<br>IOWait；<br>traces文件<br>四、其他<br>导致ANR常见情形：<br>I/O阻塞<br>网络阻塞；<br>onReceiver执行时间超过10s;<br>多线程死锁<br>避免ANR:<br>UI线程尽量只做跟UI相关的工作<br>耗时的工作()比如数据库操作，I/O，网络操作)，采用单独的工作线程处理<br>用Handler来处理UIthread和工作thread的交互<br>UI线程，例如：</p>
<p>Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick(),etc<br>AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel,etc<br>Mainthread handler: handleMessage(), post*(runnable r), etc<br>…<br>ANR分析：需要关注CPU/IO，trace死锁等数据。</p>
<p>五、遇到ANR怎么分析<br>导出trace文件</p>
<p>如果ANR发生，对应的应用会收到SIGQUIT异常终止信号，dalvik虚拟机就会自动在/data/anr/目录下生成trace.txt文件，这个文件记录了在发生ANR时刻系统各个线程的执行状态，获取这个文件是不需要root权限的，因此首先需要做的就是通过adb pull命令将这个文件导出并等待分析。</p>
<p>trace文件格式解析<br>导出trace文件后，可以看到类似于如下的文件内容：</p>
<p>—– pid 901 at 2015-11-28 14:38:34 —–<br>Cmd line: system_server</p>
<p>JNI: CheckJNI is off; workarounds are off; pins=6; globals=2154 (plus 409 weak)</p>
<p>DALVIK THREADS:<br>(mutexes: tll=0 tsl=0 tscl=0 ghl=0)</p>
<p>“main” prio=5 tid=1 NATIVE<br>  | group=”main” sCount=1 dsCount=0 obj=0x415a4e88 self=0x414c48d8<br>  | sysTid=901 nice=-2 sched=0/0 cgrp=apps handle=1073926484<br>  | state=S schedstat=( 303590361913 618664734427 651535 ) utm=19466 stm=10893 core=0<br>  #00  pc 00021914  /system/lib/libc.so (epoll_wait+12)<br>  #01  pc 0001065f  /system/lib/libutils.so (android::Looper::pollInner(int)+98)<br>  #02  pc 00010889  /system/lib/libutils.so (android::Looper::pollOnce(int, int<em>, int</em>, void<em>*)+92)<br>  #03  pc 0006b771  /system/lib/libandroid_runtime.so (android::NativeMessageQueue::pollOnce(_JNIEnv</em>, int)+22)<br>  #04  pc 0002034c  /system/lib/libdvm.so (dvmPlatformInvoke+112)<br>  #05  pc 00050fcf  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const<em>, JValue</em>, Method const<em>, Thread</em>)+398)<br>  #06  pc 00000214  /dev/ashmem/dalvik-jit-code-cache (deleted)<br>  at android.os.MessageQueue.nativePollOnce(Native Method)<br>  at android.os.MessageQueue.next(MessageQueue.java:138)<br>  at android.os.Looper.loop(Looper.java:196)<br>  at com.android.server.ServerThread.initAndLoop(SystemServer.java:1174)<br>  at com.android.server.SystemServer.main(SystemServer.java:1271)<br>  at java.lang.reflect.Method.invokeNative(Native Method)<br>  at java.lang.reflect.Method.invoke(Method.java:515)<br>  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:878)<br>  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:694)<br>  at dalvik.system.NativeStart.main(Native Method)<br>首先需要了解这些参数表示的意义，我们挑其中关键的几个说明：</p>
<p>第一二行</p>
<p>—– pid 901 at 2015-11-28 14:38:34 —–<br>Cmd line: system_server<br>说明了发生ANR的进程id、时间和进程名称。</p>
<p>后面三行是线程的基本信息</p>
<p>JNI: CheckJNI is off; workarounds are off; pins=6; globals=2154 (plus 409 weak)</p>
<p>DALVIK THREADS:<br>(mutexes: tll=0 tsl=0 tscl=0 ghl=0)<br>其中tll、tsl、tscl、ghl、hwl、hwll分别对应：thread list lock, thread suspend lock, thread suspend count lock, gc heap lock, heap worker lock和heap worker list lock。</p>
<p>main prio=5 tid=1 NATIVE说明了线程名称、线程的优先级、线程锁id和线程状态。线程名称是启动线程的时候手动指明的，这里的main标识是主线程，是Android自动设定的一个线程名称，如果是自己手动创建的线程，一般会被命名成“Thread-xx”的格式，其中xx是线程id，它只增不减不会被复用；注意这其中的tid不是线程的id,它是一个在Java虚拟机中用来实现线程锁的变量，随着线程的增减，这个变量的值是可能被复用的；最后线程的状态还分为如下几种</p>
<p>状态    值    说明<br>THREAD_ZOMBIE    0    TERMINATED<br>THREAD_RUNNING    1    RUNNABLE or running now<br>THREAD_TIMED_WAIT    2    TIMED_WAITING in Object.wait()<br>THREAD_MONITOR    3    BLOCKED on a monitor<br>THREAD_INITIALIZING    5    allocated not yet running<br>THREAD_STARTING    6    started not yet on thread list<br>THREAD_NATIVE    7    off in a JNI native method<br>THREAD_VMWAIT    8    waiting on a VM resource<br>THREAD_SUSPENDED    9    suspended usually by GC or debugger<br>特别说明一下MONITOR状态和SUSPEND状态，MONITOR状态一般是类的同步块或者同步方法造成的，SUSPENDED状态在debugger的时候会出现，可以用来区别是不是真的是用户正常操作跑出了ANR。</p>
<p>后面一行</p>
<p>| group=”main” sCount=1 dsCount=0 obj=0x415a4e88 self=0x414c48d8<br>group是线程组名称。sCount是此线程被挂起的次数，dsCount是线程被调试器挂起的次数，当一个进程被调试后，sCount会重置为0，调试完毕后sCount会根据是否被正常挂起增长，但是dsCount不会被重置为0，所以dsCount也可以用来判断这个线程是否被调试过。obj表示这个线程的Java对象的地址，self表示这个线程本身的地址。</p>
<p>此后是线程的调度信息</p>
<p>sysTid=901 nice=-2 sched=0/0 cgrp=apps handle=1073926484<br>sysTid是Linux下的内核线程id，nice是线程的调度优先级，sched分别标志了线程的调度策略和优先级，cgrp是调度属组，handle是线程的处理函数地址。</p>
<p>然后是线程当前上下文信息</p>
<p>state=S schedstat=( 303590361913 618664734427 651535 ) utm=19466 stm=10893 core=0<br>state是调度状态；schedstat从 /proc/[pid]/task/[tid]/schedstat读出，三个值分别表示线程在cpu上执行的时间、线程的等待时间和线程执行的时间片长度，有的android内核版本不支持这项信息，得到的三个值都是0；utm是线程用户态下使用的时间值(单位是jiffies）;stm是内核态下的调度时间值；core是最后执行这个线程的cpu核的序号。</p>
<p>最后就是这个线程的调用栈信息。<br>通过分析trace文件得到ANR信息<br>通过上面分析，可以看到trace文件的头部就包含了很多与该线程相关的信息，但是并不是每个信息我们都必须弄懂，排查ANR的时候只需要找到其中关键的几个信息即可。一般可以通过以下几个简单的方法来判断。</p>
<p>trace文件顶部的线程一般是ANR的元凶<br>这是一个简单的方法，但是大部分情况下都适用，可以通过这个方法来快速判断是否是自己的应用造成了本次ANR。说明以下，并不是trace文件包含的应用就一定是造成ANR的帮凶，应用出现在trace文件中，只能说明出现ANR的时候这个应用进程还活着，trace文件的顶部则是触发ANR的应用信息。因此，如果你的应用出现在了trace文件的顶部，那么很有可能是因为你的应用造成了ANR，否则是你的应用造成ANR的可能性不大，但是具体是不是还需要进一步分析。例如：</p>
<pre><code>----- pid 1182 at 2015-11-26 01:53:34 -----
Cmd line: system_server

JNI: CheckJNI is off; workarounds are off; pins=5; globals=2982 (plus 135 weak)

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 NATIVE
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x420a0e58 self=0x4208f918
  | sysTid=1182 nice=-2 sched=0/0 cgrp=apps handle=1074594132
  | state=S schedstat=( 211672310629 149959255867 472114 ) utm=13047 stm=8120 core=1
  #00  pc 000218b8  /system/lib/libc.so (epoll_wait+12)
  ...
 at android.os.MessageQueue.nativePollOnce(Native Method)
  at android.os.MessageQueue.next(MessageQueue.java:138)
  at android.os.Looper.loop(Looper.java:123)
  at com.android.server.ServerThread.initAndLoop(SystemServer.java:1213)
  at com.android.server.SystemServer.main(SystemServer.java:1317)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:515)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)
  at dalvik.system.NativeStart.main(Native Method)

  ...

----- end 1182 -----

 ----- pid 18927 at 2015-11-26 01:53:34 -----
Cmd line: com.android.example

JNI: CheckJNI is off; workarounds are off; pins=0; globals=465 (plus 984 weak)

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 NATIVE
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x420a0e58 self=0x4208f918
  | sysTid=18927 nice=-6 sched=0/0 cgrp=apps handle=1074594132
  | state=S schedstat=( 7748840431407 1615931922290 9994018 ) utm=712375 stm=62509 core=1
  #00  pc 00020704  /system/lib/libc.so (__ioctl+8)
  #01  pc 0002cfa3  /system/lib/libc.so (ioctl+14)
  #02  pc 0001d3ed  /system/lib/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+140)
  #03  pc 0001d8d7  /system/lib/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, int*)+42)
  #04  pc 0001dadf  /system/lib/libbinder.so (android::IPCThreadState::transact(int, unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+118)
  #05  pc 00019791  /system/lib/libbinder.so (android::BpBinder::transact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+30)
  ...
  #23  pc 00000d80  /system/bin/app_process
  at android.os.BinderProxy.transact(Native Method)
  at android.app.IAlarmManager$Stub$Proxy.set(IAlarmManager.java:154)
  at android.app.AlarmManager.setImpl(AlarmManager.java:369)
  at android.app.AlarmManager.setRepeating(AlarmManager.java:258)
  at android.os.Handler.handleCallback(Handler.java:733)
  at android.os.Handler.dispatchMessage(Handler.java:95)
  at android.os.Looper.loop(Looper.java:136)
  at android.app.ActivityThread.main(ActivityThread.java:5072)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:515)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)
  at dalvik.system.NativeStart.main(Native Method)</code></pre><p>虽然应用com.android.example出现在了trace文件中，但是在ANR的时候它在通过IPCThread在进行进程间通信，而此次ANR发生于system_server获取用户事件的native方法里面，并不是我们的应用造成了ANR。又例如下面的trace文件顶部内容为：</p>
<pre><code>----- pid 13406 at 2015-11-27 11:46:14 -----
Cmd line: com.android.example

JNI: CheckJNI is off; workarounds are off; pins=0; globals=536 (plus 102 weak)

DALVIK THREADS:
(mutexes: tll=0 tsl=0 tscl=0 ghl=0)

&quot;main&quot; prio=5 tid=1 SUSPENDED
  | group=&quot;main&quot; sCount=1 dsCount=0 obj=0x41795e58 self=0x416b58b0
  | sysTid=13406 nice=-6 sched=0/0 cgrp=apps handle=1074557268
  | state=S schedstat=( 2352435524847 736727917292 2633566 ) utm=213075 stm=22168 core=1
  at java.lang.String.&lt;init&gt;(String.java:~261)
  at java.util.zip.ZipEntry.&lt;init&gt;(ZipEntry.java:392)
  at java.util.zip.ZipFile.readCentralDir(ZipFile.java:414)
  at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:151)
  at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:123)
  at com.android.example.Utility.isValideFile(Utility.java:2700)
  at com.android.example.Test.getPath(Test.java:243)
  at com.android.example.Test$1.run(Test.java:531)
  at android.os.Handler.handleCallback(Handler.java:733)
  at android.os.Handler.dispatchMessage(Handler.java:95)
  at android.os.Looper.loop(Looper.java:136)
  at android.app.ActivityThread.main(ActivityThread.java:5050)
  at java.lang.reflect.Method.invokeNative(Native Method)
  at java.lang.reflect.Method.invoke(Method.java:515)
  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:807)
  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:623)
  at dalvik.system.NativeStart.main(Native Method)
  ...</code></pre><p>这种情况说明ANR发生于com.android.example应用中，而且指明了ANR发生时代码的执行位置，这种情况十有八九就是我们应用程序的问题，之后就需要通过这个trace文件指明的路径来对代码进行排查。</p>
<p>注意死锁和等待<br>虽然说ANR一般情况是由于让主线程做了很多耗时的操作，但是死锁或者主线程等待也是ANR高发的原因，例如如下的trace:</p>
<p>—– pid 9436 at 2015-11-28 21:30:41 —–<br>Cmd line: com.example.yxz.myapplication</p>
<p>JNI: CheckJNI is off; workarounds are off; pins=0; globals=277</p>
<p>DALVIK THREADS:<br>(mutexes: tll=0 tsl=0 tscl=0 ghl=0)</p>
<p>“main” prio=5 tid=1 MONITOR<br>  | group=”main” sCount=1 dsCount=0 obj=0x415a4e88 self=0x414c48d8<br>  | sysTid=9436 nice=0 sched=0/0 cgrp=apps handle=1073926484<br>  | state=S schedstat=( 671264662 337280259 1005 ) utm=53 stm=14 core=0<br>  at com.example.yxz.myapplication.performancetest.WaitANR$InnerMonitorClass.TimeConsumeFunc(WaitANR.java:~48)</p>
<ul>
<li>waiting to lock &lt;0x447a5670&gt;  held by tid=11 (Thread-14208)<br>at com.example.yxz.myapplication.performancetest.WaitANR$2.run(WaitANR.java:32)<br>at android.os.Handler.handleCallback(Handler.java:733)<br>at android.os.Handler.dispatchMessage(Handler.java:95)<br>at android.os.Looper.loop(Looper.java:212)<br>at android.app.ActivityThread.main(ActivityThread.java:5135)<br>at java.lang.reflect.Method.invokeNative(Native Method)<br>at java.lang.reflect.Method.invoke(Method.java:515)<br>at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:878)<br>at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:694)<br>at dalvik.system.NativeStart.main(Native Method)</li>
</ul>
<p>….</p>
<p>“Thread-14208” prio=10 tid=11 TIMED_WAIT<br>  | group=”main” sCount=1 dsCount=0 obj=0x447a4b98 self=0x78296bb8<br>  | sysTid=9955 nice=-8 sched=0/0 cgrp=apps handle=2015978016<br>  | state=S schedstat=( 946045 640869 1 ) utm=0 stm=0 core=2<br>  at java.lang.VMThread.sleep(Native Method)<br>  at java.lang.Thread.sleep(Thread.java:1013)<br>  at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:331)<br>  at com.example.yxz.myapplication.performancetest.WaitANR$InnerMonitorClass.TimeConsumeFunc(WaitANR.java:48)<br>  at com.example.yxz.myapplication.performancetest.WaitANR$1.run(WaitANR.java:20)<br>  at java.lang.Thread.run(Thread.java:841)<br>从trace文件可以看出，发生ANR的主线程正处于monitor状态，也就是它在等待一个synchronized块或者方法，但是目前这个monitor正在被tid=11的线程持有，所以造成了主线程被阻塞，从而发生了ANR。死锁的分析也是类似，发生死锁的线程一般处于MONITOR状态或者WAIT状态，等待其他进程的锁或者monitor，而其他进程又在等待另外线程的锁或者monitor，一直这样依赖下去，直到形成一个环。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/VirtualAPK%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/15/VirtualAPK%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">VirtualAPK 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-15 20:19:06" itemprop="dateCreated datePublished" datetime="2020-07-15T20:19:06+08:00">2020-07-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/VirtualAPK/" itemprop="url" rel="index"><span itemprop="name">VirtualAPK</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="VirtualAPK-原理剖析"><a href="#VirtualAPK-原理剖析" class="headerlink" title="VirtualAPK 原理剖析"></a>VirtualAPK 原理剖析</h4><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p><a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a></p>
<p>那么其中的难点很明显是对四大组件支持，因为大家都清楚，四大组件都是需要在AndroidManifest中注册的，而插件apk中的组件是不可能预先知晓名字，提前注册中宿主apk中的，所以现在基本都采用一些hack方案类解决，VirtualAPK大体方案如下：</p>
<ul>
<li>Activity：在宿主apk中提前占几个坑，然后通过“欺上瞒下”（这个词好像是360之前的ppt中提到）的方式，启动插件apk的Activity；因为要支持不同的launchMode以及一些特殊的属性，需要占多个坑。</li>
<li>Service：通过代理Service的方式去分发；主进程和其他进程，VirtualAPK使用了两个代理Service。</li>
<li>BroadcastReceiver：静态转动态</li>
<li>ContentProvider：通过一个代理Provider进行分发。<br>这些占坑的数量并不是固定的，比如Activity想支持某个属性，该属性不能动态设置，只能在Manifest中设置，那就需要去占坑支持。所以占坑数量这些，可以根据自己的需求进行调整</li>
</ul>
<h4 id="二、Activity的支持"><a href="#二、Activity的支持" class="headerlink" title="二、Activity的支持"></a>二、Activity的支持</h4><p>这里就不按照某个流程一行行代码往下读了，针对性的讲一些关键流程，可能更好阅读一些。</p>
<p>首先看一段启动插件Activity的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final String pkg &#x3D; &quot;com.didi.virtualapk.demo&quot;;</span><br><span class="line">if (PluginManager.getInstance(this).getLoadedPlugin(pkg) &#x3D;&#x3D; null) &#123;</span><br><span class="line">    Toast.makeText(this, &quot;plugin [com.didi.virtualapk.demo] not loaded&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; test Activity and Service</span><br><span class="line">Intent intent &#x3D; new Intent();</span><br><span class="line">intent.setClassName(pkg, &quot;com.didi.virtualapk.demo.aidl.BookManagerActivity&quot;);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>可以看到优先根据包名判断该插件是否已经加载，所以在插件使用前其实还需要调用</p>
<p>pluginManager.loadPlugin(apk);<br>1<br>加载插件。</p>
<p>这里就不赘述源码了，大致为调用PackageParser.parsePackage解析apk，获得该apk对应的PackageInfo，资源相关（AssetManager，Resources），DexClassLoader（加载类），四大组件相关集合（mActivityInfos，mServiceInfos，mReceiverInfos，mProviderInfos），针对Plugin的PluginContext等一堆信息，封装为LoadedPlugin对象。</p>
<p>详细可以参考com.didi.virtualapk.internal.LoadedPlugin类。</p>
<p>ok，如果该插件以及加载过，则直接通过startActivity去启动插件中目标Activity。</p>
<p>（1）替换Activity<br>这里大家肯定会有疑惑，该Activity必然没有在Manifest中注册，这么启动不会报错吗？</p>
<p>正常肯定会报错呀，所以我们看看它是怎么做的吧。</p>
<p>跟进startActivity的调用流程，会发现其最终会进入Instrumentation的execStartActivity方法，然后再通过ActivityManagerProxy与AMS进行交互。</p>
<p>而Activity是否存在的校验是发生在AMS端，所以我们在于AMS交互前，提前将Activity的ComponentName进行替换为占坑的名字不就好了么？</p>
<p>这里可以选择hook Instrumentation，或者ActivityManagerProxy都可以达到目标，VirtualAPK选择了hook Instrumentation.</p>
<p>打开PluginManager可以看到如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void hookInstrumentationAndHandler() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Instrumentation baseInstrumentation &#x3D; ReflectUtil.getInstrumentation(this.mContext);</span><br><span class="line">        if (baseInstrumentation.getClass().getName().contains(&quot;lbe&quot;)) &#123;</span><br><span class="line">            &#x2F;&#x2F; reject executing in paralell space, for example, lbe.</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final VAInstrumentation instrumentation &#x3D; new VAInstrumentation(this, baseInstrumentation);</span><br><span class="line">        Object activityThread &#x3D; ReflectUtil.getActivityThread(this.mContext);</span><br><span class="line">        ReflectUtil.setInstrumentation(activityThread, instrumentation);</span><br><span class="line">        ReflectUtil.setHandlerCallback(this.mContext, instrumentation);</span><br><span class="line">        this.mInstrumentation &#x3D; instrumentation;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到首先通过反射拿到了原本的Instrumentation对象，拿的过程是首先拿到ActivityThread，由于ActivityThread可以通过静态变量sCurrentActivityThread或者静态方法currentActivityThread()获取，所以拿到其对象相当轻松。拿到ActivityThread对象后，调用其getInstrumentation()方法，即可获取当前的Instrumentation对象。</p>
<p>然后自己创建了一个VAInstrumentation对象，接下来就直接反射将VAInstrumentation对象设置给ActivityThread对象即可。</p>
<p>这样就完成了hook Instrumentation,之后调用Instrumentation的任何方法，都可以在VAInstrumentation进行拦截并做一些修改。</p>
<p>这里还hook了ActivityThread的mH类的Callback，暂不赘述。</p>
<p>刚才说了，可以通过Instrumentation的execStartActivity方法进行偷梁换柱，所以我们直接看对应的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);</span><br><span class="line">    &#x2F;&#x2F; null component is an implicitly intent</span><br><span class="line">    if (intent.getComponent() !&#x3D; null) &#123;</span><br><span class="line">        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(),</span><br><span class="line">                intent.getComponent().getClassName()));</span><br><span class="line">        &#x2F;&#x2F; resolve intent with Stub Activity if needed</span><br><span class="line">        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityResult result &#x3D; realExecStartActivity(who, contextThread, token, target,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用transformIntentToExplicitAsNeeded，这个主要是当component为null时，根据启动Activity时，配置的action，data,category等去已加载的plugin中匹配到确定的Activity的。</p>
<p>本例我们的写法ComponentName肯定不为null，所以直接看markIntentIfNeeded()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void markIntentIfNeeded(Intent intent) &#123;</span><br><span class="line">    if (intent.getComponent() &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String targetPackageName &#x3D; intent.getComponent().getPackageName();</span><br><span class="line">    String targetClassName &#x3D; intent.getComponent().getClassName();</span><br><span class="line">    &#x2F;&#x2F; search map and return specific launchmode stub activity</span><br><span class="line">    if (!targetPackageName.equals(mContext.getPackageName())</span><br><span class="line">            &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) !&#x3D; null) &#123;</span><br><span class="line">        intent.putExtra(Constants.KEY_IS_PLUGIN, true);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);</span><br><span class="line">        dispatchStubActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中判断如果启动的是插件中类，则将启动的包名和Activity类名存到了intent中，可以看到这里存储明显是为了后面恢复用的。</p>
<p>然后调用了dispatchStubActivity(intent)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void dispatchStubActivity(Intent intent) &#123;</span><br><span class="line">    ComponentName component &#x3D; intent.getComponent();</span><br><span class="line">    String targetClassName &#x3D; intent.getComponent().getClassName();</span><br><span class="line">    LoadedPlugin loadedPlugin &#x3D; mPluginManager.getLoadedPlugin(intent);</span><br><span class="line">    ActivityInfo info &#x3D; loadedPlugin.getActivityInfo(component);</span><br><span class="line">    if (info &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;can not find &quot; + component);</span><br><span class="line">    &#125;</span><br><span class="line">    int launchMode &#x3D; info.launchMode;</span><br><span class="line">    Resources.Theme themeObj &#x3D; loadedPlugin.getResources().newTheme();</span><br><span class="line">    themeObj.applyStyle(info.theme, true);</span><br><span class="line">    String stubActivity &#x3D; mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj);</span><br><span class="line">    Log.i(TAG, String.format(&quot;dispatchStubActivity,[%s -&gt; %s]&quot;, targetClassName, stubActivity));</span><br><span class="line">    intent.setClassName(mContext, stubActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接看最后一行，intent通过setClassName替换启动的目标Activity了！这个stubActivity是由mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj)返回。</p>
<p>很明显，传入的参数launchMode、themeObj都是决定选择哪一个占坑类用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public String getStubActivity(String className, int launchMode, Theme theme) &#123;</span><br><span class="line">    String stubActivity&#x3D; mCachedStubActivity.get(className);</span><br><span class="line">    if (stubActivity !&#x3D; null) &#123;</span><br><span class="line">        return stubActivity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TypedArray array &#x3D; theme.obtainStyledAttributes(new int[]&#123;</span><br><span class="line">            android.R.attr.windowIsTranslucent,</span><br><span class="line">            android.R.attr.windowBackground</span><br><span class="line">    &#125;);</span><br><span class="line">    boolean windowIsTranslucent &#x3D; array.getBoolean(0, false);</span><br><span class="line">    array.recycle();</span><br><span class="line">    if (Constants.DEBUG) &#123;</span><br><span class="line">        Log.d(&quot;StubActivityInfo&quot;, &quot;getStubActivity, is transparent theme ? &quot; + windowIsTranslucent);</span><br><span class="line">    &#125;</span><br><span class="line">    stubActivity &#x3D; String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);</span><br><span class="line">    switch (launchMode) &#123;</span><br><span class="line">        case ActivityInfo.LAUNCH_MULTIPLE: &#123;</span><br><span class="line">            stubActivity &#x3D; String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);</span><br><span class="line">            if (windowIsTranslucent) &#123;</span><br><span class="line">                stubActivity &#x3D; String.format(STUB_ACTIVITY_STANDARD, corePackage, 2);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case ActivityInfo.LAUNCH_SINGLE_TOP: &#123;</span><br><span class="line">            usedSingleTopStubActivity &#x3D; usedSingleTopStubActivity % MAX_COUNT_SINGLETOP + 1;</span><br><span class="line">            stubActivity &#x3D; String.format(STUB_ACTIVITY_SINGLETOP, corePackage, usedSingleTopStubActivity);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 省略LAUNCH_SINGLE_TASK，LAUNCH_SINGLE_INSTANCE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCachedStubActivity.put(className, stubActivity);</span><br><span class="line">    return stubActivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到主要就是根据launchMode去选择不同的占坑类。<br>例如：</p>
<p>stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity);<br>1<br>STUB_ACTIVITY_STANDARD值为：”%s.A$%d”, corePackage值为com.didi.virtualapk.core，usedStandardStubActivity为数字值。</p>
<p>所以最终类名格式为：com.didi.virtualapk.core.A$1</p>
<p>再看一眼，CoreLibrary下的AndroidManifest中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name&#x3D;&quot;.A$1&quot; android:launchMode&#x3D;&quot;standard&quot;&#x2F;&gt;</span><br><span class="line">&lt;activity android:name&#x3D;&quot;.A$2&quot; android:launchMode&#x3D;&quot;standard&quot;</span><br><span class="line">    android:theme&#x3D;&quot;@android:style&#x2F;Theme.Translucent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Stub Activities --&gt;</span><br><span class="line">&lt;activity android:name&#x3D;&quot;.B$1&quot; android:launchMode&#x3D;&quot;singleTop&quot;&#x2F;&gt;</span><br><span class="line">&lt;activity android:name&#x3D;&quot;.B$2&quot; android:launchMode&#x3D;&quot;singleTop&quot;&#x2F;&gt;</span><br><span class="line">&lt;activity android:name&#x3D;&quot;.B$3&quot; android:launchMode&#x3D;&quot;singleTop&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>到这里就可以看到，替换我们启动的Activity为占坑Activity，将我们原本启动的包名，类名存储到了Intent中。</p>
<p>这样做只完成了一半，为什么这么说呢？</p>
<p>(2) 还原Activity<br>因为欺骗过了AMS，AMS执行完成后，最终要启动的不可能是占坑Activity，还应该是我们的启动的目标Activity呀。</p>
<p>这里需要知道Activity的启动流程：</p>
<p>AMS在处理完启动Activity后，会调用：app.thread.scheduleLaunchActivity，这里的thread对应的server端未我们ActivityThread中的ApplicationThread对象(binder可以理解有一个client端和一个server端)，所以会调用ApplicationThread.scheduleLaunchActivity方法，在其内部会调用mH类的sendMessage方法，传递的标识为H.LAUNCH_ACTIVITY，进入调用到ActivityThread的handleLaunchActivity方法-&gt;ActivityThread#handleLaunchActivity-&gt;mInstrumentation.newActivity()。</p>
<p>ps:这里流程不清楚没关系，暂时理解为最终会回调到Instrumentation的newActivity方法即可，细节可以自己去查看结合老罗的blog理解。</p>
<p>关键的来了，最终又到了Instrumentation的newActivity方法，还记得这个类我们已经改为VAInstrumentation啦：</p>
<p>直接看其newActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cl.loadClass(className);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        LoadedPlugin plugin &#x3D; this.mPluginManager.getLoadedPlugin(intent);</span><br><span class="line">        String targetClassName &#x3D; PluginUtil.getTargetActivity(intent);</span><br><span class="line"></span><br><span class="line">        if (targetClassName !&#x3D; null) &#123;</span><br><span class="line">            Activity activity &#x3D; mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);</span><br><span class="line">            activity.setIntent(intent);</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 省略兼容性处理代码</span><br><span class="line">            return activity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mBase.newActivity(cl, className, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是首先从intent中取出我们的目标Activity，然后通过plugin的ClassLoader去加载（还记得在加载插件时，会生成一个LoadedPlugin对象，其中会对应其初始化一个DexClassLoader）。</p>
<p>这样就完成了Activity的“偷梁换柱”。</p>
<p>还没完，接下来在callActivityOnCreate方法中：</p>
<p> @Override<br>public void callActivityOnCreate(Activity activity, Bundle icicle) {<br>    final Intent intent = activity.getIntent();<br>    if (PluginUtil.isIntentFromPlugin(intent)) {<br>        Context base = activity.getBaseContext();<br>        try {<br>            LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);<br>            ReflectUtil.setField(base.getClass(), base, “mResources”, plugin.getResources());<br>            ReflectUtil.setField(ContextWrapper.class, activity, “mBase”, plugin.getPluginContext());<br>            ReflectUtil.setField(Activity.class, activity, “mApplication”, plugin.getApplication());<br>            ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, “mBase”, plugin.getPluginContext());</p>
<pre><code>        // set screenOrientation
        ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent));
        if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
            activity.setRequestedOrientation(activityInfo.screenOrientation);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }

}

mBase.callActivityOnCreate(activity, icicle);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">设置了修改了mResources、mBase（Context）、mApplication对象。以及设置一些可动态设置的属性，这里仅设置了屏幕方向。</span><br><span class="line"></span><br><span class="line">这里提一下，将mBase替换为PluginContext，可以修改Resources、AssetManager以及拦截相当多的操作。</span><br><span class="line"></span><br><span class="line">看一眼代码就清楚了：</span><br><span class="line"></span><br><span class="line">原本Activity的部分get操作</span><br><span class="line"></span><br><span class="line"># ContextWrapper</span><br></pre></td></tr></table></figure>
<p>@Override<br>public AssetManager getAssets() {<br>    return mBase.getAssets();<br>}</p>
<p>@Override<br>public Resources getResources()<br>{<br>    return mBase.getResources();<br>}</p>
<p>@Override<br>public PackageManager getPackageManager() {<br>    return mBase.getPackageManager();<br>}</p>
<p>@Override<br>public ContentResolver getContentResolver() {<br>    return mBase.getContentResolver();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">直接替换为：</span><br><span class="line"></span><br><span class="line"># PluginContext</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Resources getResources() &#123;</span><br><span class="line">    return this.mPlugin.getResources();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public AssetManager getAssets() &#123;</span><br><span class="line">    return this.mPlugin.getAssets();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ContentResolver getContentResolver() &#123;</span><br><span class="line">    return new PluginContentResolver(getHostContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看得出来还是非常巧妙的。可以做的事情也非常多，后面对ContentProvider的描述也会提现出来。</p>
<p>好了，到此Activity就可以正常启动了。</p>
<p>下面看Service。</p>
<p>三、Service的支持<br>Service和Activity有点不同，显而易见的首先我们也会将要启动的Service类替换为占坑的Service类，但是有一点不同，在Standard模式下多次启动同一个占坑Activity会创建多个对象来对象我们的目标类。而Service多次启动只会调用onStartCommond方法，甚至常规多次调用bindService，seviceConn对象不变，甚至都不会多次回调bindService方法（多次调用可以通过给Intent设置不同Action解决）。</p>
<p>还有一点，最明显的差异是，Activity的生命周期是由用户交互决定的，而Service的声明周期是我们主动通过代码调用的。</p>
<p>也就是说，start、stop、bind、unbind都是我们显示调用的，所以我们可以拦截这几个方法，做一些事情。</p>
<p>Virtual Apk的做法，即将所有的操作进行拦截，都改为startService，然后统一在onStartCommond中分发。</p>
<p>下面看详细代码：</p>
<p>(1) hook IActivityManager<br>再次来到PluginManager，发下如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void hookSystemServices() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Singleton&lt;IActivityManager&gt; defaultSingleton &#x3D; (Singleton&lt;IActivityManager&gt;) ReflectUtil.getField(ActivityManagerNative.class, null, &quot;gDefault&quot;);</span><br><span class="line">        IActivityManager activityManagerProxy &#x3D; ActivityManagerProxy.newInstance(this, defaultSingleton.get());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Hook IActivityManager from ActivityManagerNative</span><br><span class="line">        ReflectUtil.setField(defaultSingleton.getClass().getSuperclass(), defaultSingleton, &quot;mInstance&quot;, activityManagerProxy);</span><br><span class="line"></span><br><span class="line">        if (defaultSingleton.get() &#x3D;&#x3D; activityManagerProxy) &#123;</span><br><span class="line">            this.mActivityManager &#x3D; activityManagerProxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先拿到ActivityManagerNative中的gDefault对象，该对象返回的是一个Singleton<IActivityManager>,然后拿到其mInstance对象，即IActivityManager对象（可以理解为和AMS交互的binder的client对象）对象。</p>
<p>然后通过动态代理的方式，替换为了一个代理对象。</p>
<p>那么重点看对应的InvocationHandler对象即可，该代理对象调用的方法都会辗转到其invoke方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    if (&quot;startService&quot;.equals(method.getName())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return startService(proxy, method, args);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Start service error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (&quot;stopService&quot;.equals(method.getName())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return stopService(proxy, method, args);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Stop Service error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (&quot;stopServiceToken&quot;.equals(method.getName())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return stopServiceToken(proxy, method, args);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Stop service token error&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 省略bindService，unbindService等方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用startService时，跟进代码，可以发现调用流程为：</p>
<p>startService-&gt;startServiceCommon-&gt;ActivityManagerNative.getDefault().startService<br>1<br>这个getDefault刚被我们hook，所以会被上述方法拦截，然后调用：startService(proxy, method, args)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Object startService(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    IApplicationThread appThread &#x3D; (IApplicationThread) args[0];</span><br><span class="line">    Intent target &#x3D; (Intent) args[1];</span><br><span class="line">    ResolveInfo resolveInfo &#x3D; this.mPluginManager.resolveService(target, 0);</span><br><span class="line">    if (null &#x3D;&#x3D; resolveInfo || null &#x3D;&#x3D; resolveInfo.serviceInfo) &#123;</span><br><span class="line">        &#x2F;&#x2F; is host service</span><br><span class="line">        return method.invoke(this.mActivityManager, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return startDelegateServiceForTarget(target, resolveInfo.serviceInfo, null, RemoteService.EXTRA_COMMAND_START_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不看代码，考虑下我们这里唯一要做的就是通过Intent保存关键数据，替换启动的Service类为占坑类。</p>
<p>所以直接看最后的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private ComponentName startDelegateServiceForTarget(Intent target,</span><br><span class="line">                                                    ServiceInfo serviceInfo,</span><br><span class="line">                                                    Bundle extras, int command) &#123;</span><br><span class="line">    Intent wrapperIntent &#x3D; wrapperTargetIntent(target, serviceInfo, extras, command);</span><br><span class="line">    return mPluginManager.getHostContext().startService(wrapperIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行就是启动了，那么替换的操作应该在wrapperTargetIntent中完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Intent wrapperTargetIntent(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123;</span><br><span class="line">    &#x2F;&#x2F; fill in service with ComponentName</span><br><span class="line">    target.setComponent(new ComponentName(serviceInfo.packageName, serviceInfo.name));</span><br><span class="line">    String pluginLocation &#x3D; mPluginManager.getLoadedPlugin(target.getComponent()).getLocation();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; start delegate service to run plugin service inside</span><br><span class="line">    boolean local &#x3D; PluginUtil.isLocalService(serviceInfo);</span><br><span class="line">    Class&lt;? extends Service&gt; delegate &#x3D; local ? LocalService.class : RemoteService.class;</span><br><span class="line">    Intent intent &#x3D; new Intent();</span><br><span class="line">    intent.setClass(mPluginManager.getHostContext(), delegate);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_TARGET, target);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_COMMAND, command);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation);</span><br><span class="line">    if (extras !&#x3D; null) &#123;</span><br><span class="line">        intent.putExtras(extras);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果不其然，重新初始化了Intent，设置了目标类为LocalService（多进程时设置为RemoteService），然后将原本的Intent存储到EXTRA_TARGET，携带command为EXTRA_COMMAND_START_SERVICE，以及插件apk路径。</p>
<p>（2）代理分发<br>那么接下来代码就到了LocalService的onStartCommond中啦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略一些代码...</span><br><span class="line"></span><br><span class="line">    Intent target &#x3D; intent.getParcelableExtra(EXTRA_TARGET);</span><br><span class="line">    int command &#x3D; intent.getIntExtra(EXTRA_COMMAND, 0);</span><br><span class="line">    if (null &#x3D;&#x3D; target || command &lt;&#x3D; 0) &#123;</span><br><span class="line">        return START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component &#x3D; target.getComponent();</span><br><span class="line">    LoadedPlugin plugin &#x3D; mPluginManager.getLoadedPlugin(component);</span><br><span class="line"></span><br><span class="line">    switch (command) &#123;</span><br><span class="line">        case EXTRA_COMMAND_START_SERVICE: &#123;</span><br><span class="line">            ActivityThread mainThread &#x3D; (ActivityThread)ReflectUtil.getActivityThread(getBaseContext());</span><br><span class="line">            IApplicationThread appThread &#x3D; mainThread.getApplicationThread();</span><br><span class="line">            Service service;</span><br><span class="line"></span><br><span class="line">            if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123;</span><br><span class="line">                service &#x3D; this.mPluginManager.getComponentsHandler().getService(component);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    service &#x3D; (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();</span><br><span class="line"></span><br><span class="line">                    Application app &#x3D; plugin.getApplication();</span><br><span class="line">                    IBinder token &#x3D; appThread.asBinder();</span><br><span class="line">                    Method attach &#x3D; service.getClass().getMethod(&quot;attach&quot;, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);</span><br><span class="line">                    IActivityManager am &#x3D; mPluginManager.getActivityManager();</span><br><span class="line"></span><br><span class="line">                    attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);</span><br><span class="line">                    service.onCreate();</span><br><span class="line">                    this.mPluginManager.getComponentsHandler().rememberService(component, service);</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    return START_STICKY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            service.onStartCommand(target, 0, this.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement());</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 省略下面的代码</span><br><span class="line">         case EXTRA_COMMAND_BIND_SERVICE:break;</span><br><span class="line">         case EXTRA_COMMAND_STOP_SERVICE:break;</span><br><span class="line">         case EXTRA_COMMAND_UNBIND_SERVICE:break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里代码很简单了，根据command类型，比如EXTRA_COMMAND_START_SERVICE，直接通过plugin的ClassLoader去load目标Service的class，然后反射创建实例。比较重要的是，Service创建好后，需要调用它的attach方法，这里凑够参数，然后反射调用即可，最后调用onCreate、onStartCommand收工。然后将其保存起来，stop的时候取出来调用其onDestroy即可。</p>
<p>bind、unbind以及stop的代码与上述基本一致，不在赘述。</p>
<p>唯一提醒的就是，刚才看到还hook了一个方法叫做：stopServiceToken，该方法是什么时候用的呢？</p>
<p>主要有一些特殊的Service，比如IntentService，其stopSelf是由自身调用的，最终会调用mActivityManager.stopServiceToken方法，同样的中转为STOP操作即可。</p>
<p>四、BroadcastReceiver的支持<br>这个比较简单，直接解析Manifest后，静态转动态即可。</p>
<p>相关代码在LoadedPlugin的构造方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (PackageParser.Activity receiver : this.mPackage.receivers) &#123;</span><br><span class="line">    receivers.put(receiver.getComponentName(), receiver.info);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        BroadcastReceiver br &#x3D; BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());</span><br><span class="line">        for (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123;</span><br><span class="line">            this.mHostContext.registerReceiver(br, aii);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到解析到receiver信息后，直接通过pluginClassloader去loadClass拿到receiver对象，然后调用this.mHostContext.registerReceiver即可。</p>
<p>五、ContentProvider的支持<br>（1）hook IContentProvider<br>ContentProvider的支持依然是通过代理分发。</p>
<p>看一段CP使用的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cursor bookCursor &#x3D; getContentResolver().query(bookUri, new String[]&#123;&quot;_id&quot;, &quot;name&quot;&#125;, null, null, null);</span><br></pre></td></tr></table></figure>

<p>这里用到了PluginContext，在生成Activity、Service的时候，为其设置的Context都为PluginContext对象。</p>
<p>所以当你调用getContentResolver时，调用的为PluginContext的getContentResolver。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ContentResolver getContentResolver() &#123;</span><br><span class="line">    return new PluginContentResolver(getHostContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的是一个PluginContentResolver对象，当我们调用query方法时，会辗转调用到<br>ContentResolver.acquireUnstableProvider方法。该方法被PluginContentResolver中复写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected IContentProvider acquireUnstableProvider(Context context, String auth) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (mPluginManager.resolveContentProvider(auth, 0) !&#x3D; null) &#123;</span><br><span class="line">            return mPluginManager.getIContentProvider();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (IContentProvider) sAcquireUnstableProvider.invoke(mBase, context, auth);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用的auth为插件apk中的provider，则直接返回mPluginManager.getIContentProvider()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized IContentProvider getIContentProvider() &#123;</span><br><span class="line">    if (mIContentProvider &#x3D;&#x3D; null) &#123;</span><br><span class="line">        hookIContentProviderAsNeeded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mIContentProvider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咦，又看到一个hook方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void hookIContentProviderAsNeeded() &#123;</span><br><span class="line">    Uri uri &#x3D; Uri.parse(PluginContentResolver.getUri(mContext));</span><br><span class="line">    mContext.getContentResolver().call(uri, &quot;wakeup&quot;, null, null);</span><br><span class="line">    try &#123;</span><br><span class="line">        Field authority &#x3D; null;</span><br><span class="line">        Field mProvider &#x3D; null;</span><br><span class="line">        ActivityThread activityThread &#x3D; (ActivityThread) ReflectUtil.getActivityThread(mContext);</span><br><span class="line">        Map mProviderMap &#x3D; (Map) ReflectUtil.getField(activityThread.getClass(), activityThread, &quot;mProviderMap&quot;);</span><br><span class="line">        Iterator iter &#x3D; mProviderMap.entrySet().iterator();</span><br><span class="line">        while (iter.hasNext()) &#123;</span><br><span class="line">            Map.Entry entry &#x3D; (Map.Entry) iter.next();</span><br><span class="line">            Object key &#x3D; entry.getKey();</span><br><span class="line">            Object val &#x3D; entry.getValue();</span><br><span class="line">            String auth;</span><br><span class="line">            if (key instanceof String) &#123;</span><br><span class="line">                auth &#x3D; (String) key;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (authority &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    authority &#x3D; key.getClass().getDeclaredField(&quot;authority&quot;);</span><br><span class="line">                    authority.setAccessible(true);</span><br><span class="line">                &#125;</span><br><span class="line">                auth &#x3D; (String) authority.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">            if (auth.equals(PluginContentResolver.getAuthority(mContext))) &#123;</span><br><span class="line">                if (mProvider &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mProvider &#x3D; val.getClass().getDeclaredField(&quot;mProvider&quot;);</span><br><span class="line">                    mProvider.setAccessible(true);</span><br><span class="line">                &#125;</span><br><span class="line">                IContentProvider rawProvider &#x3D; (IContentProvider) mProvider.get(val);</span><br><span class="line">                IContentProvider proxy &#x3D; IContentProviderProxy.newInstance(mContext, rawProvider);</span><br><span class="line">                mIContentProvider &#x3D; proxy;</span><br><span class="line">                Log.d(TAG, &quot;hookIContentProvider succeed : &quot; + mIContentProvider);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前两行比较重要，第一行是拿到了占坑的provider的uri，然后主动调用了其call方法。<br>如果你跟进去，会发现，其会调用acquireProvider-&gt;mMainThread.acquireProvider-&gt;ActivityManagerNative.getDefault().getContentProvider-&gt;installProvider。简单来说，其首先调用已经注册provider，得到返回的IContentProvider对象。</p>
<p>这个IContentProvider对象是在ActivityThread.installProvider方法中加入到mProviderMap中。</p>
<p>而ActivityThread对象又容易获取，mProviderMap又是它成员变量，那么也容易获取，所以上面的一大坨（除了前两行）代码，就为了拿到占坑的provider对应的IContentProvider对象。</p>
<p>然后通过动态代理的方式，进行了hook，关注InvocationHandler的实例IContentProviderProxy。</p>
<p>IContentProvider能干吗呢？其实就能拦截我们正常的query、insert、update、delete等操作。</p>
<p>拦截这些方法干嘛？</p>
<p>当然是修改uri啦，把用户调用的uri，替换为占坑provider的uri，再把原本的uri作为参数拼接在占坑provider的uri后面即可。</p>
<p>好了，直接看invoke方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    Log.v(TAG, method.toGenericString() + &quot; : &quot; + Arrays.toString(args));</span><br><span class="line">    wrapperUri(method, args);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        return method.invoke(mBase, args);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        throw e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看wrapperUri</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void wrapperUri(Method method, Object[] args) &#123;</span><br><span class="line">    Uri uri &#x3D; null;</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    if (args !&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            if (args[i] instanceof Uri) &#123;</span><br><span class="line">                uri &#x3D; (Uri) args[i];</span><br><span class="line">                index &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 省略部分代码</span><br><span class="line"></span><br><span class="line">    PluginManager pluginManager &#x3D; PluginManager.getInstance(mContext);</span><br><span class="line">    ProviderInfo info &#x3D; pluginManager.resolveContentProvider(uri.getAuthority(), 0);</span><br><span class="line">    if (info !&#x3D; null) &#123;</span><br><span class="line">        String pkg &#x3D; info.packageName;</span><br><span class="line">        LoadedPlugin plugin &#x3D; pluginManager.getLoadedPlugin(pkg);</span><br><span class="line">        String pluginUri &#x3D; Uri.encode(uri.toString());</span><br><span class="line">        StringBuilder builder &#x3D; new StringBuilder(PluginContentResolver.getUri(mContext));</span><br><span class="line">        builder.append(&quot;&#x2F;?plugin&#x3D;&quot; + plugin.getLocation());</span><br><span class="line">        builder.append(&quot;&amp;pkg&#x3D;&quot; + pkg);</span><br><span class="line">        builder.append(&quot;&amp;uri&#x3D;&quot; + pluginUri);</span><br><span class="line">        Uri wrapperUri &#x3D; Uri.parse(builder.toString());</span><br><span class="line">        if (method.getName().equals(&quot;call&quot;)) &#123;</span><br><span class="line">            bundleInCallMethod.putString(KEY_WRAPPER_URI, wrapperUri.toString());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            args[index] &#x3D; wrapperUri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从参数中找到uri，往下看，搞了个StringBuilder首先加入占坑provider的uri，然后将目标uri，pkg,plugin等参数等拼接上去，替换到args中的uri，然后继续走原本的流程。</p>
<p>假设是query方法，应该就到达我们占坑provider的query方法啦。</p>
<p>（2）代理分发<br>占坑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;com.didi.virtualapk.delegate.RemoteContentProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.VirtualAPK.Provider&quot;</span><br><span class="line">    android:process&#x3D;&quot;:daemon&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>打开RemoteContentProvider，直接看query方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Cursor query(Uri uri, String[] projection, String selection,</span><br><span class="line">                    String[] selectionArgs, String sortOrder) &#123;</span><br><span class="line"></span><br><span class="line">    ContentProvider provider &#x3D; getContentProvider(uri);</span><br><span class="line">    Uri pluginUri &#x3D; Uri.parse(uri.getQueryParameter(KEY_URI));</span><br><span class="line">    if (provider !&#x3D; null) &#123;</span><br><span class="line">        return provider.query(pluginUri, projection, selection, selectionArgs, sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到通过传入的生成了一个新的provider,然后拿到目标uri，在直接调用provider.query传入目标uri即可。</p>
<p>那么这个provider实际上是这个代理类帮我们生成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private ContentProvider getContentProvider(final Uri uri) &#123;</span><br><span class="line">    final PluginManager pluginManager &#x3D; PluginManager.getInstance(getContext());</span><br><span class="line">    Uri pluginUri &#x3D; Uri.parse(uri.getQueryParameter(KEY_URI));</span><br><span class="line">    final String auth &#x3D; pluginUri.getAuthority();</span><br><span class="line">    &#x2F;&#x2F; 省略了缓存管理</span><br><span class="line">    LoadedPlugin plugin &#x3D; pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));</span><br><span class="line">    if (plugin &#x3D;&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            pluginManager.loadPlugin(new File(uri.getQueryParameter(KEY_PLUGIN)));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ProviderInfo providerInfo &#x3D; pluginManager.resolveContentProvider(auth, 0);</span><br><span class="line">    if (providerInfo !&#x3D; null) &#123;</span><br><span class="line">        RunUtil.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    LoadedPlugin loadedPlugin &#x3D; pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG));</span><br><span class="line">                    ContentProvider contentProvider &#x3D; (ContentProvider) Class.forName(providerInfo.name).newInstance();</span><br><span class="line">                    contentProvider.attachInfo(loadedPlugin.getPluginContext(), providerInfo);</span><br><span class="line">                    sCachedProviders.put(auth, contentProvider);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, true);</span><br><span class="line">        return sCachedProviders.get(auth);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，取出原本的uri，拿到auth，在通过加载plugin得到providerInfo，反射生成provider对象，在调用其attachInfo方法即可。</p>
<p>其他的几个方法：insert、update、delete、call逻辑基本相同，就不赘述了。</p>
<p>感觉这里其实通过hook AMS的getContentProvider方法也能完成上述流程，感觉好像可以更彻底，不需要依赖PluginContext了。</p>
<p>六、总结<br>总结下，其实就是文初的内容，可以看到VritualApk大体方案如下：</p>
<p>Activity：在宿主apk中提前占几个坑，然后通过“欺上瞒下”（这个词好像是360之前的ppt中提到）的方式，启动插件apk的Activity；因为要支持不同的launchMode以及一些特殊的属性，需要占多个坑。<br>Service：通过代理Service的方式去分发；主进程和其他进程，VirtualAPK使用了两个代理Service。<br>BroadcastReceiver：静态转动态。<br>ContentProvider：通过一个代理Provider进行分发。<br>整体代码看起来还是很轻松的~</p>
<p>当然如果你要选择某一个插件化方案进行使用，一定要了解其中的实现原理，文档上描述的并不是所有细节，很多一些属性什么的，以及由于其实现的方式造成一些特性的不支持。了解源码，可以方便自己排查问题，扩展，甚至写一套根据自己业务需求的插件化方案~~</p>
<p>再多嘴一句，还是建议大多多在某一方面深入了解，不要痴迷于UI特效（上班路上看看我的推文就好啦<del>玩笑</del>，很多特效的，了解下原理即可）~~其实我早期浪费了很多时间在上面，在你掌握了自定义View的详细细节、事件分发机制这些机制后，大部分UI的编写都是时间问题。</p>
<p>不要在上面浪费过多时间，比别人多研究几个特效并不会对自己的提升有巨大的帮助，过来人，忠言逆耳~。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/10/ARouter%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/10/ARouter%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">ARouter 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-10 23:53:54" itemprop="dateCreated datePublished" datetime="2020-07-10T23:53:54+08:00">2020-07-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p><a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">ARouter</a>一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦</p>
<p><img src="ARouter%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="ARouter架构图"></p>
<p>主要功能：</p>
<ul>
<li>支持直接解析标准URL进行跳转，并自动注入参数到目标页面中支持多模块工程使用</li>
<li>支持添加多个拦截器，自定义拦截顺序</li>
<li>支持依赖注入，可单独作为依赖注入框架使用</li>
<li>支持用户指定全局降级与局部降级策略</li>
<li>页面、拦截器、服务等组件均自动注册到框架</li>
</ul>
<h4 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h4><ol>
<li>添加依赖和配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments &#x3D; [AROUTER_MODULE_NAME: project.getName()]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;com.alibaba:arouter-api:x.x.x&#39;</span><br><span class="line">    annotationProcessor &#39;com.alibaba:arouter-compiler:x.x.x&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加注解</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Route(path &#x3D; &quot;&#x2F;test&#x2F;activity&quot;)</span><br><span class="line">public class YourActivity extend Activity &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化SDK(推荐在Application中初始化)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (isDebug()) &#123;           </span><br><span class="line">    ARouter.openLog();</span><br><span class="line">    ARouter.openDebug();</span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>发起路由操作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 应用内简单的跳转(通过URL跳转在&#39;进阶用法&#39;中)</span><br><span class="line">ARouter.getInstance().build(&quot;&#x2F;test&#x2F;activity&quot;).navigation();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 跳转并携带参数</span><br><span class="line">ARouter.getInstance().build(&quot;&#x2F;test&#x2F;1&quot;)</span><br><span class="line">            .withLong(&quot;key1&quot;, 666L)</span><br><span class="line">            .withString(&quot;key3&quot;, &quot;888&quot;)</span><br><span class="line">            .withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))</span><br><span class="line">            .navigation();</span><br></pre></td></tr></table></figure>

<h4 id="三、源码剖析"><a href="#三、源码剖析" class="headerlink" title="三、源码剖析"></a>三、源码剖析</h4><p>整个ARouter框架的源码主要分为三个模块：<strong>arouter-annotation</strong>、<strong>arouter-compiler</strong>、<strong>arouter-api</strong></p>
<h5 id="3-1-annotation注解模块"><a href="#3-1-annotation注解模块" class="headerlink" title="3.1 annotation注解模块"></a>3.1 annotation注解模块</h5><p><strong>Route.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Route &#123;</span><br><span class="line">    String path();</span><br><span class="line">    String group() default &quot;&quot;;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line">    int extras() default Integer.MIN_VALUE;</span><br><span class="line">    int priority() default -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Autowired.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line">    boolean required() default false;</span><br><span class="line">    String desc() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-compiler注解处理模块"><a href="#3-2-compiler注解处理模块" class="headerlink" title="3.2 compiler注解处理模块"></a>3.2 compiler注解处理模块</h5><p><strong>RouteProcessor注解处理器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class RouteProcessor extends BaseProcessor &#123;</span><br><span class="line">    private Map&lt;String, Set&lt;RouteMeta&gt;&gt; groupMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private Map&lt;String, String&gt; rootMap &#x3D; new TreeMap&lt;&gt;(); </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        if (CollectionUtils.isNotEmpty(annotations)) &#123;</span><br><span class="line">            Set&lt;? extends Element&gt; routeElements &#x3D; roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">            parseRoutes(routeElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void parseRoutes(Set&lt;? extends Element&gt; routeElements) throws IOException &#123;</span><br><span class="line">        if (CollectionUtils.isNotEmpty(routeElements)) &#123;</span><br><span class="line">            rootMap.clear();</span><br><span class="line">            &#x2F;&#x2F; 定义参数类型: Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span><br><span class="line">            ParameterizedTypeName inputMapTypeOfRoot &#x3D; ParameterizedTypeName.get(</span><br><span class="line">                    ClassName.get(Map.class),</span><br><span class="line">                    ClassName.get(String.class),</span><br><span class="line">                    ParameterizedTypeName.get(</span><br><span class="line">                            ClassName.get(Class.class),</span><br><span class="line">                            WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">                    )</span><br><span class="line">            );</span><br><span class="line">            ParameterSpec rootParamSpec &#x3D; ParameterSpec.builder(inputMapTypeOfRoot, &quot;routes&quot;).build();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 定义参数类型: Map&lt;String, RouteMeta&gt;</span><br><span class="line">            ParameterizedTypeName inputMapTypeOfGroup &#x3D; ParameterizedTypeName.get(</span><br><span class="line">                    ClassName.get(Map.class),</span><br><span class="line">                    ClassName.get(String.class),</span><br><span class="line">                    ClassName.get(RouteMeta.class)</span><br><span class="line">            ); </span><br><span class="line">            ParameterSpec groupParamSpec &#x3D; ParameterSpec.builder(inputMapTypeOfGroup, &quot;atlas&quot;).build();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 定义loadInto方法</span><br><span class="line">            MethodSpec.Builder loadIntoMethodOfRootBuilder &#x3D; MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">                    .addAnnotation(Override.class)</span><br><span class="line">                    .addModifiers(PUBLIC)</span><br><span class="line">                    .addParameter(rootParamSpec);</span><br><span class="line">                    </span><br><span class="line">            for (Element element : routeElements) &#123;</span><br><span class="line">                TypeMirror tm &#x3D; element.asType();</span><br><span class="line">                Route route &#x3D; element.getAnnotation(Route.class);</span><br><span class="line">                RouteMeta routeMeta;    </span><br><span class="line">                ...</span><br><span class="line">                routeMeta &#x3D; new RouteMeta(route, element, RouteType.ACTIVITY, paramsType);</span><br><span class="line">                ...</span><br><span class="line">                categories(routeMeta);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for (Map.Entry&lt;String, Set&lt;RouteMeta&gt;&gt; entry : groupMap.entrySet()) &#123;</span><br><span class="line">                String groupName &#x3D; entry.getKey();</span><br><span class="line">                MethodSpec.Builder loadIntoMethodOfGroupBuilder &#x3D; MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">                        .addAnnotation(Override.class)</span><br><span class="line">                        .addModifiers(PUBLIC)</span><br><span class="line">                        .addParameter(groupParamSpec);</span><br><span class="line">            </span><br><span class="line">                Set&lt;RouteMeta&gt; groupData &#x3D; entry.getValue();</span><br><span class="line">                for (RouteMeta routeMeta : groupData) &#123;</span><br><span class="line">                    ClassName className &#x3D; ClassName.get((TypeElement) routeMeta.getRawType());</span><br><span class="line">                    StringBuilder mapBodyBuilder &#x3D; new StringBuilder();</span><br><span class="line">                    Map&lt;String, Integer&gt; paramsType &#x3D; routeMeta.getParamsType();</span><br><span class="line">                    Map&lt;String, Autowired&gt; injectConfigs &#x3D; routeMeta.getInjectConfig();</span><br><span class="line">                    if (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                        for (Map.Entry&lt;String, Integer&gt; types : paramsType.entrySet()) &#123;</span><br><span class="line">                            mapBodyBuilder.append(&quot;put(\&quot;&quot;).append(types.getKey()).append(&quot;\&quot;, &quot;).append(types.getValue()).append(&quot;); &quot;);</span><br><span class="line">                            Autowired injectConfig &#x3D; injectConfigs.get(types.getKey());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String mapBody &#x3D; mapBodyBuilder.toString();</span><br><span class="line"></span><br><span class="line">                    loadIntoMethodOfGroupBuilder.addStatement(</span><br><span class="line">                            &quot;atlas.put($S, $T.build($T.&quot; + routeMeta.getType() + &quot;, $T.class, $S, $S, &quot; + (StringUtils.isEmpty(mapBody) ? null : (&quot;new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;&quot; + mapBodyBuilder.toString() + &quot;&#125;&#125;&quot;)) + &quot;, &quot; + routeMeta.getPriority() + &quot;, &quot; + routeMeta.getExtra() + &quot;))&quot;,</span><br><span class="line">                            routeMeta.getPath(),</span><br><span class="line">                            routeMetaCn,</span><br><span class="line">                            routeTypeCn,</span><br><span class="line">                            className,</span><br><span class="line">                            routeMeta.getPath().toLowerCase(),</span><br><span class="line">                            routeMeta.getGroup().toLowerCase());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终生成的代码路径：app/build/generated/ap_generated_sources/</p>
<p><img src="ARouter%E6%B3%A8%E8%A7%A3%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81.png" alt="ARouter注解生成代码"></p>
<h5 id="3-3-api接口模块"><a href="#3-3-api接口模块" class="headerlink" title="3.3 api接口模块"></a>3.3 api接口模块</h5><p><strong>ARouter门面类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * ARouter 代理模式， 内部实际是_ARouter</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final class ARouter &#123;</span><br><span class="line">    private volatile static ARouter instance &#x3D; null;</span><br><span class="line">    private volatile static boolean hasInit &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    public static void init(Application application) &#123;</span><br><span class="line">        if (!hasInit) &#123;</span><br><span class="line">            hasInit &#x3D; _ARouter.init(application);</span><br><span class="line">            if (hasInit) &#123;</span><br><span class="line">                _ARouter.afterInit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; DCL</span><br><span class="line">    public static ARouter getInstance() &#123;</span><br><span class="line">        if (!hasInit) &#123;</span><br><span class="line">            Log.d(TAG, &quot;ARouter::Init::Invoke init(context) first!&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                synchronized (ARouter.class) &#123;</span><br><span class="line">                    if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        instance &#x3D; new ARouter();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Postcard build(String path) &#123;</span><br><span class="line">        return _ARouter.getInstance().build(path);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object navigation(Context mContext, Postcard postcard, int requestCode, NavigationCallback callback) &#123;</span><br><span class="line">        return _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>_ARouter 实际类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">final class _ARouter &#123;</span><br><span class="line">    private volatile static _ARouter instance &#x3D; null;</span><br><span class="line">    private static Handler mHandler;    </span><br><span class="line"></span><br><span class="line">    protected static synchronized boolean init(Application application) &#123;</span><br><span class="line">        mContext &#x3D; application;</span><br><span class="line">        LogisticsCenter.init(mContext, executor);</span><br><span class="line">        hasInit &#x3D; true;</span><br><span class="line">        mHandler &#x3D; new Handler(Looper.getMainLooper());</span><br><span class="line">        return true;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    protected Postcard build(String path) &#123;</span><br><span class="line">        return build(path, extractGroup(path), true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据path、group生成Postcard对象</span><br><span class="line">    protected Postcard build(String path, String group, Boolean afterReplace) &#123;</span><br><span class="line">        return new Postcard(path, group);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            LogisticsCenter.completion(postcard);</span><br><span class="line">        &#125; catch (NoRouteFoundException ex) &#123;</span><br><span class="line">            if (null !&#x3D; callback) &#123;</span><br><span class="line">                callback.onLost(postcard);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 采用降级服务</span><br><span class="line">                DegradeService degradeService &#x3D; ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">                if (null !&#x3D; degradeService) &#123;</span><br><span class="line">                    degradeService.onLost(context, postcard);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (null !&#x3D; callback) &#123;</span><br><span class="line">            callback.onFound(postcard);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!postcard.isGreenChannel()) &#123;</span><br><span class="line">            &#x2F;&#x2F; It must be run in async thread, maybe interceptor cost too mush time made ANR.</span><br><span class="line">            interceptorService.doInterceptions(postcard, new InterceptorCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onContinue(Postcard postcard) &#123;</span><br><span class="line">                    _navigation(context, postcard, requestCode, callback);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onInterrupt(Throwable exception) &#123;</span><br><span class="line">                    if (null !&#x3D; callback) &#123;</span><br><span class="line">                        callback.onInterrupt(postcard);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);        </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return _navigation(context, postcard, requestCode, callback);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123;</span><br><span class="line">        final Context currentContext &#x3D; null &#x3D;&#x3D; context ? mContext : context;</span><br><span class="line"></span><br><span class="line">        switch (postcard.getType()) &#123;</span><br><span class="line">            case ACTIVITY:</span><br><span class="line">                final Intent intent &#x3D; new Intent(currentContext, postcard.getDestination());</span><br><span class="line">                intent.putExtras(postcard.getExtras());</span><br><span class="line">                int flags &#x3D; postcard.getFlags();</span><br><span class="line">                if (-1 !&#x3D; flags) &#123;</span><br><span class="line">                    intent.setFlags(flags);</span><br><span class="line">                &#125; else if (!(currentContext instanceof Activity)) &#123;</span><br><span class="line">                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String action &#x3D; postcard.getAction();</span><br><span class="line">                if (!TextUtils.isEmpty(action)) &#123;</span><br><span class="line">                    intent.setAction(action);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                runInMainThread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        startActivity(requestCode, currentContext, intent, postcard, callback);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                break;</span><br><span class="line">            case PROVIDER:</span><br><span class="line">                return postcard.getProvider();</span><br><span class="line">            case BOARDCAST:</span><br><span class="line">            case CONTENT_PROVIDER:</span><br><span class="line">            case FRAGMENT:</span><br><span class="line">                Class fragmentMeta &#x3D; postcard.getDestination();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Object instance &#x3D; fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                    if (instance instanceof Fragment) &#123;</span><br><span class="line">                        ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125; else if (instance instanceof androidx.fragment.app.Fragment) &#123;</span><br><span class="line">                        ((androidx.fragment.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    return instance;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            case METHOD:</span><br><span class="line">            case SERVICE:</span><br><span class="line">            default:</span><br><span class="line">                return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    private void startActivity(int requestCode, Context currentContext, Intent intent, Postcard postcard, NavigationCallback callback) &#123;</span><br><span class="line">        if (requestCode &gt;&#x3D; 0) &#123;</span><br><span class="line">            if (currentContext instanceof Activity) &#123;</span><br><span class="line">                ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.d(TAG, &quot;Must use [navigation(activity, ...)] to support [startActivityForResult]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((-1 !&#x3D; postcard.getEnterAnim() &amp;&amp; -1 !&#x3D; postcard.getExitAnim()) &amp;&amp; currentContext instanceof Activity) &#123;</span><br><span class="line">            &#x2F;&#x2F; Old version.</span><br><span class="line">            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null !&#x3D; callback) &#123; &#x2F;&#x2F; Navigation over.</span><br><span class="line">            callback.onArrival(postcard);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LogisticsCenter 物流中心</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class LogisticsCenter &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        executor &#x3D; tpe;</span><br><span class="line">        </span><br><span class="line">        loadRouterMap();</span><br><span class="line">        if (registerByPlugin) &#123;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Set&lt;String&gt; routerMap;</span><br><span class="line">            if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 根据包名，获取对应报名下的所有注解生成文件[ARouter混淆策略]</span><br><span class="line">                &#x2F;* 获取所有的dex文件路径</span><br><span class="line">                 ** 1. ApplicationInfo.sourceDir</span><br><span class="line">                 ** 2. 如果不支持Multidex,需要包含所有的次dex文件</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                routerMap &#x3D; ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">                if (!routerMap.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 保存到缓存文件之中</span><br><span class="line">                    context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">                &#125;</span><br><span class="line">                PackageUtils.updateVersion(context);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                routerMap &#x3D; new HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet&lt;String&gt;()));</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 反射调用注解生成的类方法loadInto</span><br><span class="line">            &#x2F;&#x2F; Class.forName和ClassLoader加载类有何不同？</span><br><span class="line">            for (String className : routerMap) &#123;</span><br><span class="line">                if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class="line">                &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">                &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized static void completion(Postcard postcard) &#123;</span><br><span class="line">        RouteMeta routeMeta &#x3D; Warehouse.routes.get(postcard.getPath());</span><br><span class="line">        if (null &#x3D;&#x3D; routeMeta) &#123;</span><br><span class="line">            Class&lt;? extends IRouteGroup&gt; groupMeta &#x3D; Warehouse.groupsIndex.get(postcard.getGroup()); </span><br><span class="line">            if (null &#x3D;&#x3D; groupMeta) &#123;</span><br><span class="line">                throw new NoRouteFoundException(TAG + &quot;There is no route match the path [&quot; + postcard.getPath() + &quot;], in group [&quot; + postcard.getGroup() + &quot;]&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                 &#x2F;&#x2F; Load route and cache it into memory, then delete from metas.</span><br><span class="line">                try &#123;</span><br><span class="line">                    IRouteGroup iGroupInstance &#x3D; groupMeta.getConstructor().newInstance();</span><br><span class="line">                    iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                    Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    throw new HandlerException(TAG + &quot;Fatal exception when loading group meta. [&quot; + e.getMessage() + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                completion(postcard);   &#x2F;&#x2F; Reload</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">            postcard.setType(routeMeta.getType());</span><br><span class="line">            postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">            postcard.setExtra(routeMeta.getExtra());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Warehouse 全局数据仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Warehouse &#123;</span><br><span class="line">    &#x2F;&#x2F; Cache route and metas</span><br><span class="line">    static Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    static Map&lt;String, RouteMeta&gt; routes &#x3D; new HashMap&lt;&gt;();  </span><br><span class="line">    &#x2F;&#x2F; Cache provider</span><br><span class="line">    static Map&lt;Class, IProvider&gt; providers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    static Map&lt;String, RouteMeta&gt; providersIndex &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache interceptor</span><br><span class="line">    static Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex &#x3D; new UniqueKeyTreeMap&lt;&gt;(&quot;More than one interceptors use same priority [%s]&quot;);</span><br><span class="line">    static List&lt;IInterceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/26/22%20Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E4%B9%8BHook%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/26/22%20Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E4%B9%8BHook%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">22 Android 插件化之Hook机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-26 11:27:17 / 修改时间：14:53:33" itemprop="dateCreated datePublished" datetime="2020-06-26T11:27:17+08:00">2020-06-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Android-%E6%8F%92%E4%BB%B6%E5%8C%96%E4%B9%8BHook%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">Android 插件化之Hook机制</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/26/22%20Android%20%E6%8F%92%E4%BB%B6%E5%8C%96%E4%B9%8BHook%E6%9C%BA%E5%88%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/24/21%20Android%20MultiDex%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/24/21%20Android%20MultiDex%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">21 Android MultiDex 实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-24 22:21:22" itemprop="dateCreated datePublished" datetime="2020-06-24T22:21:22+08:00">2020-06-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Android-MultiDex-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">Android MultiDex 实现原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是64K限制和LinearAlloc限制"><a href="#什么是64K限制和LinearAlloc限制" class="headerlink" title="什么是64K限制和LinearAlloc限制"></a>什么是64K限制和LinearAlloc限制</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/24/21%20Android%20MultiDex%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84&%E6%B3%A8%E8%A7%A3&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84&%E6%B3%A8%E8%A7%A3&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="post-title-link" itemprop="url">Java基础之反射&注解&动态代理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-21 22:31:16" itemprop="dateCreated datePublished" datetime="2020-06-21T22:31:16+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">反射&注解&动态代理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/21/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84&%E6%B3%A8%E8%A7%A3&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/Android%E5%9F%BA%E7%A1%80%E4%B9%8BSparseArray%20&%20ArrayMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/Android%E5%9F%BA%E7%A1%80%E4%B9%8BSparseArray%20&%20ArrayMap/" class="post-title-link" itemprop="url">Android基础之SparseArray & ArrayMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 18:06:31 / 修改时间：22:09:40" itemprop="dateCreated datePublished" datetime="2020-06-21T18:06:31+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Android基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h4><p>SparseArray<E>是用于在Android平台上替代HashMap的数据结构,更具体的说，是用于替代key为int类型，value为Object类型的HashMap。</p>
<p>和ArrayMap类似，它的实现相比于HashMap更加节省空间，而且由于key指定为int类型，也可以节省int-Integer的装箱拆箱操作带来的性能消耗。</p>
<p>它也是<strong>线程不安全的，允许value为null</strong>。内部实现是基于两个数组。一个int[]数组mKeys，用于保存每个item的key，key本身就是int类型，所以可以理解hashCode值就是key的值.一个Object[]数组mValues，保存value。容量和key数组的一样。<strong>扩容时只需要数组拷贝工作，不需要重建哈希表。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">public class SparseArray&lt;E&gt; implements Cloneable &#123;</span><br><span class="line">    &#x2F;&#x2F; 同来标记已删除的元素</span><br><span class="line">    private static final Object DELETED &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; GC标记</span><br><span class="line">    private boolean mGarbage &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 用来保存key的数据</span><br><span class="line">    private int[] mKeys;</span><br><span class="line">    &#x2F;&#x2F; 同来保存value的数组</span><br><span class="line">    private Object[] mValues;</span><br><span class="line">    &#x2F;&#x2F; SparseArray的大小</span><br><span class="line">    private int mSize;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 默认大小为10</span><br><span class="line">    public SparseArray() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public SparseArray(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mKeys &#x3D; EmptyArray.INT;</span><br><span class="line">            mValues &#x3D; EmptyArray.OBJECT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mValues &#x3D; ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">            mKeys &#x3D; new int[mValues.length];</span><br><span class="line">        &#125;</span><br><span class="line">        mSize &#x3D; 0;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 深拷贝</span><br><span class="line">    public SparseArray&lt;E&gt; clone() &#123;</span><br><span class="line">        SparseArray&lt;E&gt; clone &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clone &#x3D; (SparseArray&lt;E&gt;) super.clone();</span><br><span class="line">            clone.mKeys &#x3D; mKeys.clone();</span><br><span class="line">            clone.mValues &#x3D; mValues.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException cnse) &#123;</span><br><span class="line">            &#x2F;* ignore *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 【添加元素】</span><br><span class="line">    public void put(int key, E value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 二分查找key对应的位置</span><br><span class="line">        int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 更新value值</span><br><span class="line">            mValues[i] &#x3D; value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 没找到，则取反返回应该插入的位置</span><br><span class="line">            i &#x3D; ~i;</span><br><span class="line">            &#x2F;&#x2F; 待插入的位置为已经删除的元素，则替换</span><br><span class="line">            if (i &lt; mSize &amp;&amp; mValues[i] &#x3D;&#x3D; DELETED) &#123;</span><br><span class="line">                mKeys[i] &#x3D; key;</span><br><span class="line">                mValues[i] &#x3D; value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果size大小数组的长度，则进行GC回收完成之后再插入</span><br><span class="line">            if (mGarbage &amp;&amp; mSize &gt;&#x3D; mKeys.length) &#123;</span><br><span class="line">                gc();</span><br><span class="line">                i &#x3D; ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 这里涉及到扩容</span><br><span class="line">            mKeys &#x3D; GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">            mValues &#x3D; GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">            mSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;    </span><br><span class="line">&#x2F;&#x2F; [GrowingArrayUtils.java] </span><br><span class="line">    public static int[] insert(int[] array, int currentSize, int index, int element) &#123;</span><br><span class="line">        assert currentSize &lt;&#x3D; array.length;</span><br><span class="line"></span><br><span class="line">        if (currentSize + 1 &lt;&#x3D; array.length) &#123;</span><br><span class="line">            &#x2F;&#x2F; 这里涉及到移动元素的位置</span><br><span class="line">            System.arraycopy(array, index, array, index + 1, currentSize - index);</span><br><span class="line">            array[index] &#x3D; element;</span><br><span class="line">            return array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] newArray &#x3D; new int[growSize(currentSize)];</span><br><span class="line">        System.arraycopy(array, 0, newArray, 0, index);</span><br><span class="line">        newArray[index] &#x3D; element;</span><br><span class="line">        System.arraycopy(array, index, newArray, index + 1, array.length - index);</span><br><span class="line">        return newArray;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    public static int growSize(int currentSize) &#123;</span><br><span class="line">        return currentSize &lt;&#x3D; 4 ? 8 : currentSize * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 【查找元素】</span><br><span class="line">    public E get(int key) &#123;</span><br><span class="line">        return get(key, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E get(int key, E valueIfKeyNotFound) &#123;</span><br><span class="line">        &#x2F;&#x2F; 二分查找返回key的位置</span><br><span class="line">        int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        if (i &lt; 0 || mValues[i] &#x3D;&#x3D; DELETED) &#123;</span><br><span class="line">            return valueIfKeyNotFound;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (E) mValues[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 【删除元素】</span><br><span class="line">    public void delete(int key) &#123;</span><br><span class="line">        int i &#x3D; ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">        if (i &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 删除元素之后，将mGarbage标记为true</span><br><span class="line">            if (mValues[i] !&#x3D; DELETED) &#123;</span><br><span class="line">                mValues[i] &#x3D; DELETED;</span><br><span class="line">                mGarbage &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 【回收已经删除的元素】</span><br><span class="line">    private void gc() &#123;</span><br><span class="line">        int n &#x3D; mSize;</span><br><span class="line">        int o &#x3D; 0;</span><br><span class="line">        int[] keys &#x3D; mKeys;</span><br><span class="line">        Object[] values &#x3D; mValues;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">            Object val &#x3D; values[i];</span><br><span class="line"></span><br><span class="line">            if (val !&#x3D; DELETED) &#123;</span><br><span class="line">                if (i !&#x3D; o) &#123;</span><br><span class="line">                    keys[o] &#x3D; keys[i];</span><br><span class="line">                    values[o] &#x3D; val;</span><br><span class="line">                    values[i] &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                o++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mGarbage &#x3D; false;</span><br><span class="line">        mSize &#x3D; o;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SparseArray是android里为&lt;Interger,Object&gt;这样的Hashmap而专门写的类,目的是提高内存效率，其核心是折半查找函数（binarySearch）。注意内存二字很重要，因为它仅仅提高内存效率，而不是提高执行效率，它只适用于android系统（内存对android项目有多重要，地球人都知道）。SparseArray有两个优点：1.避免了自动装箱（auto-boxing），2.数据结构不会依赖于外部对象映射。我们知道HashMap 采用一种所谓的“Hash 算法”来决定每个元素的存储位置，存放的都是数组元素的引用，通过每个对象的hash值来映射对象。而SparseArray则是用数组数据结构来保存映射，然后通过折半查找来找到对象。但其实一般来说，SparseArray执行效率比HashMap要慢一点，因为查找需要折半查找，而添加删除则需要在数组中执行，而HashMap都是通过外部映射。但相对来说影响不大，最主要是SparseArray不需要开辟内存空间来额外存储外部映射，从而节省内存</p>
<p>总结来说，有几点设计思想还是值得学习的：</p>
<ul>
<li>延迟删除机制</li>
<li>二分查找的返回值处理</li>
<li>利用gc函数一次性压缩空间，提高效率</li>
</ul>
<h4 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h4><p>ArrayMap 实现了implements Map&lt;K, V&gt;接口，所以它也是一个关联数组、哈希表。存储以key-&gt;value 结构形式的数据。它也是线程不安全的，允许key为null,value为null。</p>
<p>相比HashMap，空间效率更高。它的内部实现是基于两个数组。一个int[]数组，用于保存每个item的hashCode.一个Object[]数组，保存key/value键值对。容量是上一个数组的两倍。它可以避免在将数据插入Map中时额外的空间消耗（对比HashMap）。而且它扩容的更合适，扩容时只需要数组拷贝工作，不需要重建哈希表。</p>
<p>ArrayMap有如下的特点：</p>
<ul>
<li>ArrayMap是Android特有的api，用在移动端，所以它主要是提高内存效率。</li>
<li>ArrayMap比传统的HashMap慢，所以ArrayMap不适合包含大数据的处理，因为添加和删除元素的时候需要使用二分搜索来查找元素。</li>
<li>ArrayMap会在remove item的时候收缩数组。</li>
<li>ArrayMap不是线程安全的。</li>
</ul>
<p><img src="BN7Vna7.png" alt="ArrayMap原理"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">public final class ArrayMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;扩容默认的size， 4是相对效率较高的大小</span><br><span class="line">    private static final int BASE_SIZE &#x3D; 4;</span><br><span class="line">    &#x2F;&#x2F;表示集合是不可变的</span><br><span class="line">    static final int[] EMPTY_IMMUTABLE_INTS &#x3D; new int[0];</span><br><span class="line">    &#x2F;&#x2F;是否利用System.identityHashCode(key) 获取唯一HashCode模式。    </span><br><span class="line">    final boolean mIdentityHashCode;</span><br><span class="line"></span><br><span class="line">    int[] mHashes;</span><br><span class="line">    Object[] mArray;</span><br><span class="line">    int mSize;</span><br><span class="line"></span><br><span class="line">    public ArrayMap() &#123;</span><br><span class="line">        this(0, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArrayMap(int capacity, boolean identityHashCode) &#123;</span><br><span class="line">        mIdentityHashCode &#x3D; identityHashCode;</span><br><span class="line">        &#x2F;&#x2F; capacity &lt; 0，构建一个不可变的ArrayMap</span><br><span class="line">        if (capacity &lt; 0) &#123;</span><br><span class="line">            mHashes &#x3D; EMPTY_IMMUTABLE_INTS;</span><br><span class="line">            mArray &#x3D; EmptyArray.OBJECT;</span><br><span class="line">        &#125; else if (capacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mHashes &#x3D; EmptyArray.INT;</span><br><span class="line">            mArray &#x3D; EmptyArray.OBJECT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            allocArrays(capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        mSize &#x3D; 0;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 【查询元素】</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        final int index &#x3D; indexOfKey(key);</span><br><span class="line">        return index &gt;&#x3D; 0 ? (V)mArray[(index&lt;&lt;1)+1] : null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int indexOfKey(Object key) &#123;</span><br><span class="line">        return key &#x3D;&#x3D; null ? indexOfNull()</span><br><span class="line">                : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    int indexOf(Object key, int hash) &#123;</span><br><span class="line">        final int N &#x3D; mSize;</span><br><span class="line">        if (N &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return ~0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int index &#x3D; binarySearchHashes(mHashes, N, hash);</span><br><span class="line">        &#x2F;&#x2F; 没有找到该hash</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 找到则判断key是否相同，如果不相同则hash冲突</span><br><span class="line">        if (key.equals(mArray[index&lt;&lt;1])) &#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        int end;</span><br><span class="line">        &#x2F;&#x2F; 查询index后面的key</span><br><span class="line">        for (end &#x3D; index + 1; end &lt; N &amp;&amp; mHashes[end] &#x3D;&#x3D; hash; end++) &#123;</span><br><span class="line">            if (key.equals(mArray[end &lt;&lt; 1])) return end;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; &#x2F;&#x2F; 查询index前面的key</span><br><span class="line">        for (int i &#x3D; index - 1; i &gt;&#x3D; 0 &amp;&amp; mHashes[i] &#x3D;&#x3D; hash; i--) &#123;</span><br><span class="line">            if (key.equals(mArray[i &lt;&lt; 1])) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 真的没有找到</span><br><span class="line">        return ~end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 【添加元素】</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        final int osize &#x3D; mSize;</span><br><span class="line">        final int hash;</span><br><span class="line">        int index;</span><br><span class="line">        &#x2F;&#x2F; 处理key&#x3D;null</span><br><span class="line">        if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            hash &#x3D; 0;</span><br><span class="line">            index &#x3D; indexOfNull();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            hash &#x3D; mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();</span><br><span class="line">            index &#x3D; indexOf(key, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 处理覆盖操作</span><br><span class="line">        if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">            index &#x3D; (index&lt;&lt;1) + 1;</span><br><span class="line">            final V old &#x3D; (V)mArray[index];</span><br><span class="line">            mArray[index] &#x3D; value;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index &#x3D; ~index;</span><br><span class="line">        &#x2F;&#x2F; 需要扩容</span><br><span class="line">        if (osize &gt;&#x3D; mHashes.length) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果容量大于8，则扩容一半。</span><br><span class="line">            &#x2F;&#x2F; 否则容量大于4，则扩容到8.</span><br><span class="line">            &#x2F;&#x2F; 否则扩容到4</span><br><span class="line">            final int n &#x3D; osize &gt;&#x3D; (BASE_SIZE*2) ? (osize+(osize&gt;&gt;1))</span><br><span class="line">                    : (osize &gt;&#x3D; BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);</span><br><span class="line">            &#x2F;&#x2F; 临时数组</span><br><span class="line">            final int[] ohashes &#x3D; mHashes;</span><br><span class="line">            final Object[] oarray &#x3D; mArray;</span><br><span class="line">            &#x2F;&#x2F; 分配空间完成扩容</span><br><span class="line">            allocArrays(n);</span><br><span class="line">            &#x2F;&#x2F; 复制临时数组中的数组进新数组</span><br><span class="line">            if (mHashes.length &gt; 0) &#123;</span><br><span class="line">                System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);</span><br><span class="line">                System.arraycopy(oarray, 0, mArray, 0, oarray.length);</span><br><span class="line">            &#125;</span><br><span class="line">            freeArrays(ohashes, oarray, osize);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 因为这时候已经找到了插入的index位置，所以mHashes与mArray都要挪一位，为了给即将插入的元素留下位置。</span><br><span class="line">        if (index &lt; osize) &#123;</span><br><span class="line">            System.arraycopy(mHashes, index, mHashes, index + 1, osize - index);</span><br><span class="line">            System.arraycopy(mArray, index &lt;&lt; 1, mArray, (index + 1) &lt;&lt; 1, (mSize - index) &lt;&lt; 1);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 赋值操作</span><br><span class="line">        mHashes[index] &#x3D; hash;</span><br><span class="line">        mArray[index&lt;&lt;1] &#x3D; key;</span><br><span class="line">        mArray[(index&lt;&lt;1)+1] &#x3D; value;</span><br><span class="line">        mSize++;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayMap增加元素的流程图]:</p>
<p><img src="3768281-a6cd7588adac33c4.png" alt="ArrayMap增加元素的流程图"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/20%20Android%E6%8F%92%E4%BB%B6%E5%8C%96&%E7%83%AD%E4%BF%AE%E5%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/20%20Android%E6%8F%92%E4%BB%B6%E5%8C%96&%E7%83%AD%E4%BF%AE%E5%A4%8D/" class="post-title-link" itemprop="url">20 Android插件化&热修复</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-21 17:31:37" itemprop="dateCreated datePublished" datetime="2020-06-21T17:31:37+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Android%E6%8F%92%E4%BB%B6%E5%8C%96-%E7%83%AD%E4%BF%AE%E5%A4%8D/" itemprop="url" rel="index"><span itemprop="name">Android插件化&热修复</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Android插件化-amp-热修复"><a href="#Android插件化-amp-热修复" class="headerlink" title="Android插件化&amp;热修复"></a>Android插件化&amp;热修复</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/06/21/20%20Android%E6%8F%92%E4%BB%B6%E5%8C%96&%E7%83%AD%E4%BF%AE%E5%A4%8D/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
