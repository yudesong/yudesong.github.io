<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（七）：深入分析Synchronized原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 20:44:03" itemprop="dateCreated datePublished" datetime="2020-06-01T20:44:03+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>记得开始学习Java的时候，一遇到多线程情况就使用synchronized，相对于当时的我们来说synchronized是这么的神奇而又强大，那个时候我们赋予它一个名字“同步”，也成为了我们解决多线程情况的百试不爽的良药。但是，<strong>随着学习的进行我们知道在JDK1.5之前synchronized是一个重量级锁，相对于j.u.c.Lock，它会显得那么笨重，以至于我们认为它不是那么的高效而慢慢摒弃它。</strong></p>
<p>不过，<strong>随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。</strong>下面来一起探索synchronized的基本使用、实现机制、Java是如何对它进行了优化、锁优化机制、锁的存储结构等升级过程。</p>
<h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h4><p>Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。<strong>Synchronized的作用主要有三个：</strong></p>
<blockquote>
<p><strong>1.原子性</strong>：确保线程互斥的访问同步代码；<br><strong>2.可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的<strong>“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”</strong>来保证的；<br><strong>3.有序性</strong>：有效解决重排序问题，即<strong>“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</strong>；</p>
</blockquote>
<p>从语法上讲，<strong>Synchronized可以把任何一个非null对象作为”锁”，</strong>在HotSpot JVM实现中，锁有个专门的名字：对象监视器（Object Monitor）。</p>
<p><strong>Synchronized总共有三种用法：</strong></p>
<blockquote>
<p>1.当synchronized作用在实例方法时，<strong>监视器锁（monitor）便是对象实例（this）</strong>；<br>2.当synchronized作用在静态方法时，<strong>监视器锁（monitor）便是对象的Class实例</strong>，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；<br>3.当synchronized作用在某一个对象实例时，<strong>监视器锁（monitor）便是括号括起来的对象实例</strong>；</p>
</blockquote>
<p>注意，<strong>synchronized 内置锁</strong>是一种 对象锁（锁的是对象而非引用变量），作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是可重入的。<strong>其可重入最大的作用是避免死锁</strong>，如：</p>
<blockquote>
<p>子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁；</p>
</blockquote>
<h4 id="2-同步原理"><a href="#2-同步原理" class="headerlink" title="2 同步原理"></a>2 同步原理</h4><p>数据同步需要依赖锁，那锁的同步又依赖谁？<strong>synchronized给出的答案是在软件层面依赖JVM，而j.u.c.Lock给出的答案是在硬件层面依赖特殊的CPU指令。</strong></p>
<p>当一个线程访问同步代码块时，<strong>首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，</strong>那么它是如何来实现这个机制的呢？我们先看一段简单的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.paddx.test.concurrent;</span><br><span class="line">public class SynchronizedDemo &#123;</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;Method 1 start&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看反编译后结果：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-b98084591219da8c.png" alt="反编译结果"></p>
<p><strong>1. monitorenter：</strong>每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<blockquote>
<p><strong>1.如果monitor的进入数为0，</strong>则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；<br><strong>2.如果线程已经占有该monitor，</strong>只是重新进入，则进入monitor的进入数加1；<br><strong>3.如果其他线程已经占用了monitor，</strong>则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</p>
</blockquote>
<p><strong>2.monitorexit：</strong>执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<blockquote>
<p><strong>monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</strong></p>
</blockquote>
<p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理,<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，</strong>这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，<strong>否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</strong></p>
<p>再来看一下同步方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.paddx.test.concurrent;</span><br><span class="line"></span><br><span class="line">public class SynchronizedMethod &#123;</span><br><span class="line">    public synchronized void method() &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查看反编译后结果：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-8b7734120fae6645.png" alt="反编译结果"></p>
<p>从编译的结果来看，方法的同步并没有通过指令<strong>monitorenter</strong>和 <strong>monitorexit</strong> 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 ACC_SYNCHRONIZED 标示符。<strong>JVM就是根据该标示符来实现方法的同步的：</strong></p>
<blockquote>
<p>当方法调用时，<strong>调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</strong></p>
</blockquote>
<p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。<strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度,</strong>会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
<h4 id="3-同步概念"><a href="#3-同步概念" class="headerlink" title="3 同步概念"></a>3 同步概念</h4><h5 id="3-1-Java对象头"><a href="#3-1-Java对象头" class="headerlink" title="3.1 Java对象头"></a>3.1 Java对象头</h5><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-9a78f7ea7671a031.png" alt=""></p>
<blockquote>
<p>1.实例数据：存放类的属性数据信息，包括父类的属性信息；<br>2.对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；<br>3.对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
</blockquote>
<p>Synchronized用的锁就是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：<strong>Mark Word（标记字段）</strong>、 <strong>Class Pointer（类型指针）</strong>。其中 Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。 </p>
<p>Java对象头具体结构描述如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-2ab6edc7f91a1535.png" alt="Java对象头结构组成"></p>
<p>Mark Word用于存储对象自身的运行时数据，如：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。下图是Java对象头 无锁状态下Mark Word部分的存储结构（32位虚拟机）：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-063a9a5dc677cd12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp" alt="Mark Word存储结构"><br>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，可能变化为存储以下4种数据：</p>
<p>Mark Word可能存储4种数据<br>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p>
<p>64位Mark Word存储结构<br>对象头的最后两位存储了锁的标志位，01是初始状态，未加锁，其对象头里存储的是对象本身的哈希码，随着锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID；而轻量级则存储指向线程栈中锁记录的指针。从这里我们可以看到，“锁”这个东西，可能是个锁记录+对象头里的引用指针（判断线程是否拥有锁时将线程的锁记录地址和对象头里的指针地址比较)，也可能是对象头里的线程ID（判断线程是否拥有锁时将线程的ID和对象头里存储的线程ID比较）。</p>
<p>HotSpot虚拟机对象头Mark Word</p>
<p><strong>64位JVM如果开启+UseCompressedOops选项，Klass Word（类指针）、数组长度区域长度也将由64位压缩至32位。</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/114422601" target="_blank" rel="noopener">Object obj=new Object()占多少字节啊？</a></p>
<p>3.2 对象头中Mark Word与线程中Lock Record<br>在线程进入同步代码块的时候，如果此同步对象没有被锁定，即它的锁标志位是01，则虚拟机首先在当前线程的栈中创建我们称之为“锁记录（Lock Record）”的空间，用于存储锁对象的Mark Word的拷贝，官方把这个拷贝称为Displaced Mark Word。整个Mark Word及其拷贝至关重要。</p>
<p>Lock Record是线程私有的数据结构，每一个线程都有一个可用Lock Record列表，同时还有一个全局的可用列表。每一个被锁住的对象Mark Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock Record的起始地址），同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识（或者object mark word），表示该锁被这个线程占用。如下图所示为Lock Record的内部结构：</p>
<p>Lock Record    描述<br>Owner    初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；<br>EntryQ    关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程；<br>RcThis    表示blocked或waiting在该monitor record上的所有线程的个数；<br>Nest    用来实现 重入锁的计数；<br>HashCode    保存从对象头拷贝过来的HashCode值（可能还包含GC age）。<br>Candidate    用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。<br>3.3 监视器（Monitor）<br>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<p>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；<br>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；<br>那什么是Monitor？可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。</p>
<p>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p>
<p>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       &#x3D; NULL;</span><br><span class="line">    _count        &#x3D; 0; &#x2F;&#x2F; 记录个数</span><br><span class="line">    _waiters      &#x3D; 0,</span><br><span class="line">    _recursions   &#x3D; 0;</span><br><span class="line">    _object       &#x3D; NULL;</span><br><span class="line">    _owner        &#x3D; NULL;</span><br><span class="line">    _WaitSet      &#x3D; NULL; &#x2F;&#x2F; 处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  &#x3D; 0 ;</span><br><span class="line">    _Responsible  &#x3D; NULL ;</span><br><span class="line">    _succ         &#x3D; NULL ;</span><br><span class="line">    _cxq          &#x3D; NULL ;</span><br><span class="line">    FreeNext      &#x3D; NULL ;</span><br><span class="line">    _EntryList    &#x3D; NULL ; &#x2F;&#x2F; 处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">    _SpinFreq     &#x3D; 0 ;</span><br><span class="line">    _SpinClock    &#x3D; 0 ;</span><br><span class="line">    OwnerIsThread &#x3D; 0 ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：</p>
<p>首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；<br>若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；<br>若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；<br>同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</p>
<p>监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p>
<p>什么时候需要协作？ 比如：</p>
<p>一个线程向缓冲区写数据，另一个线程从缓冲区读数据，如果读线程发现缓冲区为空就会等待，当写线程向缓冲区写入数据，就会唤醒读线程，这里读线程和写线程就是一个合作关系。JVM通过Object类的wait方法来使自己等待，在调用wait方法后，该线程会释放它持有的监视器，直到其他线程通知它才有执行的机会。一个线程调用notify方法通知在等待的线程，这个等待的线程并不会马上执行，而是要通知线程释放监视器后，它重新获取监视器才有执行的机会。如果刚好唤醒的这个线程需要的监视器被其他线程抢占，那么这个线程会继续等待。Object类中的notifyAll方法可以解决这个问题，它可以唤醒所有等待的线程，总有一个线程执行。</p>
<p>如上图所示，一个线程通过1号门进入Entry Set(入口区)，如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。线程在持有监视器的过程中，有两个选择，一个是正常执行监视器区域的代码，释放监视器，通过5号门退出监视器；还有可能等待某个条件的出现，于是它会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。</p>
<p>注意：</p>
<p>当一个线程释放监视器时，在入口区和等待区的等待线程都会去竞争监视器，如果入口区的线程赢了，会从2号门进入；如果等待区的线程赢了会从4号门进入。只有通过3号门才能进入等待区，在等待区中的线程只有通过4号门才能退出等待区，也就是说一个线程只有在持有监视器时才能执行wait操作，处于等待的线程只有再次获得监视器才能退出等待状态。</p>
<h5 id="4-锁的优化"><a href="#4-锁的优化" class="headerlink" title="4 锁的优化"></a>4 锁的优化</h5><p>从JDK5引入了现代操作系统新增加的CAS原子操作（ JDK5中并没有对synchronized关键字做优化，而是体现在J.U.C中，所以在该版本concurrent包有更好的性能 ），从JDK6开始，就对synchronized的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p>
<p>在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p>
<h5 id="4-1-自旋锁"><a href="#4-1-自旋锁" class="headerlink" title="4.1 自旋锁"></a>4.1 自旋锁</h5><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。</p>
<p>所以引入自旋锁，何谓自旋锁？</p>
<p>所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p>
<p>自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
<p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。</p>
<p>如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p>
<h5 id="4-2-适应性自旋锁"><a href="#4-2-适应性自旋锁" class="headerlink" title="4.2 适应性自旋锁"></a>4.2 适应性自旋锁</h5><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。那它如何进行适应性自旋呢？</p>
<p>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
<p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h5 id="4-3-锁消除"><a href="#4-3-锁消除" class="headerlink" title="4.3 锁消除"></a>4.3 锁消除</h5><p>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。</p>
<p>锁消除的依据是逃逸分析的数据支持</p>
<p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于程序员来说这还不清楚么？在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void vectorTest()&#123;</span><br><span class="line">    Vector&lt;String&gt; vector &#x3D; new Vector&lt;String&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; 10 ; i++)&#123;</span><br><span class="line">        vector.add(i + &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p>
<h5 id="4-4-锁粗化"><a href="#4-4-锁粗化" class="headerlink" title="4.4 锁粗化"></a>4.4 锁粗化</h5><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是 为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p>
<p>在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</p>
<p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p>
<p>如上面实例：</p>
<p>vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<p>4.5 偏向锁<br>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>偏向锁是在单线程执行代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。</p>
<p>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。如果并发数较大同时同步代码块执行时间较长，则被多个线程同时访问的概率就很大，就可以使用参数-XX:-UseBiasedLocking来禁止偏向锁(但这是个JVM参数，不能针对某个对象锁来单独设置)。</p>
<p>引入偏向锁主要目的是：为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗）。</p>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<p>那么偏向锁是如何来减少不必要的CAS操作呢？首先我们看下无竞争下锁存在什么问题：</p>
<p>现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住/解锁监视对象，按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是 一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。</p>
<p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构：</p>
<p>SMP（对称多处理器）架构<br>其意思是 所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。</p>
<p>而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p>
<p>例如：Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。</p>
<p>而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。</p>
<p>Cache一致性：</p>
<p>上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：<a href="http://en.wikipedia.org/wiki/MESI_protocol。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/MESI_protocol。</a></p>
<p>Cache一致性流量的例外情况：</p>
<p>其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：<a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot" target="_blank" rel="noopener">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></p>
<p>NUMA(Non Uniform Memory Access Achitecture）架构：</p>
<p>与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。</p>
<p>所以，当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要花费CAS操作来争夺锁资源，只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：</p>
<p>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；<br>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；<br>如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；<br>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；<br>执行同步代码块；<br>偏向锁的释放采用了 一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要 等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<p>暂停拥有偏向锁的线程；<br>判断锁对象是否还处于被锁定状态，否，则恢复到无锁状态（01），以允许其余线程竞争。是，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头Mark Word，升级为轻量级锁状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；<br>注意：此处将 当前线程挂起再恢复的过程中并没有发生锁的转移，仍然在当前线程手中，只是穿插了个 “将对象头中的线程ID变更为指向锁记录地址的指针” 这么个事。</p>
<p>偏向锁的获取和释放过程<br>4.6 轻量级锁<br>引入轻量级锁的主要目的是 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p>
<p>在线程进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。此时线程堆栈与对象头的状态如下图所示：</p>
<p>轻量级锁CAS操作之前线程堆栈与对象的状态<br>拷贝对象头中的Mark Word复制到锁记录（Lock Record）中；</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象Mark Word中的Lock Word更新为指向当前线程Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）；</p>
<p>如果这个更新动作成功了，那么当前线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，此时线程堆栈与对象头的状态如下图所示：</p>
<p>轻量级锁CAS操作之后线程堆栈与对象的状态<br>如果这个更新操作失败了，虚拟机首先会检查对象Mark Word中的Lock Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，进入自旋执行（3），若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</p>
<p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<p>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word；<br>如果替换成功，整个同步过程就完成了，恢复到无锁状态（01）；<br>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程；<br>对于轻量级锁，其性能提升的依据是 “对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<p>轻量级锁的获取和释放过程<br>为什么升级为轻量锁时要把对象头里的Mark Word复制到线程栈的锁记录中呢？</p>
<p>因为在申请对象锁时 需要以该值作为CAS的比较条件，同时在升级到重量级锁的时候，能通过这个比较判定是否在持有锁的过程中此锁被其他线程申请过，如果被其他线程申请了，则在释放锁的时候要唤醒被挂起的线程。</p>
<p>为什么会尝试CAS不成功以及什么情况下会不成功？</p>
<p>CAS本身是不带锁机制的，其是通过比较而来。假设如下场景：线程A和线程B都在对象头里的锁标识为无锁状态进入，那么如线程A先更新对象头为其锁记录指针成功之后，线程B再用CAS去更新，就会发现此时的对象头已经不是其操作前的对象HashCode了，所以CAS会失败。也就是说，只有两个线程并发申请锁的时候会发生CAS失败。</p>
<p>然后线程B进行CAS自旋，等待对象头的锁标识重新变回无锁状态或对象头内容等于对象HashCode（因为这是线程B做CAS操作前的值），这也就意味着线程A执行结束（参见后面轻量级锁的撤销，只有线程A执行完毕撤销锁了才会重置对象头），此时线程B的CAS操作终于成功了，于是线程B获得了锁以及执行同步代码的权限。如果线程A的执行时间较长，线程B经过若干次CAS时钟没有成功，则锁膨胀为重量级锁，即线程B被挂起阻塞、等待重新调度。</p>
<p>此处，如何理解“轻量级”？“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。</p>
<p>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。</p>
<p>4.7 重量级锁<br>Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。</p>
<p>4.8 重量级锁、轻量级锁和偏向锁之间转换<br>重量级锁、轻量级锁和偏向锁之间转换<br>Synchronized偏向锁、轻量级锁及重量级锁转换流程</p>
<h5 id="5-锁的优劣"><a href="#5-锁的优劣" class="headerlink" title="5 锁的优劣"></a>5 锁的优劣</h5><p>各种锁并不是相互代替的，而是在不同场景下的不同选择，绝对不是说重量级锁就是不合适的。每种锁是只能升级，不能降级，即由偏向锁-&gt;轻量级锁-&gt;重量级锁，而这个过程就是开销逐渐加大的过程。</p>
<p>如果是单线程使用，那偏向锁毫无疑问代价最小，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较下对象头就可以了；<br>如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁；<br>如果其他线程通过一定次数的CAS尝试没有成功，则进入重量级锁；<br>在第3种情况下进入同步代码块就 要做偏向锁建立、偏向锁撤销、轻量级锁建立、升级到重量级锁，最终还是得靠重量级锁来解决问题，那这样的代价就比直接用重量级锁要大不少了。所以使用哪种技术，一定要看其所处的环境及场景，在绝大多数的情况下，偏向锁是有效的，这是基于HotSpot作者发现的“大多数锁只会由同一线程并发申请”的经验规律。</p>
<p>锁的优劣<br>6 扩展资料<br>JVM源码分析之synchronized实现<br>自旋锁、排队自旋锁、MCS锁、CLH锁<br>深入理解Java并发之synchronized实现原理</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">啃碎并发（六）：Java线程同步与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:30:50 / 修改时间：20:43:38" itemprop="dateCreated datePublished" datetime="2020-06-01T20:30:50+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p><strong>为何要使用Java线程同步？</strong> Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时，将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<p><strong>但其并发编程的根本，就是使线程间进行正确的通信。</strong>其中两个比较重要的关键点，如下：</p>
<blockquote>
<p>1.线程通信：重点关注线程同步的几种方式；<br>2.正确通信：重点关注是否有线程安全问题；</p>
</blockquote>
<p>Java中提供了很多线程同步操作，比如：<strong>synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</strong>本文主要说明一下这几种同步方式的使用及优劣。</p>
<h4 id="1-ReentrantLock可重入锁"><a href="#1-ReentrantLock可重入锁" class="headerlink" title="1 ReentrantLock可重入锁"></a>1 ReentrantLock可重入锁</h4><p>自JDK5开始，新增了Lock接口以及它的一个实现类ReentrantLock。ReentrantLock可重入锁是J.U.C包内置的一个锁对象，可以用来实现同步，基本使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line">    private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000l);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest &#x3D; new ReentrantLockTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子表示 同一时间段只能有1个线程执行execute方法，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br></pre></td></tr></table></figure>
<p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起。</strong>可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1。</p>
<p>举个例子再次说明一下可重入的意思：在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用(调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void anotherLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">Thread-0 invoke anotherLock</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br><span class="line">Thread-1 invoke anotherLock</span><br></pre></td></tr></table></figure>

<h5 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 synchronized</h5><p>synchronized跟ReentrantLock一样，也支持可重入锁。但是它是 一个关键字，是一种语法级别的同步方式，称为内置锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedKeyWordTest &#123;</span><br><span class="line">    public synchronized void execute() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void anotherLock() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynchronizedKeyWordTest reentrantLockTest &#x3D; new SynchronizedKeyWordTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果跟ReentrantLock一样，这个例子说明内置锁可以作用在方法上。synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p>
<p>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p>
<p><strong>synchronized跟ReentrantLock相比，有几点局限性：</strong></p>
<blockquote>
<p>1.加锁的时候不能设置超时。ReentrantLock有提供tryLock方法，可以设置超时时间，如果超过了这个时间并且没有获取到锁，就会放弃，而synchronized却没有这种功能；<br>2.ReentrantLock可以使用多个Condition，而synchronized却只能有1个<br>3.不能中断一个试图获得锁的线程；<br>4.ReentrantLock可以选择公平锁和非公平锁；<br>5.ReentrantLock可以获得正在等待线程的个数，计数器等；</p>
</blockquote>
<p>所以，Lock的操作与synchronized相比，灵活性更高，而且Lock提供多种方式获取锁，有Lock、ReadWriteLock接口，以及实现这两个接口的ReentrantLock类、ReentrantReadWriteLock类。</p>
<p><strong>关于Lock对象和synchronized关键字选择的考量：</strong></p>
<blockquote>
<p>1.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。<br>2.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码。<br>3.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁。</p>
</blockquote>
<p>在性能考量上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h5 id="3-Condition条件对象"><a href="#3-Condition条件对象" class="headerlink" title="3 Condition条件对象"></a>3 Condition条件对象</h5><p>Condition条件对象的意义在于 对于一个已经获取Lock锁的线程，如果还需要等待其他条件才能继续执行的情况下，才会使用Condition条件对象。</p>
<p>Condition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。</p>
<p>为什么方法名不直接叫wait()/notify()/nofityAll()？因为Object的这几个方法是final的，不可重写！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">        Condition condition &#x3D; lock.newCondition();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中thread1执行到condition.await()时，当前线程会被挂起，直到thread2调用了condition.signalAll()方法之后，thread1才会重新被激活执行。</p>
<p>这里需要注意的是thread1调用Condition的await方法之后，thread1线程释放锁，然后马上加入到Condition的等待队列，由于thread1释放了锁，thread2获得锁并执行，thread2执行signalAll方法之后，Condition中的等待队列thread1被取出并加入到AQS中，接下来thread2执行完毕之后释放锁，由于thread1已经在AQS的等待队列中，所以thread1被唤醒，继续执行。</p>
<p>传统线程的通信方式，Condition都可以实现。Condition的强大之处在于它可以为多个线程间建立不同的Condition。</p>
<p>注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<h5 id="4-wait-amp-notify-notifyAll方式"><a href="#4-wait-amp-notify-notifyAll方式" class="headerlink" title="4 wait&amp;notify/notifyAll方式"></a>4 wait&amp;notify/notifyAll方式</h5><p>Java线程的状态转换图与相关方法，如下：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2fb881c9f4656c80.png" alt="线程状态转换图"></p>
<p>在图中，红框标识的部分方法，可以认为已过时，不再使用。上图中的方法能够参与到线程同步中的方法，如下：</p>
<p><strong>1. wait、notify、notifyAll方法：线程中通信可以使用的方法。线程中调用了wait方法，则进入阻塞状态，只有等另一个线程调用与wait同一个对象的notify方法。这里有个特殊的地方，调用wait或者notify，前提是需要获取锁，也就是说，需要在同步块中做以上操作。</strong></p>
<blockquote>
<p>wait/notifyAll方式跟ReentrantLock/Condition方式的原理是一样的。</p>
<p>Java中每个对象都拥有一个内置锁，在内置锁中调用wait，notify方法相当于调用锁的Condition条件对象的await和signalAll方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyAllTest &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">            this.notifyAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WaitNotifyAllTest waitNotifyAllTest &#x3D; new WaitNotifyAllTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doNotify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 调用wait/notifyAll方法的时候一定要获得当前线程的锁，否则会发生IllegalMonitorStateException异常。</p>
<p><strong>2.join方法：该方法主要作用是在该线程中的run方法结束后，才往下执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.thread.simple;</span><br><span class="line">public class ThreadJoin &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread&#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                   System.err.println(&quot;线程&quot;+Thread.currentThread().getId()+&quot; 打印信息&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">     </span><br><span class="line">        try &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;主线程打印信息&quot;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. yield方法：线程本身的调度方法，使用时线程可以在run方法执行完毕时，调用该方法，告知线程已可以出让CPU资源。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. sleep方法：通过sleep(millis)</strong>使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法告诉操作系统 至少在指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。实际上，调用sleep方法时并不要求持有任何锁。</p>
<p>所以，sleep方法并不需要持有任何形式的锁，也就不需要包裹在synchronized中。</p>
<h5 id="5-ThreadLocal"><a href="#5-ThreadLocal" class="headerlink" title="5 ThreadLocal"></a>5 ThreadLocal</h5><p>ThreadLocal是一种把变量放到线程本地的方式来实现线程同步的。比如：SimpleDateFormat不是一个线程安全的类，可以使用ThreadLocal实现同步，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal &#x3D; new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为何SimpleDateFormat不是线程安全的类？具体请参考：</strong></p>
<p><a href="https://blog.csdn.net/zdp072/article/details/41044059" target="_blank" rel="noopener">https://blog.csdn.net/zdp072/article/details/41044059</a><br><a href="https://blog.csdn.net/zq602316498/article/details/40263083" target="_blank" rel="noopener">https://blog.csdn.net/zq602316498/article/details/40263083</a></p>
<p>ThreadLocal与同步机制的对比选择：</p>
<blockquote>
<p>ThreadLocal与同步机制都是 为了解决多线程中相同变量的访问冲突问题。<br>前者采用以 “空间换时间” 的方法，后者采用以 “时间换空间” 的方式。</p>
</blockquote>
<h5 id="6-volatile修饰变量"><a href="#6-volatile修饰变量" class="headerlink" title="6 volatile修饰变量"></a>6 volatile修饰变量</h5><p>volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只给出要修改的代码，其余代码与上同</span><br><span class="line">public class Bank &#123;</span><br><span class="line">    &#x2F;&#x2F;需要同步的变量加上volatile</span><br><span class="line">    private volatile int account &#x3D; 100;</span><br><span class="line">    public int getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这里不再需要synchronized </span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account +&#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</p>
<h5 id="7-Semaphore信号量"><a href="#7-Semaphore信号量" class="headerlink" title="7 Semaphore信号量"></a>7 Semaphore信号量</h5><p>Semaphore信号量被用于控制特定资源在同一个时间被访问的个数。类似连接池的概念，保证资源可以被合理的使用。可以使用构造器初始化资源个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">    private static Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date());</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-0 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-3 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-2 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-4 Mon Apr 18 18:03:56 CST 2016</span><br></pre></td></tr></table></figure>

<h5 id="8-并发包下的工具类"><a href="#8-并发包下的工具类" class="headerlink" title="8 并发包下的工具类"></a>8 并发包下的工具类</h5><h5 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h5><p>CountDownLatch是一个计数器，它的构造方法中需要设置一个数值，用来设定计数的次数。每次调用countDown()方法之后，这个计数器都会减去1，CountDownLatch会一直阻塞着调用await()方法的线程，直到计数器的值变为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;all thread over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-2 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-3 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-4 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-0 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-1 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">all thread over</span><br></pre></td></tr></table></figure>

<h5 id="8-2-CyclicBarrier"><a href="#8-2-CyclicBarrier" class="headerlink" title="8.2 CyclicBarrier"></a>8.2 CyclicBarrier</h5><p>CyclicBarrier阻塞调用的线程，直到条件满足时，阻塞的线程同时被打开。</p>
<p>调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>在CyclicBarrier的构造方法中，还可以设置一个barrierAction。在所有的屏障都到达之后，会启动一个线程来运行这里面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int secs &#x3D; random.nextInt(5);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run, sleep &quot; + secs + &quot; secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(secs * 1000);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; runs over&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比CountDownLatch，CyclicBarrier是可以被循环使用的，而且遇到线程中断等情况时，还可以利用reset()方法，重置计数器，从这些方面来说，CyclicBarrier会比CountDownLatch更加灵活一些。</p>
<h5 id="9-使用原子变量实现线程同步"><a href="#9-使用原子变量实现线程同步" class="headerlink" title="9 使用原子变量实现线程同步"></a>9 使用原子变量实现线程同步</h5><p>有时需要使用线程同步的根本原因在于 对普通变量的操作不是原子的。那么什么是原子操作呢？</p>
<p>原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作<br>即-这几种行为要么同时完成，要么都不完成。</p>
<p>在java.util.concurrent.atomic包中提供了创建原子类型变量的工具类，使用该类可以简化线程同步。比如：其中AtomicInteger以原子方式更新int的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line">    private AtomicInteger account &#x3D; new AtomicInteger(100);</span><br><span class="line"></span><br><span class="line">    public AtomicInteger getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account.addAndGet(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-AbstractQueuedSynchronizer"><a href="#10-AbstractQueuedSynchronizer" class="headerlink" title="10 AbstractQueuedSynchronizer"></a>10 AbstractQueuedSynchronizer</h5><p>AQS是很多同步工具类的基础，比如：ReentrantLock里的公平锁和非公平锁，Semaphore里的公平锁和非公平锁，CountDownLatch里的锁等他们的底层都是使用AbstractQueuedSynchronizer完成的。</p>
<p>基于AbstractQueuedSynchronizer自定义实现一个独占锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class MySynchronizer extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">        if(compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryRelease(int arg) &#123;</span><br><span class="line">        setState(0);</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MySynchronizer mySynchronizer &#x3D; new MySynchronizer();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; will sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-使用阻塞队列实现线程同步"><a href="#11-使用阻塞队列实现线程同步" class="headerlink" title="11 使用阻塞队列实现线程同步"></a>11 使用阻塞队列实现线程同步</h5><p>前面几种同步方式都是基于底层实现的线程同步，但是在实际开发当中，应当尽量远离底层结构。本节主要是使用LinkedBlockingQueue<E>来实现线程的同步。</p>
<p>LinkedBlockingQueue<E>是一个基于链表的队列，先进先出的顺序（FIFO），范围任意的blocking queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.xhj.thread;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BlockingSynchronizedThread &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个阻塞队列用来存储生产出来的商品</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LinkedBlockingQueue&lt;Integer&gt; queue &#x3D; new LinkedBlockingQueue&lt;Integer&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义生产商品个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final int size &#x3D; 10;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int flag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private class LinkBlockThread implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int new_flag &#x3D; flag++;</span><br><span class="line">            System.out.println(&quot;启动线程 &quot; + new_flag);</span><br><span class="line">            if (new_flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    int b &#x3D; new Random().nextInt(255);</span><br><span class="line">                    System.out.println(&quot;生产商品：&quot; + b + &quot;号&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(b);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size &#x2F; 2; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int n &#x3D; queue.take();</span><br><span class="line">                        System.out.println(&quot;消费者买去了&quot; + n + &quot;号商品&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO: handle exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingSynchronizedThread bst &#x3D; new BlockingSynchronizedThread();</span><br><span class="line">        LinkBlockThread lbt &#x3D; bst.new LinkBlockThread();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(lbt);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(lbt);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">啃碎并发（五）：Java线程安全特性与问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:09:11 / 修改时间：20:30:20" itemprop="dateCreated datePublished" datetime="2020-06-01T20:09:11+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在单线程中不会出现线程安全问题，而在多线程编程中，有可能会出现同时访问同一个<strong>共享、可变资源</strong>的情况，这种资源可以是：<strong>一个变量、一个对象、一个文件等。</strong>特别注意两点：</p>
<blockquote>
<p>1.共享： 意味着该资源可以由多个线程同时访问；<br>2.可变： 意味着该资源可以在其生命周期内被修改；</p>
</blockquote>
<p>简单的说，<strong>如果你的代码在单线程下执行和在多线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</strong>那么，当进行多线程编程时，我们又会面临哪些线程安全的要求呢？又是要如何去解决的呢？</p>
<h4 id="1-线程安全特性"><a href="#1-线程安全特性" class="headerlink" title="1 线程安全特性"></a>1 线程安全特性</h4><h5 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h5><p>跟数据库事务的原子性概念差不多，<strong>即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。</strong></p>
<p>关于原子性，一个非常经典的例子就是银行转账问题：</p>
<blockquote>
<p>比如：A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p>
</blockquote>
<h5 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a>1.2 可见性</h5><p>可见性是指，<strong>当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。</strong>可见性问题是好多人忽略或者理解错误的一点。</p>
<p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。<strong>每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。</strong>此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p><strong>这一点是操作系统或者说是硬件层面的机制，</strong>所以很多应用开发人员经常会忽略。</p>
<h5 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3 有序性"></a>1.3 有序性</h5><p>有序性指的是，<strong>程序执行的顺序按照代码的先后顺序执行。</strong>以下面这段代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean started &#x3D; false; &#x2F;&#x2F; 语句1</span><br><span class="line">long counter &#x3D; 0L; &#x2F;&#x2F; 语句2</span><br><span class="line">counter &#x3D; 1; &#x2F;&#x2F; 语句3</span><br><span class="line">started &#x3D; true; &#x2F;&#x2F; 语句4</span><br></pre></td></tr></table></figure>

<p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p>
<p><strong>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</strong></p>
<p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，<strong>CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</strong></p>
<h4 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2 线程安全问题"></a>2 线程安全问题</h4><h5 id="2-1-竞态条件与临界区"><a href="#2-1-竞态条件与临界区" class="headerlink" title="2.1 竞态条件与临界区"></a>2.1 竞态条件与临界区</h5><p>线程之间共享堆空间，在编程的时候就要格外注意避免竞态条件。危险在于多个线程同时访问相同的资源并进行读写操作。<strong>当其中一个线程需要根据某个变量的状态来相应执行某个操作的之前，该变量很可能已经被其它线程修改。</strong></p>
<blockquote>
<p>也就是说，当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在<strong>竞态条件</strong>。导致竟态条件发生的代码称作<strong>临界区</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 以下这段代码就存在竞态条件，其中return ++count就是临界区。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Obj &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public int incr()&#123;</span><br><span class="line">        return ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-死锁"><a href="#2-2-死锁" class="headerlink" title="2.2 死锁"></a>2.2 死锁</h5><p>死锁：<strong>指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</strong>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>关于死锁发生的条件：</strong></p>
<blockquote>
<p><strong>1.互斥条件：</strong>线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。<br><strong>2.请求和保持条件：</strong>线程T1至少已经保持了一个资源R1占用，但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。<br><strong>3.不剥夺条件：</strong>线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。<br><strong>4.环路等待条件：</strong>在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn}，进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。<strong>（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）。</strong></p>
</blockquote>
<h5 id="2-3-活锁"><a href="#2-3-活锁" class="headerlink" title="2.3 活锁"></a>2.3 活锁</h5><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。<strong>这样你让我，我让你，最后两个线程都无法使用资源。</strong></p>
<p><strong>关于“死锁与活锁”的比喻：</strong></p>
<blockquote>
<p><strong>死锁：</strong>迎面开来的汽车A和汽车B过马路，汽车A得到了半条路的资源（满足死锁发生条件1：资源访问是排他性的，我占了路你就不能上来，除非你爬我头上去），汽车B占了汽车A的另外半条路的资源，A想过去必须请求另一半被B占用的道路（死锁发生条件2：必须整条车身的空间才能开过去，我已经占了一半，尼玛另一半的路被B占用了），B若想过去也必须等待A让路，A是辆兰博基尼，B是开奇瑞QQ的屌丝，A素质比较低开窗对B狂骂：快给老子让开，B很生气，你妈逼的，老子就不让（死锁发生条件3：在未使用完资源前，不能被其他线程剥夺），于是两者相互僵持一个都走不了（死锁发生条件4：环路等待条件），而且导致整条道上的后续车辆也走不了。</p>
<p><strong>活锁：</strong>马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。</p>
</blockquote>
<h5 id="2-4-饥饿"><a href="#2-4-饥饿" class="headerlink" title="2.4 饥饿"></a>2.4 饥饿</h5><p>饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，<strong>T2可能永远等待。</strong></p>
<p>也就是，如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，<strong>这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</strong></p>
<p><strong>关于“饥饿”的比喻：</strong></p>
<blockquote>
<p>在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的却没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p>
</blockquote>
<p>在Java中，下面三个常见的原因会导致线程饥饿，如下：</p>
<p><strong>1.高优先级线程吞噬所有的低优先级线程的CPU时间</strong></p>
<blockquote>
<p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。</p>
</blockquote>
<p><strong>2.线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问</strong></p>
<blockquote>
<p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>
</blockquote>
<p><strong>3.线程在等待一个本身（在其上调用wait()）也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒</strong></p>
<blockquote>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
</blockquote>
<h5 id="2-5-公平"><a href="#2-5-公平" class="headerlink" title="2.5 公平"></a>2.5 公平</h5><p><strong>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。</strong>在Java中实现公平性方案，需要：</p>
<blockquote>
<p>1.使用锁，而不是同步块；<br>2.使用公平锁；<br>3.注意性能方面；</p>
</blockquote>
<p>在Java中实现公平性，虽Java不可能实现100%的公平性，依然可以通过同步结构在线程间实现公平性的提高。</p>
<p>首先来学习一段简单的同步态代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    public synchronized void doSynchronized () &#123;</span><br><span class="line">        &#x2F;&#x2F; do a lot of work which takes a long time</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。</p>
<p>改为 使用锁方式替代同步块，为了提高等待线程的公平性，我们使用锁方式来替代同步块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line">    public void doSynchronized() throws InterruptedException&#123;</span><br><span class="line">        this.lock.lock();</span><br><span class="line">        &#x2F;&#x2F;critical section, do a lot of work which takes a long time</span><br><span class="line">        this.lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。下面是用Lock类做的一个实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Lock&#123;</span><br><span class="line"></span><br><span class="line">    private boolean isLocked      &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException&#123;</span><br><span class="line">        while(isLocked)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; true;</span><br><span class="line">        lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。</p>
<p>这回看下doSynchronized()，你会注意到在lock()和unlock()之间的注释：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。</p>
<p>在早些时候提到过，同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。</p>
<p>但我们能够改变这种情况，如下：</p>
<blockquote>
<p>当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
</blockquote>
<p>下面将上面Lock类转变为公平锁FairLock。你会注意到新的实现和之前的Lock类中的同步和wait()/notify()稍有不同。重点是，每一个调用lock()的线程都会进入一个队列，当解锁时，只有队列里的第一个线程被允许锁住FairLock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class FairLock &#123;</span><br><span class="line">    private boolean isLocked &#x3D; false;</span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line">    private List&lt;QueueObject&gt; waitingThreads &#x3D; new ArrayList&lt;QueueObject&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() throws InterruptedException&#123;</span><br><span class="line">        &#x2F;&#x2F; 当前线程创建“令牌”</span><br><span class="line">        QueueObject queueObject &#x3D; new QueueObject();</span><br><span class="line">        boolean isLockedForThisThread &#x3D; true;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            &#x2F;&#x2F; 所有线程的queueObject令牌，入队</span><br><span class="line">            waitingThreads.add(queueObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(isLockedForThisThread)&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                &#x2F;&#x2F; 1. 判断是否已被锁住：是否已有线程获得锁，正在执行同步代码块</span><br><span class="line">                &#x2F;&#x2F; 2. 判断头部令牌与当前线程令牌是否一致：也就是只锁住头部令牌对应的线程；</span><br><span class="line">                isLockedForThisThread &#x3D; isLocked || waitingThreads.get(0) !&#x3D; queueObject;</span><br><span class="line">                if(!isLockedForThisThread)&#123;</span><br><span class="line">                    isLocked &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; 移除头部令牌</span><br><span class="line">                    waitingThreads.remove(queueObject);</span><br><span class="line">                    lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                &#x2F;&#x2F; 其他线程执行doWait()，进行等待</span><br><span class="line">                queueObject.doWait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        if(waitingThreads.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 唤醒头部令牌对应的线程，可以执行</span><br><span class="line">            waitingThreads.get(0).doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QueueObject &#123;</span><br><span class="line">    private boolean isNotified &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() throws InterruptedException &#123;</span><br><span class="line">        while(!isNotified)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.isNotified &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        this.isNotified &#x3D; true;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        return this &#x3D;&#x3D; o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先注意到lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。</p>
<blockquote>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队操作。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p>
</blockquote>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个线程调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。</p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p>
<h4 id="3-如何确保线程安全特性"><a href="#3-如何确保线程安全特性" class="headerlink" title="3 如何确保线程安全特性"></a>3 如何确保线程安全特性</h4><h5 id="3-1-如何确保原子性"><a href="#3-1-如何确保原子性" class="headerlink" title="3.1 如何确保原子性"></a>3.1 如何确保原子性</h5><h5 id="3-1-1-锁和同步"><a href="#3-1-1-锁和同步" class="headerlink" title="3.1.1 锁和同步"></a>3.1.1 锁和同步</h5><p>常用的保证Java操作原子性的工具是 锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    synchronized (anyObject)&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论使用锁还是synchronized，本质都是一样，通过锁或同步来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</p>
<h5 id="3-1-2-CAS（compare-and-swap）"><a href="#3-1-2-CAS（compare-and-swap）" class="headerlink" title="3.1.2 CAS（compare and swap）"></a>3.1.2 CAS（compare and swap）</h5><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line">for(int b &#x3D; 0; b &lt; numThreads; b++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for(int a &#x3D; 0; a &lt; iteration; a++) &#123;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-如何确保可见性"><a href="#3-2-如何确保可见性" class="headerlink" title="3.2 如何确保可见性"></a>3.2 如何确保可见性</h5><p>Java提供了volatile关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它线程缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
<p>volatile适用场景：volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isRunning &#x3D; false;</span><br><span class="line">public void start () &#123;</span><br><span class="line">    new Thread( () -&gt; &#123;</span><br><span class="line">        while(isRunning) &#123;</span><br><span class="line">            someOperation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">public void stop () &#123;</span><br><span class="line">    isRunning &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用stop()方法将isRunning设置为false，循环也不一定会立即结束。可以通过volatile关键字，保证while循环及时得到isRunning最新的状态从而及时停止循环，结束线程。</p>
<h5 id="3-3-如何确保有序性"><a href="#3-3-如何确保有序性" class="headerlink" title="3.3 如何确保有序性"></a>3.3 如何确保有序性</h5><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p>
<blockquote>
<p>Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。</p>
</blockquote>
<p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p>
<p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p>
<p>happens-before原则（先行发生原则），如下：</p>
<blockquote>
<p><strong>1.传递规则：</strong>如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性。<br><strong>2.锁定规则：</strong>一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取。<br><strong>3.volatile变量规则：</strong>对一个被volatile修饰的写操作先发生于后面对该变量的读操作。<br><strong>4.程序次序规则：</strong>一个线程内，按照代码顺序执行。<br><strong>5.线程启动规则：</strong>Thread对象的start()方法先发生于此线程的其它动作。<br><strong>6.线程终结原则：</strong>线程的终止检测后发生于线程中其它的所有操作。<br><strong>7.线程中断规则： *<em>对线程interrupt()方法的调用先发生于对该中断异常的获取。<br>*</em>8.对象终结规则：</strong>一个对象构造先于它的finalize发生。</p>
</blockquote>
<h5 id="4-关于线程安全的几个为什么"><a href="#4-关于线程安全的几个为什么" class="headerlink" title="4 关于线程安全的几个为什么"></a>4 关于线程安全的几个为什么</h5><p><strong>1.平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？</strong></p>
<blockquote>
<p>锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。</p>
</blockquote>
<p><strong>2.锁和synchronized为何能保证可见性？</strong></p>
<blockquote>
<p>根据JDK 7的Java doc中对concurrent包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由happen-before原则推断出在读操作之前发生。</p>
</blockquote>
<p><strong>3.既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？</strong></p>
<blockquote>
<p>synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</p>
</blockquote>
<p><strong>4.既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？</strong></p>
<blockquote>
<p>锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。</p>
</blockquote>
<p><strong>5.还有没有别的办法保证线程安全？</strong></p>
<blockquote>
<p>有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。</p>
</blockquote>
<p><strong>6.synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？</strong></p>
<blockquote>
<p>synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">Android基础 -- 四大组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 15:33:18 / 修改时间：15:33:19" itemprop="dateCreated datePublished" datetime="2020-06-01T15:33:18+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/FrameWork/" itemprop="url" rel="index"><span itemprop="name">FrameWork</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="Activity生命周期.png"/>

<p>注意：当activityB在activityA之前启动时，将在A上调用onPause()回调。在A的onPause()返回之前，将不会创建B，因此请确保onPause()中不要做任何冗长的操作。</p>
<ol>
<li><p>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为entire lifetime。</p>
</li>
<li><p>当执行onStart回调方法时，Activity开始被用户所见（也就是说，onCreate时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到onStop之前，此阶段Activity都是被用户可见，称之为visible lifetime。</p>
</li>
<li><p>当执行到onResume回调方法时，Activity可以响应用户交互，一直到onPause方法之前，此阶段Activity称之为foreground lifetime。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序启动</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.687</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.819</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.823</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.802</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.815</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.824</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">54.156</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.672</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.716</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.717</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br><span class="line"><span class="comment">// 按下home键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.703</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.722</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.723</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 返回应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.968</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">20.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.274</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.925</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.959</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.963</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入task</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.056</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.068</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.088</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 后台终止</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">51.310</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="打印生命周期"><a href="#打印生命周期" class="headerlink" title="打印生命周期"></a>打印生命周期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BaseActivity"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onCreate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onResume"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onPause"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onRestart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStop"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onNewIntent"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onActivityResult"><a href="#onActivityResult" class="headerlink" title="onActivityResult"></a>onActivityResult</h2><p>MainActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>), 0)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"MainActivity-onActivityResult"</span>);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"result = "</span> + data.getStringExtra(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecondActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"value"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">setResult(<span class="number">1</span>, intent);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.038</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.070</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.166</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.170</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.659</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.672</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.679</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.682</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">40.015</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">48.965</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onActivityResult</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: result = hearing</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.395</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.396</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br></pre></td></tr></table></figure>

<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>通过android:launchMode配置</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是Activity默认的启动模式，在不指定Activity启动模式的情况下，所有Activity使用的都是standard模式。</p>
<p>在standard模式下，每当启动一个新的Activity，它就会进入任务栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会判断该Activity在栈中是否存在，每次启动都会创建一个新的实例。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop模式与standard类似，不同的是，当启动的Activity已经位于栈顶时，则直接使用它不创建新的实例，此时栈顶的Activity实例会调onNewIntent方法。如果启动的Activity没有位于栈顶时，则创建一个新的实例位于栈顶。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>如果希望Activity在整个应用程序中只存在一个实例，可以使用singleTask模式，当Activity的启动模式指定为 singleTask，每次启动该Activity时，系统首先会检查栈中是否存在该Activity的实例，如果发现已经存在则直接使用该实例，此时栈顶的Activity实例会调onNewIntent方法，并将当前Activity之上的所有Activity出栈，如果没有发现则创建一个新的实例。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>在程序开发过程中，如果需要Activity在整个系统中都只有一个实例，这时就需要用到singleInstance模式。指定为singleInstance模式的Activity会启动一个新的任务栈来管理这个Activity。</p>
<p>singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。采用这种模式启动Activity会分为一下两种情况：</p>
<ul>
<li>如果要启动的Activity不存在，系统会创建一个新的任务栈，在创建该Activity的实例，并把该Activity加入栈顶.</li>
<li>如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。</li>
</ul>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a>allowTaskReparenting</h3><p>如果该Activity的allowTaskReparenting设置为true，它进入后台，当一个和它有相同affinity的Task进入前台时，它会重新宿主，进入到该前台的task中。</p>
<table>
<thead>
<tr>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">taskAffinity</th>
<th align="center">allowTaskReparenting</th>
</tr>
</thead>
<tbody><tr>
<td align="center">application1</td>
<td align="center">Activity1</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">application2</td>
<td align="center">Activity2</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>创建两个工程：application1和application2，分别含有Activity1和Activity2，它们的taskAffinity相同，Activity1的allowTaskReparenting为true。</p>
<p>首先，我们启动application1,加载Activity1，然后按Home键，使该task（假设为task1）进入后台。然后启动application2，默认加载Activity2。本来应该是显示Activity2，但是我们却看到了Activity1。实际上Activity2也被加载了，只是Activity1重新宿主，所以看到了Activity1。</p>
<h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>如果加载某个Activity的intent，Flag被设置成FLAG_ACTIVITY_NEW_TASK时，它会首先检查是否存在与自己taskAffinity相同的Task，如果存在，那么它会直接宿主到该Task中，如果不存在则重新创建Task。</p>
<p>写一个应用，包含两个Activity：Activity1的taskAffinity为<code>com.hearing.task</code>，Activity2为入口，且点击Activity2会以FLAG_ACTIVITY_NEW_TASK启动Activity1。再写一个应用MyActivity，它包含一个Activity（MyActivity），其taskAffinity为<code>com.hearing.task</code>。</p>
<p>首先启动MyActivity，然后Home回桌面，然后打开Activity2，点击Activity2，进入Activity1。然后按返回键。进入Activity的顺序为Activity2-&gt;Activity1，而返回时顺序为Activity1-&gt;MyActivity。这就说明了一个问题，Activity1在启动时，重新宿主到了MyActivity所在的Task中去了。</p>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul>
<li>当一个应用程序加载一个singleTask模式的Activity时，首先该Activity会检查是否存在与它的taskAffinity相同的Task。如果存在，那么检查是否实例化，如果已经实例化，那么销毁在该Activity以上的Activity并调用onNewIntent。如果没有实例化，那么该Activity实例化并入栈。如果不存在，那么就重新创建Task，并入栈。</li>
<li>当一个应用程序加载一个singleInstance模式的Activity时，如果该Activity没有被实例化，那么就重新创建一个Task，并入栈，如果已经被实例化，那么就调用该Activity的onNewIntent.singleInstance的Activity所在的Task不允许存在其他Activity，任何从该Activity加载的其它Activity（假设为Activity2）都会被放入其它的Task中，如果存在与Activity2相同affinity的Task，则在该Task内创建Activity2。如果不存在，则重新生成新的Task并入栈。</li>
</ul>
<h2 id="onSaveInstanceState与onRestoreInstanceState方法"><a href="#onSaveInstanceState与onRestoreInstanceState方法" class="headerlink" title="onSaveInstanceState与onRestoreInstanceState方法"></a>onSaveInstanceState与onRestoreInstanceState方法</h2><p>onSaveInstanceState主要是用于保存一些临时数据，当Activity恢复时，可以恢复对应的数据，onRestoreInstanceState当Activity被重新创建时调用，可以从该 方法中恢复一些之前保存过的数据。</p>
<p>onSaveInstanceState一般是在Activity被“打断”的情况下被调用，例如被覆盖，包括全覆盖或者部分覆盖，或者按home退到后台，或者灭屏。另外一种情况就是Activity被重新创建会调用，例如用户在当前Activity旋转屏幕，或者用户调用recreate方法。点击返回键该方法不会被调用。onSaveInstanceState的调用顺序是在onPause之后，onStop之前。</p>
<p>onRestoreInstanceState一般是在Activty被重新创建恢复时会被调用，例如用户切换横竖屏。用户将Activty挂后台，切换系统设置，然后再启动该Activity。</p>
<h2 id="启动方式的问题"><a href="#启动方式的问题" class="headerlink" title="启动方式的问题"></a>启动方式的问题</h2><p>MainActivity是SingleTask或者SingleInstance模式，启动TestActivity，TestActivity马上跳转到MainActivity，这种情况下，MainActivity的onResume会回调两次。日志如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onCreate</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onStart</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">TestActivity onCreate</span><br><span class="line">TestActivity onStart</span><br><span class="line">TestActivity onResume</span><br><span class="line">TestActivity onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onNewIntent</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">TestActivity onStop</span><br></pre></td></tr></table></figure>

<p>适当延时500ms再跳转回MainActivity可以解决这个问题（可能由于业务场景不同，会带来新的问题）。</p>
<p>在<a href="https://stackoverflow.com/questions/11092101/startactivity-on-foreground-application-causes-onpause-onresume" target="_blank" rel="noopener">stackoverflow</a>上也有人发现过类似的问题。</p>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>普通广播（Normal Broadcast）</li>
<li>系统广播（System Broadcast）</li>
<li>有序广播（Ordered Broadcast）</li>
<li>粘性广播（Sticky Broadcast）（已弃用）</li>
<li>App应用内广播（Local Broadcast）</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="BroadcastReceiver-1"><a href="#BroadcastReceiver-1" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><ul>
<li>继承BroadcastReceivre基类</li>
<li>必须复写抽象方法onReceive()方法</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><ul>
<li>常驻：不受任何组件声明周期影响</li>
<li>耗电，占内存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    //此<span class="attr">broadcastReceiver</span>能否接收其他<span class="attr">App</span>的发出的广播</span></span><br><span class="line"><span class="tag">    //默认值是由<span class="attr">receiver</span>中有无<span class="attr">intent-filter</span>决定的：如果有<span class="attr">intent-filter</span>，默认值为<span class="attr">true</span>，否则为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    //继承<span class="attr">BroadcastReceiver</span>子类的类名</span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".mBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">    //具有相应权限的广播发送者发送的广播才能被此<span class="attr">BroadcastReceiver</span>所接收；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">BroadcastReceiver</span>运行所处的进程</span></span><br><span class="line"><span class="tag">    //默认为<span class="attr">app</span>的进程，可以指定独立的进程</span></span><br><span class="line"><span class="tag">    //注：<span class="attr">Android</span>四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    //用于指定此广播接收器将接收的广播类型</span><br><span class="line">    //本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><ul>
<li>非常驻，灵活</li>
<li>手动释放</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">    mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> mBroadcastReceiver();</span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中</span></span><br><span class="line"><span class="comment">// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</li>
<li>假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>生命周期:</p>
<ol>
<li><p>startService()</p>
<ul>
<li>作用：启动Service服务</li>
<li>手动调用startService()后，自动调用内部方法：onCreate()、onStartCommand() </li>
<li>如果一个service被startService多次启动，onCreate()只会调用一次 </li>
<li>onStartCommand()调用次数=startService()次数</li>
</ul>
</li>
<li><p>stopService()</p>
<ul>
<li>作用：关闭Service服务 </li>
<li>手动调用stopService()后，自动调用内部方法：onDestory() </li>
<li>如果一个service被启动且被绑定，如果没有在绑定的前提下stopService()是无法停止服务的。</li>
</ul>
</li>
<li><p>bindService()</p>
<ul>
<li>作用：绑定Service服务 </li>
<li>手动调用bindService()后，自动调用内部方法：onCreate()、onBind()</li>
</ul>
</li>
<li><p>unbindService()</p>
<ul>
<li>作用：解绑Service服务 </li>
<li>手动调用unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory()</li>
</ul>
</li>
</ol>
<p>接口函数：</p>
<ul>
<li>onStartCommand()：当其他组件调用startService()方法请求启动Service时，该方法被回调。一旦Service启动，它会在后台独立运行。当Service执行完以后，需调用stopSelf() 或 stopService()方法停止Service。（若您只希望bind Service，则无需调用这些方法）</li>
<li>onBind()：当其他组件调用bindService()方法请求绑定Service时，该方法被回调。该方法返回一个IBinder接口，该接口是Service与绑定的组件进行交互的桥梁。若Service未绑定其他组件，该方法应返回null。</li>
<li>onCreate()：当Service第一次创建时，回调该方法。该方法只被回调一次，并在onStartCommand() 或 onBind()方法被回调之前执行。若Service处于运行状态，该方法不会回调。</li>
<li>onDestroy()：当Service被销毁时回调，在该方法中应清除一些占用的资源，如停止线程、接触绑定注册的监听器或broadcast receiver 等。该方法是Service中的最后一个回调。</li>
</ul>
<p>启动方式：</p>
<ul>
<li>Started：其他组件调用startService()方法启动一个Service。一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。通常，一个被start的Service会在后台执行单独的操作，也并不给启动它的组件返回结果。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</li>
<li>Bound：其他组件调用bindService()方法绑定一个Service。通过绑定方式启动的Service是一个client-server结构，该Service可以与绑定它的组件进行交互。一个bound service仅在有组件与其绑定时才会运行（A bound service runs only as long as another application component is bound to it），多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。</li>
</ul>
<p>注意：</p>
<ul>
<li>Service运行在主线程中（A service runs in the main thread of its hosting process），Service并不是一个新的线程，也不是新的进程。也就是说，若您需要在Service中执行较为耗时的操作（如播放音乐、执行网络请求等），需要在Service中创建一个新的线程。这可以防止ANR的发生，同时主线程可以执行正常的UI操作。</li>
<li>如果某个组件通过调用startService()启动了Service（系统会回调onStartCommand()方法），那么直到在Service中手动调用stopSelf()方法、或在其他组件中手动调用stopService()方法，该Service才会停止。</li>
<li>如果某个组件通过调用bindService()绑定了Service（系统不会回调onStartCommand()方法），只要该组件与Service处于绑定状态，Service就会一直运行，当Service不再与组件绑定时，该Service将被destroy。</li>
<li>当系统内存低时，系统将强制停止Service的运行；若Service绑定了正在与用户交互的activity，那么该Service将不大可能被系统kill（ less likely to be killed）。如果创建的是前台Service，那么该Service几乎不会被kill（almost never be killed）。否则，当创建了一个长时间在后台运行的Service后，系统会降低该Service在后台任务栈中的级别——这意味着它容易被kill（lower its position in the list of background tasks over time and the service will become highly susceptible to killing），所以在开发Service时，需要使Service变得容易被restart，因为一旦Service被kill，再restart它需要其资源可用时才行</li>
</ul>
<h2 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.servicetest.MyService"</span> &gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承IntentService类"><a href="#继承IntentService类" class="headerlink" title="继承IntentService类"></a>继承IntentService类</h2><ul>
<li>默认在子线程中处理回传到onStartCommand()方法中的Intent；</li>
<li>在重写的onHandleIntent()方法中处理按时间排序的Intent队列，所以不用担心多线程（multi-threading）带来的问题。</li>
<li>当所有请求处理完成后，自动停止service，无需手动调用stopSelf()方法；</li>
<li>默认实现了onBind()方法，并返回null；</li>
<li>默认实现了onStartCommand()方法，并将回传的Intent以序列的形式发送给onHandleIntent()，只需重写该方法并处理Intent即可。</li>
</ul>
<h2 id="继承Service类"><a href="#继承Service类" class="headerlink" title="继承Service类"></a>继承Service类</h2><p>如果需要在Service中执行多线程而不是处理一个请求队列，那么需要继承Service类，分别处理每个Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Log.d(TAG, <span class="string">"onCreate() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">		Log.d(TAG, <span class="string">"onStartCommand() executed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">		Log.d(TAG, <span class="string">"onDestroy() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mBinder;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="string">"TAG"</span>, <span class="string">"startDownload() executed"</span>);</span><br><span class="line">			<span class="comment">// 执行具体的下载任务</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onStartCommand()返回一个整形变量，该变量必须是下列常量之一：</p>
<ul>
<li>START_NOT_STICKY：若执行完onStartCommand()方法后，系统就kill了service，不要再重新创建service，除非系统回传了一个pending intent。这避免了在不必要的时候运行service，您的应用也可以restart任何未完成的操作。</li>
<li>START_STICKY：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()。dangerous不要重新传递最后一个Intent（do not redeliver the last intent）。相反，系统回调onStartCommand()时回传一个空的Intent，除非有 pending intents传递，否则Intent将为null。该模式适合做一些类似播放音乐的操作。</li>
<li>START_REDELIVER_INTENT：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()并将最后一个Intent回传至该方法。任何 pending intents都会被轮流传递。该模式适合做一些类似下载文件的操作。</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>startService(intent)方法将立即返回，并回调onStartCommand()（请不要手动调用该方法），若该Service未处于运行状态，系统将首先回调onCreate()，接着再回调onStartCommand()。若您希望Service可以返回结果，那么需要通过调用getBroadcast 返回的PendingIntent启动Service（将PendingIntent包装为Intent），service可使用broadcast 传递结果。</p>
<p>多个启动Service的请求可能导致onStartCommand()多次调用，但只需调用stopSelf() 、 stopService()这两个方法之一，就可停止该服务。</p>
<h2 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h2><ul>
<li>通过其他组件调用bindService()方法可以绑定一个Service以保持长连接（long-standing connection），这时一般不允许其他组件调用startService()启动Service。</li>
<li>当其他组件需要与Service交互或者需要跨进程通信时，可以创建一个bound Service。</li>
<li>为创建一个bound Service，必须重写onBind()回调，该方法返回一个IBinder接口。该接口时组件与Service通信的桥梁。组件调用bindService()与Service绑定，该组件可获取IBinder接口，一旦获取该接口，就可以调用Service中的方法。一旦没有组件与Service绑定，系统将destroy它，您不必手动停止它。</li>
<li>为创建一个bound Service，必须定义一个接口 ，该接口指定组件与Service如何通信。定义的接口在组件与Service之间，且必须实现IBinder接口。这正是onBind()的返回值。一旦组件接收了IBinder，组件与Service便可以开始通信。</li>
<li>多个组件可同时与Service绑定，当组件与Service交互结束后，可调用unbindService()方法解绑。bound Service比start Service要复杂，故我将在后续单独翻译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyService.MyBinder myBinder;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">			myBinder = (MyService.MyBinder) service;</span><br><span class="line">			myBinder.startDownload();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.start_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			startService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">			Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			stopService(stopIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">			Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">			unbindService(connection);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行前台Service"><a href="#运行前台Service" class="headerlink" title="运行前台Service"></a>运行前台Service</h2><ul>
<li>前台Service用于动态通知消息，如天气预报。该Service不易被kill。前台Service必须提供status bar，只有前台Service被destroy后，status bar才能消失。</li>
<li>举例来说，一个播放音乐的Service必须是前台Service，只有这样用户才能确知其运行状态。为前台Service提供的status bar可以显示当前音乐的播放状态，并可以启动播放音乐的Activity。</li>
<li>调用startForeground()可以启动前台Service。该方法接收两个参数，参数一是一个int型变量，用户指定该通知的唯一性标识，而参数而是一个Notification用于配置status bar</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ContentProvider为不同的应用之间数据共享提供统一的接口，Android系统中应用内部的数据是对外隔离的，要想让其它应用能够访问自己的数据，可以使用ContentProvider，其底层采用Binder机制实现跨进程共享数据。</p>
<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p>Uri的四个组成部分：content://contacts/people/5</p>
<ul>
<li>schema：已由Android固定设置为content://</li>
<li>authority：ContentProvider权限，在AndroidMenifest中设置权限</li>
<li>path：要操作的数据库表</li>
<li>id：查询的关键字（可选字段）</li>
</ul>
<p>Uri匹配模式：Uri的匹配表示要查询的数据，对于单个数据查询，可直接使用Uri定位具体的资源位置，但当范围查询时就需要结合通配符的使用，Uri提供以下两种通配符：</p>
<ul>
<li><code>*</code>：匹配由任意长度的任何有效字符组成的字符串</li>
<li><code>#</code>：匹配由任意长度的数字字符组成的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table2/*  //多数据查询</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/#</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/6  //单数据查询</span></span><br></pre></td></tr></table></figure>

<p>Uri的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(“content:<span class="comment">//contacts/people/5")</span></span><br></pre></td></tr></table></figure>

<p>Uri创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过将 ID 值追加到 URI 末尾来访问表中的单个行</span></span><br><span class="line">Uri singleUri = ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ContentUris"><a href="#ContentUris" class="headerlink" title="ContentUris"></a>ContentUris</h2><p>核心方法有两个：</p>
<ul>
<li>withAppendedId()：向Uri追加一个id</li>
<li>parseId()：从Uri中获取id</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>)</span><br><span class="line"><span class="comment">// 生成的Uri为：content://cn.scu.myprovider/user/7</span></span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user/7"</span>)</span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>

<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p>UriMatcher的作用：</p>
<ul>
<li>在ContentProvider 中注册Uri</li>
<li>根据 Uri 匹配 ContentProvider 中对应的数据表</li>
</ul>
<p>使用步骤：</p>
<ol>
<li>初始化UriMatcher对象</li>
<li>在ContentProvider 中注册URI（addURI()）</li>
<li>根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match()）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line"><span class="comment">// 常量UriMatcher.NO_MATCH：不匹配任何路径的返回码</span></span><br><span class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI</span></span><br><span class="line"><span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user1"</span>, URI_CODE_a); </span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user2"</span>, URI_CODE_b); </span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a</span></span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(matcher.match(uri)) &#123;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_a:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser1;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_b:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentProvider-1"><a href="#ContentProvider-1" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>ContentProvider主要以表格的形式组织数据，同时也支持文件数据。它一般配合数据库共同使用，实现对外共享数据的目的，所以它需要对数据库的增删改查操作，ContentProvider也为我们提供了相应的操作方法，使用时只需实现即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后或打开系统后其它进程第一次访问该ContentProvider时由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前 Uri 所代表数据的MIME类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>上述CRUD方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</li>
<li>存在多线程并发访问，需要实现线程同步<ul>
<li>若ContentProvider的数据存储方式是使用一个SQLite，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</li>
<li>若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</li>
</ul>
</li>
</ol>
<h2 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a>ContentResolver</h2><p>外部进程通过 ContentResolver类，从而与ContentProvider类进行交互。一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大，所以在ContentProvider类上加多了一个 ContentResolver类对所有的ContentProvider进行统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.hearing.provider.myprovider/tablename"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条记录</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">values.put(<span class="string">"age"</span>, <span class="number">26</span>);</span><br><span class="line">resolver.insert(uri, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tablename表中所有记录</span></span><br><span class="line">Cursor cursor = resolver.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"tablename data"</span>);</span><br><span class="line"><span class="keyword">while</span>(cursor.moveToNext()) &#123;</span><br><span class="line">   Log.i(<span class="string">"ContentTest"</span>, <span class="string">"tablename_id="</span>+ cursor.getInt(<span class="number">0</span>)+ <span class="string">", name="</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把id为1的记录的name字段值更改新为zhang1</span></span><br><span class="line">ContentValues updateValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">updateValues.put(<span class="string">"name"</span>, <span class="string">"zhang1"</span>);</span><br><span class="line">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.update(updateIdUri, updateValues, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除id为2的记录，即字段age</span></span><br><span class="line">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.delete(deleteIdUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>com.hearing.provider.myprovider需要在 AndroidManifest.xml 中进行注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"com.hearing.provider.myprovider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ContentObserver"><a href="#ContentObserver" class="headerlink" title="ContentObserver"></a>ContentObserver</h2><p>观察者模式：当ContentProvider中指定Uri中的数据变化时通知外界。</p>
<p>自定义ContentObserver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, myOberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">        db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values); </span><br><span class="line">        getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line">getContentResolver().unregisterContentObserver(myOberver);</span><br></pre></td></tr></table></figure>

<h2 id="MimeType"><a href="#MimeType" class="headerlink" title="MimeType"></a>MimeType</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>ContentProvider 类具有两个返回 MIME 类型的方法：</p>
<ul>
<li>getType()：任何ContentProvider程序都需要实现的方法</li>
<li>getStreamTypes()：当ContentProvider程序提供文件时要求实现</li>
</ul>
<h3 id="table的-MIME-类型"><a href="#table的-MIME-类型" class="headerlink" title="table的 MIME 类型"></a>table的 MIME 类型</h3><p>getType() 方法会返回一个 MIME 格式的 String，后者描述内容 URI 参数返回的数据类型。Uri 参数可以是pattern，而不是特定 URI；在这种情况下应该返回与匹配该模式的内容 URI 关联的数据类型。</p>
<p>对于文本、HTML 或 JPEG 等常见数据类型，getType() 应该为该数据返回标准 MIME 类型。</p>
<p>对于指向一个或多个表数据行的内容 URI，getType() 应该以 Android 供应商特有 MIME 格式返回 MIME 类型：</p>
<ol>
<li>类型部分：vnd</li>
<li>子类型部分：<ul>
<li>如果 URI 模式用于单个行：android.cursor.item/</li>
<li>如果 URI 模式用于多个行：android.cursor.dir/</li>
</ul>
</li>
<li>程序特有部分：<code>vnd.&lt;name&gt;.&lt;type&gt;</code><br> <code>&lt;name&gt;</code>值应具有全局唯一性，<type> 值应在对应的 URI pattern 中具有唯一性。通常使用包名或者公司域名作为<code>&lt;name&gt;</code>。适合选择 URI 关联表的标识字符串作为<code>&lt;type&gt;</code>。</li>
</ol>
<p>例如，如果ContentProvider的authority是 com.example.app.provider，并且它公开了一个名为 table1 的表，则 table1 中多个行的 MIME 类型是：<code>vnd.android.cursor.dir/vnd.com.example.provider.table1</code>；对于 table1 的单个行，MIME 类型是：<code>vnd.android.cursor.item/vnd.com.example.provider.table1</code>。</p>
<h3 id="文件的-MIME-类型"><a href="#文件的-MIME-类型" class="headerlink" title="文件的 MIME 类型"></a>文件的 MIME 类型</h3><p>如果 ContentProvider 程序提供文件，则需要实现 getStreamTypes()。该方法返回一个 MIME 类型的 String 数组，表示给定的 URI 返回的文件类型。</p>
<p>例如，假设提供程序以 .jpg、.png 和 .gif 格式文件形式提供照片图像。如果应用调用 ContentResolver.getStreamTypes() 时使用了过滤器字符串 image/*，则 ContentProvider.getStreamTypes() 方法应返回数组：<code>{ &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;}</code></p>
<p>如果应用只对 .jpg 文件感兴趣，则可以在调用 ContentResolver.getStreamTypes() 时使用过滤器字符串 */jpeg，ContentProvider.getStreamTypes() 应返回：<code>{&quot;image/jpeg&quot;}</code></p>
<p>如果程序未提供过滤器字符串中请求的任何 MIME 类型，则 getStreamTypes() 应返回 null。</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>指定其他应用访问提供程序的数据所必须具备权限的属性。</p>
<h3 id="grantUriPermssions"><a href="#grantUriPermssions" class="headerlink" title="grantUriPermssions"></a>grantUriPermssions</h3><p><code>android:grantUriPermssions</code>：表示是否可以通过临时权限访问数据，默认为false，在开发中可以只对限定的内容提供临时权限，如对照片的内容 URI 设置临时权限。</p>
<ul>
<li><p>true：系统会向整个系统授予临时权限，并替代其他设置的权限。</p>
</li>
<li><p>false：需添加<code>&lt;grant-uri-permission&gt;</code>并表明可以授权临时权限所对应的URI</p>
<ul>
<li><p>path：表示绝对路径Uri</p>
</li>
<li><p>pathPattern：表示限定完整的路径但可以使用./*通配符匹配</p>
</li>
<li><p>pathPrefix：限定路径的初始部分后面可以变化，只要初始部分符合即可授权</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:grantUriPermissions="false"</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">grant-uri-permission</span> <span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h3><ul>
<li>android:permission：统一提供程序范围读取/写入权限</li>
<li>android:readPermission：提供程序范围读取权限，优先于permission权限</li>
<li>android:writePermission：提供程序范围写入权限，优先于permission权限</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:readPermission="com.hearing.provider.permission.READ_PERMISSION"</span><br><span class="line">android:writePermission="com.hearing.provider.permission.WRITE_PERMISSION"</span><br><span class="line">android:permission="com.hearing.provider.permission.PERMISSION"</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建两个程序A和B，在程序A中使用ContentProvider保存数据，在程序B中进行查询，在开始A程序中不设置任何权限，B程序进行访问数据会报错；</li>
<li>修改A程序清单文件添加android:exported=”true”，再次访问数据访问成功；</li>
<li>在A程序的清单文件中，为Provider添加两个读写权限，添加完权限后再次在B程序中获取数据，还是会报错，也很正常因为已经对数据的访问设置了门槛，所以在B程序中声明读写权限即可。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A程序 --&gt;</span></span><br><span class="line">android:writePermission="com.alex.kotlin.job.provider.WRITE"</span><br><span class="line">android:readPermission="com.alex.kotlin.job.provider.READ"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- B程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.READ"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.WRITE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="系统ContentProvider"><a href="#系统ContentProvider" class="headerlink" title="系统ContentProvider"></a>系统ContentProvider</h2><p>举几个实例：铃声，联系人部分操作。</p>
<h3 id="铃声"><a href="#铃声" class="headerlink" title="铃声"></a>铃声</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改系统铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File sdFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    values.put(MediaStore.MediaColumns.DATA, sdFile.getAbsolutePath());</span><br><span class="line">    values.put(MediaStore.MediaColumns.TITLE, sdFile.getName());</span><br><span class="line">    values.put(MediaStore.MediaColumns.MIME_TYPE, <span class="string">"audio/*"</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_RINGTONE, <span class="keyword">true</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_NOTIFICATION, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_ALARM, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_MUSIC, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Uri uri = MediaStore.Audio.Media.getContentUriForPath(sdFile.getAbsolutePath());</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"uri is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String delete = MediaStore.MediaColumns.DATA + <span class="string">"=\""</span> + sdFile.getAbsolutePath() + <span class="string">"\""</span>;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + delete);</span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + context.getContentResolver().delete(uri, delete, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    Uri newUri = context.getContentResolver().insert(uri, values);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"uri = "</span> + uri);</span><br><span class="line">    Log.d(TAG, <span class="string">"new uri = "</span> + newUri);</span><br><span class="line"></span><br><span class="line">    RingtoneManager.setActualDefaultRingtoneUri(context, RingtoneManager.TYPE_RINGTONE, newUri);</span><br><span class="line">    Toast.makeText(context, <span class="string">"设置来电铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定电话号码的来电铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, number);</span><br><span class="line">    <span class="keyword">final</span> String[] projection = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            ContactsContract.Contacts._ID, ContactsContract.Contacts.LOOKUP_KEY</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> Cursor data = context.getContentResolver().query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.moveToFirst()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> contactId = data.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> String lookupKey = data.getString(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> Uri contactUri = ContactsContract.Contacts.getLookupUri(contactId, lookupKey);</span><br><span class="line">            <span class="keyword">if</span> (contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Invalid arguments"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">final</span> String value = Uri.fromFile(file).toString();</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"uri = "</span> + contactUri);</span><br><span class="line">            Log.d(TAG, <span class="string">"value = "</span> + value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ContentValues values = <span class="keyword">new</span> ContentValues(<span class="number">1</span>);</span><br><span class="line">            values.put(ContactsContract.Contacts.CUSTOM_RINGTONE, value);</span><br><span class="line">            context.getContentResolver().update(contactUri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Toast.makeText(context, <span class="string">"设置联系人铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联系人"><a href="#联系人" class="headerlink" title="联系人"></a>联系人</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据uri查询指定联系人电话(uri可以通过跳转联系人页面返回得到：intent.getData())</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContacts</span><span class="params">(Context context, Uri contactUri)</span> </span>&#123;</span><br><span class="line">    String phoneNumber = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor cursor = context.getContentResolver().query(contactUri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        String id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));</span><br><span class="line">        Cursor phones = context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,</span><br><span class="line">                <span class="keyword">null</span>, ContactsContract.CommonDataKinds.Phone.CONTACT_ID</span><br><span class="line">                        + <span class="string">"="</span> + id, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (phones != <span class="keyword">null</span> &amp;&amp; phones.moveToNext()) &#123;</span><br><span class="line">            phoneNumber = phones.getString(phones.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">            phones.close();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, <span class="string">"number = "</span> + phoneNumber);</span><br><span class="line">    <span class="keyword">return</span> phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据电话获取联系人名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContactName</span><span class="params">(Context context, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">    Uri lookupUri;</span><br><span class="line">    String[] projection = <span class="keyword">new</span> String[]&#123;ContactsContract.PhoneLookup._ID, ContactsContract.PhoneLookup.DISPLAY_NAME&#125;;</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));</span><br><span class="line">        cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lookupUri = Uri.withAppendedPath(android.provider.Contacts.Phones.CONTENT_FILTER_URL,</span><br><span class="line">                    Uri.encode(number));</span><br><span class="line">            cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = context.getResources().getString(R.string.unknown_contract);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.getCount() &gt; <span class="number">0</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        ret = cursor.getString(<span class="number">1</span>);</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h2><h3 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"finch.db"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_TABLE_NAME = <span class="string">"job"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 数据库版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DATABASE_NAME, <span class="keyword">null</span>, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个表格:用户表 和职业表</span></span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" name TEXT)"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + JOB_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" job TEXT)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义ContentProvider"><a href="#自定义ContentProvider" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    DBHelper mDbHelper = <span class="keyword">null</span>;</span><br><span class="line">    SQLiteDatabase db = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOHORITY = <span class="string">"cn.scu.myprovider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> User_Code = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Job_Code = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UriMatcher类使用:在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher mMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        mMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        mMatcher.addURI(AUTOHORITY,<span class="string">"user"</span>, User_Code);</span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">"job"</span>, Job_Code);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化ContentProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">// 在ContentProvider创建时对数据库进行初始化，不能做耗时操作，此处仅作展示</span></span><br><span class="line">        mDbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(1,'Carson');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(2,'Kobe');"</span>);</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from job"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(1,'Android');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(2,'iOS');"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">return</span> db.query(table,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> User_Code:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Job_Code:</span><br><span class="line">                tableName = DBHelper.JOB_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册ContentProvider"><a href="#注册ContentProvider" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"cn.scu.myprovider"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="访问ContentProvider的数据"><a href="#访问ContentProvider的数据" class="headerlink" title="访问ContentProvider的数据"></a>访问ContentProvider的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Iverson"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user, values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://cn.scu.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程1"><a href="#进程1" class="headerlink" title="进程1"></a>进程1</h3><h4 id="创建数据库类-1"><a href="#创建数据库类-1" class="headerlink" title="创建数据库类"></a>创建数据库类</h4><p>同上。</p>
<h4 id="自定义ContentProvider-1"><a href="#自定义ContentProvider-1" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h4><p>同上。</p>
<h4 id="注册ContentProvider-1"><a href="#注册ContentProvider-1" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"scut.carson_ho.myprovider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"scut.carson_ho.PROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span> = <span class="string">"scut.carson_ho.Read"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:writePermission</span> = <span class="string">"scut.carson_ho.Write"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="进程2"><a href="#进程2" class="headerlink" title="进程2"></a>进程2</h3><h4 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="访问ContentProvider"><a href="#访问ContentProvider" class="headerlink" title="访问ContentProvider"></a>访问ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Jordan"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user,values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>对于面向Android 7.0及以上的应用，Android禁止在应用外部公开<code>file://url</code>。如果一项包含文件URI的intent离开应用，则应用会抛出FileUriExposedException异常。</p>
<p>解决方案：要在应用间共享文件，应发送一项content://URI，并授予URI临时访问权限。进行此授权的最简单方式是使用FileProvider类。FileProvider是ContentProvider的一个特殊的子类，它让应用间共享文件变得更加容易，其通过创建一个Content URI来代替File URI。</p>
<h3 id="注册FileProvider"><a href="#注册FileProvider" class="headerlink" title="注册FileProvider"></a>注册FileProvider</h3><p>由于FileProvider中已经包含了为file生成Content URI的基本代码了，所以开发者不必再去定义一个FileProvider的子类。你可以在XML文件中指定一个FileProvider：在manifest中使用<code>&lt;provider&gt;</code>标签来指定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.hearing.fileprovider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name的值一般都固定为android.support.v4.content.FileProvider。如果开发者继承了FileProvider，则可以写上其绝对路径。</li>
<li>authorities字段的值用来表明使用的使用者，在FileProvider的函数getUriForFile需要传入该参数。</li>
<li>exported 的值为false，表示该FileProvider只能本应用使用，不是public的。</li>
<li>grantUriPermissions 的值为true，表示允许赋予临时权限。</li>
</ul>
<h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>只有事先指定了目录，一个FileProvider才可以为文件生成一个对应的Content URI。要指定一个路径，需要在XML文件中指定其存储的路径。使用<code>&lt;paths&gt;</code>标签。例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/files/path/</code></li>
<li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalFilesDir(null) + &quot;/path/&quot;</code>，<code>/storage/emulated/0/Android/data/&lt;package_name&gt;/files/path/</code></li>
<li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalCacheDir() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/Android/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Environment.getExternalStorageDirectory() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/path/</code></li>
</ul>
<p>在res目录下新建xml目录，然后新建文件file_paths.xml，根据上述内容编写。</p>
<h3 id="获取Content-Uri"><a href="#获取Content-Uri" class="headerlink" title="获取Content Uri"></a>获取Content Uri</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">Uri data;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    data = FileProvider.getUriForFile(mContext, <span class="string">"com.hearing.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋予临时权限"><a href="#赋予临时权限" class="headerlink" title="赋予临时权限"></a>赋予临时权限</h3><p>两种方法：（通常使用第2种）</p>
<ol>
<li>Context.grantUriPermission(package, Uri, mode_flags)</li>
<li>Intent.setFlags()：<code>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);</code></li>
</ol>
<p>Flag意义如下：</p>
<ul>
<li>FLAG_GRANT_READ_URI_PERMISSION：表示读取权限； </li>
<li>FLAG_GRANT_WRITE_URI_PERMISSION：表示写入权限。</li>
</ul>
<h3 id="分享文件URI"><a href="#分享文件URI" class="headerlink" title="分享文件URI"></a>分享文件URI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"shareFile: "</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="string">"com.hearing.fileproviderclient"</span>,</span><br><span class="line">            <span class="string">"com.hearing.fileproviderclient.MainActivity"</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">    Uri data;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        data = FileProvider.getUriForFile(mContext, FILE_PROVIDER_AUTHORITIES, file);</span><br><span class="line">        <span class="comment">// 给目标应用一个临时授权</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">    intent.setData(data);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>安全</p>
<p>  ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据根据需求开放给 其他应用进行增、删、改、查，而不用担心因为直接开放数据库权限而带来的安全问题</p>
</li>
<li><p>访问简单 &amp; 高效</p>
</li>
</ul>
<h1 id="Mime-Type"><a href="#Mime-Type" class="headerlink" title="Mime Type"></a>Mime Type</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>MIME：多用途互联网邮件扩展（Multipurpose Internet Mail Extensions）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。</p>
<p>MIME TYPE一般以这种形式出现：<code>[type]/[subtype]</code></p>
<p>type标识内容type，有下面的形式：</p>
<ul>
<li>Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</li>
<li>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</li>
<li>Application：用于传输应用程序数据或者二进制数据；</li>
<li>Message：用于包装一个E-mail消息；</li>
<li>Image：用于传输静态图片数据；</li>
<li>Audio：用于传输音频或者音声数据；</li>
<li>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。</li>
</ul>
<p>subtype用于指定type的详细形式。<code>content-type/subtype</code>配对的集合和与此相关的参数，将随着时间而增长。为了确保这些值在一个有序而且公开的状态下开发，MIME使用Internet Assigned Numbers Authority (IANA)作为中心的注册机制来管理这些值。常用的subtype值如下所示：</p>
<ul>
<li>text/plain（纯文本）</li>
<li>text/html（HTML文档）</li>
<li>application/xhtml+xml（XHTML文档）</li>
<li>image/gif（GIF图像）</li>
<li>image/jpeg（JPEG图像）</li>
<li>image/png（PNG图像）</li>
<li>video/mpeg（MPEG动画）</li>
<li>application/octet-stream（任意的二进制数据）</li>
<li>application/pdf（PDF文档）</li>
<li>application/msword（Microsoft Word文件）</li>
<li>message/rfc822（RFC 822形式）</li>
<li>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）</li>
<li>application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）</li>
<li>multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>当Android系统接收到一个隐式Intent要启动一个Activity(或其他组件)时，Android会根据以下三个信息比较Intent的信息与注册的组件的intent-filter的信息，从而为该Intent选择出最匹配的Activity(或其他组件)：</p>
<ul>
<li>intent中的action</li>
<li>intent中的category</li>
<li>intent中的data（包含Uri以及data的MIME类型）</li>
</ul>
<p>也就是隐式intent对象要满足要启动的目标组件中注册的intent-filter中的<code>&lt;action/&gt;</code>、<code>&lt;category/&gt;</code>、<code>&lt;data/&gt;</code>三个标签中的信息，即要分别通过action测试、category测试以及data测试。</p>
<p>MINI类型即在data中指定。</p>
<h1 id="Intent和Intent-filter"><a href="#Intent和Intent-filter" class="headerlink" title="Intent和Intent-filter"></a>Intent和Intent-filter</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Intent 是一个消息传递对象，可以用来从其他应用组件请求操作，尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ol>
<li>启动 Activity：通过将 Intent 传递给 startActivity()，可以启动新的 Activity 实例，Intent 用于描述要启动的 Activity，并携带任何必要的数据。</li>
<li>启动 Service：使用 Android 5.0（API 级别 21）及更高版本，可以启动包含 JobScheduler 的服务。对于 Android 5.0（API 级别 21）之前的版本，可以使用 Service 类的方法来启动服务，通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 用于描述要启动的服务，并携带任何必要的数据。如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，可以从其他组件绑定到此服务。</li>
<li>传递 BroadCast：广播是任何应用均可接收的消息，系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播，通过将 Intent 传递给 sendBroadcast() 或 sendOrderedBroadcast()，可以将广播传递给其他应用。</li>
</ol>
<h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><ul>
<li>显式 Intent：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。例如，启动应用内的新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li>隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent-filter进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent-filter匹配，则系统将启动该组件，并向其传递 Intent 对象。如果多个 Intent-filter兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</li>
</ul>
<p>Intent-filter是应用清单文件中的一个表达式，用于指定该组件要接收的 Intent 类型。例如，通过为 Activity 声明 Intent-filter，可以使其他应用能够直接使用某一特定类型的 Intent 启动 Activity。同样，如果您没有为 Activity 声明任何 Intent-filter，则 Activity 只能通过显式 Intent 启动。</p>
<p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent-filter。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p>
<h2 id="构建Intent"><a href="#构建Intent" class="headerlink" title="构建Intent"></a>构建Intent</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>如Component name，Action，Data以及Category，这些属性（组件名称、操作、数据和category）表示 Intent 的既定特征。通过读取这些属性，Android 系统能够解析应当启动哪个应用组件。但是，Intent 也有可能会携带一些不影响其如何解析为应用组件的信息。Intent 还可以提供以下信息：Extras和Flags。</p>
<h4 id="Component-name"><a href="#Component-name" class="headerlink" title="Component name"></a>Component name</h4><p>这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。如果没有组件名称，则 Intent 则为隐式，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和category）决定哪个组件应当接收 Intent。如需在应用中启动特定的组件，则应指定该组件的名称。</p>
<p>启动 Service 时，应始终指定组件名称。否则无法确定哪项服务会响应 Intent，且用户无法看到哪项服务已启动。</p>
<p>Intent 的这一字段是 ComponentName 对象，可以使用目标组件的完全限定类名指定此对象，其中包括应用的软件包名称。例如，com.example.ExampleActivity，可以使用 setComponent()、setClass()、setClassName()，或 Intent 构造函数设置组件名称。</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>指定要执行的通用操作（例如，查看或选取）的字符串。</p>
<p>对于广播 Intent，这是指已发生且正在报告的操作。action会在很大程度上决定其余 Intent 的构成，特别是 data 和 extra 中包含的内容。可以指定自己的操作，供 Intent 在您的应用内使用（或者供其他应用在您的应用中调用组件）。但是，您通常应该使用由Intent 类或其他框架类定义的操作常量。以下是一些用于启动 Activity 的常见操作：</p>
<ol>
<li>ACTION_VIEW：如果您拥有一些某项 Activity 可向用户显示的信息（例如，要使用图库应用查看的照片；或者要使用地图应用查看的地址），请通过 Intent 将此操作与 startActivity() 结合使用。</li>
<li>ACTION_SEND：这也称为共享 Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此操作与 startActivity() 结合使用。</li>
</ol>
<p>可以使用 setAction() 或 Intent 构造函数为 Intent 指定操作。</p>
<p>如以下示例所示，如果定义自己的操作，请确保加入应用的软件包名称作为前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ACTION_TIMETRAVEL = <span class="string">"com.example.action.TIMETRAVEL"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。</p>
<p>创建 Intent 时，除了指定 URI 以外，指定数据类型（MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件。但有时 MIME 类型可以从 URI 中推断得出，特别当数据是 content:URI 时尤其如此。content:URI 表明数据位于设备中，且由 ContentProvider 控制，这使得数据 MIME 类型对系统可见。</p>
<p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，您可以使用 setDataAndType() 同时显式设置二者。</p>
<p>注意：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType() 同时设置 URI 和 MIME 类型。</p>
<h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的Category放入一个 Intent 中，但大多数 Intent 均不需要 Category。以下是一些常见category：</p>
<ul>
<li>CATEGORY_BROWSABLE：目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。</li>
<li>CATEGORY_LAUNCHER：该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</li>
<li>CATEGORY_HOME：桌面应用需要声明。</li>
<li>CATEGORY_DEFAULT：通过隐式启动Activity时，Android会默认加上一个CATEGORY_DEFAULT，所以如果Activity要支持隐式启动的话，除了默认LaunchActivity，其余都需要加上CATEGORY_DEFAULT。</li>
</ul>
<p>可以使用 addCategory() 指定category。</p>
<h4 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h4><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。可以使用各种 putExtra() 方法添加 extra 数据，每种方法均接受两个参数：键名和值。还可以创建一个包含所有 extra 数据的 Bundle 对象，然后使用 putExtras() 将 Bundle 插入 Intent 中。</p>
<p>例如，使用 ACTION_SEND 创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL 键指定目标收件人，并使用 EXTRA_SUBJECT 键指定主题。</p>
<p>Intent 类将为标准化的数据类型指定多个 EXTRA_* 常量。如需声明自己的 extra 键（对于应用接收的 Intent），请确保将应用的软件包名称作为前缀，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_GIGAWATTS = <span class="string">"com.example.EXTRA_GIGAWATTS"</span>;</span><br></pre></td></tr></table></figure>

<p>注意：在发送您希望另一个应用接收的 Intent 时，请勿使用 Parcelable 或 Serializable 数据。如果某个应用尝试访问 Bundle 对象中的数据，但没有对打包或序列化类的访问权限，则系统将提出一个 RuntimeException。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><p>Flags 在 Intent 类中定义，充当 Intent 的元数据。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理（例如，Activity 是否属于最近的 Activity 列表）。</p>
<p>可以使用 setFlags() 方法添加Flags。</p>
<h3 id="显式-Intent-示例"><a href="#显式-Intent-示例" class="headerlink" title="显式 Intent 示例"></a>显式 Intent 示例</h3><p>显式 Intent 是指用于启动某个特定应用组件（例如，应用中的某个特定 Activity 或服务）的 Intent，要创建显式 Intent，需要为 Intent 对象定义组件名称，Intent 的所有其他属性均为可选属性。</p>
<p>例如，如果在应用中构建一个名为 DownloadService、旨在从网页下载文件的服务，则可使用以下代码启动该服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed in an Activity, so 'this' is the Context</span></span><br><span class="line"><span class="comment">// The fileUrl is a string URL, such as "http://www.example.com/image.png"</span></span><br><span class="line">Intent downloadIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DownloadService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">downloadIntent.setData(Uri.parse(fileUrl));</span><br><span class="line">startService(downloadIntent);</span><br></pre></td></tr></table></figure>

<p>Intent(Context, Class) 构造函数分别为应用和组件提供 Context 和 Class 对象。因此，此 Intent 将显式启动该应用中的 DownloadService 类。</p>
<h3 id="隐式-Intent-示例"><a href="#隐式-Intent-示例" class="headerlink" title="隐式 Intent 示例"></a>隐式 Intent 示例</h3><p>隐式 Intent 指定能够在可以执行相应操作的设备上调用任何应用的操作。如果您的应用无法执行该操作而其他应用可以，且您希望用户选取要使用的应用，则使用隐式 Intent 非常有用。例如，如果您希望用户与他人分享您的内容，请使用 ACTION_SEND 操作创建 Intent，并添加指定共享内容的 extra。使用该 Intent 调用 startActivity() 时，用户可以选取分享内容所使用的应用。</p>
<p>注意：用户可能没有任何应用处理您发送到 startActivity() 的隐式 Intent。或者，由于配置文件限制或管理员执行的设置，可能无法访问应用。如果发生这样的情况，调用失败，应用也会崩溃。要验证 Activity 是否会接收 Intent，请对 Intent 对象调用 resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，并且可以安全调用 startActivity()。如果结果为空，不要使用该 Intent。以下示例说明如何验证 Intent 是否解析为 Activity。此示例没有使用 URI，但已声明 Intent 的数据类型，用于指定 extra 携带的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the text message with a string</span></span><br><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</span><br><span class="line">sendIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the intent will resolve to an activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(sendIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 startActivity() 时，系统将检查已安装的所有应用，确定哪些应用能够处理这种 Intent（即：含 ACTION_SEND 操作并携带“text/plain”数据的 Intent）。如果只有一个应用能够处理，则该应用将立即打开并为其提供 Intent。如果多个 Activity 接受 Intent，则系统将显示一个对话框，使用户能够选取要使用的应用。</p>
<h3 id="强制使用应用选择器"><a href="#强制使用应用选择器" class="headerlink" title="强制使用应用选择器"></a>强制使用应用选择器</h3><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。如果用户可能希望每次使用相同的应用执行某项操作（例如，打开网页时，用户往往倾向于仅使用一种网络浏览器），则选择默认选项的功能十分有用。</p>
<p>但是，如果多个应用可以响应 Intent，且用户可能希望每次使用不同的应用，则应采用显式方式显示选择器对话框。选择器对话框会要求用户选择用于操作的应用（用户无法为该操作选择默认应用）。例如，当应用使用 ACTION_SEND 操作执行“共享”时，用户根据目前的状况可能需要使用另一不同的应用，因此应当始终使用选择器对话框。</p>
<p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()，如下例所示。此示例将显示一个对话框，其中有响应传递给 createChooser() 方法的 Intent 的应用列表，并且将提供的文本用作对话框标题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always use string resources for UI text.</span></span><br><span class="line"><span class="comment">// This says something like "Share this photo with"</span></span><br><span class="line">String title = getResources().getString(R.string.chooser_title);</span><br><span class="line"><span class="comment">// Create intent to show the chooser dialog</span></span><br><span class="line">Intent chooser = Intent.createChooser(sendIntent, title);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the original intent will resolve to at least one activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><h3 id="接收隐式-Intent-1"><a href="#接收隐式-Intent-1" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，请在 Manifest 文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent-filter。每个 Intent-filter均根据 Intent 的操作、数据和category指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent-filter之一传递时，系统才会将该 Intent 传递给应用组件。</p>
<p>请注意：显式 Intent 始终会传递给其目标，无论组件声明的 Intent-filter如何均是如此。</p>
<p>应用组件应当为自身可执行的每个独特作业声明单独的filter。例如，图像库应用中的一个 Activity 可能会有两个filter，分别用于查看图像和编辑图像。当 Activity 启动时，将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。</p>
<p>每个 Intent-filter均由应用Manifest文件中的 <code>&lt;intent-filter&gt;</code> 元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code> 元素）中。在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<ul>
<li><code>&lt;action&gt;</code>：在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。</li>
<li><code>&lt;data&gt;</code>：使用一个或多个指定数据 URI（scheme、host、port、path）各个方面和 MIME 类型的属性，声明接受的数据类型。</li>
<li><code>&lt;category&gt;</code>：在 name 属性中，声明接受的 Intent category。该值必须是操作的文本字符串值，而不是类常量。</li>
</ul>
<p>请注意：要接收隐式 Intent，必须将 CATEGORY_DEFAULT category包括在 Intent-filter中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT category的方式处理所有 Intent。如果未在 Intent-filter中声明此category，则隐式 Intent 不会解析为您的 Activity。</p>
<p>例如，以下是一个使用包含 Intent-filter的 Activity 声明，当数据类型为文本时，系统将接收 ACTION_SEND Intent ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您可以创建一个包括多个 <code>&lt;action&gt;</code>、<code>&lt;data&gt;</code> 或 <code>&lt;category&gt;</code> 实例的filtet。创建时，需确定组件能够处理这些filter元素的任何及所有组合。</p>
<p>如需仅以操作、数据和类别类型的特定组合来处理多种 Intent，则需创建多个 Intent-filter。</p>
<p>系统通过将 Intent 与所有这三个元素进行比较，根据filter测试隐式 Intent。隐式 Intent 若要传递给组件，必须通过所有这三项测试。如果 Intent 无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件。但是，由于一个组件可能有多个 Intent-filter，因此未能通过某一组件filter的 Intent 可能会通过另一filter。</p>
<p>注意：使用 Intent-filter时，无法安全地防止其他应用启动组件。尽管 Intent-filter将组件限制为仅响应特定类型的隐式 Intent，但如果开发者确定您的组件名称，则其他应用有可能通过使用显式 Intent 启动您的应用组件。如果必须确保只有您自己的应用才能启动您的某一组件，请勿在您的清单中声明 Intent-filter，将该组件的 exported 属性设置为 “false”。</p>
<p>同样，为了避免无意中运行不同应用的 Service，请始终使用显式 Intent 启动您自己的服务。</p>
<p>请注意：对于所有 Activity，您必须在清单文件中声明 Intent-filter。但是，广播接收器的filter可以通过调用 registerReceiver() 动态注册。这样一来，应用便可仅在应用运行时的某一指定时间段内侦听特定的广播。</p>
<h3 id="filter示例"><a href="#filter示例" class="headerlink" title="filter示例"></a>filter示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity is the main entry, should appear in app launcher --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity handles "SEND" actions with text data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND_MULTIPLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.google.panorama360+jpg"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开：</p>
<ul>
<li>ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。</li>
<li>CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。如果 <code>&lt;activity&gt;</code> 元素未使用 icon 指定图标，则系统将使用 <code>&lt;application&gt;</code> 元素中的图标。</li>
</ul>
<p>这两个元素必须配对使用，Activity 才会显示在应用启动器中。</p>
<p>第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent-filter之一匹配）的另一应用中直接进入 ShareActivity。</p>
<h2 id="使用PendingIntent"><a href="#使用PendingIntent" class="headerlink" title="使用PendingIntent"></a>使用PendingIntent</h2><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p>
<p>PendingIntent 的主要用例包括：</p>
<ul>
<li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用您的应用微件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li>
</ul>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建 PendingIntent。使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent 时，您必须声明所需的组件类型：</p>
<ul>
<li>PendingIntent.getActivity()，适用于启动 Activity 的 Intent。</li>
<li>PendingIntent.getService()，适用于启动 Service 的 Intent。</li>
<li>PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。</li>
</ul>
<p>除非您的应用正在从其他应用中接收待定 Intent，否则上述用于创建 PendingIntent 的方法可能是您所需的唯一 PendingIntent 方法。</p>
<p>每种方法均会提取当前的应用 Context、您要封装的 Intent 以及一个或多个指定应如何使用该 Intent 的标志（例如，是否可以多次使用该 Intent）。</p>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该 Intent 与 Intent-filter进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Action</li>
<li>Data（URI 和数据类型）。</li>
<li>Category</li>
</ul>
<h3 id="Action测试"><a href="#Action测试" class="headerlink" title="Action测试"></a>Action测试</h3><p>要指定接受的 Intent action，Intent-filter既可以不声明任何 <code>&lt;action&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.EDIT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要通过此filter，Intent 中指定的action必须与filter中列出的某一action匹配。</p>
<h3 id="Category测试"><a href="#Category测试" class="headerlink" title="Category测试"></a>Category测试</h3><p>要指定接受的 Intent category，Intent-filter既可以不声明任何 <code>&lt;category&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若要使 Intent 通过category测试，则 Intent 中的每个category均必须与filter中的category匹配。Intent-filter声明的category可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。因此，不含category的 Intent 应当始终会通过此测试，无论filter中声明何种category均是如此。</p>
<p>请注意：Android 会自动将 CATEGORY_DEFAULT category应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent。如需 Activity 接收显示 Intent，则必须将 “android.intent.category.DEFAULT” 的category包括在其 Intent-filter中。</p>
<h3 id="Data测试"><a href="#Data测试" class="headerlink" title="Data测试"></a>Data测试</h3><p>要指定接受的 Intent 数据，Intent-filter既可以不声明任何 <code>&lt;data&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：scheme、host、port 和 path：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>在 <code>&lt;data&gt;</code> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p>
<ul>
<li>如果未指定scheme，则会忽略host。</li>
<li>如果未指定host，则会忽略port。</li>
<li>如果未指定scheme和host，则会忽略path。</li>
</ul>
<p>将 Intent 中的 URI 与filter中的 URI 规范进行比较时，它仅与filter中包含的部分 URI 进行比较。例如：</p>
<ul>
<li>如果filter仅指定scheme，则具有该scheme的所有 URI 均与该filter匹配。</li>
<li>如果filter指定scheme和host，但未指定path，则具有相同scheme和host的所有 URI 都会通过filter，无论其path如何均是如此。</li>
<li>如果filter指定scheme、host和path，则仅具有相同scheme、host和path的 URI 才会通过filter。</li>
</ul>
<p>请注意：path规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。</p>
<p>数据测试会将 Intent 中的 URI 和 MIME 类型与filter中指定的 URI 和 MIME 类型进行比较。规则如下：</p>
<ul>
<li>仅当filter未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与filter的 URI 格式匹配、且filter同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当filter列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与filter中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与filter中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且filter未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果filter只是列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<p>请注意：如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <code>&lt;intent-filter&gt;</code> 中没有 <code>&lt;data&gt;</code> 元素时失败。</p>
<p>最后一条规则反映出对组件能够从文件中或内容提供程序处获得本地数据的预期。因此，其filter只能列出数据类型，不需要显式命名 content: 和 file: scheme。以下是一个典型示例，说明 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从内容提供程序处获得并显示图像数据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于大部分可用数据均由内容提供程序分发，因此指定数据类型（而非 URI）的filter也许最为常见。</p>
<p>另一常见的配置是具有scheme和数据类型的filter。例如，下文中的 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从网络中检索视频数据以执行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent-filter匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。例如，主页应用通过使用指定 ACTION_MAIN action和 CATEGORY_LAUNCHER category的 Intent-filter查找所有 Activity，以此填充应用启动器。如 IntentFilter 类文档所述，只有当 Intent 中的操作和category与filter匹配时，匹配才会成功。</p>
<p>您的应用可以使用类似于主页应用的方式使用 Intent 匹配。PackageManager 提供一整套 query…() 方法来返回所有能够接受特定 Intent 的组件。此外，还会提供一系列类似的 resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities() 将返回能够执行作为参数传递的 Intent 中列出的所有 Activity，而 queryIntentServices() 则可返回类似的一系列服务。这两种方法均不会激活组件；而只是列出能够响应的组件。对于广播接收器，有一种类似的方法：queryBroadcastReceivers()。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/Android%E5%9F%BA%E7%A1%80%20--%20%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Android%E5%9F%BA%E7%A1%80%20--%20%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">Android基础 -- 四大组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 10:33:14 / 修改时间：10:35:51" itemprop="dateCreated datePublished" datetime="2020-06-01T10:33:14+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/FrameWork/" itemprop="url" rel="index"><span itemprop="name">FrameWork</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="Activity生命周期.png"/>

<p>注意：当activityB在activityA之前启动时，将在A上调用onPause()回调。在A的onPause()返回之前，将不会创建B，因此请确保onPause()中不要做任何冗长的操作。</p>
<ol>
<li><p>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为entire lifetime。</p>
</li>
<li><p>当执行onStart回调方法时，Activity开始被用户所见（也就是说，onCreate时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到onStop之前，此阶段Activity都是被用户可见，称之为visible lifetime。</p>
</li>
<li><p>当执行到onResume回调方法时，Activity可以响应用户交互，一直到onPause方法之前，此阶段Activity称之为foreground lifetime。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序启动</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.687</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.819</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.823</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.802</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.815</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.824</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">54.156</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.672</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.716</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.717</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br><span class="line"><span class="comment">// 按下home键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.703</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.722</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.723</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 返回应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.968</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">20.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.274</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.925</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.959</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.963</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入task</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.056</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.068</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.088</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 后台终止</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">51.310</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="打印生命周期"><a href="#打印生命周期" class="headerlink" title="打印生命周期"></a>打印生命周期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BaseActivity"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onCreate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onResume"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onPause"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onRestart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStop"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onNewIntent"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onActivityResult"><a href="#onActivityResult" class="headerlink" title="onActivityResult"></a>onActivityResult</h2><p>MainActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>), 0)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"MainActivity-onActivityResult"</span>);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"result = "</span> + data.getStringExtra(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecondActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"value"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">setResult(<span class="number">1</span>, intent);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.038</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.070</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.166</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.170</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.659</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.672</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.679</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.682</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">40.015</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">48.965</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onActivityResult</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: result = hearing</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.395</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.396</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br></pre></td></tr></table></figure>

<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>通过android:launchMode配置</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是Activity默认的启动模式，在不指定Activity启动模式的情况下，所有Activity使用的都是standard模式。</p>
<p>在standard模式下，每当启动一个新的Activity，它就会进入任务栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会判断该Activity在栈中是否存在，每次启动都会创建一个新的实例。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop模式与standard类似，不同的是，当启动的Activity已经位于栈顶时，则直接使用它不创建新的实例，此时栈顶的Activity实例会调onNewIntent方法。如果启动的Activity没有位于栈顶时，则创建一个新的实例位于栈顶。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>如果希望Activity在整个应用程序中只存在一个实例，可以使用singleTask模式，当Activity的启动模式指定为 singleTask，每次启动该Activity时，系统首先会检查栈中是否存在该Activity的实例，如果发现已经存在则直接使用该实例，此时栈顶的Activity实例会调onNewIntent方法，并将当前Activity之上的所有Activity出栈，如果没有发现则创建一个新的实例。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>在程序开发过程中，如果需要Activity在整个系统中都只有一个实例，这时就需要用到singleInstance模式。指定为singleInstance模式的Activity会启动一个新的任务栈来管理这个Activity。</p>
<p>singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。采用这种模式启动Activity会分为一下两种情况：</p>
<ul>
<li>如果要启动的Activity不存在，系统会创建一个新的任务栈，在创建该Activity的实例，并把该Activity加入栈顶.</li>
<li>如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。</li>
</ul>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a>allowTaskReparenting</h3><p>如果该Activity的allowTaskReparenting设置为true，它进入后台，当一个和它有相同affinity的Task进入前台时，它会重新宿主，进入到该前台的task中。</p>
<table>
<thead>
<tr>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">taskAffinity</th>
<th align="center">allowTaskReparenting</th>
</tr>
</thead>
<tbody><tr>
<td align="center">application1</td>
<td align="center">Activity1</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">application2</td>
<td align="center">Activity2</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>创建两个工程：application1和application2，分别含有Activity1和Activity2，它们的taskAffinity相同，Activity1的allowTaskReparenting为true。</p>
<p>首先，我们启动application1,加载Activity1，然后按Home键，使该task（假设为task1）进入后台。然后启动application2，默认加载Activity2。本来应该是显示Activity2，但是我们却看到了Activity1。实际上Activity2也被加载了，只是Activity1重新宿主，所以看到了Activity1。</p>
<h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>如果加载某个Activity的intent，Flag被设置成FLAG_ACTIVITY_NEW_TASK时，它会首先检查是否存在与自己taskAffinity相同的Task，如果存在，那么它会直接宿主到该Task中，如果不存在则重新创建Task。</p>
<p>写一个应用，包含两个Activity：Activity1的taskAffinity为<code>com.hearing.task</code>，Activity2为入口，且点击Activity2会以FLAG_ACTIVITY_NEW_TASK启动Activity1。再写一个应用MyActivity，它包含一个Activity（MyActivity），其taskAffinity为<code>com.hearing.task</code>。</p>
<p>首先启动MyActivity，然后Home回桌面，然后打开Activity2，点击Activity2，进入Activity1。然后按返回键。进入Activity的顺序为Activity2-&gt;Activity1，而返回时顺序为Activity1-&gt;MyActivity。这就说明了一个问题，Activity1在启动时，重新宿主到了MyActivity所在的Task中去了。</p>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul>
<li>当一个应用程序加载一个singleTask模式的Activity时，首先该Activity会检查是否存在与它的taskAffinity相同的Task。如果存在，那么检查是否实例化，如果已经实例化，那么销毁在该Activity以上的Activity并调用onNewIntent。如果没有实例化，那么该Activity实例化并入栈。如果不存在，那么就重新创建Task，并入栈。</li>
<li>当一个应用程序加载一个singleInstance模式的Activity时，如果该Activity没有被实例化，那么就重新创建一个Task，并入栈，如果已经被实例化，那么就调用该Activity的onNewIntent.singleInstance的Activity所在的Task不允许存在其他Activity，任何从该Activity加载的其它Activity（假设为Activity2）都会被放入其它的Task中，如果存在与Activity2相同affinity的Task，则在该Task内创建Activity2。如果不存在，则重新生成新的Task并入栈。</li>
</ul>
<h2 id="onSaveInstanceState与onRestoreInstanceState方法"><a href="#onSaveInstanceState与onRestoreInstanceState方法" class="headerlink" title="onSaveInstanceState与onRestoreInstanceState方法"></a>onSaveInstanceState与onRestoreInstanceState方法</h2><p>onSaveInstanceState主要是用于保存一些临时数据，当Activity恢复时，可以恢复对应的数据，onRestoreInstanceState当Activity被重新创建时调用，可以从该 方法中恢复一些之前保存过的数据。</p>
<p>onSaveInstanceState一般是在Activity被“打断”的情况下被调用，例如被覆盖，包括全覆盖或者部分覆盖，或者按home退到后台，或者灭屏。另外一种情况就是Activity被重新创建会调用，例如用户在当前Activity旋转屏幕，或者用户调用recreate方法。点击返回键该方法不会被调用。onSaveInstanceState的调用顺序是在onPause之后，onStop之前。</p>
<p>onRestoreInstanceState一般是在Activty被重新创建恢复时会被调用，例如用户切换横竖屏。用户将Activty挂后台，切换系统设置，然后再启动该Activity。</p>
<h2 id="启动方式的问题"><a href="#启动方式的问题" class="headerlink" title="启动方式的问题"></a>启动方式的问题</h2><p>MainActivity是SingleTask或者SingleInstance模式，启动TestActivity，TestActivity马上跳转到MainActivity，这种情况下，MainActivity的onResume会回调两次。日志如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onCreate</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onStart</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">TestActivity onCreate</span><br><span class="line">TestActivity onStart</span><br><span class="line">TestActivity onResume</span><br><span class="line">TestActivity onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onNewIntent</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">TestActivity onStop</span><br></pre></td></tr></table></figure>

<p>适当延时500ms再跳转回MainActivity可以解决这个问题（可能由于业务场景不同，会带来新的问题）。</p>
<p>在<a href="https://stackoverflow.com/questions/11092101/startactivity-on-foreground-application-causes-onpause-onresume" target="_blank" rel="noopener">stackoverflow</a>上也有人发现过类似的问题。</p>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>普通广播（Normal Broadcast）</li>
<li>系统广播（System Broadcast）</li>
<li>有序广播（Ordered Broadcast）</li>
<li>粘性广播（Sticky Broadcast）（已弃用）</li>
<li>App应用内广播（Local Broadcast）</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="BroadcastReceiver-1"><a href="#BroadcastReceiver-1" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><ul>
<li>继承BroadcastReceivre基类</li>
<li>必须复写抽象方法onReceive()方法</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><ul>
<li>常驻：不受任何组件声明周期影响</li>
<li>耗电，占内存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    //此<span class="attr">broadcastReceiver</span>能否接收其他<span class="attr">App</span>的发出的广播</span></span><br><span class="line"><span class="tag">    //默认值是由<span class="attr">receiver</span>中有无<span class="attr">intent-filter</span>决定的：如果有<span class="attr">intent-filter</span>，默认值为<span class="attr">true</span>，否则为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    //继承<span class="attr">BroadcastReceiver</span>子类的类名</span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".mBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">    //具有相应权限的广播发送者发送的广播才能被此<span class="attr">BroadcastReceiver</span>所接收；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">BroadcastReceiver</span>运行所处的进程</span></span><br><span class="line"><span class="tag">    //默认为<span class="attr">app</span>的进程，可以指定独立的进程</span></span><br><span class="line"><span class="tag">    //注：<span class="attr">Android</span>四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    //用于指定此广播接收器将接收的广播类型</span><br><span class="line">    //本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><ul>
<li>非常驻，灵活</li>
<li>手动释放</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">    mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> mBroadcastReceiver();</span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中</span></span><br><span class="line"><span class="comment">// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</li>
<li>假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>生命周期:</p>
<ol>
<li><p>startService()</p>
<ul>
<li>作用：启动Service服务</li>
<li>手动调用startService()后，自动调用内部方法：onCreate()、onStartCommand() </li>
<li>如果一个service被startService多次启动，onCreate()只会调用一次 </li>
<li>onStartCommand()调用次数=startService()次数</li>
</ul>
</li>
<li><p>stopService()</p>
<ul>
<li>作用：关闭Service服务 </li>
<li>手动调用stopService()后，自动调用内部方法：onDestory() </li>
<li>如果一个service被启动且被绑定，如果没有在绑定的前提下stopService()是无法停止服务的。</li>
</ul>
</li>
<li><p>bindService()</p>
<ul>
<li>作用：绑定Service服务 </li>
<li>手动调用bindService()后，自动调用内部方法：onCreate()、onBind()</li>
</ul>
</li>
<li><p>unbindService()</p>
<ul>
<li>作用：解绑Service服务 </li>
<li>手动调用unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory()</li>
</ul>
</li>
</ol>
<p>接口函数：</p>
<ul>
<li>onStartCommand()：当其他组件调用startService()方法请求启动Service时，该方法被回调。一旦Service启动，它会在后台独立运行。当Service执行完以后，需调用stopSelf() 或 stopService()方法停止Service。（若您只希望bind Service，则无需调用这些方法）</li>
<li>onBind()：当其他组件调用bindService()方法请求绑定Service时，该方法被回调。该方法返回一个IBinder接口，该接口是Service与绑定的组件进行交互的桥梁。若Service未绑定其他组件，该方法应返回null。</li>
<li>onCreate()：当Service第一次创建时，回调该方法。该方法只被回调一次，并在onStartCommand() 或 onBind()方法被回调之前执行。若Service处于运行状态，该方法不会回调。</li>
<li>onDestroy()：当Service被销毁时回调，在该方法中应清除一些占用的资源，如停止线程、接触绑定注册的监听器或broadcast receiver 等。该方法是Service中的最后一个回调。</li>
</ul>
<p>启动方式：</p>
<ul>
<li>Started：其他组件调用startService()方法启动一个Service。一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。通常，一个被start的Service会在后台执行单独的操作，也并不给启动它的组件返回结果。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</li>
<li>Bound：其他组件调用bindService()方法绑定一个Service。通过绑定方式启动的Service是一个client-server结构，该Service可以与绑定它的组件进行交互。一个bound service仅在有组件与其绑定时才会运行（A bound service runs only as long as another application component is bound to it），多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。</li>
</ul>
<p>注意：</p>
<ul>
<li>Service运行在主线程中（A service runs in the main thread of its hosting process），Service并不是一个新的线程，也不是新的进程。也就是说，若您需要在Service中执行较为耗时的操作（如播放音乐、执行网络请求等），需要在Service中创建一个新的线程。这可以防止ANR的发生，同时主线程可以执行正常的UI操作。</li>
<li>如果某个组件通过调用startService()启动了Service（系统会回调onStartCommand()方法），那么直到在Service中手动调用stopSelf()方法、或在其他组件中手动调用stopService()方法，该Service才会停止。</li>
<li>如果某个组件通过调用bindService()绑定了Service（系统不会回调onStartCommand()方法），只要该组件与Service处于绑定状态，Service就会一直运行，当Service不再与组件绑定时，该Service将被destroy。</li>
<li>当系统内存低时，系统将强制停止Service的运行；若Service绑定了正在与用户交互的activity，那么该Service将不大可能被系统kill（ less likely to be killed）。如果创建的是前台Service，那么该Service几乎不会被kill（almost never be killed）。否则，当创建了一个长时间在后台运行的Service后，系统会降低该Service在后台任务栈中的级别——这意味着它容易被kill（lower its position in the list of background tasks over time and the service will become highly susceptible to killing），所以在开发Service时，需要使Service变得容易被restart，因为一旦Service被kill，再restart它需要其资源可用时才行</li>
</ul>
<h2 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.servicetest.MyService"</span> &gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承IntentService类"><a href="#继承IntentService类" class="headerlink" title="继承IntentService类"></a>继承IntentService类</h2><ul>
<li>默认在子线程中处理回传到onStartCommand()方法中的Intent；</li>
<li>在重写的onHandleIntent()方法中处理按时间排序的Intent队列，所以不用担心多线程（multi-threading）带来的问题。</li>
<li>当所有请求处理完成后，自动停止service，无需手动调用stopSelf()方法；</li>
<li>默认实现了onBind()方法，并返回null；</li>
<li>默认实现了onStartCommand()方法，并将回传的Intent以序列的形式发送给onHandleIntent()，只需重写该方法并处理Intent即可。</li>
</ul>
<h2 id="继承Service类"><a href="#继承Service类" class="headerlink" title="继承Service类"></a>继承Service类</h2><p>如果需要在Service中执行多线程而不是处理一个请求队列，那么需要继承Service类，分别处理每个Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Log.d(TAG, <span class="string">"onCreate() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">		Log.d(TAG, <span class="string">"onStartCommand() executed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">		Log.d(TAG, <span class="string">"onDestroy() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mBinder;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="string">"TAG"</span>, <span class="string">"startDownload() executed"</span>);</span><br><span class="line">			<span class="comment">// 执行具体的下载任务</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onStartCommand()返回一个整形变量，该变量必须是下列常量之一：</p>
<ul>
<li>START_NOT_STICKY：若执行完onStartCommand()方法后，系统就kill了service，不要再重新创建service，除非系统回传了一个pending intent。这避免了在不必要的时候运行service，您的应用也可以restart任何未完成的操作。</li>
<li>START_STICKY：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()。dangerous不要重新传递最后一个Intent（do not redeliver the last intent）。相反，系统回调onStartCommand()时回传一个空的Intent，除非有 pending intents传递，否则Intent将为null。该模式适合做一些类似播放音乐的操作。</li>
<li>START_REDELIVER_INTENT：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()并将最后一个Intent回传至该方法。任何 pending intents都会被轮流传递。该模式适合做一些类似下载文件的操作。</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>startService(intent)方法将立即返回，并回调onStartCommand()（请不要手动调用该方法），若该Service未处于运行状态，系统将首先回调onCreate()，接着再回调onStartCommand()。若您希望Service可以返回结果，那么需要通过调用getBroadcast 返回的PendingIntent启动Service（将PendingIntent包装为Intent），service可使用broadcast 传递结果。</p>
<p>多个启动Service的请求可能导致onStartCommand()多次调用，但只需调用stopSelf() 、 stopService()这两个方法之一，就可停止该服务。</p>
<h2 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h2><ul>
<li>通过其他组件调用bindService()方法可以绑定一个Service以保持长连接（long-standing connection），这时一般不允许其他组件调用startService()启动Service。</li>
<li>当其他组件需要与Service交互或者需要跨进程通信时，可以创建一个bound Service。</li>
<li>为创建一个bound Service，必须重写onBind()回调，该方法返回一个IBinder接口。该接口时组件与Service通信的桥梁。组件调用bindService()与Service绑定，该组件可获取IBinder接口，一旦获取该接口，就可以调用Service中的方法。一旦没有组件与Service绑定，系统将destroy它，您不必手动停止它。</li>
<li>为创建一个bound Service，必须定义一个接口 ，该接口指定组件与Service如何通信。定义的接口在组件与Service之间，且必须实现IBinder接口。这正是onBind()的返回值。一旦组件接收了IBinder，组件与Service便可以开始通信。</li>
<li>多个组件可同时与Service绑定，当组件与Service交互结束后，可调用unbindService()方法解绑。bound Service比start Service要复杂，故我将在后续单独翻译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyService.MyBinder myBinder;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">			myBinder = (MyService.MyBinder) service;</span><br><span class="line">			myBinder.startDownload();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.start_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			startService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">			Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			stopService(stopIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">			Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">			unbindService(connection);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行前台Service"><a href="#运行前台Service" class="headerlink" title="运行前台Service"></a>运行前台Service</h2><ul>
<li>前台Service用于动态通知消息，如天气预报。该Service不易被kill。前台Service必须提供status bar，只有前台Service被destroy后，status bar才能消失。</li>
<li>举例来说，一个播放音乐的Service必须是前台Service，只有这样用户才能确知其运行状态。为前台Service提供的status bar可以显示当前音乐的播放状态，并可以启动播放音乐的Activity。</li>
<li>调用startForeground()可以启动前台Service。该方法接收两个参数，参数一是一个int型变量，用户指定该通知的唯一性标识，而参数而是一个Notification用于配置status bar</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ContentProvider为不同的应用之间数据共享提供统一的接口，Android系统中应用内部的数据是对外隔离的，要想让其它应用能够访问自己的数据，可以使用ContentProvider，其底层采用Binder机制实现跨进程共享数据。</p>
<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p>Uri的四个组成部分：content://contacts/people/5</p>
<ul>
<li>schema：已由Android固定设置为content://</li>
<li>authority：ContentProvider权限，在AndroidMenifest中设置权限</li>
<li>path：要操作的数据库表</li>
<li>id：查询的关键字（可选字段）</li>
</ul>
<p>Uri匹配模式：Uri的匹配表示要查询的数据，对于单个数据查询，可直接使用Uri定位具体的资源位置，但当范围查询时就需要结合通配符的使用，Uri提供以下两种通配符：</p>
<ul>
<li><code>*</code>：匹配由任意长度的任何有效字符组成的字符串</li>
<li><code>#</code>：匹配由任意长度的数字字符组成的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table2/*  //多数据查询</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/#</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/6  //单数据查询</span></span><br></pre></td></tr></table></figure>

<p>Uri的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(“content:<span class="comment">//contacts/people/5")</span></span><br></pre></td></tr></table></figure>

<p>Uri创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过将 ID 值追加到 URI 末尾来访问表中的单个行</span></span><br><span class="line">Uri singleUri = ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ContentUris"><a href="#ContentUris" class="headerlink" title="ContentUris"></a>ContentUris</h2><p>核心方法有两个：</p>
<ul>
<li>withAppendedId()：向Uri追加一个id</li>
<li>parseId()：从Uri中获取id</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>)</span><br><span class="line"><span class="comment">// 生成的Uri为：content://cn.scu.myprovider/user/7</span></span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user/7"</span>)</span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>

<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p>UriMatcher的作用：</p>
<ul>
<li>在ContentProvider 中注册Uri</li>
<li>根据 Uri 匹配 ContentProvider 中对应的数据表</li>
</ul>
<p>使用步骤：</p>
<ol>
<li>初始化UriMatcher对象</li>
<li>在ContentProvider 中注册URI（addURI()）</li>
<li>根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match()）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line"><span class="comment">// 常量UriMatcher.NO_MATCH：不匹配任何路径的返回码</span></span><br><span class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI</span></span><br><span class="line"><span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user1"</span>, URI_CODE_a); </span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user2"</span>, URI_CODE_b); </span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a</span></span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(matcher.match(uri)) &#123;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_a:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser1;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_b:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentProvider-1"><a href="#ContentProvider-1" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>ContentProvider主要以表格的形式组织数据，同时也支持文件数据。它一般配合数据库共同使用，实现对外共享数据的目的，所以它需要对数据库的增删改查操作，ContentProvider也为我们提供了相应的操作方法，使用时只需实现即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后或打开系统后其它进程第一次访问该ContentProvider时由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前 Uri 所代表数据的MIME类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>上述CRUD方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</li>
<li>存在多线程并发访问，需要实现线程同步<ul>
<li>若ContentProvider的数据存储方式是使用一个SQLite，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</li>
<li>若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</li>
</ul>
</li>
</ol>
<h2 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a>ContentResolver</h2><p>外部进程通过 ContentResolver类，从而与ContentProvider类进行交互。一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大，所以在ContentProvider类上加多了一个 ContentResolver类对所有的ContentProvider进行统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.hearing.provider.myprovider/tablename"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条记录</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">values.put(<span class="string">"age"</span>, <span class="number">26</span>);</span><br><span class="line">resolver.insert(uri, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tablename表中所有记录</span></span><br><span class="line">Cursor cursor = resolver.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"tablename data"</span>);</span><br><span class="line"><span class="keyword">while</span>(cursor.moveToNext()) &#123;</span><br><span class="line">   Log.i(<span class="string">"ContentTest"</span>, <span class="string">"tablename_id="</span>+ cursor.getInt(<span class="number">0</span>)+ <span class="string">", name="</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把id为1的记录的name字段值更改新为zhang1</span></span><br><span class="line">ContentValues updateValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">updateValues.put(<span class="string">"name"</span>, <span class="string">"zhang1"</span>);</span><br><span class="line">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.update(updateIdUri, updateValues, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除id为2的记录，即字段age</span></span><br><span class="line">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.delete(deleteIdUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>com.hearing.provider.myprovider需要在 AndroidManifest.xml 中进行注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"com.hearing.provider.myprovider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ContentObserver"><a href="#ContentObserver" class="headerlink" title="ContentObserver"></a>ContentObserver</h2><p>观察者模式：当ContentProvider中指定Uri中的数据变化时通知外界。</p>
<p>自定义ContentObserver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, myOberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">        db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values); </span><br><span class="line">        getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line">getContentResolver().unregisterContentObserver(myOberver);</span><br></pre></td></tr></table></figure>

<h2 id="MimeType"><a href="#MimeType" class="headerlink" title="MimeType"></a>MimeType</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>ContentProvider 类具有两个返回 MIME 类型的方法：</p>
<ul>
<li>getType()：任何ContentProvider程序都需要实现的方法</li>
<li>getStreamTypes()：当ContentProvider程序提供文件时要求实现</li>
</ul>
<h3 id="table的-MIME-类型"><a href="#table的-MIME-类型" class="headerlink" title="table的 MIME 类型"></a>table的 MIME 类型</h3><p>getType() 方法会返回一个 MIME 格式的 String，后者描述内容 URI 参数返回的数据类型。Uri 参数可以是pattern，而不是特定 URI；在这种情况下应该返回与匹配该模式的内容 URI 关联的数据类型。</p>
<p>对于文本、HTML 或 JPEG 等常见数据类型，getType() 应该为该数据返回标准 MIME 类型。</p>
<p>对于指向一个或多个表数据行的内容 URI，getType() 应该以 Android 供应商特有 MIME 格式返回 MIME 类型：</p>
<ol>
<li>类型部分：vnd</li>
<li>子类型部分：<ul>
<li>如果 URI 模式用于单个行：android.cursor.item/</li>
<li>如果 URI 模式用于多个行：android.cursor.dir/</li>
</ul>
</li>
<li>程序特有部分：<code>vnd.&lt;name&gt;.&lt;type&gt;</code><br> <code>&lt;name&gt;</code>值应具有全局唯一性，<type> 值应在对应的 URI pattern 中具有唯一性。通常使用包名或者公司域名作为<code>&lt;name&gt;</code>。适合选择 URI 关联表的标识字符串作为<code>&lt;type&gt;</code>。</li>
</ol>
<p>例如，如果ContentProvider的authority是 com.example.app.provider，并且它公开了一个名为 table1 的表，则 table1 中多个行的 MIME 类型是：<code>vnd.android.cursor.dir/vnd.com.example.provider.table1</code>；对于 table1 的单个行，MIME 类型是：<code>vnd.android.cursor.item/vnd.com.example.provider.table1</code>。</p>
<h3 id="文件的-MIME-类型"><a href="#文件的-MIME-类型" class="headerlink" title="文件的 MIME 类型"></a>文件的 MIME 类型</h3><p>如果 ContentProvider 程序提供文件，则需要实现 getStreamTypes()。该方法返回一个 MIME 类型的 String 数组，表示给定的 URI 返回的文件类型。</p>
<p>例如，假设提供程序以 .jpg、.png 和 .gif 格式文件形式提供照片图像。如果应用调用 ContentResolver.getStreamTypes() 时使用了过滤器字符串 image/*，则 ContentProvider.getStreamTypes() 方法应返回数组：<code>{ &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;}</code></p>
<p>如果应用只对 .jpg 文件感兴趣，则可以在调用 ContentResolver.getStreamTypes() 时使用过滤器字符串 */jpeg，ContentProvider.getStreamTypes() 应返回：<code>{&quot;image/jpeg&quot;}</code></p>
<p>如果程序未提供过滤器字符串中请求的任何 MIME 类型，则 getStreamTypes() 应返回 null。</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>指定其他应用访问提供程序的数据所必须具备权限的属性。</p>
<h3 id="grantUriPermssions"><a href="#grantUriPermssions" class="headerlink" title="grantUriPermssions"></a>grantUriPermssions</h3><p><code>android:grantUriPermssions</code>：表示是否可以通过临时权限访问数据，默认为false，在开发中可以只对限定的内容提供临时权限，如对照片的内容 URI 设置临时权限。</p>
<ul>
<li><p>true：系统会向整个系统授予临时权限，并替代其他设置的权限。</p>
</li>
<li><p>false：需添加<code>&lt;grant-uri-permission&gt;</code>并表明可以授权临时权限所对应的URI</p>
<ul>
<li><p>path：表示绝对路径Uri</p>
</li>
<li><p>pathPattern：表示限定完整的路径但可以使用./*通配符匹配</p>
</li>
<li><p>pathPrefix：限定路径的初始部分后面可以变化，只要初始部分符合即可授权</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:grantUriPermissions="false"</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">grant-uri-permission</span> <span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h3><ul>
<li>android:permission：统一提供程序范围读取/写入权限</li>
<li>android:readPermission：提供程序范围读取权限，优先于permission权限</li>
<li>android:writePermission：提供程序范围写入权限，优先于permission权限</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:readPermission="com.hearing.provider.permission.READ_PERMISSION"</span><br><span class="line">android:writePermission="com.hearing.provider.permission.WRITE_PERMISSION"</span><br><span class="line">android:permission="com.hearing.provider.permission.PERMISSION"</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建两个程序A和B，在程序A中使用ContentProvider保存数据，在程序B中进行查询，在开始A程序中不设置任何权限，B程序进行访问数据会报错；</li>
<li>修改A程序清单文件添加android:exported=”true”，再次访问数据访问成功；</li>
<li>在A程序的清单文件中，为Provider添加两个读写权限，添加完权限后再次在B程序中获取数据，还是会报错，也很正常因为已经对数据的访问设置了门槛，所以在B程序中声明读写权限即可。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A程序 --&gt;</span></span><br><span class="line">android:writePermission="com.alex.kotlin.job.provider.WRITE"</span><br><span class="line">android:readPermission="com.alex.kotlin.job.provider.READ"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- B程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.READ"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.WRITE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="系统ContentProvider"><a href="#系统ContentProvider" class="headerlink" title="系统ContentProvider"></a>系统ContentProvider</h2><p>举几个实例：铃声，联系人部分操作。</p>
<h3 id="铃声"><a href="#铃声" class="headerlink" title="铃声"></a>铃声</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改系统铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File sdFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    values.put(MediaStore.MediaColumns.DATA, sdFile.getAbsolutePath());</span><br><span class="line">    values.put(MediaStore.MediaColumns.TITLE, sdFile.getName());</span><br><span class="line">    values.put(MediaStore.MediaColumns.MIME_TYPE, <span class="string">"audio/*"</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_RINGTONE, <span class="keyword">true</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_NOTIFICATION, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_ALARM, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_MUSIC, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Uri uri = MediaStore.Audio.Media.getContentUriForPath(sdFile.getAbsolutePath());</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"uri is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String delete = MediaStore.MediaColumns.DATA + <span class="string">"=\""</span> + sdFile.getAbsolutePath() + <span class="string">"\""</span>;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + delete);</span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + context.getContentResolver().delete(uri, delete, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    Uri newUri = context.getContentResolver().insert(uri, values);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"uri = "</span> + uri);</span><br><span class="line">    Log.d(TAG, <span class="string">"new uri = "</span> + newUri);</span><br><span class="line"></span><br><span class="line">    RingtoneManager.setActualDefaultRingtoneUri(context, RingtoneManager.TYPE_RINGTONE, newUri);</span><br><span class="line">    Toast.makeText(context, <span class="string">"设置来电铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定电话号码的来电铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, number);</span><br><span class="line">    <span class="keyword">final</span> String[] projection = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            ContactsContract.Contacts._ID, ContactsContract.Contacts.LOOKUP_KEY</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> Cursor data = context.getContentResolver().query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.moveToFirst()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> contactId = data.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> String lookupKey = data.getString(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> Uri contactUri = ContactsContract.Contacts.getLookupUri(contactId, lookupKey);</span><br><span class="line">            <span class="keyword">if</span> (contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Invalid arguments"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">final</span> String value = Uri.fromFile(file).toString();</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"uri = "</span> + contactUri);</span><br><span class="line">            Log.d(TAG, <span class="string">"value = "</span> + value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ContentValues values = <span class="keyword">new</span> ContentValues(<span class="number">1</span>);</span><br><span class="line">            values.put(ContactsContract.Contacts.CUSTOM_RINGTONE, value);</span><br><span class="line">            context.getContentResolver().update(contactUri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Toast.makeText(context, <span class="string">"设置联系人铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联系人"><a href="#联系人" class="headerlink" title="联系人"></a>联系人</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据uri查询指定联系人电话(uri可以通过跳转联系人页面返回得到：intent.getData())</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContacts</span><span class="params">(Context context, Uri contactUri)</span> </span>&#123;</span><br><span class="line">    String phoneNumber = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor cursor = context.getContentResolver().query(contactUri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        String id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));</span><br><span class="line">        Cursor phones = context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,</span><br><span class="line">                <span class="keyword">null</span>, ContactsContract.CommonDataKinds.Phone.CONTACT_ID</span><br><span class="line">                        + <span class="string">"="</span> + id, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (phones != <span class="keyword">null</span> &amp;&amp; phones.moveToNext()) &#123;</span><br><span class="line">            phoneNumber = phones.getString(phones.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">            phones.close();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, <span class="string">"number = "</span> + phoneNumber);</span><br><span class="line">    <span class="keyword">return</span> phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据电话获取联系人名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContactName</span><span class="params">(Context context, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">    Uri lookupUri;</span><br><span class="line">    String[] projection = <span class="keyword">new</span> String[]&#123;ContactsContract.PhoneLookup._ID, ContactsContract.PhoneLookup.DISPLAY_NAME&#125;;</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));</span><br><span class="line">        cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lookupUri = Uri.withAppendedPath(android.provider.Contacts.Phones.CONTENT_FILTER_URL,</span><br><span class="line">                    Uri.encode(number));</span><br><span class="line">            cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = context.getResources().getString(R.string.unknown_contract);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.getCount() &gt; <span class="number">0</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        ret = cursor.getString(<span class="number">1</span>);</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h2><h3 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"finch.db"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_TABLE_NAME = <span class="string">"job"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 数据库版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DATABASE_NAME, <span class="keyword">null</span>, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个表格:用户表 和职业表</span></span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" name TEXT)"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + JOB_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" job TEXT)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义ContentProvider"><a href="#自定义ContentProvider" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    DBHelper mDbHelper = <span class="keyword">null</span>;</span><br><span class="line">    SQLiteDatabase db = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOHORITY = <span class="string">"cn.scu.myprovider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> User_Code = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Job_Code = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UriMatcher类使用:在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher mMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        mMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        mMatcher.addURI(AUTOHORITY,<span class="string">"user"</span>, User_Code);</span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">"job"</span>, Job_Code);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化ContentProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">// 在ContentProvider创建时对数据库进行初始化，不能做耗时操作，此处仅作展示</span></span><br><span class="line">        mDbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(1,'Carson');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(2,'Kobe');"</span>);</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from job"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(1,'Android');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(2,'iOS');"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">return</span> db.query(table,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> User_Code:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Job_Code:</span><br><span class="line">                tableName = DBHelper.JOB_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册ContentProvider"><a href="#注册ContentProvider" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"cn.scu.myprovider"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="访问ContentProvider的数据"><a href="#访问ContentProvider的数据" class="headerlink" title="访问ContentProvider的数据"></a>访问ContentProvider的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Iverson"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user, values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://cn.scu.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程1"><a href="#进程1" class="headerlink" title="进程1"></a>进程1</h3><h4 id="创建数据库类-1"><a href="#创建数据库类-1" class="headerlink" title="创建数据库类"></a>创建数据库类</h4><p>同上。</p>
<h4 id="自定义ContentProvider-1"><a href="#自定义ContentProvider-1" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h4><p>同上。</p>
<h4 id="注册ContentProvider-1"><a href="#注册ContentProvider-1" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"scut.carson_ho.myprovider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"scut.carson_ho.PROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span> = <span class="string">"scut.carson_ho.Read"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:writePermission</span> = <span class="string">"scut.carson_ho.Write"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="进程2"><a href="#进程2" class="headerlink" title="进程2"></a>进程2</h3><h4 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="访问ContentProvider"><a href="#访问ContentProvider" class="headerlink" title="访问ContentProvider"></a>访问ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Jordan"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user,values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>对于面向Android 7.0及以上的应用，Android禁止在应用外部公开<code>file://url</code>。如果一项包含文件URI的intent离开应用，则应用会抛出FileUriExposedException异常。</p>
<p>解决方案：要在应用间共享文件，应发送一项content://URI，并授予URI临时访问权限。进行此授权的最简单方式是使用FileProvider类。FileProvider是ContentProvider的一个特殊的子类，它让应用间共享文件变得更加容易，其通过创建一个Content URI来代替File URI。</p>
<h3 id="注册FileProvider"><a href="#注册FileProvider" class="headerlink" title="注册FileProvider"></a>注册FileProvider</h3><p>由于FileProvider中已经包含了为file生成Content URI的基本代码了，所以开发者不必再去定义一个FileProvider的子类。你可以在XML文件中指定一个FileProvider：在manifest中使用<code>&lt;provider&gt;</code>标签来指定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.hearing.fileprovider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name的值一般都固定为android.support.v4.content.FileProvider。如果开发者继承了FileProvider，则可以写上其绝对路径。</li>
<li>authorities字段的值用来表明使用的使用者，在FileProvider的函数getUriForFile需要传入该参数。</li>
<li>exported 的值为false，表示该FileProvider只能本应用使用，不是public的。</li>
<li>grantUriPermissions 的值为true，表示允许赋予临时权限。</li>
</ul>
<h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>只有事先指定了目录，一个FileProvider才可以为文件生成一个对应的Content URI。要指定一个路径，需要在XML文件中指定其存储的路径。使用<code>&lt;paths&gt;</code>标签。例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/files/path/</code></li>
<li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalFilesDir(null) + &quot;/path/&quot;</code>，<code>/storage/emulated/0/Android/data/&lt;package_name&gt;/files/path/</code></li>
<li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalCacheDir() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/Android/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Environment.getExternalStorageDirectory() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/path/</code></li>
</ul>
<p>在res目录下新建xml目录，然后新建文件file_paths.xml，根据上述内容编写。</p>
<h3 id="获取Content-Uri"><a href="#获取Content-Uri" class="headerlink" title="获取Content Uri"></a>获取Content Uri</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">Uri data;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    data = FileProvider.getUriForFile(mContext, <span class="string">"com.hearing.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋予临时权限"><a href="#赋予临时权限" class="headerlink" title="赋予临时权限"></a>赋予临时权限</h3><p>两种方法：（通常使用第2种）</p>
<ol>
<li>Context.grantUriPermission(package, Uri, mode_flags)</li>
<li>Intent.setFlags()：<code>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);</code></li>
</ol>
<p>Flag意义如下：</p>
<ul>
<li>FLAG_GRANT_READ_URI_PERMISSION：表示读取权限； </li>
<li>FLAG_GRANT_WRITE_URI_PERMISSION：表示写入权限。</li>
</ul>
<h3 id="分享文件URI"><a href="#分享文件URI" class="headerlink" title="分享文件URI"></a>分享文件URI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"shareFile: "</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="string">"com.hearing.fileproviderclient"</span>,</span><br><span class="line">            <span class="string">"com.hearing.fileproviderclient.MainActivity"</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">    Uri data;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        data = FileProvider.getUriForFile(mContext, FILE_PROVIDER_AUTHORITIES, file);</span><br><span class="line">        <span class="comment">// 给目标应用一个临时授权</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">    intent.setData(data);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>安全</p>
<p>  ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据根据需求开放给 其他应用进行增、删、改、查，而不用担心因为直接开放数据库权限而带来的安全问题</p>
</li>
<li><p>访问简单 &amp; 高效</p>
</li>
</ul>
<h1 id="Mime-Type"><a href="#Mime-Type" class="headerlink" title="Mime Type"></a>Mime Type</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>MIME：多用途互联网邮件扩展（Multipurpose Internet Mail Extensions）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。</p>
<p>MIME TYPE一般以这种形式出现：<code>[type]/[subtype]</code></p>
<p>type标识内容type，有下面的形式：</p>
<ul>
<li>Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</li>
<li>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</li>
<li>Application：用于传输应用程序数据或者二进制数据；</li>
<li>Message：用于包装一个E-mail消息；</li>
<li>Image：用于传输静态图片数据；</li>
<li>Audio：用于传输音频或者音声数据；</li>
<li>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。</li>
</ul>
<p>subtype用于指定type的详细形式。<code>content-type/subtype</code>配对的集合和与此相关的参数，将随着时间而增长。为了确保这些值在一个有序而且公开的状态下开发，MIME使用Internet Assigned Numbers Authority (IANA)作为中心的注册机制来管理这些值。常用的subtype值如下所示：</p>
<ul>
<li>text/plain（纯文本）</li>
<li>text/html（HTML文档）</li>
<li>application/xhtml+xml（XHTML文档）</li>
<li>image/gif（GIF图像）</li>
<li>image/jpeg（JPEG图像）</li>
<li>image/png（PNG图像）</li>
<li>video/mpeg（MPEG动画）</li>
<li>application/octet-stream（任意的二进制数据）</li>
<li>application/pdf（PDF文档）</li>
<li>application/msword（Microsoft Word文件）</li>
<li>message/rfc822（RFC 822形式）</li>
<li>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）</li>
<li>application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）</li>
<li>multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>当Android系统接收到一个隐式Intent要启动一个Activity(或其他组件)时，Android会根据以下三个信息比较Intent的信息与注册的组件的intent-filter的信息，从而为该Intent选择出最匹配的Activity(或其他组件)：</p>
<ul>
<li>intent中的action</li>
<li>intent中的category</li>
<li>intent中的data（包含Uri以及data的MIME类型）</li>
</ul>
<p>也就是隐式intent对象要满足要启动的目标组件中注册的intent-filter中的<code>&lt;action/&gt;</code>、<code>&lt;category/&gt;</code>、<code>&lt;data/&gt;</code>三个标签中的信息，即要分别通过action测试、category测试以及data测试。</p>
<p>MINI类型即在data中指定。</p>
<h1 id="Intent和Intent-filter"><a href="#Intent和Intent-filter" class="headerlink" title="Intent和Intent-filter"></a>Intent和Intent-filter</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Intent 是一个消息传递对象，可以用来从其他应用组件请求操作，尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ol>
<li>启动 Activity：通过将 Intent 传递给 startActivity()，可以启动新的 Activity 实例，Intent 用于描述要启动的 Activity，并携带任何必要的数据。</li>
<li>启动 Service：使用 Android 5.0（API 级别 21）及更高版本，可以启动包含 JobScheduler 的服务。对于 Android 5.0（API 级别 21）之前的版本，可以使用 Service 类的方法来启动服务，通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 用于描述要启动的服务，并携带任何必要的数据。如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，可以从其他组件绑定到此服务。</li>
<li>传递 BroadCast：广播是任何应用均可接收的消息，系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播，通过将 Intent 传递给 sendBroadcast() 或 sendOrderedBroadcast()，可以将广播传递给其他应用。</li>
</ol>
<h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><ul>
<li>显式 Intent：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。例如，启动应用内的新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li>隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent-filter进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent-filter匹配，则系统将启动该组件，并向其传递 Intent 对象。如果多个 Intent-filter兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</li>
</ul>
<p>Intent-filter是应用清单文件中的一个表达式，用于指定该组件要接收的 Intent 类型。例如，通过为 Activity 声明 Intent-filter，可以使其他应用能够直接使用某一特定类型的 Intent 启动 Activity。同样，如果您没有为 Activity 声明任何 Intent-filter，则 Activity 只能通过显式 Intent 启动。</p>
<p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent-filter。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p>
<h2 id="构建Intent"><a href="#构建Intent" class="headerlink" title="构建Intent"></a>构建Intent</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>如Component name，Action，Data以及Category，这些属性（组件名称、操作、数据和category）表示 Intent 的既定特征。通过读取这些属性，Android 系统能够解析应当启动哪个应用组件。但是，Intent 也有可能会携带一些不影响其如何解析为应用组件的信息。Intent 还可以提供以下信息：Extras和Flags。</p>
<h4 id="Component-name"><a href="#Component-name" class="headerlink" title="Component name"></a>Component name</h4><p>这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。如果没有组件名称，则 Intent 则为隐式，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和category）决定哪个组件应当接收 Intent。如需在应用中启动特定的组件，则应指定该组件的名称。</p>
<p>启动 Service 时，应始终指定组件名称。否则无法确定哪项服务会响应 Intent，且用户无法看到哪项服务已启动。</p>
<p>Intent 的这一字段是 ComponentName 对象，可以使用目标组件的完全限定类名指定此对象，其中包括应用的软件包名称。例如，com.example.ExampleActivity，可以使用 setComponent()、setClass()、setClassName()，或 Intent 构造函数设置组件名称。</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>指定要执行的通用操作（例如，查看或选取）的字符串。</p>
<p>对于广播 Intent，这是指已发生且正在报告的操作。action会在很大程度上决定其余 Intent 的构成，特别是 data 和 extra 中包含的内容。可以指定自己的操作，供 Intent 在您的应用内使用（或者供其他应用在您的应用中调用组件）。但是，您通常应该使用由Intent 类或其他框架类定义的操作常量。以下是一些用于启动 Activity 的常见操作：</p>
<ol>
<li>ACTION_VIEW：如果您拥有一些某项 Activity 可向用户显示的信息（例如，要使用图库应用查看的照片；或者要使用地图应用查看的地址），请通过 Intent 将此操作与 startActivity() 结合使用。</li>
<li>ACTION_SEND：这也称为共享 Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此操作与 startActivity() 结合使用。</li>
</ol>
<p>可以使用 setAction() 或 Intent 构造函数为 Intent 指定操作。</p>
<p>如以下示例所示，如果定义自己的操作，请确保加入应用的软件包名称作为前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ACTION_TIMETRAVEL = <span class="string">"com.example.action.TIMETRAVEL"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。</p>
<p>创建 Intent 时，除了指定 URI 以外，指定数据类型（MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件。但有时 MIME 类型可以从 URI 中推断得出，特别当数据是 content:URI 时尤其如此。content:URI 表明数据位于设备中，且由 ContentProvider 控制，这使得数据 MIME 类型对系统可见。</p>
<p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，您可以使用 setDataAndType() 同时显式设置二者。</p>
<p>注意：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType() 同时设置 URI 和 MIME 类型。</p>
<h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的Category放入一个 Intent 中，但大多数 Intent 均不需要 Category。以下是一些常见category：</p>
<ul>
<li>CATEGORY_BROWSABLE：目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。</li>
<li>CATEGORY_LAUNCHER：该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</li>
<li>CATEGORY_HOME：桌面应用需要声明。</li>
<li>CATEGORY_DEFAULT：通过隐式启动Activity时，Android会默认加上一个CATEGORY_DEFAULT，所以如果Activity要支持隐式启动的话，除了默认LaunchActivity，其余都需要加上CATEGORY_DEFAULT。</li>
</ul>
<p>可以使用 addCategory() 指定category。</p>
<h4 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h4><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。可以使用各种 putExtra() 方法添加 extra 数据，每种方法均接受两个参数：键名和值。还可以创建一个包含所有 extra 数据的 Bundle 对象，然后使用 putExtras() 将 Bundle 插入 Intent 中。</p>
<p>例如，使用 ACTION_SEND 创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL 键指定目标收件人，并使用 EXTRA_SUBJECT 键指定主题。</p>
<p>Intent 类将为标准化的数据类型指定多个 EXTRA_* 常量。如需声明自己的 extra 键（对于应用接收的 Intent），请确保将应用的软件包名称作为前缀，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_GIGAWATTS = <span class="string">"com.example.EXTRA_GIGAWATTS"</span>;</span><br></pre></td></tr></table></figure>

<p>注意：在发送您希望另一个应用接收的 Intent 时，请勿使用 Parcelable 或 Serializable 数据。如果某个应用尝试访问 Bundle 对象中的数据，但没有对打包或序列化类的访问权限，则系统将提出一个 RuntimeException。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><p>Flags 在 Intent 类中定义，充当 Intent 的元数据。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理（例如，Activity 是否属于最近的 Activity 列表）。</p>
<p>可以使用 setFlags() 方法添加Flags。</p>
<h3 id="显式-Intent-示例"><a href="#显式-Intent-示例" class="headerlink" title="显式 Intent 示例"></a>显式 Intent 示例</h3><p>显式 Intent 是指用于启动某个特定应用组件（例如，应用中的某个特定 Activity 或服务）的 Intent，要创建显式 Intent，需要为 Intent 对象定义组件名称，Intent 的所有其他属性均为可选属性。</p>
<p>例如，如果在应用中构建一个名为 DownloadService、旨在从网页下载文件的服务，则可使用以下代码启动该服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed in an Activity, so 'this' is the Context</span></span><br><span class="line"><span class="comment">// The fileUrl is a string URL, such as "http://www.example.com/image.png"</span></span><br><span class="line">Intent downloadIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DownloadService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">downloadIntent.setData(Uri.parse(fileUrl));</span><br><span class="line">startService(downloadIntent);</span><br></pre></td></tr></table></figure>

<p>Intent(Context, Class) 构造函数分别为应用和组件提供 Context 和 Class 对象。因此，此 Intent 将显式启动该应用中的 DownloadService 类。</p>
<h3 id="隐式-Intent-示例"><a href="#隐式-Intent-示例" class="headerlink" title="隐式 Intent 示例"></a>隐式 Intent 示例</h3><p>隐式 Intent 指定能够在可以执行相应操作的设备上调用任何应用的操作。如果您的应用无法执行该操作而其他应用可以，且您希望用户选取要使用的应用，则使用隐式 Intent 非常有用。例如，如果您希望用户与他人分享您的内容，请使用 ACTION_SEND 操作创建 Intent，并添加指定共享内容的 extra。使用该 Intent 调用 startActivity() 时，用户可以选取分享内容所使用的应用。</p>
<p>注意：用户可能没有任何应用处理您发送到 startActivity() 的隐式 Intent。或者，由于配置文件限制或管理员执行的设置，可能无法访问应用。如果发生这样的情况，调用失败，应用也会崩溃。要验证 Activity 是否会接收 Intent，请对 Intent 对象调用 resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，并且可以安全调用 startActivity()。如果结果为空，不要使用该 Intent。以下示例说明如何验证 Intent 是否解析为 Activity。此示例没有使用 URI，但已声明 Intent 的数据类型，用于指定 extra 携带的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the text message with a string</span></span><br><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</span><br><span class="line">sendIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the intent will resolve to an activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(sendIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 startActivity() 时，系统将检查已安装的所有应用，确定哪些应用能够处理这种 Intent（即：含 ACTION_SEND 操作并携带“text/plain”数据的 Intent）。如果只有一个应用能够处理，则该应用将立即打开并为其提供 Intent。如果多个 Activity 接受 Intent，则系统将显示一个对话框，使用户能够选取要使用的应用。</p>
<h3 id="强制使用应用选择器"><a href="#强制使用应用选择器" class="headerlink" title="强制使用应用选择器"></a>强制使用应用选择器</h3><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。如果用户可能希望每次使用相同的应用执行某项操作（例如，打开网页时，用户往往倾向于仅使用一种网络浏览器），则选择默认选项的功能十分有用。</p>
<p>但是，如果多个应用可以响应 Intent，且用户可能希望每次使用不同的应用，则应采用显式方式显示选择器对话框。选择器对话框会要求用户选择用于操作的应用（用户无法为该操作选择默认应用）。例如，当应用使用 ACTION_SEND 操作执行“共享”时，用户根据目前的状况可能需要使用另一不同的应用，因此应当始终使用选择器对话框。</p>
<p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()，如下例所示。此示例将显示一个对话框，其中有响应传递给 createChooser() 方法的 Intent 的应用列表，并且将提供的文本用作对话框标题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always use string resources for UI text.</span></span><br><span class="line"><span class="comment">// This says something like "Share this photo with"</span></span><br><span class="line">String title = getResources().getString(R.string.chooser_title);</span><br><span class="line"><span class="comment">// Create intent to show the chooser dialog</span></span><br><span class="line">Intent chooser = Intent.createChooser(sendIntent, title);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the original intent will resolve to at least one activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><h3 id="接收隐式-Intent-1"><a href="#接收隐式-Intent-1" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，请在 Manifest 文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent-filter。每个 Intent-filter均根据 Intent 的操作、数据和category指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent-filter之一传递时，系统才会将该 Intent 传递给应用组件。</p>
<p>请注意：显式 Intent 始终会传递给其目标，无论组件声明的 Intent-filter如何均是如此。</p>
<p>应用组件应当为自身可执行的每个独特作业声明单独的filter。例如，图像库应用中的一个 Activity 可能会有两个filter，分别用于查看图像和编辑图像。当 Activity 启动时，将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。</p>
<p>每个 Intent-filter均由应用Manifest文件中的 <code>&lt;intent-filter&gt;</code> 元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code> 元素）中。在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<ul>
<li><code>&lt;action&gt;</code>：在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。</li>
<li><code>&lt;data&gt;</code>：使用一个或多个指定数据 URI（scheme、host、port、path）各个方面和 MIME 类型的属性，声明接受的数据类型。</li>
<li><code>&lt;category&gt;</code>：在 name 属性中，声明接受的 Intent category。该值必须是操作的文本字符串值，而不是类常量。</li>
</ul>
<p>请注意：要接收隐式 Intent，必须将 CATEGORY_DEFAULT category包括在 Intent-filter中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT category的方式处理所有 Intent。如果未在 Intent-filter中声明此category，则隐式 Intent 不会解析为您的 Activity。</p>
<p>例如，以下是一个使用包含 Intent-filter的 Activity 声明，当数据类型为文本时，系统将接收 ACTION_SEND Intent ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您可以创建一个包括多个 <code>&lt;action&gt;</code>、<code>&lt;data&gt;</code> 或 <code>&lt;category&gt;</code> 实例的filtet。创建时，需确定组件能够处理这些filter元素的任何及所有组合。</p>
<p>如需仅以操作、数据和类别类型的特定组合来处理多种 Intent，则需创建多个 Intent-filter。</p>
<p>系统通过将 Intent 与所有这三个元素进行比较，根据filter测试隐式 Intent。隐式 Intent 若要传递给组件，必须通过所有这三项测试。如果 Intent 无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件。但是，由于一个组件可能有多个 Intent-filter，因此未能通过某一组件filter的 Intent 可能会通过另一filter。</p>
<p>注意：使用 Intent-filter时，无法安全地防止其他应用启动组件。尽管 Intent-filter将组件限制为仅响应特定类型的隐式 Intent，但如果开发者确定您的组件名称，则其他应用有可能通过使用显式 Intent 启动您的应用组件。如果必须确保只有您自己的应用才能启动您的某一组件，请勿在您的清单中声明 Intent-filter，将该组件的 exported 属性设置为 “false”。</p>
<p>同样，为了避免无意中运行不同应用的 Service，请始终使用显式 Intent 启动您自己的服务。</p>
<p>请注意：对于所有 Activity，您必须在清单文件中声明 Intent-filter。但是，广播接收器的filter可以通过调用 registerReceiver() 动态注册。这样一来，应用便可仅在应用运行时的某一指定时间段内侦听特定的广播。</p>
<h3 id="filter示例"><a href="#filter示例" class="headerlink" title="filter示例"></a>filter示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity is the main entry, should appear in app launcher --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity handles "SEND" actions with text data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND_MULTIPLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.google.panorama360+jpg"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开：</p>
<ul>
<li>ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。</li>
<li>CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。如果 <code>&lt;activity&gt;</code> 元素未使用 icon 指定图标，则系统将使用 <code>&lt;application&gt;</code> 元素中的图标。</li>
</ul>
<p>这两个元素必须配对使用，Activity 才会显示在应用启动器中。</p>
<p>第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent-filter之一匹配）的另一应用中直接进入 ShareActivity。</p>
<h2 id="使用PendingIntent"><a href="#使用PendingIntent" class="headerlink" title="使用PendingIntent"></a>使用PendingIntent</h2><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p>
<p>PendingIntent 的主要用例包括：</p>
<ul>
<li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用您的应用微件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li>
</ul>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建 PendingIntent。使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent 时，您必须声明所需的组件类型：</p>
<ul>
<li>PendingIntent.getActivity()，适用于启动 Activity 的 Intent。</li>
<li>PendingIntent.getService()，适用于启动 Service 的 Intent。</li>
<li>PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。</li>
</ul>
<p>除非您的应用正在从其他应用中接收待定 Intent，否则上述用于创建 PendingIntent 的方法可能是您所需的唯一 PendingIntent 方法。</p>
<p>每种方法均会提取当前的应用 Context、您要封装的 Intent 以及一个或多个指定应如何使用该 Intent 的标志（例如，是否可以多次使用该 Intent）。</p>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该 Intent 与 Intent-filter进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Action</li>
<li>Data（URI 和数据类型）。</li>
<li>Category</li>
</ul>
<h3 id="Action测试"><a href="#Action测试" class="headerlink" title="Action测试"></a>Action测试</h3><p>要指定接受的 Intent action，Intent-filter既可以不声明任何 <code>&lt;action&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.EDIT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要通过此filter，Intent 中指定的action必须与filter中列出的某一action匹配。</p>
<h3 id="Category测试"><a href="#Category测试" class="headerlink" title="Category测试"></a>Category测试</h3><p>要指定接受的 Intent category，Intent-filter既可以不声明任何 <code>&lt;category&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若要使 Intent 通过category测试，则 Intent 中的每个category均必须与filter中的category匹配。Intent-filter声明的category可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。因此，不含category的 Intent 应当始终会通过此测试，无论filter中声明何种category均是如此。</p>
<p>请注意：Android 会自动将 CATEGORY_DEFAULT category应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent。如需 Activity 接收显示 Intent，则必须将 “android.intent.category.DEFAULT” 的category包括在其 Intent-filter中。</p>
<h3 id="Data测试"><a href="#Data测试" class="headerlink" title="Data测试"></a>Data测试</h3><p>要指定接受的 Intent 数据，Intent-filter既可以不声明任何 <code>&lt;data&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：scheme、host、port 和 path：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>在 <code>&lt;data&gt;</code> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p>
<ul>
<li>如果未指定scheme，则会忽略host。</li>
<li>如果未指定host，则会忽略port。</li>
<li>如果未指定scheme和host，则会忽略path。</li>
</ul>
<p>将 Intent 中的 URI 与filter中的 URI 规范进行比较时，它仅与filter中包含的部分 URI 进行比较。例如：</p>
<ul>
<li>如果filter仅指定scheme，则具有该scheme的所有 URI 均与该filter匹配。</li>
<li>如果filter指定scheme和host，但未指定path，则具有相同scheme和host的所有 URI 都会通过filter，无论其path如何均是如此。</li>
<li>如果filter指定scheme、host和path，则仅具有相同scheme、host和path的 URI 才会通过filter。</li>
</ul>
<p>请注意：path规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。</p>
<p>数据测试会将 Intent 中的 URI 和 MIME 类型与filter中指定的 URI 和 MIME 类型进行比较。规则如下：</p>
<ul>
<li>仅当filter未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与filter的 URI 格式匹配、且filter同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当filter列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与filter中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与filter中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且filter未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果filter只是列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<p>请注意：如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <code>&lt;intent-filter&gt;</code> 中没有 <code>&lt;data&gt;</code> 元素时失败。</p>
<p>最后一条规则反映出对组件能够从文件中或内容提供程序处获得本地数据的预期。因此，其filter只能列出数据类型，不需要显式命名 content: 和 file: scheme。以下是一个典型示例，说明 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从内容提供程序处获得并显示图像数据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于大部分可用数据均由内容提供程序分发，因此指定数据类型（而非 URI）的filter也许最为常见。</p>
<p>另一常见的配置是具有scheme和数据类型的filter。例如，下文中的 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从网络中检索视频数据以执行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent-filter匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。例如，主页应用通过使用指定 ACTION_MAIN action和 CATEGORY_LAUNCHER category的 Intent-filter查找所有 Activity，以此填充应用启动器。如 IntentFilter 类文档所述，只有当 Intent 中的操作和category与filter匹配时，匹配才会成功。</p>
<p>您的应用可以使用类似于主页应用的方式使用 Intent 匹配。PackageManager 提供一整套 query…() 方法来返回所有能够接受特定 Intent 的组件。此外，还会提供一系列类似的 resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities() 将返回能够执行作为参数传递的 Intent 中列出的所有 Activity，而 queryIntentServices() 则可返回类似的一系列服务。这两种方法均不会激活组件；而只是列出能够响应的组件。对于广播接收器，有一种类似的方法：queryBroadcastReceivers()。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">啃碎并发（四）：Java线程Dump分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 10:26:46 / 修改时间：15:33:08" itemprop="dateCreated datePublished" datetime="2020-06-01T10:26:46+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-Thread-Dump介绍"><a href="#1-Thread-Dump介绍" class="headerlink" title="1 Thread Dump介绍"></a>1 Thread Dump介绍</h4><h5 id="1-1-什么是Thread-Dump"><a href="#1-1-什么是Thread-Dump" class="headerlink" title="1.1 什么是Thread Dump"></a>1.1 什么是Thread Dump</h5><p>Thread Dump是非常有用的诊断Java应用问题的工具。<strong>每一个Java虚拟机都有及时生成所有线程在某一点状态的thread-dump的能力，</strong>虽然各个 Java虚拟机打印的thread dump略有不同，但是<strong>大多都提供了当前活动线程的快照，及JVM中所有Java线程的堆栈跟踪信息，堆栈信息一般包含完整的类名及所执行的方法，</strong>如果可能的话还有源代码的行数。</p>
<h5 id="1-2-Thread-Dump特点"><a href="#1-2-Thread-Dump特点" class="headerlink" title="1.2 Thread Dump特点"></a>1.2 Thread Dump特点</h5><blockquote>
<p>1.能在各种操作系统下使用；<br>2.能在各种Java应用服务器下使用；<br>3.能在生产环境下使用而不影响系统的性能；<br>4.能将问题直接定位到应用程序的代码行上；</p>
</blockquote>
<h5 id="1-3-Thread-Dump抓取"><a href="#1-3-Thread-Dump抓取" class="headerlink" title="1.3 Thread Dump抓取"></a>1.3 Thread Dump抓取</h5><p><strong>一般当服务器挂起，崩溃或者性能低下时，</strong>就需要抓取服务器的线程堆栈（Thread Dump）用于后续的分析。在实际运行中，往往一次 dump的信息，还不足以确认问题。为了反映线程状态的动态变化，<strong>需要接连多次做thread dump，每次间隔10-20s，建议至少产生三次 dump信息，</strong>如果每次 dump都指向同一个问题，我们才确定问题的典型性。</p>
<p><strong>1. 操作系统命令获取ThreadDump</strong></p>
<blockquote>
<p>1.ps –ef | grep java<br>2.kill -3 <pid></p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>一定要谨慎, 一步不慎就可能让服务器进程被杀死。kill -9 命令会杀死进程。</p>
</blockquote>
<p><strong>2. JVM 自带的工具获取线程堆栈</strong></p>
<blockquote>
<ol>
<li>jps 或 ps –ef | grep java （获取PID）</li>
<li>jstack [-l ] <pid> | tee -a jstack.log（获取ThreadDump）</li>
</ol>
</blockquote>
<h4 id="2-Thread-Dump分析"><a href="#2-Thread-Dump分析" class="headerlink" title="2 Thread Dump分析"></a>2 Thread Dump分析</h4><h5 id="2-1-Thread-Dump信息"><a href="#2-1-Thread-Dump信息" class="headerlink" title="2.1 Thread Dump信息"></a>2.1 Thread Dump信息</h5><p><strong>1. 头部信息：时间，JVM信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-11-02 19:05:06  </span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (16.3-b01 mixed mode):</span><br></pre></td></tr></table></figure>

<p><strong>2. 线程INFO信息块：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;Timer-0&quot; daemon prio&#x3D;10 tid&#x3D;0xac190c00 nid&#x3D;0xaef in Object.wait() [0xae77d000] </span><br><span class="line"># 线程名称：Timer-0；线程类型：daemon；优先级: 10，默认是5；</span><br><span class="line"># JVM线程id：tid&#x3D;0xac190c00，JVM内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现）。</span><br><span class="line"># 对应系统线程id（NativeThread ID）：nid&#x3D;0xaef，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）</span><br><span class="line"># 线程状态：in Object.wait()；</span><br><span class="line"># 起始栈地址：[0xae77d000]，对象的内存地址，通过JVM内存查看工具，能够看出线程是在哪儿个对象上等待；</span><br><span class="line">2.  java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">3.  at java.lang.Object.wait(Native Method)</span><br><span class="line">4.  -waiting on &lt;0xb3885f60&gt; (a java.util.TaskQueue)     # 继续wait </span><br><span class="line">5.  at java.util.TimerThread.mainLoop(Timer.java:509)</span><br><span class="line">6.  -locked &lt;0xb3885f60&gt; (a java.util.TaskQueue)         # 已经locked</span><br><span class="line">7.  at java.util.TimerThread.run(Timer.java:462)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java thread statck trace：是上面2-7行的信息。到目前为止这是最重要的数据，Java stack trace提供了大部分信息来精确定位问题根源。</p>
</blockquote>
<p><strong>3. Java thread statck trace详解：</strong></p>
<p><strong>堆栈信息应该逆向解读：</strong>程序先执行的是第7行，然后是第6行，依次类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- locked &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br><span class="line">- waiting on &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br></pre></td></tr></table></figure>

<p><strong>也就是说对象先上锁，锁住对象0xb3885f60，然后释放该对象锁，进入waiting状态。</strong>为啥会出现这样的情况呢？看看下面的java代码示例，就会明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;  </span><br><span class="line">   .........  </span><br><span class="line">   obj.wait();  </span><br><span class="line">   .........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，线程的执行过程，先用 synchronized 获得了这个对象的 Monitor（对应于 locked &lt;0xb3885f60&gt; ）。当执行到 obj.wait()，线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on &lt;0xb3885f60&gt; ）。</p>
</blockquote>
<p><strong>在堆栈的第一行信息中，进一步标明了线程在代码级的状态，例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br></pre></td></tr></table></figure>

<p><strong>解释如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|blocked|</span><br><span class="line"></span><br><span class="line">&gt; This thread tried to enter asynchronized block, but the lock was taken by another thread. This thread isblocked until the lock gets released.</span><br><span class="line"></span><br><span class="line">|blocked (on thin lock)|</span><br><span class="line"></span><br><span class="line">&gt; This is the same state asblocked, but the lock in question is a thin lock.</span><br><span class="line"></span><br><span class="line">|waiting|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledObject.wait() on an object. The thread will remain there until some otherthread sends a notification to that object.</span><br><span class="line"></span><br><span class="line">|sleeping|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.lang.Thread.sleep().</span><br><span class="line"></span><br><span class="line">|parked|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.util.concurrent.locks.LockSupport.park().</span><br><span class="line"></span><br><span class="line">|suspended|</span><br><span class="line"></span><br><span class="line">&gt; The thread&#39;s execution wassuspended by java.lang.Thread.suspend() or a JVMTI agent call.</span><br></pre></td></tr></table></figure>

<h5 id="2-2-Thread状态分析"><a href="#2-2-Thread状态分析" class="headerlink" title="2.2 Thread状态分析"></a>2.2 Thread状态分析</h5><p>线程的状态是一个很重要的东西，因此thread dump中会显示这些状态，通过对这些状态的分析，能够得出线程的运行状况，进而发现可能存在的问题。<strong>线程的状态在Thread.State这个枚举类型中定义</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public enum State   </span><br><span class="line">&#123;  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread which has not yet started. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       NEW,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a runnable thread.  A thread in the runnable </span><br><span class="line">        * state is executing in the Java virtual machine but it may </span><br><span class="line">        * be waiting for other resources from the operating system </span><br><span class="line">        * such as processor. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       RUNNABLE,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread blocked waiting for a monitor lock. </span><br><span class="line">        * A thread in the blocked state is waiting for a monitor lock </span><br><span class="line">        * to enter a synchronized block&#x2F;method or  </span><br><span class="line">        * reenter a synchronized block&#x2F;method after calling </span><br><span class="line">        * &#123;@link Object#wait() Object.wait&#125;. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       BLOCKED,  </span><br><span class="line">     </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread. </span><br><span class="line">        * A thread is in the waiting state due to calling one of the  </span><br><span class="line">        * following methods: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *  </span><br><span class="line">        * &lt;p&gt;A thread in the waiting state is waiting for another thread to </span><br><span class="line">        * perform a particular action.   </span><br><span class="line">        * </span><br><span class="line">        * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt; </span><br><span class="line">        * on an object is waiting for another thread to call  </span><br><span class="line">        * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on  </span><br><span class="line">        * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;  </span><br><span class="line">        * is waiting for a specified thread to terminate. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       WAITING,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread with a specified waiting time. </span><br><span class="line">        * A thread is in the timed waiting state due to calling one of  </span><br><span class="line">        * the following methods with a specified positive waiting time: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;  </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TIMED_WAITING,  </span><br><span class="line">  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a terminated thread. </span><br><span class="line">        * The thread has completed execution. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TERMINATED;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. NEW：</strong></p>
<p><strong>每一个线程，在堆内存中都有一个对应的Thread对象。</strong>Thread t = new Thread();当刚刚在堆内存中创建Thread对象，还没有调用t.start()方法之前，线程就处在NEW状态。<strong>在这个状态上，线程与普通的java对象没有什么区别，就仅仅是一个堆内存中的对象。</strong></p>
<p><strong>2. RUNNABLE：</strong></p>
<p><strong>该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。</strong>这个状态的线程比较正常，但如果线程长时间停留在在这个状态就不正常了，这说明线程运行的时间很长（存在性能问题），或者是线程一直得不得执行的机会（存在线程饥饿的问题）。</p>
<p><strong>3. BLOCKED：</strong></p>
<p><strong>线程正在等待获取java对象的监视器(也叫内置锁)，即线程正在等待进入由synchronized保护的方法或者代码块。</strong>synchronized用来保证原子性，任意时刻最多只能由一个线程进入该临界区域，其他线程只能排队等待。</p>
<p><strong>4. WAITING：</strong></p>
<p><strong>处在该线程的状态，正在等待某个事件的发生，只有特定的条件满足，才能获得执行机会。</strong>而产生这个特定的事件，通常都是另一个线程。也就是说，<strong>如果不发生特定的事件，那么处在该状态的线程一直等待，不能获取执行的机会。</strong> 比如：</p>
<blockquote>
<p>1.A线程调用了obj对象的obj.wait()方法，如果没有线程调用obj.notify或obj.notifyAll，那么A线程就没有办法恢复运行；<br>2.如果A线程调用了LockSupport.park()，没有别的线程调用LockSupport.unpark(A)，那么A没有办法恢复运行。</p>
</blockquote>
<p><strong>5. TIMED_WAITING：</strong></p>
<p>J.U.C中很多与线程相关类，都提供了限时版本和不限时版本的API。 <strong>TIMED_WAITING意味着线程调用了限时版本的API，正在等待时间流逝。 **当等待时间过去后，线程一样可以恢复运行。</strong>如果线程进入了WAITING状态，一定要特定的事件发生才能恢复运行；而处在TIMED_WAITING的线程，如果特定的事件发生或者是时间流逝完毕，都会恢复运行。**</p>
<p><strong>6. TERMINATED：</strong></p>
<p><strong>线程执行完毕，执行完run方法正常返回，或者抛出了运行时异常而结束，线程都会停留在这个状态。</strong>这个时候线程只剩下Thread对象了，没有什么用了。</p>
<h5 id="2-3-关键状态分析"><a href="#2-3-关键状态分析" class="headerlink" title="2.3 关键状态分析"></a>2.3 关键状态分析</h5><ol>
<li>Wait on condition：The thread is either sleeping or waiting to be notified by another thread.<br>该状态说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(n)。</li>
</ol>
<p><strong>此时线程状态大致为以下几种：</strong></p>
<blockquote>
<p>1.java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；<br>2.java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p>
</blockquote>
<ol start="2">
<li>Waiting for Monitor Entry 和 in Object.wait()：The thread is waiting to get the lock for an object (some other thread may be holding the lock). This happens if two or more threads try to execute synchronized code. Note that the lock is always for an object and not for individual methods.</li>
</ol>
<p>在多线程的JAVA程序中，实现线程之间的同步，就要说说 Monitor。 *<em>Monitor是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者Class的锁。 *</em>每一个对象都有，也仅有一个 Monitor。下面这个图，描述了线程和 Monitor之间关系，以及线程的状态转换图：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2770d7fd4e31c5fa.png" alt="A Java Monitor And Thread"></p>
<p>如上图，每个Monitor在某个时刻，只能被一个线程拥有，*<em>该线程就是 “ActiveThread”，而其它线程都是 “Waiting Thread”，分别在两个队列“Entry Set”和“Wait Set”里等候。 *</em>在“Entry Set”中等待的线程状态是“Waiting for monitor entry”，而在“Wait Set”中等待的线程状态是“in Object.wait()”。</p>
<p><strong>先看“Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了“Entry Set”队列。</strong>对应的 code就像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;</span><br><span class="line">   .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这时有两种可能性：</strong></p>
<blockquote>
<p>1.该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码。<br>2.该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。</p>
</blockquote>
<p><strong>在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-0&quot; prio&#x3D;10 tid&#x3D;0x08222eb0 nid&#x3D;0x9 waiting for monitor entry [0xf927b000..0xf927bdb8] </span><br><span class="line">at testthread.WaitThread.run(WaitThread.java:39) </span><br><span class="line">- waiting to lock &lt;0xef63bf08&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line">at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p><strong>临界区的设置，是为了保证其内部的代码执行的原子性和完整性。</strong>但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。</p>
<p><strong>再看“Wait Set”里面的线程。</strong>当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll()，“Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;10 tid&#x3D;0x08223250 nid&#x3D;0xa in Object.wait() [0xef47a000..0xef47aa38] </span><br><span class="line"> at java.lang.Object.wait(Native Method) </span><br><span class="line"> - waiting on &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Object.wait(Object.java:474) </span><br><span class="line"> at testthread.MyWaitThread.run(MyWaitThread.java:40) </span><br><span class="line"> - locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p>综上，一般CPU很忙时，则关注runnable的线程，CPU很闲时，则关注waiting for monitor entry的线程。</p>
<ol start="3">
<li>JDK 5.0 的 Lock</li>
</ol>
<p>上面提到如果 synchronized和 monitor机制运用不当，可能会造成多线程程序的性能问题。在 JDK 5.0中，引入了 Lock机制，从而使开发者能更灵活的开发高性能的并发多线程程序，可以替代以往 JDK中的 synchronized和 Monitor的 机制。** 但是，要注意的是，因为 Lock类只是一个普通类，JVM无从得知 Lock对象的占用情况，所以在线程 DUMP中，也不会包含关于 Lock的信息，**关于死锁等问题，就不如用 synchronized的编程方式容易识别。</p>
<h5 id="2-4-关键状态示例"><a href="#2-4-关键状态示例" class="headerlink" title="2.4 关键状态示例"></a>2.4 关键状态示例</h5><p><strong>显示BLOCKED状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class BlockedState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis(); </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取object的线程会执行5分钟，这5分钟内会一直持有object的监视器，另一个线程无法执行处在B</p>
<p><strong>LOCKED状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1314 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7a800 nid&#x3D;0x1350 waiting for monitor entry [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:17)  </span><br><span class="line">     - waiting to lock &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d79400 nid&#x3D;0x1338 runnable [0x282ef000]  </span><br><span class="line"> java.lang.Thread.State: RUNNABLE  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:22)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>通过thread dump可以看到：t2线程确实处在BLOCKED (on object monitor)。waiting for monitor entry 等待进入synchronized保护的区域。</p>
<p><strong>显示WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class WaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        try  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            &#x2F;&#x2F; 进入等待的同时,会进入释放监视器  </span><br><span class="line">                            object.wait();  </span><br><span class="line">                        &#125; catch (InterruptedException e)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1734 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7e000 nid&#x3D;0x17f4 in Object.wait() [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d7d400 nid&#x3D;0x17f0 in Object.wait() [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以发现t1和t2都处在WAITING (on object monitor)，进入等待状态的原因是调用了in Object.wait()。通过J.U.C包下的锁和条件队列，也是这个效果，大家可以自己实践下。</p>
<p><strong>显示TIMED_WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">import java.util.concurrent.TimeUnit;  </span><br><span class="line">import java.util.concurrent.locks.Condition;  </span><br><span class="line">import java.util.concurrent.locks.Lock;  </span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line">public class TimedWaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    &#x2F;&#x2F; java的显示锁,类似java对象内置的监视器  </span><br><span class="line">    private static Lock lock &#x3D; new ReentrantLock();  </span><br><span class="line">    &#x2F;&#x2F; 锁关联的条件队列(类似于object.wait)  </span><br><span class="line">    private static Condition condition &#x3D; lock.newCondition();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                &#x2F;&#x2F; 加锁,进入临界区  </span><br><span class="line">                lock.lock();  </span><br><span class="line">                try  </span><br><span class="line">                &#123;  </span><br><span class="line">                    condition.await(5, TimeUnit.MINUTES);  </span><br><span class="line">                &#125; catch (InterruptedException e)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                &#x2F;&#x2F; 解锁,退出临界区  </span><br><span class="line">                lock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x169c waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7d800 nid&#x3D;0xc30 waiting on condition [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x280d0c00 nid&#x3D;0x16e0 waiting on condition [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以看到t1和t2线程都处在java.lang.Thread.State: TIMED_WAITING (parking)，这个parking代表是调用的JUC下的工具类，而不是java默认的监视器。</p>
<h4 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3 案例分析"></a>3 案例分析</h4><h5 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a>3.1 问题场景</h5><p><strong>1. CPU飙高，load高，响应很慢</strong></p>
<blockquote>
<p>1.一个请求过程中多次dump；<br>2.对比多次dump文件的runnable线程，如果执行的方法有比较大变化，说明比较正常。如果在执行同一个方法，就有一些问题了；</p>
</blockquote>
<p><strong>2. 查找占用CPU最多的线程</strong></p>
<blockquote>
<p>1.使用命令：top -H -p pid（pid为被测系统的进程号），找到导致CPU高的线程ID，对应thread dump信息中线程的nid，只不过一个是十进制，一个是十六进制；<br>2.在thread dump中，根据top命令查找的线程id，查找对应的线程堆栈信息；</p>
</blockquote>
<p><strong>3. CPU使用率不高但是响应很慢</strong></p>
<blockquote>
<p>进行dump，查看是否有很多thread struck在了i/o、数据库等地方，定位瓶颈原因；</p>
</blockquote>
<p><strong>4. 请求无法响应</strong></p>
<blockquote>
<p>多次dump，对比是否所有的runnable线程都一直在执行相同的方法，如果是的，恭喜你，锁住了！</p>
</blockquote>
<h5 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h5><p><strong>死锁经常表现为程序的停顿，或者不再响应用户的请求。</strong>从操作系统上观察，对应进程的CPU占用率为零，很快会从top或prstat的输出中消失。</p>
<p>比如在下面这个示例中，是个较为典型的死锁情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;5 tid&#x3D;0x00acc490 nid&#x3D;0xe50 waiting for monitor entry [0x02d3f000 </span><br><span class="line">..0x02d3fd68] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f18&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot; prio&#x3D;5 tid&#x3D;0x00accdb0 nid&#x3D;0xdec waiting for monitor entry [0x02cff000 </span><br><span class="line">..0x02cff9e8] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f18&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure>

<p>在 JAVA 5中加强了对死锁的检测。线程 Dump中可以直接报告出 Java级别的死锁，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock: </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">&quot;Thread-1&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f334 (object 0x22c19f18, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-0&quot; </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f314 (object 0x22c19f20, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-热锁"><a href="#3-3-热锁" class="headerlink" title="3.3 热锁"></a>3.3 热锁</h5><p>热锁，也往往是导致系统性能瓶颈的主要因素。其表现特征为：由于多个线程对临界区，或者锁的竞争，可能出现：</p>
<blockquote>
<p>1.频繁的线程的上下文切换：从操作系统对线程的调度来看，当线程在等待资源而阻塞的时候，操作系统会将之切换出来，放到等待的队列，当线程获得资源之后，调度算法会将这个线程切换进去，放到执行队列中。<br>2.大量的系统调用：因为线程的上下文切换，以及热锁的竞争，或者临界区的频繁的进出，都可能导致大量的系统调用。<br>3.大部分CPU开销用在“系统态”：线程上下文切换，和系统调用，都会导致 CPU在 “系统态 ”运行，换而言之，虽然系统很忙碌，但是CPU用在 “用户态 ”的比例较小，应用程序得不到充分的 CPU资源。<br>4.随着CPU数目的增多，系统的性能反而下降。因为CPU数目多，同时运行的线程就越多，可能就会造成更频繁的线程上下文切换和系统态的CPU开销，从而导致更糟糕的性能。</p>
</blockquote>
<p>上面的描述，都是一个 scalability（可扩展性）很差的系统的表现。从整体的性能指标看，由于线程热锁的存在，程序的响应时间会变长，吞吐量会降低。</p>
<p>那么，怎么去了解 “热锁 ”出现在什么地方呢？</p>
<blockquote>
<p>一个重要的方法是 结合操作系统的各种工具观察系统资源使用状况，以及收集Java线程的DUMP信息，看线程都阻塞在什么方法上，了解原因，才能找到对应的解决方法。</p>
</blockquote>
<h5 id="4-JVM重要线程"><a href="#4-JVM重要线程" class="headerlink" title="4 JVM重要线程"></a>4 JVM重要线程</h5><p>JVM运行过程中产生的一些比较重要的线程罗列如下：</p>
<table>
<thead>
<tr>
<th>线程名称</th>
<th align="right">所属</th>
<th align="right">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>Attach Listener</td>
<td align="right">JVM</td>
<td align="right">Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并把结果返回给发送者。通常我们会用一些命令去要求JVM给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在JVM启动的时候没有初始化，那么，则会在用户第一次执行JVM命令时，得到启动。</td>
</tr>
<tr>
<td>Signal Dispatcher</td>
<td align="right">JVM</td>
<td align="right">前面提到Attach Listener线程的职责是接收外部JVM命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部JVM命令时，进行初始化工作。</td>
</tr>
<tr>
<td>CompilerThread0</td>
<td align="right">JVM</td>
<td align="right">用来调用JITing，实时编译装卸class 。 通常，JVM会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：CompilerThread1。</td>
</tr>
<tr>
<td>Concurrent Mark-Sweep GC Thread</td>
<td align="right">JVM</td>
<td align="right">并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。ps：启用该垃圾回收器，需要在JVM启动参数中加上：-XX:+UseConcMarkSweepGC。</td>
</tr>
<tr>
<td>DestroyJavaVM</td>
<td align="right">JVM</td>
<td align="right">执行main()的线程，在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程，处于等待状态，等待其它线程（Java线程和Native线程）退出时通知它卸载JVM。每个线程退出时，都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，则通知DestroyJavaVM 线程卸载JVM。</td>
</tr>
<tr>
<td>Finalizer Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：1) 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；2) 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</td>
</tr>
<tr>
<td>Low Memory Detector</td>
<td align="right">JVM</td>
<td align="right">这个线程是负责对可使用内存进行检测，如果发现可用内存低，分配新的内存空间。</td>
</tr>
<tr>
<td>Reference Handler</td>
<td align="right">JVM</td>
<td align="right">JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</td>
</tr>
<tr>
<td>VM Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程就比较牛b了，是JVM里面的线程母体，根据hotspot源码（vmThread.hpp）里面的注释，它是一个单个的对象（最原始的线程）会产生或触发所有其他的线程，这个单个的VM线程是会被其他线程所使用来做一些VM操作（如：清扫垃圾等）。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">啃碎并发（三）：Java线程上下文切换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:37:55" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是<strong>多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</strong></p>
<p>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。<strong>一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。</strong></p>
<p>多线程比多任务更加有挑战。<strong>多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。</strong>这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着<strong>不同的线程能被不同的CPU核得到真正意义的并行执行。</strong></p>
<p>所以，<strong>在多线程、多任务情况下，线程上下文切换是必须的，</strong>然而对于CPU架构设计中的概念，应先熟悉了解，这样会有助于理解线程上下文切换原理。</p>
<h4 id="1-多核、多CPU、超线程、多线程"><a href="#1-多核、多CPU、超线程、多线程" class="headerlink" title="1 多核、多CPU、超线程、多线程"></a>1 多核、多CPU、超线程、多线程</h4><h5 id="1-1-为什么要多核"><a href="#1-1-为什么要多核" class="headerlink" title="1.1 为什么要多核"></a>1.1 为什么要多核</h5><p>先要说的是多核、多CPU、超线程，这三个其实都是CPU架构设计的概念，<strong>一个现代CPU除了处理器核心之外还包括寄存器、L1L2缓存这些存储设备、浮点运算单元、整数运算单元等一些辅助运算设备以及内部总线等。</strong>一个多核的CPU也就是一个CPU上有多个处理器核心，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，<strong>就意味着这个程序的不同线程需要经常在CPU之间的外部总线上通信，同时还要处理不同CPU之间不同缓存导致数据不一致的问题，所以在这种场景下多核单CPU的架构就能发挥很大的优势，通信都在内部总线，共用同一个缓存。</strong></p>
<h5 id="1-2-为什么要多CPU"><a href="#1-2-为什么要多CPU" class="headerlink" title="1.2 为什么要多CPU"></a>1.2 为什么要多CPU</h5><p>前面提了多核的好处，那为什么要多CPU呢？这个其实很容易想到，如果要运行多个程序（进程）的话，假如只有一个CPU的话，就意味着要经常进行进程上下文切换，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，所以 <strong>多个进程就必然要经常进行进程上下文切换，这个代价是很高的。</strong></p>
<h5 id="1-3-为什么要超线程"><a href="#1-3-为什么要超线程" class="headerlink" title="1.3 为什么要超线程"></a>1.3 为什么要超线程</h5><p>超线程这个概念是Intel提出的，<strong>简单来说是在一个CPU上真正的并发两个线程</strong>，听起来似乎不太可能，因为CPU都是分时的啊，其实这里也是分时，<strong>因为前面也提到一个CPU除了处理器核心还有其他设备，一段代码执行过程也不光是只有处理器核心工作，如果两个线程A和B，A正在使用处理器核心，B正在使用缓存或者其他设备，那AB两个线程就可以并发执行，但是如果AB都在访问同一个设备，那就只能等前一个线程执行完后一个线程才能执行。</strong>实现这种并发的原理是<strong>在CPU里加了一个协调辅助核心，</strong>根据Intel提供的数据，这样一个设备会使得设备面积增大5%，但是性能提高15%~30%。</p>
<h5 id="1-4-为什么要多线程"><a href="#1-4-为什么要多线程" class="headerlink" title="1.4 为什么要多线程"></a>1.4 为什么要多线程</h5><p>这个问题也许是面试中问的最多的一个经典问题了，<strong>一个进程里多线程之间可以共享变量，线程间通信开销也较小，可以更好的利用多核CPU的性能，多核CPU上跑多线程程序往往会比单线程更快，</strong>有的时候甚至在单核CPU上多线程程序也会有更好的性能，<strong>因为虽然多线程会有上下文切换和线程创建销毁开销，但是单线程程序会被IO阻塞无法充分利用CPU资源，加上线程的上下文开销较低以及线程池的大量应用，多线程在很多场景下都会有更高的效率。</strong></p>
<h5 id="1-5-线程与进程"><a href="#1-5-线程与进程" class="headerlink" title="1.5 线程与进程"></a>1.5 线程与进程</h5><p><strong>进程是操作系统的管理单位，而线程则是进程的管理单位；</strong>一个进程至少包含一个执行线程。不管是在单线程还是多线程中，每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）。虽然线程寄生在进程中，但与他的进程是不同的概念，并且可以分别处理：<strong>进程是系统分配资源的基本单位，线程是调度CPU的基本单位。</strong></p>
<p>一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，<strong>每条线程并行执行不同的任务。每个线程共享堆空间，拥有自己独立的栈空间。</strong></p>
<blockquote>
<p>1.线程划分尺度小于进程，线程隶属于某个进程；<br>2.进程是CPU、内存等资源占用的基本单位，线程是不能独立占有这些资源的；<br>3.进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信方便；<br>4.进程在执行过程中，包含：固定的入口、执行顺序和出口，而进程的这些过程会被应用程序控制；<br>进程&amp;线程表项</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-926d1b70a1b4cac0.png" alt=""></p>
<h4 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2 上下文切换"></a>2 上下文切换</h4><p>支持多任务处理是CPU设计史上最大的跨越之一。<strong>在计算机中，多任务处理是指同时运行两个或多个程序。</strong>从使用者的角度来看，这看起来并不复杂或者难以实现，但是它确实是计算机设计史上一次大的飞跃。<strong>在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里。</strong>上下文切换就是这样一个过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。</p>
<p>多任务系统往往需要同时执行多道作业。作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者<strong>巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载, 这段过程就叫做上下文切换。</strong>时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-4c5c5e8b4fd1e2c0.png" alt="任务的状态保存及再加载, 这段过程就叫做上下文切换"></p>
<h5 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p>上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程或线程切换到另一个进程或线程。</p>
<blockquote>
<p>1.进程（有时候也称做任务）是指一个程序运行的实例。<br>2.在Linux系统中，<strong>线程</strong>就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的 轻量级的进程。<br>3.<strong>上下文</strong>是指某一时间点 CPU 寄存器和程序计数器的内容。<br>4.<strong>寄存器</strong>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。<strong>寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</strong><br>5.<strong>程序计数器是一个专用的寄存器，</strong>用于表明指令序列中 CPU 正在执行的位置，<strong>存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</strong></p>
</blockquote>
<p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：</p>
<blockquote>
<p>1.挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处；<br>2.恢复一个进程，在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复；<br>3.跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</p>
</blockquote>
<h5 id="2-2-切换种类"><a href="#2-2-切换种类" class="headerlink" title="2.2 切换种类"></a>2.2 切换种类</h5><p>上下文切换在不同的场合有不同的含义，在下表中列出：</p>
<table>
<thead>
<tr>
<th>上下文切换种类</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>线程切换</td>
<td align="right">同一进程中的两个线程之间的切换</td>
</tr>
<tr>
<td>进程切换</td>
<td align="right">两个进程之间的切换</td>
</tr>
<tr>
<td>模式切换</td>
<td align="right">在给定线程中，用户模式和内核模式的切换</td>
</tr>
<tr>
<td>地址空间切换</td>
<td align="right">将虚拟内存切换到物理内存</td>
</tr>
</tbody></table>
<h5 id="2-3-切换步骤"><a href="#2-3-切换步骤" class="headerlink" title="2.3 切换步骤"></a>2.3 切换步骤</h5><p>在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。<strong>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB, process control block）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</strong></p>
<p><strong>PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，</strong>它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。</p>
<blockquote>
<p>1.保存进程A的状态（寄存器和操作系统数据）；<br>2.更新PCB中的信息，对进程A的“运行态”做出相应更改；<br>3.将进程A的PCB放入相关状态的队列；<br>4.将进程B的PCB信息改为“运行态”，并执行进程B；<br>5.B执行完后，从队列中取出进程A的PCB，恢复进程A被切换时的上下文，继续执行A；</p>
</blockquote>
<p>线程切换和进程切换的步骤也不同。进程的上下文切换分为两步：</p>
<blockquote>
<p>1.切换页目录以使用新的地址空间；<br>2.切换内核栈和硬件上下文；</p>
</blockquote>
<p>对于Linux来说，线程和进程的最大区别就在于地址空间。<strong>对于线程切换，第1步是不需要做的，</strong>第2是进程和线程切换都要做的。所以明显是进程切换代价大。线程上下文切换和进程上下文切换一个最主要的区别是<strong>线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。</strong>这两种上下文切换的处理都是<strong>通过操作系统内核来完成的。</strong>内核的这种切换过程伴随的 最显著的性能损耗是将寄存器中的内容切换出。</p>
<p>对于一个正在执行的进程包括<strong>程序计数器、寄存器、变量的当前值等 ，</strong>而这些数据都是 <strong>保存在CPU的寄存器中的，</strong>且这些寄存器只能是正在使用CPU的进程才能享用，在进程切换时，首先得保存上一个进程的这些数据（便于下次获得CPU的使用权时从上次的中断处开始继续顺序执行，而不是返回到进程开始，否则每次进程重新获得CPU时所处理的任务都是上一次的重复，可能永远也到不了进程的结束出，因为一个进程几乎不可能执行完所有任务后才释放CPU），然后将本次获得CPU的进程的这些数据装入CPU的寄存器从上次断点处继续执行剩下的任务。</p>
<p><strong>操作系统为了便于管理系统内部进程，为每个进程创建了一张进程表项：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-e2afee842676828d.png" alt="进程表项"></p>
<h5 id="2-4-切换查看"><a href="#2-4-切换查看" class="headerlink" title="2.4 切换查看"></a>2.4 切换查看</h5><p>在Linux系统下可以使用vmstat命令来查看上下文切换的次数，下面是利用vmstat查看上下文切换次数的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-73c88cc6c86895f3.png" alt="上线文切换查看"></p>
<blockquote>
<p>vmstat 1指每秒统计一次, 其中cs列就是指上下文切换的数目. 一般情况下, 空闲系统的上下文切换每秒大概在1500以下.</p>
</blockquote>
<h5 id="3-切换原因"><a href="#3-切换原因" class="headerlink" title="3 切换原因"></a>3 切换原因</h5><p>引起线程上下文切换的原因，主要存在三种情况如下：</p>
<blockquote>
<p>1.中断处理：在中断处理中，其他程序”打断”了当前正在运行的程序。当CPU接收到中断请求时，会在正在运行的程序和发起中断请求的程序之间进行一次上下文切换。中断分为硬件中断和软件中断，软件中断包括因为IO阻塞、未抢到资源或者用户代码等原因，线程被挂起。<br>2.多任务处理：在多任务处理中，CPU会在不同程序之间来回切换，每个程序都有相应的处理时间片，CPU在两个时间片的间隔中进行上下文切换。<br>3.用户态切换：对于一些操作系统，当进行用户态切换时也会进行一次上下文切换，虽然这不是必须的。</p>
</blockquote>
<p>对于我们经常 使用的抢占式操作系统 而言，引起线程上下文切换的原因大概有以下几种：</p>
<blockquote>
<p>1.当前执行任务的时间片用完之后，系统CPU正常调度下一个任务；<br>2.当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务；<br>3.多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；<br>4.用户代码挂起当前任务，让出CPU时间；<br>5.硬件中断；</p>
</blockquote>
<h5 id="4-切换损耗"><a href="#4-切换损耗" class="headerlink" title="4 切换损耗"></a>4 切换损耗</h5><p>上下文切换会带来 直接和间接 两种因素影响程序性能的消耗。</p>
<blockquote>
<p>1.直接消耗：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉；<br>2.间接消耗：指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小；</p>
</blockquote>
<h5 id="5-减少切换"><a href="#5-减少切换" class="headerlink" title="5 减少切换"></a>5 减少切换</h5><p>既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。但上下文切换又分为2种：</p>
<blockquote>
<p>1.让步式上下文切换：指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；<br>2.抢占式上下文切换：指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。</p>
</blockquote>
<p>所以，减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p>
<blockquote>
<p>1.无锁并发：多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据；<br>2.CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；<br>3.最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；<br>4.使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；</p>
</blockquote>
<h5 id="6-线程数目"><a href="#6-线程数目" class="headerlink" title="6 线程数目"></a>6 线程数目</h5><p>合理设置线程数目，<strong>关键点是：1. 尽量减少线程切换和管理的开支；2. 最大化利用CPU；</strong></p>
<blockquote>
<p>1.对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支；</p>
<p>对于2，要求尽量多的线程，以保证CPU资源最大化的利用；</p>
</blockquote>
<p>所以<strong>对于任务耗时短的情况，要求线程尽量少，</strong>如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；</p>
<p><strong>对于耗时长的任务，要分是CPU任务，还是IO等类型的任务。</strong>如果是CPU类型的任务，线程数不宜太多；但是如果是IO类型的任务，线程多一些更好，可以更充分利用CPU。</p>
<p><strong>高并发，低耗时的情况：</strong>建议少线程，只要满足并发即可，因为上下文切换本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片，反而会增加线程切换的开销；例如并发100，线程池可能设置为10就可以；</p>
<p><strong>低并发，高耗时的情况：</strong>建议多线程，保证有空闲线程，接受新的任务；例如并发10，线程池可能就要设置为20；</p>
<p><strong>高并发高耗时</strong>：1. 要分析任务类型；2. 增加排队；3. 加大线程数；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">啃碎并发（二）：Java线程的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:37:55" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是 线程状态也会多次在运行、阻塞之间切换。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-bf153c2ed5c95f66.png" alt=""></p>
<h6 id="1-新建（New）状态"><a href="#1-新建（New）状态" class="headerlink" title="1 新建（New）状态"></a>1 新建（New）状态</h6><p>当程序使用new关键字创建了一个线程之后，该线程就处于<strong>新建状态</strong>，此时的线程情况如下：</p>
<blockquote>
<p><strong>1.此时JVM为其分配内存，并初始化其成员变量的值；<br>2.此时线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体；</strong></p>
</blockquote>
<h6 id="2-就绪（Runnable）状态"><a href="#2-就绪（Runnable）状态" class="headerlink" title="2 就绪（Runnable）状态"></a>2 就绪（Runnable）状态</h6><p>当线程对象调用了start()方法之后，该线程处于<strong>就绪状态</strong>。此时的线程情况如下：</p>
<blockquote>
<p>1.此时JVM会为其<strong>创建方法调用栈和程序计数器；</strong><br>2.该状态的线程一直处于<strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；<br>3.此时线程<strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</p>
</blockquote>
<p>调用start()方法与run()方法，对比如下：</p>
<blockquote>
<p>1.调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体；<br>2.需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常；</p>
</blockquote>
<p>如何让子线程调用start()方法之后立即执行而非”等待执行”：</p>
<blockquote>
<p>程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行；</p>
</blockquote>
<h6 id="3-运行（Running）状态"><a href="#3-运行（Running）状态" class="headerlink" title="3 运行（Running）状态"></a>3 运行（Running）状态</h6><p>当CPU开始调度处于<strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 运行状态。</p>
<blockquote>
<p><strong>1.如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；<br>2.如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；<br>3.当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</strong></p>
</blockquote>
<p>处于运行状态的线程最为复杂，它 不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。线程状态可能会变为 阻塞状态、就绪状态和死亡状态。比如：</p>
<blockquote>
<p><strong>1.对于采用 抢占式策略 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 从运行状态变为就绪状态，重新等待系统分配资源；<br>2.对于采用 协作式策略的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—也就是必须由该线程主动放弃所占用的资源，线程就会又 从运行状态变为就绪状态。</strong></p>
</blockquote>
<h5 id="4-阻塞（Blocked）状态"><a href="#4-阻塞（Blocked）状态" class="headerlink" title="4 阻塞（Blocked）状态"></a>4 阻塞（Blocked）状态</h5><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入<strong>阻塞状态</strong>。</p>
<p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p>
<blockquote>
<p><strong>1.线程调用sleep()方法，主动放弃所占用的处理器资源，暂时进入中断状态（不会释放持有的对象锁），时间到后等待系统分配CPU继续执行；<br>2.线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；<br>3.线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有;<br>4.程序调用了线程的suspend方法将线程挂起；<br>5.线程调用wait，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</strong></p>
</blockquote>
<p>阻塞状态分类：</p>
<blockquote>
<p><strong>1.等待阻塞：运行状态中的 线程执行wait()方法，使本线程进入到等待阻塞状态；<br>同步阻塞：线程在 获取synchronized同步锁失败（因为锁被其它线程占用），它会进入到同步阻塞状态；<br>其他阻塞：通过调用线程的 sleep()或join()或发出I/O请求 时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕 时，线程重新转入就绪状态；<br>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。</strong></p>
</blockquote>
<blockquote>
<p>但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。</p>
</blockquote>
<h5 id="4-1-等待（WAITING）状态"><a href="#4-1-等待（WAITING）状态" class="headerlink" title="4.1 等待（WAITING）状态"></a>4.1 等待（WAITING）状态</h5><p>线程处于 无限制等待状态，等待一个特殊的事件来重新唤醒，如：</p>
<blockquote>
<p><strong>1.通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；<br>2.通过join()方法进行等待的线程等待目标线程运行结束而唤醒；<br>以上两种一旦通过相关事件唤醒线程，线程就进入了 就绪（RUNNABLE）状态 继续运行。</strong></p>
</blockquote>
<h5 id="4-2-时限等待（TIMED-WAITING）状态"><a href="#4-2-时限等待（TIMED-WAITING）状态" class="headerlink" title="4.2 时限等待（TIMED_WAITING）状态"></a>4.2 时限等待（TIMED_WAITING）状态</h5><p>线程进入了一个 时限等待状态，如：</p>
<blockquote>
<p>sleep(3000)，等待3秒后线程重新进行 就绪（RUNNABLE）状态 继续运行。</p>
</blockquote>
<h5 id="5-死亡（Dead）状态"><a href="#5-死亡（Dead）状态" class="headerlink" title="5 死亡（Dead）状态"></a>5 死亡（Dead）状态</h5><p>线程会以如下3种方式结束，结束后就处于 死亡状态：</p>
<blockquote>
<p><strong>1.run()或call()方法执行完成，线程正常结束；<br>2.线程抛出一个未捕获的Exception或Error；<br>3.直接调用该线程stop()方法来结束该线程—该方法容易导致死锁，通常不推荐使用；</strong></p>
</blockquote>
<p>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。**</p>
<p>所以，需要注意的是：</p>
<blockquote>
<p>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态。</p>
</blockquote>
<h5 id="5-1-终止（TERMINATED）状态"><a href="#5-1-终止（TERMINATED）状态" class="headerlink" title="5.1 终止（TERMINATED）状态"></a>5.1 终止（TERMINATED）状态</h5><p>线程执行完毕后，进入终止（TERMINATED）状态。</p>
<h5 id="6-线程相关方法"><a href="#6-线程相关方法" class="headerlink" title="6 线程相关方法"></a>6 线程相关方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Thread&#123;</span><br><span class="line">    &#x2F;&#x2F; 线程的启动</span><br><span class="line">    public void start(); </span><br><span class="line">    &#x2F;&#x2F; 线程体</span><br><span class="line">    public void run(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void stop(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void resume(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void suspend(); </span><br><span class="line">    &#x2F;&#x2F; 在指定的毫秒数内让当前正在执行的线程休眠</span><br><span class="line">    public static void sleep(long millis); </span><br><span class="line">    &#x2F;&#x2F; 同上，增加了纳秒参数</span><br><span class="line">    public static void sleep(long millis, int nanos); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否处于活动状态</span><br><span class="line">    public boolean isAlive(); </span><br><span class="line">    &#x2F;&#x2F; 中断线程</span><br><span class="line">    public void interrupt(); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否已经中断</span><br><span class="line">    public boolean isInterrupted(); </span><br><span class="line">    &#x2F;&#x2F; 测试当前线程是否已经中断</span><br><span class="line">    public static boolean interrupted(); </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止</span><br><span class="line">    public void join() throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒</span><br><span class="line">    public void join(long millis) throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</span><br><span class="line">    public void join(long millis, int nanos) throws InterruptedException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/2062729-3220c4bc58f5448b.png" alt=""></p>
<h5 id="6-1-线程就绪、运行和死亡状态转换"><a href="#6-1-线程就绪、运行和死亡状态转换" class="headerlink" title="6.1 线程就绪、运行和死亡状态转换"></a>6.1 线程就绪、运行和死亡状态转换</h5><p>1.就绪状态转换为运行状态：此线程得到CPU资源；<br>2.运行状态转换为就绪状态：此线程主动调用yield()方法或在运行过程中失去CPU资源。<br>3.运行状态转换为死亡状态：此线程执行执行完毕或者发生了异常；</p>
<p><strong>注意：</strong></p>
<blockquote>
<p><strong>当调用线程中的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的那个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</strong></p>
</blockquote>
<h5 id="6-2-run-amp-start"><a href="#6-2-run-amp-start" class="headerlink" title="6.2 run &amp; start"></a>6.2 run &amp; start</h5><p>通过调用start启动线程，线程执行时会执行run方法中的代码。</p>
<blockquote>
<p><strong>1.start()：线程的启动；<br>2.run()：线程的执行体；</strong></p>
</blockquote>
<h6 id="6-3-sleep-amp-yield"><a href="#6-3-sleep-amp-yield" class="headerlink" title="6.3 sleep &amp; yield"></a>6.3 sleep &amp; yield</h6><p>sleep()：通过sleep(millis)使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<p><strong>比如，我们想要使主线程每休眠100毫秒，然后再打印出数字：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意如下几点问题：</strong></p>
<p><strong>sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。</strong>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread&#x3D;new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        &#x2F;&#x2F; 这里sleep的就是main线程，而非myThread线程 </span><br><span class="line">        myThread.sleep(1000); </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName()+&quot;线程&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(50);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看某一次的运行结果：可以发现，线程0首先执行，然后线程1执行一次，又了执行一次。发现并不是按照sleep的顺序执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0线程0次执行！  </span><br><span class="line">Thread-1线程0次执行！  </span><br><span class="line">Thread-1线程1次执行！  </span><br><span class="line">Thread-0线程1次执行！  </span><br><span class="line">Thread-0线程2次执行！  </span><br><span class="line">Thread-1线程2次执行！</span><br></pre></td></tr></table></figure>

<p><strong>yield()</strong>：与sleep类似，也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。</p>
<blockquote>
<p><strong>实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于sleep()方法和yield()方的区别如下：</strong></p>
<blockquote>
<p><strong>sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态；<br>sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常；<br>sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行；</strong></p>
</blockquote>
<h5 id="6-4-join"><a href="#6-4-join" class="headerlink" title="6.4 join"></a>6.4 join</h5><p>线程的合并的含义就是 将几个并行线程的线程合并为一个单线程执行，应用场景是 当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。</p>
<p>join有3个重载的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void join()</span><br><span class="line">当前线程等该加入该线程后面，等待该线程终止。    </span><br><span class="line">void join(long millis)    </span><br><span class="line">当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   </span><br><span class="line">void join(long millis,int nanos)    </span><br><span class="line">等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span><br></pre></td></tr></table></figure>

<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在主线程中调用thread.join(); 就是将主线程加入到thread子线程后面等待执行。不过有时间限制，为1毫秒。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread t&#x3D;new MyThread();  </span><br><span class="line">        t.start();  </span><br><span class="line">        t.join(1);&#x2F;&#x2F;将主线程加入到子线程后面，不过如果子线程在1毫秒时间内没执行完，则主线程便不再等待它执行完，进入就绪状态，等待cpu调度  </span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++)&#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在JDK中join方法的源码，如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)    throws InterruptedException &#123;  </span><br><span class="line">    long base &#x3D; System.currentTimeMillis();  </span><br><span class="line">    long now &#x3D; 0;  </span><br><span class="line">  </span><br><span class="line">    if (millis &lt; 0) &#123;  </span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">          </span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">           wait(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">            long delay &#x3D; millis - now;  </span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            wait(delay);  </span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>join方法实现是通过调用wait方法实现。当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁)，调用该对象的wait(等待时间)，直到该对象唤醒main线程，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。</strong></p>
</blockquote>
<h5 id="6-5-suspend-amp-resume-已过时"><a href="#6-5-suspend-amp-resume-已过时" class="headerlink" title="6.5 suspend &amp; resume (已过时)"></a>6.5 suspend &amp; resume (已过时)</h5><p>suspend-线程进入阻塞状态，但不会释放锁。此方法已不推荐使用，因为同步时不会释放锁，会造成死锁的问题。</p>
<p>resume-使线程重新进入可执行状态。</p>
<p>为什么<strong>Thread.suspend **和</strong>Thread.resume**被废弃了？</p>
<blockquote>
<p><strong>Thread.suspend 天生容易引起死锁。如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了。这种死锁一般自身表现为“冻结（ frozen ）”进程。</strong></p>
</blockquote>
<h5 id="6-6-stop（已过时）"><a href="#6-6-stop（已过时）" class="headerlink" title="6.6 stop（已过时）"></a>6.6 stop（已过时）</h5><p>不推荐使用，且以后可能去除，因为它不安全。为什么 Thread.stop 被废弃了？</p>
<p>因为其天生是不安全的。停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。这种对象被称为受损的 （damaged）。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。</p>
<p>不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。</p>
<h5 id="6-7-wait-amp-notify-notifyAll"><a href="#6-7-wait-amp-notify-notifyAll" class="headerlink" title="6.7 wait &amp; notify/notifyAll"></a>6.7 wait &amp; notify/notifyAll</h5><p>*<em>wait &amp; notify/notifyAll *</em>这三个都是Object类的方法。使用 wait ，notify 和 notifyAll 前提是先获得调用对象的锁。</p>
<blockquote>
<p><strong>1.调用 wait 方法后，释放持有的对象锁，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列；<br>2.调用notify 或者 notifyAll 方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回；<br>3.notify 方法：将等待队列的一个等待线程从等待队列种移到同步队列中 ，而 notifyAll 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked。</strong></p>
</blockquote>
<p>前面一直提到两个概念，等待队列（等待池），同步队列（锁池），这两者是不一样的。具体如下：</p>
<blockquote>
<p><strong>1. 同步队列（锁池）：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked。<br>2.等待队列（等待池）：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么 仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）。</strong></p>
</blockquote>
<p><strong>被notify或notifyAll唤起的线程是有规律的，具体如下：</strong></p>
<blockquote>
<p><strong>1.如果是通过notify来唤起的线程，那 先进入wait的线程会先被唤起来；<br>2. 如果是通过nootifyAll唤起的线程，默认情况是 最后进入的会先被唤起来，即LIFO的策略；</strong></p>
</blockquote>
<h5 id="6-8-线程优先级"><a href="#6-8-线程优先级" class="headerlink" title="6.8 线程优先级"></a>6.8 线程优先级</h5><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p>
<blockquote>
<p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级；</p>
</blockquote>
<p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   &#x3D;10</span><br><span class="line">MIN_PRIORITY   &#x3D;1</span><br><span class="line">NORM_PRIORITY   &#x3D;5</span><br></pre></td></tr></table></figure>
<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name,int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F;设置线程的名称  </span><br><span class="line">        setPriority(pro);&#x2F;&#x2F;设置线程的优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从执行结果可以看到 ，一般情况下，高级线程更显执行完毕。</p>
<p><strong>注意一点：</strong></p>
<blockquote>
<p>虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>
<h5 id="6-9-守护线程"><a href="#6-9-守护线程" class="headerlink" title="6.9 守护线程"></a>6.9 守护线程</h5><p>守护线程与普通线程写法上基本没啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</p>
<p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</p>
<p>setDaemon方法详细说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line"></span><br><span class="line">该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">on - 如果为 true，则将该线程标记为守护线程。</span><br><span class="line">抛出：</span><br><span class="line">IllegalThreadStateException - 如果该线程处于活动状态。</span><br><span class="line">SecurityException - 如果当前线程无法修改该线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">* Java线程：线程的调度-守护线程 </span><br><span class="line">*&#x2F;  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">        public static void main(String[] args) &#123;  </span><br><span class="line">                Thread t1 &#x3D; new MyCommon();  </span><br><span class="line">                Thread t2 &#x3D; new Thread(new MyDaemon());  </span><br><span class="line">                t2.setDaemon(true);        &#x2F;&#x2F;设置为守护线程  </span><br><span class="line">  </span><br><span class="line">                t2.start();  </span><br><span class="line">                t1.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyCommon extends Thread &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;线程1第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyDaemon implements Runnable &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (long i &#x3D; 0; i &lt; 9999999L; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;后台线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">后台线程第0次执行！  </span><br><span class="line">线程1第0次执行！  </span><br><span class="line">线程1第1次执行！  </span><br><span class="line">后台线程第1次执行！  </span><br><span class="line">后台线程第2次执行！  </span><br><span class="line">线程1第2次执行！  </span><br><span class="line">线程1第3次执行！  </span><br><span class="line">后台线程第3次执行！  </span><br><span class="line">线程1第4次执行！  </span><br><span class="line">后台线程第4次执行！  </span><br><span class="line">后台线程第5次执行！  </span><br><span class="line">后台线程第6次执行！  </span><br><span class="line">后台线程第7次执行！</span><br></pre></td></tr></table></figure>
<p>从上面的执行结果可以看出：前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。</p>
<blockquote>
<p>实际上：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。</p>
</blockquote>
<h5 id="6-10-如何结束一个线程"><a href="#6-10-如何结束一个线程" class="headerlink" title="6.10 如何结束一个线程"></a>6.10 如何结束一个线程</h5><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。</p>
<blockquote>
<p>1.正常执行完run方法，然后结束掉；<br>2.控制循环条件和判断条件的标识符来结束掉线程；</p>
</blockquote>
<p>比如run方法这样写：只要保证在一定的情况下，run方法能够执行完毕即可。而不是while(true)的无限循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                break;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    boolean next&#x3D;true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                next&#x3D;false;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                return;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>诚然，使用上面方法的标识符来结束一个线程，是一个不错的方法，但其也有弊端，如果 该线程是处于sleep、wait、join的状态时候，while循环就不会执行，那么我们的标识符就无用武之地了，当然也不能再通过它来结束处于这3种状态的线程了。</p>
<p>所以，此时可以使用interrupt这个巧妙的方式结束掉这个线程。我们先来看看sleep、wait、join方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException </span><br><span class="line">public static native void sleep(long millis) throws InterruptedException</span><br><span class="line">public final void join() throws InterruptedException</span><br></pre></td></tr></table></figure>
<p>可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。在什么时候会产生这样一个异常呢？</p>
<blockquote>
<p>每个Thread都有一个中断状状态，默认为false。可以通过Thread对象的isInterrupted()方法来判断该线程的中断状态。可以通过Thread对象的interrupt()方法将中断状态设置为true。</p>
<p>当一个线程处于sleep、wait、join这三种状态之一的时候，如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常，并将中断状态重新设置为false。</p>
</blockquote>
<p>看下面的简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;1;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            System.out.println(this.isInterrupted());  </span><br><span class="line">            try &#123;  </span><br><span class="line">                System.out.println(&quot;我马上去sleep了&quot;);  </span><br><span class="line">                Thread.sleep(2000);  </span><br><span class="line">                this.interrupt();  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;异常捕获了&quot;+this.isInterrupted());  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">false  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">2  </span><br><span class="line">true  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">异常捕获了false</span><br></pre></td></tr></table></figure>

<p>可以看到，首先执行第一次while循环，在第一次循环中，睡眠2秒，然后将中断状态设置为true。当进入到第二次循环的时候，中断状态就是第一次设置的true，当它再次进入sleep的时候，马上就抛出了InterruptedException异常，然后被我们捕获了。然后中断状态又被重新自动设置为false了（从最后一条输出可以看出来）。</p>
<p>所以，我们可以使用interrupt方法结束一个线程。具体使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">        Thread.sleep(3000);  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(1000);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;中断异常被捕获了&quot;);  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多测试几次，会发现一般有两种执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">3  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>这两种结果恰恰说明了，只要一个线程的中断状态一旦为true，只要它进入sleep等状态，或者处于sleep状态，立马回抛出InterruptedException异常。</p>
<blockquote>
<p><strong>第一种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程正处于sleep状态，立马抛出InterruptedException异常。</p>
<p><strong>第二种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程还没有处于sleep状态。然后再第3次while循环的时候，在此进入sleep状态，立马抛出InterruptedException异常。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">啃碎并发（一）：Java线程总述与概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 21:14:46 / 修改时间：21:23:46" itemprop="dateCreated datePublished" datetime="2020-05-31T21:14:46+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h4><p>在JDK5之前，Java多线程以及其性能一直是个软肋，只有synchronized、Thread.sleep()、Object.wait/notify这样有限的方法，而synchronized的效率还特别地低，开销比较大。</p>
<p>在JDK5之后，相对于前面版本有了重大改进，不仅在Java语法上有了很多改进，包括：泛型、装箱、for循环、变参等，在多线程上也有了彻底提高，其引进了并发编程大师Doug Lea的java.util.concurrent包(后面简称J.U.C)，支持了现代CPU的CAS原语，不仅在性能上有了很大提升，在自由度上也有了更多的选择，此时 J.U.C的效率在高并发环境下的效率远优于synchronized。</p>
<p>在JDK6（Mustang 野马）中，对synchronized的内在机制做了大量显著的优化，加入了CAS的概念以及偏向锁、轻量级锁，使得synchronized的效率与J.U.C不相上下，并且官方说后面该关键字还有继续优化的空间，所以在现 在JDK7时代，synchronized已经成为一般情况下的首选，在某些特殊场景：可中断的锁、条件锁、等待获得锁一段时间如果失败则停止，J.U.C是适用的，所以对于 多线程研究来说，了解其原理以及各自的适用场景是必要的。</p>
<h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2 基本概念"></a>2 基本概念</h4><h5 id="2-1-线程"><a href="#2-1-线程" class="headerlink" title="2.1 线程"></a>2.1 线程</h5><p>线程是依附于进程的，进程是分配资源的最小单位，一个进程可以生成多个线程，这些线程拥有共享的进程资源。就每个线程而言，只有很少的独有资源，如：控制线程运行的线程控制块，保留局部变量和少数参数的栈空间等。线程有就绪、阻塞和运行三种状态，并可以在这之间切换。也正因为多个线程会共享进程资源，所以当它们对同一个共享变量/对象进行操作的时候，线程的冲突和不一致性就产生了。</p>
<p>多线程并发环境下，本质上要解决地是这两个问题：</p>
<blockquote>
<ol>
<li>线程之间如何通信；</li>
<li>线程之间如何同步；</li>
</ol>
</blockquote>
<p>概括起来说就是：线程之间如何正确地通信。虽然说的是在Java层面如何保证，但会涉及到 Java虚拟机、Java内存模型，以及Java这样的高级语言最终是要映射到CPU来执行（关键原因：如今的CPU有缓存、并且是多核的），虽然有些难懂，但对于深刻把握多线程是至关重要的，所以需要多花一些时间。</p>
<h5 id="2-2-锁"><a href="#2-2-锁" class="headerlink" title="2.2 锁"></a>2.2 锁</h5><p>当多个线程对同一个共享变量/对象进行操作，即使是最简单的操作，如：i++，在处理上实际也涉及到读取、自增、赋值这三个操作，也就是说 这中间存在时间差，导致多个线程没有按照如程序编写者所设想的去顺序执行，出现错位，从而导致最终结果与预期不一致。</p>
<p>Java中的多线程同步是通过锁的概念来体现。锁不是一个对象、不是一个具体的东西，而是一种机制的名称。锁机制需要保证如下两种特性：</p>
<blockquote>
<p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性；<br>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致；</p>
</blockquote>
<h5 id="2-3-挂起、休眠、阻塞与非阻塞"><a href="#2-3-挂起、休眠、阻塞与非阻塞" class="headerlink" title="2.3 挂起、休眠、阻塞与非阻塞"></a>2.3 挂起、休眠、阻塞与非阻塞</h5><p>挂起（Suspend）：当线程被挂起的时候，其会失去CPU的使用时间，直到被其他线程（用户线程或调度线程）唤醒。</p>
<p>休眠（Sleep）：同样是会失去CPU的使用时间，但是在过了指定的休眠时间之后，它会自动激活，无需唤醒（整个唤醒表面看是自动的，但实际上也得有守护线程去唤醒，只是不需编程者手动干预）。</p>
<p>阻塞（Block）：在线程执行时，所需要的资源不能得到，则线程被挂起，直到满足可操作的条件。</p>
<p>非阻塞(Block)：在线程执行时，所需要的资源不能得到，则线程不是被挂起等待，而是继续执行其余事情，待条件满足了之后，收到了通知（同样是守护线程去做）再执行。</p>
<p>挂起和休眠是独立的操作系统的概念，而阻塞与非阻塞则是在资源不能得到时的两种处理方式，不限于操作系统，当资源申请不到时，要么挂起线程等待、要么继续执行其他操作，资源被满足后再通知该线程重新请求。显然非阻塞的效率要高于阻塞，相应的实现的复杂度也要高一些。</p>
<p>在Java中显式的挂起之前是通过Thread的suspend方法来体现，现在此概念已经消失，原因是suspend/resume方法已经被废弃，它们容易产生死锁，在suspend方法的注释里有这么一段话：当suspend的线程持有某个对象锁，而resume它的线程又正好需要使用此锁的时候，死锁就产生了。</p>
<p>所以，现在的JDK版本中，挂起是JVM的系统行为，程序员无需干涉。休眠的过程中也不会释放锁，但它一定会在某个时间后被唤醒，所以不会死锁。现在我们所说的挂起，往往并非指编写者的程序里主动挂起，而是由操作系统的线程调度器去控制。</p>
<p>所以，我们常常说的“线程在申请锁失败后会被挂起、然后等待调度”这样有一定歧义，因为这里的“挂起”是操作系统级别的挂起，其实是在申请资源失败时的阻塞，和Java中的线程的挂起（可能已经获得锁，也可能没有锁，总之和锁无关）不是一个概念，很容易混淆，所以在后文中说的挂起，一般指的是操作系统的操作，而不是Thread中的suspend()。</p>
<p>相应地有必要提下java.lang.Object的wait/notify，这两个方法同样是等待/通知，但它们的前提是已经获得了锁，且在wait（等待）期间会释放锁。在wait方法的注释里明确提到：线程要调用wait方法，必须先获得该对象的锁，在调用wait之后，当前线程释放该对象锁并进入休眠（这里到底是进入休眠还是挂起？文档没有细说，从该方法能指定等待时间来看，更可能是休眠，没有指定等待时间的，则可能是挂起，不管如何，在休眠/挂起之前，JVM都会从当前线程中把该对象锁释放掉），只有以下几种情况下会被唤醒：其他线程调用了该对象的notify或notifyAll、当前线程被中断、调用wait时指定的时间已到。</p>
<h5 id="2-4-内核态与用户态"><a href="#2-4-内核态与用户态" class="headerlink" title="2.4 内核态与用户态"></a>2.4 内核态与用户态</h5><p>这是两个操作系统的概念，但理解它们对我们理解Java的线程机制有着一定帮助。</p>
<p>有一些系统级的调用，比如：清除时钟、创建进程等这些系统指令，如果这些底层系统级指令能够被应用程序任意访问的话，那么后果是危险的，系统随时可能崩溃，所以 CPU将所执行的指令设置为多个特权级别，在硬件执行每条指令时都会校验指令的特权，比如：Intel x86架构的CPU将特权分为0-3四个特权级，0级的权限最高，3权限最低。</p>
<p>而操作系统根据这系统调用的安全性分为两种：内核态和用户态。内核态执行的指令的特权是0，用户态执行的指令的特权是3。</p>
<blockquote>
<p>1.当一个任务（进程）执行系统调用而进入内核指令执行时，进程处于内核运行态（或简称为内核态）；<br>2. 当任务（进程）执行自己的代码时，进程就处于用户态；</p>
</blockquote>
<p>明白了内核态和用户态的概念之后，那么在这两种状态之间切换会造成什么样的效率影响？</p>
<blockquote>
<p>在执行系统级调用时，需要将变量传递进去、可能要拷贝、计数、保存一些上下文信息，然后内核态执行完成之后需要再将参数传递到用户进程中去，这个切换的代价相对来说是比较大的，所以应该是 尽量避免频繁地在内核态和用户态之间切换。</p>
</blockquote>
<p>那操作系统的这两种形态和我们的线程主题有什么关系呢？这里是关键。Java并没有自己的线程模型，而是使用了操作系统的原生线程！</p>
<p>如果要实现自己的线程模型，那么有些问题就特别复杂，难以解决，比如：如何处理阻塞、如何在多CPU之间合理地分配线程、如何锁定，包括创建、销毁线程这些，都需要Java自己来做，在JDK1.2之前Java曾经使用过自己实现的线程模型，后来放弃了，转向使用操作系统的线程模型，因此创建、销毁、调度、阻塞等这些事都交由操作系统来做，而 线程方面的事在操作系统来说属于系统级的调用，需要在内核态完成，所以如果频繁地执行线程挂起、调度，就会频繁造成在内核态和用户态之间切换，影响效率（当然，操作系统的线程操作是不允许外界（包括Java虚拟机）直接访问的，而是开放了叫“轻量级进程”的接口供外界使用，其与内核线程在Window和Linux上是一对一的关系，这里不多叙述）。</p>
<blockquote>
<p>前面说JDK5之前的synchronized效率低下，是 因为在阻塞时线程就会被挂起、然后等待重新调度，而线程操作属于内核态，这频繁的挂起、调度使得操作系统频繁处于内核态和用户态的转换，造成频繁的变量传递、上下文保存等，从而性能较低。</p>
</blockquote>
<h5 id="3-线程优势"><a href="#3-线程优势" class="headerlink" title="3 线程优势"></a>3 线程优势</h5><p>尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是：</p>
<blockquote>
<ol>
<li>资源利用率更好；</li>
<li>程序设计在某些情况下更简单；</li>
<li>程序响应更快速；</li>
</ol>
</blockquote>
<h5 id="4-创建运行"><a href="#4-创建运行" class="headerlink" title="4 创建运行"></a>4 创建运行</h5><p>编写线程运行时执行的代码有两种方式：一种是创建Thread子类的一个实例并重写run方法，第二种是创建类的时候实现Runnable接口。</p>
<h5 id="5-Main线程与子线程关系"><a href="#5-Main线程与子线程关系" class="headerlink" title="5 Main线程与子线程关系"></a>5 Main线程与子线程关系</h5><p><strong>1. Main线程是个非守护线程，不能设置成守护线程</strong></p>
<p>这是因为，Main线程是由Java虚拟机在启动的时候创建的。main方法开始执行的时候，主线程已经创建好并在运行了。对于运行中的线程，调用Thread.setDaemon()会抛出异常Exception in thread “main” java.lang.IllegalThreadStateException。</p>
<p><strong>2. Main线程结束，其他线程一样可以正常运行</strong></p>
<p>主线程，只是个普通的非守护线程，用来启动应用程序，不能设置成守护线程；除此之外，它跟其他非守护线程没有什么不同。主线程执行结束，其他线程一样可以正常执行。</p>
<p>这样其实是很合理的，按照操作系统的理论，进程是资源分配的基本单位，线程是CPU调度的基本单位。对于CPU来说，其实并不存在java的主线程和子线程之分，都只是个普通的线程。进程的资源是线程共享的，只要进程还在，线程就可以正常执行，换句话说线程是强依赖于进程的。也就是说：</p>
<blockquote>
<p>线程其实并不存在互相依赖的关系，一个线程的死亡从理论上来说，不会对其他线程有什么影响。</p>
</blockquote>
<p><strong>3. Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程</strong></p>
<p>Java虚拟机（相当于进程）退出的时机是：虚拟机中所有存活的线程都是守护线程。只要还有存活的非守护线程虚拟机就不会退出，而是等待非守护线程执行完毕；反之，如果虚拟机中的线程都是守护线程，那么不管这些线程的死活java虚拟机都会退出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">数据结构 -- 查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 19:57:11" itemprop="dateCreated datePublished" datetime="2020-05-31T19:57:11+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><p><img src="https://upload-images.jianshu.io/upload_images/2062729-6175e9c6b5ecbb36.png" alt=""></p>
<h4 id="找出一个无序整型数组中第k大的数"><a href="#找出一个无序整型数组中第k大的数" class="headerlink" title="找出一个无序整型数组中第k大的数"></a>找出一个无序整型数组中第k大的数</h4><p>变种： 找出无序数组中第二大的数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">取基准元素，将元素分为两个集合，一个集合元素比基准小，另一个比基准大 ，三种情况。</span><br><span class="line">1.比基准大的元素数目标志位m正好为k-1，基准就是目的元素。</span><br><span class="line">2.比基准大的元素标志位m小于k, 那么就在比基准小的集合里面找第(k-m)大的元素</span><br><span class="line">3.若是比基准大的元素为m大于k，那就继续在该集合里面找第k大的元素。</span><br><span class="line">如下是代码：</span><br><span class="line">	static void findKMax(int[] arr, int left, int right, int k) &#123;</span><br><span class="line">        int temp &#x3D; partition(arr, left, right);</span><br><span class="line">        if (temp &#x3D;&#x3D; k - 1) &#123;</span><br><span class="line">            System.out.println(arr[temp]);</span><br><span class="line">        &#125; else if (temp &gt; k - 1) &#123;</span><br><span class="line">            findKMax(arr, left, temp - 1, k);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            findKMax(arr, temp + 1, right, k - temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">        int temp &#x3D; arr[left];</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            while (temp &gt;&#x3D; arr[right] &amp;&amp; left &lt; right)</span><br><span class="line">                --right;</span><br><span class="line">            arr[left] &#x3D; arr[right];</span><br><span class="line">            while (temp &lt;&#x3D; arr[left] &amp;&amp; left &lt; right)</span><br><span class="line">                ++left;</span><br><span class="line">            arr[right] &#x3D; arr[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[right] &#x3D; temp;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; new int[] &#123; 12, 23, 2, 3, 2, 432, 43, 534, 5, 345, 3453, 53, 43 &#125;;</span><br><span class="line">        findKMax(arr,0,arr.length - 1,2);</span><br><span class="line">    &#125;</span><br><span class="line">&#96;&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 无序数组中，和为sum的2个数(用HashMap、不用HashMap)</span><br></pre></td></tr></table></figure>

<pre><code></code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
