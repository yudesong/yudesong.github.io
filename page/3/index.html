<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%87%8D%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8811%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%87%8D%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">啃碎并发（11）：内存模型之重排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 09:05:20" itemprop="dateCreated datePublished" datetime="2020-06-03T09:05:20+08:00">2020-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/%E9%87%8D%E6%8E%92%E5%BA%8F/" itemprop="url" rel="index"><span itemprop="name">重排序</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>0 前言<br>在很多情况下，访问一个程序变量（对象实例字段，类静态字段和数组元素）可能会使用不同的顺序执行，而不是程序语义所指定的顺序执行。具体几种情况，如下：</p>
<p>编译器 能够自由的以优化的名义去改变指令顺序；<br>在特定的环境下，处理器 可能会次序颠倒的执行指令；<br>数据可能在 寄存器、处理器缓冲区和主内存 中以不同的次序移动，而不是按照程序指定的顺序；<br>例如，如果一个线程写入值到字段 a，然后写入值到字段 b，而且 b 的值不依赖于 a 的值，那么，处理器就能够自由的调整它们的执行顺序，而且缓冲区能够在 a 之前刷新 b 的值到主内存。有许多潜在的重排序的来源，例如编译器，JIT以及缓冲区。</p>
<p>所以，从Java源码变成可以被机器（或虚拟机）识别执行的程序，至少要经过编译期和运行期。在这两个期间，重排序分为两类：编译器重排序、处理器重排序（乱序执行），分别对应编译时和运行时环境。由于重排序的存在，指令实际的执行顺序，并不是源码中看到的顺序。</p>
<p>1 编译器重排序<br>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序，在不改变程序语义的前提下，尽可能减少寄存器的读取、存储次数，充分复用寄存器的存储值。</p>
<p>假设第一条指令计算一个值赋给变量A并存放在寄存器中，第二条指令与A无关但需要占用寄存器（假设它将占用A所在的那个寄存器），第三条指令使用A的值且与第二条指令无关。那么如果按照顺序一致性模型，A在第一条指令执行过后被放入寄存器，在第二条指令执行时A不再存在，第三条指令执行时A重新被读入寄存器，而这个过程中，A的值没有发生变化。通常编译器都会交换第二和第三条指令的位置，这样第一条指令结束时A存在于寄存器中，接下来可以直接从寄存器中读取A的值，降低了重复读取的开销。</p>
<p>另一种编译器优化：在循环中读取变量的时候，为提高存取速度，编译器会先把变量读取到一个寄存器中；以后再取该变量值时，就直接从寄存器中取，不会再从内存中取值了。这样能够减少不必要的访问内存。但是提高效率的同时，也引入了新问题。如果别的线程修改了内存中变量的值，那么由于寄存器中的变量值一直没有发生改变，很有可能会导致循环不能结束。编译器进行代码优化，会提高程序的运行效率，但是也可能导致错误的结果。所以程序员需要防止编译器进行错误的优化。</p>
<p>2 处理器重排序<br>2.1 指令并行重排序<br>编译器和处理器可能会对操作做重排序，但是要遵守数据依赖关系，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<p>名称    代码示例    说明<br>写后读    a = 1;b = a;    写一个变量之后，再读这个位置。<br>写后写    a = 1;a = 2;    写一个变量之后，再写这个变量。<br>读后写    a = b;b = 1;    读一个变量之后，再写这个变量。<br>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。像这种有直接依赖关系的操作，是不会进行重排序的。特别注意：这里说的依赖关系仅仅是在单个线程内。</p>
<p>举例：</p>
<p>class Demo {<br>    int a = 0;<br>    boolean flag = false;</p>
<pre><code>public void write() {
    a = 1; // 1
    flag = true; // 2
}

public void read() {
    if (flag) { // 3
        int i = a * a; // 4
    }
}</code></pre><p>}<br>由于操作 1 和 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p>
<p>当操作 1 和操作 2 重排序时，可能会产生什么效果？</p>
<p>当操作 1 和操作 2 重排序时<br>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<p>当操作 3 和操作 4 重排序时，可能会产生什么效果?（借助这个重排序，可以顺便说明控制依赖性）</p>
<p>当操作 3 和操作 4 重排序时<br>在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用 猜测（Speculation）执行 来克服控制相关性对并行度的影响。以处理器的猜测执行为例：</p>
<p>执行线程 B 的处理器可以提前读取并计算 a * a，然后把计算结果临时保存到一个名为 重排序缓冲（reorder buffer ROB） 的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p>
<p>从图中我们可以看出，猜测执行 实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；</p>
<p>在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<p>2.2 指令乱序重排序<br>现在的CPU一般采用流水线来执行指令。一个指令的执行被分成：取指、译码、访存、执行、写回、等若干个阶段。然后，多条指令可以同时存在于流水线中，同时被执行。指令流水线并不是串行的，并不会因为一个耗时很长的指令在“执行”阶段呆很长时间，而导致后续的指令都卡在“执行”之前的阶段上。相反，流水线是并行的，多个指令可以同时处于同一个阶段，只要CPU内部相应的处理部件未被占满即可。比如：CPU有一个加法器和一个除法器，那么一条加法指令和一条除法指令就可能同时处于“执行”阶段，而两条加法指令在“执行”阶段就只能串行工作。</p>
<p>然而，这样一来，乱序可能就产生了。比如：一条加法指令原本出现在一条除法指令的后面，但是由于除法的执行时间很长，在它执行完之前，加法可能先执行完了。再比如两条访存指令，可能由于第二条指令命中了cache而导致它先于第一条指令完成。一般情况下，指令乱序并不是CPU在执行指令之前刻意去调整顺序。CPU总是顺序的去内存里面取指令，然后将其顺序的放入指令流水线。但是指令执行时的各种条件，指令与指令之间的相互影响，可能导致顺序放入流水线的指令，最终乱序执行完成。这就是所谓的“顺序流入，乱序流出”。</p>
<p>指令流水线除了在资源不足的情况下会卡住之外（如前所述的一个加法器应付两条加法指令的情况），指令之间的相关性也是导致流水线阻塞的重要原因。CPU的乱序执行并不是任意的乱序，而是以保证程序上下文因果关系为前提的。有了这个前提，CPU执行的正确性才有保证。</p>
<p>比如：</p>
<p>a++;<br>b=f(a);<br>c–;<br>由于 b=f(a) 这条指令依赖于前一条指令 a++ 的执行结果，所以 b=f(a) 将在 “执行” 阶段之前被阻塞，直到 a++ 的执行结果被生成出来；而 c– 跟前面没有依赖，它可能在 b=f(a) 之前就能执行完。（注意，这里的 f(a) 并不代表一个以 a 为参数的函数调用，而是代表以 a 为操作数的指令。C语言的函数调用是需要若干条指令才能实现的，情况要更复杂些）。</p>
<p>像这样有依赖关系的指令如果挨得很近，后一条指令必定会因为等待前一条执行的结果，而在流水线中阻塞很久，占用流水线的资源。而编译器的重排序，作为编译优化的一种手段，则试图通过指令重排将这样的两条指令拉开距离，以至于后一条指令进入CPU的时候，前一条指令结果已经得到了，那么也就不再需要阻塞等待了。比如，将指令重排序为：</p>
<p>a++;<br>c–;<br>b=f(a);<br>相比于CPU指令的乱序，编译器的乱序才是真正对指令顺序做了调整。但是编译器的乱序也必须保证程序上下文的因果关系不发生改变。</p>
<p>由于重排序和乱序执行的存在，如果在并发编程中，没有做好共享数据的同步，很容易出现各种看似诡异的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8810%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（10）：内存模型之内部原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 09:03:58" itemprop="dateCreated datePublished" datetime="2020-06-03T09:03:58+08:00">2020-06-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">内存模型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>0 前言<br>如上一篇文章所述，Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整计算机的模型，因此，这个模型自然会包含一个内存模型—又称为Java内存模型。</p>
<p>如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p>1 Java内存模型<br>我们先来看看Java 线程运行内存示意图，如下图所示：</p>
<p>Java 线程运行内存示意图<br>这张图告诉我们在线程运行的时候有一个内存专用的一小块内存，当Java程序会将变量同步到线程所在的内存，这时候会操作工作内存中的变量，而线程中变量的值何时同步回主内存是不可预期的。</p>
<p>因此，依据上面图的线程运行内存示意图，Java内存模型在JVM内部抽象划分为线程栈和堆。如下图所示：</p>
<p>JMM划分为线程栈和堆<br>1.1 线程栈与堆<br>每一个运行在Java虚拟机里的线程都拥有自己的线程栈。这个线程栈包含了 线程调用的方法当前执行点相关的信息，同时线程栈具有如下特性：</p>
<p>一个线程仅能访问自己的线程栈；<br>一个线程创建的本地变量对其它线程不可见，仅自己可见；<br>即使两个线程执行同样的代码，这两个线程任然在在自己的线程栈中的代码来创建本地变量。因此，每个线程拥有每个本地变量的独有版本。</p>
<p>所有原始类型的本地变量都存放在线程栈上，因此对其它线程不可见。一个线程可能向另一个线程传递一个原始类型变量的拷贝，但是它不能共享这个原始类型变量自身。</p>
<p>堆上包含在Java程序中创建的所有对象，无论是哪一个对象创建的。这包括原始类型的对象版本。如果一个对象被创建然后赋值给一个局部变量，或者用来作为另一个对象的成员变量，这个对象任然是存放在堆上。</p>
<p>所以，调用栈和本地变量存放在线程栈上，对象存放在堆上，如下图所示：</p>
<p>线程栈与堆 &amp; 变量、对象、调用栈<br>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上；<br>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上；<br>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。<br>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。<br>静态成员变量跟随着类定义一起也存放在堆上。<br>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</p>
<p>上面说到的几点，如下图所示：</p>
<p>栈、堆 &amp; 本地变量、静态变量<br>1.2 CPU与内存<br>众所周知，CPU是计算机的大脑，它负责执行程序的指令。内存负责存数据，包括程序自身数据。同样大家都知道，内存比CPU慢很多，现在获取内存中的一条数据大概需要200多个CPU周期（CPU cycles），而CPU寄存器一般情况下1个CPU周期就够了。下面是CPU Cache的简单示意图：</p>
<p>CPU Cache示意图<br>随着多核的发展，CPU Cache分成了三个级别：L1，L2，L3。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。</p>
<p>L1是最接近CPU的，它容量最小，例如32K，速度最快，每个核上都有一个L1 Cache（准确地说每个核上有两个L1 Cache, 一个存数据 L1d Cache, 一个存指令 L1i Cache）。<br>L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache。<br>L3 Cache是三级缓存中最大的一级，例如12MB，同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个L3 Cache。<br>从CPU到    大约需要的CPU周期    大约需要的时间(单位ns)<br>寄存器    1 cycle<br>L1 Cache    ~3-4 cycles    ~0.5-1 ns<br>L2 Cache    ~10-20 cycles    ~3-7 ns<br>L3 Cache    ~40-45 cycles    ~15 ns<br>跨槽传输        ~20 ns<br>内存    ~120-240 cycles    ~60-120ns<br>在Linux下面用 cat /proc/cpuinfo，或Ubuntu下 lscpu 看看自己机器的缓存情况，更细的可以通过以下命令看看：</p>
<p>$ cat /sys/devices/system/cpu/cpu0/cache/index0/size<br>32K<br>$ cat /sys/devices/system/cpu/cpu0/cache/index0/type<br>Data<br>$ cat /sys/devices/system/cpu/cpu0/cache/index0/level<br>1<br>$ cat /sys/devices/system/cpu/cpu3/cache/index3/level<br>3<br>就像数据库cache一样，获取数据时首先会在最快的cache中找数据，如果没有命中(Cache miss) 则往下一级找，直到三层Cache都找不到,那只要向内存要数据了。一次次地未命中，代表获取数据消耗的时间越长。</p>
<p>同时，为了高效地存取缓存，不是简单随意地将单条数据写入缓存的。缓存是由缓存行组成的，典型的一行是64字节。可以通过下面的shell命令，查看 cherency_line_size 就知道知道机器的缓存行是多大：</p>
<p>$ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size<br>64<br>CPU存取缓存都是以“行”为最小单位操作的。比如：一个Java long型占8字节，所以从一条缓存行上你可以获取到8个long型变量。所以如果你访问一个long型数组，当有一个long被加载到cache中, 你将无消耗地加载了另外7个。所以你可以非常快地遍历数组。</p>
<p>2 缓存一致性<br>由于CPU和主存的处理速度上存在一定差别，为了匹配这种差距，提升计算机能力，人们在CPU和主存之间增加了多层高速缓存。每个CPU会有L1、L2甚至L3缓存，在多核计算机中会有多个CPU，那么就会存在多套缓存，在这多套缓存之间的数据就可能出现不一致的现象。为了解决这个问题，有了内存模型。内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。</p>
<p>其实Java内存模型告诉我们通过使用关键词 “synchronized” 或 “volatile” 可以让Java保证某些约束：</p>
<p>“volatile” — 保证读写的都是主内存的变量。<br>“synchronized” — 保证在块开始时都同步主内存的值到工作内存，而块结束时将变量同步回主内存。<br>通过以上描述我们就可以写出线程安全的Java程序，JDK也同时帮我们屏蔽了很多底层的东西。</p>
<p>所以，在编译器各种优化及多种类型的微架构平台上，Java语言规范制定者试图创建一个虚拟的概念并传递到Java程序员，让他们能够在这个虚拟的概念上写出线程安全的程序来，而编译器实现者会根据Java语言规范中的各种约束在不同的平台上达到Java程序员所需要的线程安全这个目的。</p>
<p>那么，在多种类型微架构平台上，又是如何解决缓存不一致性问题的呢？这是众多CPU厂商必须解决的问题。为了解决前面提到的缓存数据不一致的问题，人们提出过很多方案，通常来说有以下2种方案：</p>
<p>通过在总线加LOCK#锁的方式；<br>通过缓存一致性协议（Cache Coherence Protocol）；<br>2.1 总线的概念<br>首先，上面的两种方案，其实都涉及到了总线的概念，那到底什么是总线呢？总线是处理器与主存以及处理器与处理器之间进行通信的媒介，有两种基本的互联结构：SMP（symmetric multiprocessing 对称多处理）和NUMA（nonuniform memory access 非一致内存访问）。</p>
<p>SMP（对称多处理）和NUMA（非一致内存访问）<br>SMP系统结构非常普通，因为它们最容易构建，很多小型服务器采用这种结构。处理器和存储器之间采用总线互联，处理器和存储器都有负责发送和监听总线广播的信息的总线控制单元。但是同一时刻只能有一个处理器（或存储控制器）在总线上广播，所有的处理器都可以监听。很容易看出，对总线的使用是SMP结构的瓶颈。</p>
<p>NUMP系统结构中，一系列节点通过点对点网络互联，像一个小型互联网，每个节点包含一个或多个处理器和一个本地存储器。一个节点的本地存储对于其他节点是可见的，所有节点的本地存储一起形成了一个可以被所有处理器共享的全局存储器。可以看出，NUMP的本地存储是共享的，而不是私有的，这点和SMP是不同的。NUMP的问题是网络比总线复制，需要更加复杂的协议，处理器访问自己节点的存储器速度快于访问其他节点的存储器。NUMP的扩展性很好，所以目前很多大中型的服务器在采用NUMP结构。</p>
<p>对于上层程序员来说，最需要理解的是总线线是一种重要的资源，使用的好坏会直接影响程序的执行性能。</p>
<p>2.2 总线加Lock<br>在早期的CPU当中，是可以通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从其内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是由于在锁住总线期间，其他CPU无法访问内存，会导致效率低下。因此出现了第二种解决方案，通过缓存一致性协议来解决缓存一致性问题。</p>
<p>2.3 缓存一致性协议<br>一致性要求是指，若cache中某个字段被修改，那么在主存（以及更高层次）上，该字段的副本必须立即或最后加以修改，并确保它者引用主存上该字内容的正确性。<br>　　<br>当代多处理器系统中，每个处理器大都有自己的cache。同一主存块的拷贝能同时存于不同cache中，若允许处理器各自独立地修改自己的cache，就会出现不一致问题。解决此问题有软件办法和硬件办法。硬件办法能动态地识别出不一致产生的条件并予以及时处理，从而使cache的使用有很高的效率。并且此办法对程序员和系统软件开发人员是透明的，减轻了软件研制负担，从而普遍被采用。</p>
<p>软件办法最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。MESI协议是一种采用写–无效方式的监听协议。它要求每个cache行有两个状态位，用于描述该行当前是处于修改态（M）、专有态（E）、共享态（S）或者无效态（I）中的哪种状态，从而决定它的读/写操作行为。这四种状态的定义是：</p>
<p>修改态（Modified）：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。<br>专有态（Exclusive）：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。<br>共享态（Shared）：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。<br>无效态（Invalid）：这行数据无效。<br>MESI协议适合以总线为互连机构的多处理器系统。各cache控制器除负责响应自己CPU的内存读写操作（包括读/写命中与未命中）外，还要负责监听总线上的其它CPU的内存读写活动（包括读监听命中与写监听命中）并对自己的cache予以相应处理。所有这些处理过程要维护cache一致性，必须符合MESI协议状态转换规则。</p>
<p>MESI的总线监听与状态转换<br>下面由图的四个顶点出发，介绍总线监听与状态转换规则：</p>
<p>该I无效行在 自身Cache读未命中 将被相应内存块填充以建立新行时，读监听命中，说明其它Cache正在读同地址的内存块，以建立新行。故为多Cache共享行，应为S状态，并应继续发出读监听广播，使其它Cache的类似情况效仿。<br>该I无效行在 自身Cache读未命中 将被相应内存块填充以建立新行时，未有读监听命中，为本Cache专有，故新建行应为E状态。<br>该I无效行在 自身Cache写未命中 时，将先读入相应内存块填充新行后，再进行写修改，与原内存正本的数据不一致，故新建行为M状态。<br>该S共享行 写监听命中，说明别的Cache由于写命中修改了同此地址的行，根据写无效原则，此共享行应改变为无效（I）状态。<br>该S共享行 读命中，状态不变。<br>该S共享行 读监听命中，说明其它Cache正在读同地址内存块，以建立新行，此时该共享行状态不必改变，但应继续发读监听广播，供它者监听。<br>该S共享行 写命中，其中某字被改写，与内存正本不一致，故应改为M状态，且应发出共享行写命中监听广播，使其它Cache同地址行作废（同 4）。<br>该E专有行 读监听命中，说明别的Cache正在读同地址的内存正本，以建立新行，故其状态应改为S状态，并发出读监听广播，以使同此情况及1效仿之。<br>该E专有行 读命中 不必改变状态。<br>该E专有行 写监听命中，说明别的Cache由于写未命中而访问同地址的内存正本，该E态行内容即将过时，故应作废。<br>该E专有行 写命中，只改变状态为M态即可，无须他者监听。<br>该M修改行 写命中 状态不变。<br>该M修改行 读命中 状态不变。<br>该M修改行 读监听命中，应将该行最新数据写回内存正本后变为S状态。并发出读监听广播，供他者监听。<br>该M修改行 写监听命中，说明别的Cache由于写未命中而访问了同地址的内存块（同3），将实行先读后修改，此时本地M修改行应抢先写回主存，然后作废，以保证别的Cache读出整行而未被修改数据的正确性。<br>该M修改行 整行写监听命中，说明别的Cache由于写未命中而访问了同地址的内存块，将实行先读后整行的修改，此时本地M修改行不必写回主存，只作废即可。<br>上述分析可以看出，虽然各cache控制器随时都在监听系统总线，但能监听到的只有读未命中、写未命中以及共享行写命中三种情况。总线监控逻辑并不复杂，增添的系统总线传输开销也不大，MESI协议却有力地保证了主存块脏拷贝在多cache中的唯一性，并能及时写回，保证cache主存存取的正确性。</p>
<p>但是，值得注意的是，传统的MESI协议中有两个行为的执行成本比较大。一个是将某个Cache Line标记为Invalid状态，另一个是当某Cache Line当前状态为Invalid时写入新的数据。所以CPU通过Store Buffer和Invalidate Queue组件来降低这类操作的延时。如下图所示：</p>
<p>CPU通过Store Buffer和Invalidate Queue组件来降低这类操作的延时<br>当一个CPU进行写入时，首先会给其它CPU发送Invalid消息，然后把当前写入的数据写入到Store Buffer中，然后异步在某个时刻真正的写入到Cache中。<br>当前CPU核如果要读Cache中的数据，需要先扫描Store Buffer之后再读取Cache。<br>但是此时其它CPU核是看不到当前核的Store Buffer中的数据的，要等到Store Buffer中的数据被刷到了Cache之后才会触发失效操作。<br>而当一个CPU核收到Invalid消息时，会把消息写入自身的Invalidate Queue中，随后异步将其设为Invalid状态。<br>和Store Buffer不同的是，当前CPU核心使用Cache时并不扫描Invalidate Queue部分，所以可能会有极短时间的脏读问题。<br>所以，MESI协议，可以保证缓存的一致性，但是无法保证实时性，可能会有极短时间的脏读问题。</p>
<p>其实，并非所有情况都会使用缓存一致性的，如：被操作的数据不能被缓存在CPU内部或操作数据跨越多个缓存行（状态无法标识），则处理器会调用总线锁定；另外当CPU不支持缓存锁定时，自然也只能用总线锁定了，比如说奔腾486以及更老的CPU。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">啃碎并发（九）：内存模型之基础概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 09:03:19 / 修改时间：09:05:45" itemprop="dateCreated datePublished" datetime="2020-06-03T09:03:19+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在并发编程中，需要解决两个关键问题：</p>
<p>线程之间如何通信；<br>线程之间如何同步；<br>线程通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。</p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</p>
<p>线程同步是指程序用于控制不同线程之间操作发生相对顺序的机制。</p>
<p>在共享内存的并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</p>
<p>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>
<p>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明 — 隐式通信、显示同步。如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p>1 为什么要有内存模型<br>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p>
<p>1.1 CPU和缓存一致性<br>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p>
<p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大，这就导致CPU每次操作内存都要耗费很多等待时间。</p>
<p>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。</p>
<p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p>
<p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。它的特点是速度快，内存小，并且昂贵。</p>
<p>那么，程序的执行过程就变成了：当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>
<p>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</p>
<p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p>
<p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。这三种缓存的 技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p>
<p>那么，在有了多级缓存之后，程序的执行就变成了：当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</p>
<p>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</p>
<p>单核CPU只含有一套L1，L2，L3缓存。如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p>
<p>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</p>
<p>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</p>
<p>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</p>
<p>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</p>
<p>一个单CPU双核的缓存结构<br>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p>
<p>单线程：CPU核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p>
<p>单核CPU，多线程：进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p>
<p>多核CPU，多线程：每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p>
<p>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p>
<p>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</p>
<p>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</p>
<p>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</p>
<p>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</p>
<p>多核CPU多线程场景下缓存不一致问题<br>1.2 处理器优化和指令重排<br>上面提到在CPU和主存之间增加缓存，在多线程场景下会存在缓存一致性问题。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是处理器优化。</p>
<p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如：Java虚拟机的即时编译器（JIT）也会做指令重排。</p>
<p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p>
<p>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</p>
<p>1.3 并发编程的问题<br>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如：原子性问题，可见性问题和有序性问题。</p>
<p>其实，原子性问题，可见性问题和有序性问题，是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的 缓存一致性问题、处理器优化问题和指令重排问题 等。缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。</p>
<p>原子性 是指在一个操作中就是CPU不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p>
<p>可见性 是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>有序性 是指程序执行的顺序按照代码的先后顺序执行。</p>
<p>2 什么是内存模型<br>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p>
<p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p>
<p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型，定义了共享内存系统中多线程程序读写操作行为的规范。</p>
<p>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
<p>内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。</p>
<p>3 什么是Java内存模型<br>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p>
<p>我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p>
<p>Java内存模型规定了 所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>
<p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p>
<p>主内存与工作内存交互示意<br>特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。</p>
<p>再来总结下，JMM是一种规范，规范了Java虚拟机与计算机内存是如何协同工作的，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p>
<p>所以，如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
<p>3.1 Java内存模型抽象<br>在Java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。局部变量（Local variables），方法定义参数（formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：</p>
<p>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>
<p>Java内存模型抽象示意图<br>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<p>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去；<br>然后，线程B到主内存中去读取线程A之前已更新过的共享变量；<br>下面通过示意图来说明这两个步骤：</p>
<p>线程A与线程B之间通信<br>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p>
<p>3.2 重排序<br>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br>从Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p>三种重排序<br>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。</p>
<p>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。</p>
<p>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel称之为memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<p>3.3 处理器重排序<br>现代的处理器使用 写缓冲区 来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：</p>
<p>处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</p>
<p>两个处理器示例<br>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0。具体的原因如下图所示：</p>
<p>处理器A和处理器B并行执行程序<br>处理器 A 和 B 同时把共享变量写入在写缓冲区中（A1、B1），然后再从内存中读取另一个共享变量（A2、B2），最后才把自己写缓冲区中保存的脏数据刷新到内存中（A3、B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p>
<p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1 -&gt; A2，但内存操作实际发生的顺序却是：A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对内存写-读操作重排序。</p>
<p>3.4 内存屏障指令<br>下面是常见处理器允许的重排序类型的列表：</p>
<p>常见处理器允许的重排序类型<br>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。从上表我们可以看出：常见的处理器都允许Store-Load重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO和x86拥有相对较强的处理器内存模型，它们仅允许对写-读操作做重排序（因为它们都使用了写缓冲区）。</p>
<p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p>
<p>内存屏障指令<br>3.5 happens-before<br>JSR-133 内存模型使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p>与程序员密切相关的 happens-before 规则如下：</p>
<p>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</p>
<p>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</p>
<p>volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。</p>
<p>传递性规则：如果A happens- before B，且B happens- before C，那么A happens- before C。</p>
<p>注意，两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p>
<p>happens-before与JMM的关系<br>如上图所示，一个happens-before规则通常对应于多个编译器和处理器重排序规则。对于Java程序员来说，happens-before规则简单易懂，它避免java程序员为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>
<p>3.6 数据依赖性<br>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<p>三种类型数据依赖<br>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<p>3.7 as-if-serial 语义<br>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是如果操作之间没有数据依赖关系，这些操作就可能被编译器和处理器重排序。</p>
<p>举个例子：</p>
<p>double pi = 3.14; // A</p>
<p>double r = 1.0; // B</p>
<p>double area = pi * r * r; // C<br>上面三个操作的数据依赖关系如下图所示：</p>
<p>三个操作的数据依赖关系<br>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种可能执行顺序：</p>
<p>两种可能的执行顺序<br>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens-before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
<p>4 Java内存模型实现<br>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如：volatile、synchronized、final、concurrent包等。其实这些就是 Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p>
<p>在开发多线程的代码的时候，我们可以直接使用 synchronized 等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p>
<p>4.1 原子性<br>在Java中，为了保证原子性，提供了两个高级的字节码指令 monitorenter 和 monitorexit，这两个字节码，在Java中对应的关键字就是 synchronized。</p>
<p>因此，在Java中可以使用 synchronized 来保证方法和代码块内的操作是原子性的。</p>
<p>4.2 可见性<br>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p>
<p>Java中的 volatile 关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用 volatile 来保证多线程操作时变量的可见性。</p>
<p>除了 volatile，Java中的 synchronized 和 final 两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p>
<p>4.3 有序性<br>在Java中，可以使用 synchronized 和 volatile 来保证多线程之间操作的有序性。实现方式有所区别：<br>volatile关键字会禁止指令重排；</p>
<p>synchronized关键字保证同一时刻只允许一条线程操作；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/%E7%AE%97%E6%B3%95%20--%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/02/%E7%AE%97%E6%B3%95%20--%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">算法 -- 动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-02 19:19:17" itemprop="dateCreated datePublished" datetime="2020-06-02T19:19:17+08:00">2020-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-青蛙跳台阶"><a href="#0-青蛙跳台阶" class="headerlink" title="0. 青蛙跳台阶"></a>0. 青蛙跳台阶</h4><p>问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static int fun(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    int[] dp &#x3D; new int[n + 1];</span><br><span class="line">    dp[1] &#x3D; 1; dp[2] &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-最大连续子序列和"><a href="#1-最大连续子序列和" class="headerlink" title="1. 最大连续子序列和"></a>1. 最大连续子序列和</h4><p>给定k个整数的序列{N1,N2,…,Nk }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= k。最大连续子序列是所有连续子序中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{11,-4,13}，最大连续子序列和即为20。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 状态转移方程 dp[i] &#x3D; max&#123;dp[i-1] + A[i], A[i]&#125;</span><br><span class="line">private static int MaxSubSequence2(int[] A) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[A.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; 0;</span><br><span class="line">        if (i &#x3D;&#x3D; 0) continue;</span><br><span class="line">        if (A[i] &gt; dp[i - 1] + A[i]) &#123;</span><br><span class="line">            dp[i] &#x3D; A[i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int max &#x3D; dp[0];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; dp.length; i++) &#123;</span><br><span class="line">        if (max &lt; dp[i]) max &#x3D; dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最长递增子序列（LIS）"><a href="#2-最长递增子序列（LIS）" class="headerlink" title="2. 最长递增子序列（LIS）"></a>2. 最长递增子序列（LIS）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 【最长递增子序列（LIS）】</span><br><span class="line"> * 1.若arr[i]&gt;arr[j],说明第i个元素可以接在第j个元素后面作为新的递增序列的结尾,即dp[i] &#x3D; max(dp[j])+1 &#x3D; max(dp[j] + 1)</span><br><span class="line"> * 2.若arr[i]&lt;&#x3D;arr[j],说明第i个元素比前面所有的数都小,此时以i元素作为结尾的递增序列长度为1,即dp[i] &#x3D; 1</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int LIS(int[] A) &#123;</span><br><span class="line">    int[] dp &#x3D; new int[A.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; A.length; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; 1;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (A[i] &gt; A[j] &amp;&amp; dp[i] &lt; (dp[j] + 1)) &#123;</span><br><span class="line">                dp[i] &#x3D; dp[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int temp &#x3D; dp[0];</span><br><span class="line">    for (int m &#x3D; 0; m &lt; dp.length; m++) &#123;</span><br><span class="line">        if (temp &lt; dp[m]) &#123;</span><br><span class="line">            temp &#x3D; dp[m];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-最长公共子序列（LCS）"><a href="#3-最长公共子序列（LCS）" class="headerlink" title="3. 最长公共子序列（LCS）"></a>3. 最长公共子序列（LCS）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 【最长公共子序列（LCS）】</span><br><span class="line"> * 设序列X&#x3D;&#123;x1,x2,…,xm&#125;和Y&#x3D;&#123;y1,y2,…,yn&#125;的最长公共子序列为Z&#x3D;&#123;z1,z2,…,zk&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int LCS(int[] X, int[] Y) &#123;</span><br><span class="line">	int m &#x3D; X.length;</span><br><span class="line">	int n &#x3D; Y.length;</span><br><span class="line">	int[][] L &#x3D; new int[m][n];</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (X[i] &#x3D;&#x3D; Y[j]) &#123;</span><br><span class="line">			if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i - 1][j - 1] + 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			L[i][j] &#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125; else if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">			if (L[i - 1][j] &gt; L[i][j - 1]) &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i - 1][j];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			L[i][j] &#x3D; L[i][j - 1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return L[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-编辑距离"><a href="#4-编辑距离" class="headerlink" title="4. 编辑距离"></a>4. 编辑距离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 编辑距离</span><br><span class="line"> * 1、维护一个dp数组，其中dp[i][j]表示s1[0]---s1[i]和s2[0]--s2[j]相同需要进行的最少步骤；</span><br><span class="line"> * 2、边界条件初始化，dp[i][0]&#x3D;i，相当于将s1挨个变成空所要进行的步数，对于dp[0][j]&#x3D;j同理；</span><br><span class="line"> * 3、状态转移方程，我们要得到dp[i][j]的值，假设s1[i-1]和s2[j-1]之前的都已经相等了，那么如果s1[i]&#x3D;&#x3D;s2[j]，显然不需要进行操作，dp[i][j]&#x3D;&#x3D;dp[i-1][j-1]；如果s1[i]!&#x3D;s2[j]，那么到达dp[i][j]的就有三条路，分别从dp[i-1][j-1]、dp[i-1][j]、dp[i][j-1]，对应的含义分别是修改字符、删除字符和插入字符，在三种操作下，经历的步数都要+1，所以我们只要找三者的最小值然后+1就可以了。</span><br><span class="line">*&#x2F;</span><br><span class="line">private static int editDistance(String s1, String s2) &#123;</span><br><span class="line">    int s1_len &#x3D; s1.length();</span><br><span class="line">    int s2_len &#x3D; s2.length();</span><br><span class="line">    int[][] dp &#x3D; new int[s1_len][s2_len];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; s1_len; i++) &#123;</span><br><span class="line">        dp[i][0] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 0; j &lt; s2_len; j++) &#123;</span><br><span class="line">        dp[0][j] &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 1; i &lt; s1_len; i++)</span><br><span class="line">        for (int j &#x3D; 1; j &lt; s2_len; j++) &#123;</span><br><span class="line">            if (s1.charAt(i) &#x3D;&#x3D; s2.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i - 1][j - 1] + 1);</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i][j - 1] + 1);</span><br><span class="line">                dp[i][j] &#x3D; Math.min(dp[i][j], dp[i - 1][j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    return dp[s1_len - 1][s2_len - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
<p><strong>1. 暴力破解算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">    if (s.isEmpty()) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    String res &#x3D; s.substring(0, 1);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt;&#x3D; s.length(); j++) &#123;</span><br><span class="line">            String k &#x3D; s.substring(i, j);</span><br><span class="line">            String rk &#x3D; new StringBuffer(k).reverse().toString();</span><br><span class="line">            if (k.equals(rk) &amp;&amp; k.length() &gt; res.length()) &#123;</span><br><span class="line">                res &#x3D; k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 动态规划</strong></p>
<p>创建一个二维数组，boolean[][] dp, 其中dp[i][j]表示字符串第i到j是否为回文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string longestPalindrome(string s)</span><br><span class="line">&#123;</span><br><span class="line">    if (s.empty()) return &quot;&quot;;</span><br><span class="line">    int len &#x3D; s.size();</span><br><span class="line">    if (len &#x3D;&#x3D; 1)return s;</span><br><span class="line">    int longest &#x3D; 1;</span><br><span class="line">    int start&#x3D;0;</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; dp(len,vector&lt;int&gt;(len));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] &#x3D; 1;</span><br><span class="line">        if(i&lt;len-1)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[i + 1])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + 1] &#x3D; 1;</span><br><span class="line">                start&#x3D;i;</span><br><span class="line">                longest&#x3D;2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int l &#x3D; 3; l &lt;&#x3D; len; l++)&#x2F;&#x2F;子串长度</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i+l-1 &lt; len; i++)&#x2F;&#x2F;枚举子串的起始点</span><br><span class="line">        &#123;</span><br><span class="line">            int j&#x3D;l+i-1;&#x2F;&#x2F;终点</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[j] &amp;&amp; dp[i+1][j-1]&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] &#x3D; 1;</span><br><span class="line">                start&#x3D;i;</span><br><span class="line">                longest &#x3D; l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(start,longest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-无重复字符最长子串长度"><a href="#6-无重复字符最长子串长度" class="headerlink" title="6. 无重复字符最长子串长度"></a>6. 无重复字符最长子串长度</h4><p>dp[i]表示字符串以i结尾的中最长无重复字符的长度。 状态转移方程可以表述为：</p>
<ol>
<li>dp[i] = dp[i-1] + 1 (dp[i] 在1…i-1里面不重复）</li>
<li>dp[i] = max(d, i-1-d) </li>
</ol>
<h1 id="方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max-dp-）"><a href="#方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max-dp-）" class="headerlink" title="方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max(dp)）"></a>方法四：动态规划（dp存储以第j个字符结尾的最长无重复子串，所以最后返回值是max(dp)）</h1><h1 id="状态转移："><a href="#状态转移：" class="headerlink" title="状态转移："></a>状态转移：</h1><h1 id="1-若s-j-不存在于s-j-，那么dp-j-dp-j-1-1"><a href="#1-若s-j-不存在于s-j-，那么dp-j-dp-j-1-1" class="headerlink" title="1. 若s[j]不存在于s[:j]，那么dp[j]=dp[j-1]+1;"></a>1. 若s[j]不存在于s[:j]，那么dp[j]=dp[j-1]+1;</h1><h1 id="2-若s-j-存在于s-j-中，但是s-j-和之前重复的那个元素之间的距离d-gt-dp-j-1-，那么不对当前产生影响，dp-j-dp-j-1-1，例如：s-”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；"><a href="#2-若s-j-存在于s-j-中，但是s-j-和之前重复的那个元素之间的距离d-gt-dp-j-1-，那么不对当前产生影响，dp-j-dp-j-1-1，例如：s-”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；" class="headerlink" title="2. 若s[j]存在于s[:j]中，但是s[j]和之前重复的那个元素之间的距离d&gt;dp[j-1]，那么不对当前产生影响，dp[j]=dp[j-1]+1，例如：s=”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；"></a>2. 若s[j]存在于s[:j]中，但是s[j]和之前重复的那个元素之间的距离d&gt;dp[j-1]，那么不对当前产生影响，dp[j]=dp[j-1]+1，例如：s=”abcdba”，第二个a已经不对它产生影响，因为到第二个b的时候，无重复子串已经转移成”cdb”，已经不包含之前的a；</h1><h1 id="3-若d-lt-dp-j-1-，那么dp-j-d"><a href="#3-若d-lt-dp-j-1-，那么dp-j-d" class="headerlink" title="3. 若d&lt;dp[j-1]，那么dp[j]=d"></a>3. 若d&lt;dp[j-1]，那么dp[j]=d</h1><h4 id="7-纸牌游戏"><a href="#7-纸牌游戏" class="headerlink" title="7. 纸牌游戏"></a>7. 纸牌游戏</h4><p>有一个整型数组A，代表数值不同的纸牌排成一条线。玩家a和玩家b依次拿走每张纸牌，规定玩家a先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家a和玩家b都绝顶聪明，他们总会采用最优策略。请返回最后获胜者的分数。</p>
<p>给定纸牌序列A及序列的大小n，请返回最后分数较高者得分数(相同则返回任意一个分数)。保证A中的元素均小于等于1000。且A的大小小于等于300。</p>
<blockquote>
<p>测试样例：<br>[1,2,100,4],4<br>返回：101</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int cardGame(int[] A, int n) &#123;</span><br><span class="line">    int[][] f &#x3D; new int[n][n];</span><br><span class="line">    int[][] s &#x3D; new int[n][n];</span><br><span class="line">    &#x2F;&#x2F; 注意j，i的取值范围</span><br><span class="line">    for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">        f[j][j] &#x3D; A[j];</span><br><span class="line">        for (int i &#x3D; j - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            f[i][j] &#x3D; Math.max(A[i] + s[i + 1][j], A[j] + s[i][j - 1]);</span><br><span class="line">            s[i][j] &#x3D; Math.min(f[i + 1][j], f[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       return Math.max(f[0][n - 1], s[0][n - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-0-1背包问题"><a href="#8-0-1背包问题" class="headerlink" title="8. 0-1背包问题"></a>8. 0-1背包问题</h4><p>给定n个重量为W1、W2、W3 .. Wn , 价值为V1、V2、V3 .. Vn的物品和容量为j的背包</p>
<p>定义V(i,j)：当前背包容量j，前i个物品最佳组合对应的价值</p>
<ol>
<li>如果： j &lt; w(i)  则V(i, j) = V(i - 1, j)</li>
<li>如果： j &gt;= w(i) 则V(i, j) = max{ V(i - 1, j)，V(i - 1, j - w(i)) + v(i) ｝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; 4; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 1; j &lt;&#x3D; bagV; j++) &#123;</span><br><span class="line">        if (j &lt; w[i])</span><br><span class="line">            dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">        else</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486294&idx=1&sn=dd8968700d19ea8b1db29065dc2f7b01&chksm=ce404082f937c994444393163a2bf53f32e18f9a752aad610c3d4988f31c328cae203a84809b&scene=21#wechat_redirect" target="_blank" rel="noopener">告别动态规划，连刷40道动规算法题，我总结了动规的套路</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="post-title-link" itemprop="url">数据结构 -- 布隆过滤器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-02 10:14:21 / 修改时间：19:18:16" itemprop="dateCreated datePublished" datetime="2020-06-02T10:14:21+08:00">2020-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-问题情景"><a href="#1-问题情景" class="headerlink" title="1. 问题情景"></a>1. 问题情景</h4><p>如果面试官问你，一个网站有 100 亿 url 存在一个黑名单中，每条 url 平均 64 字节。问这个黑名单要怎么存？若此时随便输入一个 url，如何判断该 url 是否在这个黑名单中？</p>
<p>对于第一个问题，如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p>
<p>那该怎么办？ok，现在该介绍今天的主角了 —— 布隆过滤器就可以解决这样的问题。</p>
<blockquote>
<p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制矢量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
</blockquote>
<h4 id="2-具体介绍"><a href="#2-具体介绍" class="headerlink" title="2. 具体介绍"></a>2. 具体介绍</h4><blockquote>
<p>布隆过滤器实际上是一个很长的二进制矢量和一系列随机映射函数。</p>
</blockquote>
<p>「很长的二进制矢量」：这是一个长度很长的数组，什么类型的数组呢？bit 类型的数组，也是我们说的「位」，（1Byte = 8bit，1KB = 1024Byte）。<br>「一系列随机映射函数」：有多个哈希函数。那什么是哈希函数呢？JDK 里面有计算得到哈希值的方法，那就是一个哈希函数。<br>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难</p>
<h4 id="3-解决过程"><a href="#3-解决过程" class="headerlink" title="3. 解决过程"></a>3. 解决过程</h4><p>下面我说下大体的过程，细节部分可先不理解，重要的是明白流程，细节我后面补充。</p>
<p>假设，bit 类型数组的长度为 m，每个元素值为 0，有 k 个哈希函数。</p>
<p>首先，当输入一个 url 的时候，此时这个 url 会经过 k 个哈希函数处理，得到多个哈希值（v1,v2,…,vk）。之后得到这些哈希值对应在数组的下标位置，最后将这些下标的元素都置为 1。</p>
<p>那么如何判断一个 url 在黑名单里面呢？输入一条 url，它经过上述处理之后，会得到多个数组的下标位置。如果这些下标的元素值都已经为 1 了，说明该在黑名单里面，否则不在。</p>
<p>总体就是这样的流程，下面说下大家可能存在的疑问：</p>
<p>1、bit 类型的数组如何构建<br>2、得到 v1,v2,…,vk 这些哈希值后，如何得到其在数组的下标位置，并将其设置为 1 呢？</p>
<p>两个问题我一起说下，Java 里面没有 bit 这样的类型，怎么构建呢？—— 不难，我们可以使用 int，一个 int 是 32 位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建了一个 100 * 32bit 的数组</span><br><span class="line">int[] arr &#x3D; new int[100]; </span><br><span class="line">&#x2F;&#x2F; 代表 bit 数组 0-31 位的元素</span><br><span class="line">arr[0];</span><br></pre></td></tr></table></figure>

<p>因此上面再会说「分别将这些哈希值除以数组的长度 m，和对 m 取模，得到这些哈希值对应在数组的下标位置」。</p>
<p>具体我们可以拿一个哈希值 data 来举个栗子，假设 int 数组长度为 100。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Set(int data) &#123;</span><br><span class="line">       &#x2F;&#x2F; ByteNO 是表示在 table 数组中那个元素</span><br><span class="line">       int ByteNo &#x3D; data &#x2F; 32;</span><br><span class="line">       &#x2F;&#x2F; bitNo 是表示在 32 位 bit 中哪个 bit 位。</span><br><span class="line">       int BitNo &#x3D; data % 32;</span><br><span class="line">       &#x2F;&#x2F; 置 1</span><br><span class="line">       _table[ByteNo] |&#x3D; (1 &lt;&lt; BitNo); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-使用效果"><a href="#4-使用效果" class="headerlink" title="4. 使用效果"></a>4. 使用效果</h4><p>最开始我们提到，如果将 100 亿 url 放到 HashMap 中需要 640GB，那么使用布隆过滤器后又需要多少空间呢？答案是约等于 23 GB。相比之下，这个空间大小是不是就可以接受很多了。</p>
<h4 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a>5. 缺点</h4><p>布隆过滤器有宁可错杀一百，也不能放过一个的性质。讲人话就是属于黑名单的 url 一定能够正确判断它在黑名单中，但不属于黑名单中的 url 也可能会被认为在黑名单中，存在一定的失误率。</p>
<p><a href="https://juejin.im/post/5ce60f8ce51d4510bf1d65ea" target="_blank" rel="noopener">大白话布隆过滤器</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90wait&notify%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90wait&notify%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（八）：深入分析wait&notify原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 20:44:24" itemprop="dateCreated datePublished" datetime="2020-06-01T20:44:24+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>上一节讲了Synchronized关键词的原理与优化分析，而配合Synchronized使用的另外两个关键词<strong>wait&amp;notify</strong>是本章讲解的重点。最简单的东西，往往包含了最复杂的实现，因为需要为上层的存在提供一个稳定的基础，<strong>Object作为Java中所有对象的基类，其存在的价值不言而喻，其中wait&amp;notify方法的实现多线程协作提供了保证。</strong></p>
<h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1 源码"></a>1 源码</h4><p>今天我们要学习或者说分析的是<strong>Object</strong>类中的 wait&amp;notify 这两个方法，其实说是两个方法，这两个方法包括他们的重载方法一共有 5 个，而 Object 类中一共才 12 个方法，可见这 2 个方法的重要性。我们先看看 JDK 中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final native void notify();</span><br><span class="line">public final native void notifyAll();</span><br><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">&#125;</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (timeout &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                            &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 此处对于纳秒的处理不精准，只是简单增加了1毫秒，</span><br><span class="line">    if (nanos &gt; 0) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这五个方法。其中有<strong>3 个方法是 native 的，也就是由虚拟机本地的 c 代码执行的。</strong>有 2 个 wait 重载方法最终还是调用了 wait（long） 方法。</p>
<p><strong>1.wait方法：</strong>wait是要释放对象锁，进入等待池。既然是释放对象锁，那么肯定是先要获得锁。所以wait必须要写在synchronized代码块中，否则会报异常。</p>
<p><strong>2.notify方法：</strong>也需要写在synchronized代码块中，调用对象的这两个方法也需要先获得该对象的锁。 <strong>notify，notifyAll，唤醒等待该对象同步锁的线程，并放入该对象的锁池中。对象的锁池中线程可以去竞争得到对象锁，然后开始执行。</strong></p>
<blockquote>
<p>1.<strong>如果是通过notify来唤起的线程，</strong>那先进入wait的线程会先被唤起来，并非随机唤醒；<br>2.<strong>如果是通过nootifyAll唤起的线程</strong>，默认情况是最后进入的会先被唤起来，即LIFO的策略；</p>
</blockquote>
<p>另外一点比较重要，notify，notifyAll调用时并不会释放对象锁。比如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void test()</span><br><span class="line">&#123;</span><br><span class="line">    Object object &#x3D; new Object();</span><br><span class="line">    synchronized (object)&#123;</span><br><span class="line">        object.notifyAll();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然调用了notifyAll，但是紧接着进入了一个死循环。<strong>导致一直不能出临界区，一直不能释放对象锁。</strong>所以，即使它把所有在等待池中的线程都唤醒放到了对象的锁池中，<strong>但是锁池中的所有线程都不会运行，因为他们始终拿不到锁。</strong></p>
<h4 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h4><p>简单示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyCase &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread A is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;thread A get lock&quot;);</span><br><span class="line">                        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                        System.out.println(&quot;thread A do wait method&quot;);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(&quot;wait end&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;thread B is waiting to get lock&quot;);</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    System.out.println(&quot;thread B get lock&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    System.out.println(&quot;thread B do notify method&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread A is waiting to get lock</span><br><span class="line">thread A get lock</span><br><span class="line">thread B is waiting to get lock</span><br><span class="line">thread A do wait method</span><br><span class="line">thread B get lock</span><br><span class="line">thread B do notify method</span><br><span class="line">wait end</span><br></pre></td></tr></table></figure>

<p><strong>前提：必须由同一个lock对象调用wait、notify方法</strong></p>
<blockquote>
<ol>
<li>当线程A执行wait方法时，该线程会被挂起；</li>
<li>当线程B执行notify方法时，会唤醒一个被挂起的线程A；</li>
</ol>
</blockquote>
<p><strong>lock对象、线程A和线程B三者是一种什么关系？</strong>根据上面的结论，可以想象一个场景：</p>
<blockquote>
<p>1.lock对象维护了一个等待队列list；<br>2.线程A中执行lock的wait方法，把线程A保存到list中；<br>3.线程B中执行lock的notify方法，从等待队列中取出线程A继续执行；</p>
</blockquote>
<h4 id="3-相关疑问"><a href="#3-相关疑问" class="headerlink" title="3 相关疑问"></a>3 相关疑问</h4><h5 id="3-1-为何wait-amp-notify必须要加synchronized锁"><a href="#3-1-为何wait-amp-notify必须要加synchronized锁" class="headerlink" title="3.1 为何wait&amp;notify必须要加synchronized锁"></a>3.1 为何wait&amp;notify必须要加synchronized锁</h5><p>从实现上来说，这个锁至关重要，正因为这把锁，才能让整个wait/notify玩转起来，当然我觉得其实通过其他的方式也可以实现类似的机制，不过hotspot至少是完全依赖这把锁来实现wait/notify的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void Sort(int [] array) &#123;</span><br><span class="line">    &#x2F;&#x2F; synchronize this operation so that some other thread can&#39;t</span><br><span class="line">    &#x2F;&#x2F; manipulate the array while we are sorting it. This assumes that other</span><br><span class="line">    &#x2F;&#x2F; threads also synchronize their accesses to the array.</span><br><span class="line">    synchronized(array) &#123;</span><br><span class="line">        &#x2F;&#x2F; now sort elements in array</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized 代码块通过javap生成的字节码中包含** monitorenter 和 monitorexit **指令。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-e4d758d80ff508f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/533/format/webp" alt="javap生成的字节码"></p>
<p>执行 monitorenter 指令可以获取对象的monitor，而 lock.wait() 方法通过调用native方法wait(0)实现，其中接口注释中有这么一句：</p>
<blockquote>
<p>The current thread must own this object’s monitor.</p>
</blockquote>
<p>表示线程执行*<em>lock.wait() *</em>方法时，必须持有该lock对象的monitor，如果wait方法在synchronized代码中执行，该线程很显然已经持有了monitor。</p>
<p><strong>3.2 为什么wait方法可能抛出InterruptedException异常</strong><br>这个异常大家应该都知道，当我们调用了某个线程的interrupt方法时，对应的线程会抛出这个异常，wait方法也不希望破坏这种规则，因此就算当前线程因为wait一直在阻塞，当某个线程希望它起来继续执行的时候，它还是得从阻塞态恢复过来，因此wait方法被唤醒起来的时候会去检测这个状态，当有线程interrupt了它的时候，它就会抛出这个异常从阻塞状态恢复过来。</p>
<p>这里有两点要注意：</p>
<blockquote>
<p>1.如果被interrupt的线程只是创建了，并没有start，那等他start之后进入wait态之后也是不能会恢复的；</p>
<p>2.如果被interrupt的线程已经start了，在进入wait之前，如果有线程调用了其interrupt方法，那这个wait等于什么都没做，会直接跳出来，不会阻塞；</p>
</blockquote>
<p><strong>3.3 notify执行之后立马唤醒线程吗?</strong><br>其实hotspot里真正的实现是退出同步块的时候才会去真正唤醒对应的线程，不过这个也是个默认策略，也可以改的，在notify之后立马唤醒相关线程。</p>
<p><strong>3.4 notifyAll是怎么实现全唤起所有线程</strong><br>或许大家立马想到这个简单，一个for循环就搞定了，不过在JVM里没实现这么简单，而是借助了monitorexit，上面提到了当某个线程从wait状态恢复出来的时候，要先获取锁，然后再退出同步块，所以notifyAll的实现是调用notify的线程在退出其同步块的时候唤醒起最后一个进入wait状态的线程，然后这个线程退出同步块的时候继续唤醒其倒数第二个进入wait状态的线程，依次类推，同样这这是一个策略的问题，JVM里提供了挨个直接唤醒线程的参数，不过都很罕见就不提了。</p>
<p><strong>3.5 wait的线程是否会影响load</strong><br>这个或许是大家比较关心的话题，因为关乎系统性能问题，wait/nofity 是通过JVM里的 park/unpark 机制来实现的，在Linux下这种机制又是通过<br>pthread_cond_wait/pthread_cond_signal 来玩的，因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。</p>
<p>4 其他资料<br>1.<a href="https://blog.csdn.net/boling_cavalry/article/details/77793224" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之一：JVM源码分析</a><br>2.<a href="https://blog.csdn.net/boling_cavalry/article/details/77897108" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之二：修改JVM源码看参数</a><br>3.<a href="https://blog.csdn.net/boling_cavalry/article/details/77995069" target="_blank" rel="noopener">Java的wait()、notify()学习三部曲之三：修改JVM源码控制抢锁顺序</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（七）：深入分析Synchronized原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 20:44:03" itemprop="dateCreated datePublished" datetime="2020-06-01T20:44:03+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/Synchronized/" itemprop="url" rel="index"><span itemprop="name">Synchronized</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>记得开始学习Java的时候，一遇到多线程情况就使用synchronized，相对于当时的我们来说synchronized是这么的神奇而又强大，那个时候我们赋予它一个名字“同步”，也成为了我们解决多线程情况的百试不爽的良药。但是，<strong>随着学习的进行我们知道在JDK1.5之前synchronized是一个重量级锁，相对于j.u.c.Lock，它会显得那么笨重，以至于我们认为它不是那么的高效而慢慢摒弃它。</strong></p>
<p>不过，<strong>随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。</strong>下面来一起探索synchronized的基本使用、实现机制、Java是如何对它进行了优化、锁优化机制、锁的存储结构等升级过程。</p>
<h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h4><p>Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。<strong>Synchronized的作用主要有三个：</strong></p>
<blockquote>
<p><strong>1.原子性</strong>：确保线程互斥的访问同步代码；<br><strong>2.可见性</strong>：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的<strong>“对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值”</strong>来保证的；<br><strong>3.有序性</strong>：有效解决重排序问题，即<strong>“一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</strong>；</p>
</blockquote>
<p>从语法上讲，<strong>Synchronized可以把任何一个非null对象作为”锁”，</strong>在HotSpot JVM实现中，锁有个专门的名字：对象监视器（Object Monitor）。</p>
<p><strong>Synchronized总共有三种用法：</strong></p>
<blockquote>
<p>1.当synchronized作用在实例方法时，<strong>监视器锁（monitor）便是对象实例（this）</strong>；<br>2.当synchronized作用在静态方法时，<strong>监视器锁（monitor）便是对象的Class实例</strong>，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；<br>3.当synchronized作用在某一个对象实例时，<strong>监视器锁（monitor）便是括号括起来的对象实例</strong>；</p>
</blockquote>
<p>注意，<strong>synchronized 内置锁</strong>是一种 对象锁（锁的是对象而非引用变量），作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是可重入的。<strong>其可重入最大的作用是避免死锁</strong>，如：</p>
<blockquote>
<p>子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁；</p>
</blockquote>
<h4 id="2-同步原理"><a href="#2-同步原理" class="headerlink" title="2 同步原理"></a>2 同步原理</h4><p>数据同步需要依赖锁，那锁的同步又依赖谁？<strong>synchronized给出的答案是在软件层面依赖JVM，而j.u.c.Lock给出的答案是在硬件层面依赖特殊的CPU指令。</strong></p>
<p>当一个线程访问同步代码块时，<strong>首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，</strong>那么它是如何来实现这个机制的呢？我们先看一段简单的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.paddx.test.concurrent;</span><br><span class="line">public class SynchronizedDemo &#123;</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;Method 1 start&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看反编译后结果：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-b98084591219da8c.png" alt="反编译结果"></p>
<p><strong>1. monitorenter：</strong>每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p>
<blockquote>
<p><strong>1.如果monitor的进入数为0，</strong>则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；<br><strong>2.如果线程已经占有该monitor，</strong>只是重新进入，则进入monitor的进入数加1；<br><strong>3.如果其他线程已经占用了monitor，</strong>则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</p>
</blockquote>
<p><strong>2.monitorexit：</strong>执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<blockquote>
<p><strong>monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</strong></p>
</blockquote>
<p>通过上面两段描述，我们应该能很清楚的看出Synchronized的实现原理,<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，</strong>这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，<strong>否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</strong></p>
<p>再来看一下同步方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.paddx.test.concurrent;</span><br><span class="line"></span><br><span class="line">public class SynchronizedMethod &#123;</span><br><span class="line">    public synchronized void method() &#123;</span><br><span class="line">        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查看反编译后结果：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-8b7734120fae6645.png" alt="反编译结果"></p>
<p>从编译的结果来看，方法的同步并没有通过指令<strong>monitorenter</strong>和 <strong>monitorexit</strong> 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 ACC_SYNCHRONIZED 标示符。<strong>JVM就是根据该标示符来实现方法的同步的：</strong></p>
<blockquote>
<p>当方法调用时，<strong>调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</strong></p>
</blockquote>
<p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。<strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度,</strong>会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
<h4 id="3-同步概念"><a href="#3-同步概念" class="headerlink" title="3 同步概念"></a>3 同步概念</h4><h5 id="3-1-Java对象头"><a href="#3-1-Java对象头" class="headerlink" title="3.1 Java对象头"></a>3.1 Java对象头</h5><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-9a78f7ea7671a031.png" alt=""></p>
<blockquote>
<p>1.实例数据：存放类的属性数据信息，包括父类的属性信息；<br>2.对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；<br>3.对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
</blockquote>
<p>Synchronized用的锁就是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：<strong>Mark Word（标记字段）</strong>、 <strong>Class Pointer（类型指针）</strong>。其中 Class Pointer是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。 </p>
<p>Java对象头具体结构描述如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-2ab6edc7f91a1535.png" alt="Java对象头结构组成"></p>
<p>Mark Word用于存储对象自身的运行时数据，如：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。下图是Java对象头 无锁状态下Mark Word部分的存储结构（32位虚拟机）：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-063a9a5dc677cd12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/679/format/webp" alt="Mark Word存储结构"><br>对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，可能变化为存储以下4种数据：</p>
<p>Mark Word可能存储4种数据<br>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p>
<p>64位Mark Word存储结构<br>对象头的最后两位存储了锁的标志位，01是初始状态，未加锁，其对象头里存储的是对象本身的哈希码，随着锁级别的不同，对象头里会存储不同的内容。偏向锁存储的是当前占用此对象的线程ID；而轻量级则存储指向线程栈中锁记录的指针。从这里我们可以看到，“锁”这个东西，可能是个锁记录+对象头里的引用指针（判断线程是否拥有锁时将线程的锁记录地址和对象头里的指针地址比较)，也可能是对象头里的线程ID（判断线程是否拥有锁时将线程的ID和对象头里存储的线程ID比较）。</p>
<p>HotSpot虚拟机对象头Mark Word</p>
<p><strong>64位JVM如果开启+UseCompressedOops选项，Klass Word（类指针）、数组长度区域长度也将由64位压缩至32位。</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/114422601" target="_blank" rel="noopener">Object obj=new Object()占多少字节啊？</a></p>
<p>3.2 对象头中Mark Word与线程中Lock Record<br>在线程进入同步代码块的时候，如果此同步对象没有被锁定，即它的锁标志位是01，则虚拟机首先在当前线程的栈中创建我们称之为“锁记录（Lock Record）”的空间，用于存储锁对象的Mark Word的拷贝，官方把这个拷贝称为Displaced Mark Word。整个Mark Word及其拷贝至关重要。</p>
<p>Lock Record是线程私有的数据结构，每一个线程都有一个可用Lock Record列表，同时还有一个全局的可用列表。每一个被锁住的对象Mark Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock Record的起始地址），同时Lock Record中有一个Owner字段存放拥有该锁的线程的唯一标识（或者object mark word），表示该锁被这个线程占用。如下图所示为Lock Record的内部结构：</p>
<p>Lock Record    描述<br>Owner    初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；<br>EntryQ    关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程；<br>RcThis    表示blocked或waiting在该monitor record上的所有线程的个数；<br>Nest    用来实现 重入锁的计数；<br>HashCode    保存从对象头拷贝过来的HashCode值（可能还包含GC age）。<br>Candidate    用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。<br>3.3 监视器（Monitor）<br>任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态。Synchronized在JVM里的实现都是 基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<p>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；<br>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；<br>那什么是Monitor？可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。</p>
<p>与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p>
<p>也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       &#x3D; NULL;</span><br><span class="line">    _count        &#x3D; 0; &#x2F;&#x2F; 记录个数</span><br><span class="line">    _waiters      &#x3D; 0,</span><br><span class="line">    _recursions   &#x3D; 0;</span><br><span class="line">    _object       &#x3D; NULL;</span><br><span class="line">    _owner        &#x3D; NULL;</span><br><span class="line">    _WaitSet      &#x3D; NULL; &#x2F;&#x2F; 处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  &#x3D; 0 ;</span><br><span class="line">    _Responsible  &#x3D; NULL ;</span><br><span class="line">    _succ         &#x3D; NULL ;</span><br><span class="line">    _cxq          &#x3D; NULL ;</span><br><span class="line">    FreeNext      &#x3D; NULL ;</span><br><span class="line">    _EntryList    &#x3D; NULL ; &#x2F;&#x2F; 处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">    _SpinFreq     &#x3D; 0 ;</span><br><span class="line">    _SpinClock    &#x3D; 0 ;</span><br><span class="line">    OwnerIsThread &#x3D; 0 ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：</p>
<p>首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；<br>若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒；<br>若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；<br>同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。</p>
<p>监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p>
<p>什么时候需要协作？ 比如：</p>
<p>一个线程向缓冲区写数据，另一个线程从缓冲区读数据，如果读线程发现缓冲区为空就会等待，当写线程向缓冲区写入数据，就会唤醒读线程，这里读线程和写线程就是一个合作关系。JVM通过Object类的wait方法来使自己等待，在调用wait方法后，该线程会释放它持有的监视器，直到其他线程通知它才有执行的机会。一个线程调用notify方法通知在等待的线程，这个等待的线程并不会马上执行，而是要通知线程释放监视器后，它重新获取监视器才有执行的机会。如果刚好唤醒的这个线程需要的监视器被其他线程抢占，那么这个线程会继续等待。Object类中的notifyAll方法可以解决这个问题，它可以唤醒所有等待的线程，总有一个线程执行。</p>
<p>如上图所示，一个线程通过1号门进入Entry Set(入口区)，如果在入口区没有线程等待，那么这个线程就会获取监视器成为监视器的Owner，然后执行监视区域的代码。如果在入口区中有其它线程在等待，那么新来的线程也会和这些线程一起等待。线程在持有监视器的过程中，有两个选择，一个是正常执行监视器区域的代码，释放监视器，通过5号门退出监视器；还有可能等待某个条件的出现，于是它会通过3号门到Wait Set（等待区）休息，直到相应的条件满足后再通过4号门进入重新获取监视器再执行。</p>
<p>注意：</p>
<p>当一个线程释放监视器时，在入口区和等待区的等待线程都会去竞争监视器，如果入口区的线程赢了，会从2号门进入；如果等待区的线程赢了会从4号门进入。只有通过3号门才能进入等待区，在等待区中的线程只有通过4号门才能退出等待区，也就是说一个线程只有在持有监视器时才能执行wait操作，处于等待的线程只有再次获得监视器才能退出等待状态。</p>
<h5 id="4-锁的优化"><a href="#4-锁的优化" class="headerlink" title="4 锁的优化"></a>4 锁的优化</h5><p>从JDK5引入了现代操作系统新增加的CAS原子操作（ JDK5中并没有对synchronized关键字做优化，而是体现在J.U.C中，所以在该版本concurrent包有更好的性能 ），从JDK6开始，就对synchronized的实现机制进行了较大调整，包括使用JDK5引进的CAS自旋之外，还增加了自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁这些优化策略。由于此关键字的优化使得性能极大提高，同时语义清晰、操作简单、无需手动关闭，所以推荐在允许的情况下尽量使用此关键字，同时在性能上此关键字还有优化的空间。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁。但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p>
<p>在 JDK 1.6 中默认是开启偏向锁和轻量级锁的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。</p>
<h5 id="4-1-自旋锁"><a href="#4-1-自旋锁" class="headerlink" title="4.1 自旋锁"></a>4.1 自旋锁</h5><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。</p>
<p>所以引入自旋锁，何谓自旋锁？</p>
<p>所谓自旋锁，就是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p>
<p>自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了CPU处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
<p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整。</p>
<p>如果通过参数-XX:PreBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如多自旋一两次就可以获取锁），是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p>
<h5 id="4-2-适应性自旋锁"><a href="#4-2-适应性自旋锁" class="headerlink" title="4.2 适应性自旋锁"></a>4.2 适应性自旋锁</h5><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。那它如何进行适应性自旋呢？</p>
<p>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
<p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p>
<h5 id="4-3-锁消除"><a href="#4-3-锁消除" class="headerlink" title="4.3 锁消除"></a>4.3 锁消除</h5><p>为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。</p>
<p>锁消除的依据是逃逸分析的数据支持</p>
<p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于程序员来说这还不清楚么？在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？虽然没有显示使用锁，但是在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void vectorTest()&#123;</span><br><span class="line">    Vector&lt;String&gt; vector &#x3D; new Vector&lt;String&gt;();</span><br><span class="line">    for(int i &#x3D; 0 ; i &lt; 10 ; i++)&#123;</span><br><span class="line">        vector.add(i + &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p>
<h5 id="4-4-锁粗化"><a href="#4-4-锁粗化" class="headerlink" title="4.4 锁粗化"></a>4.4 锁粗化</h5><p>在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是 为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p>
<p>在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</p>
<p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</p>
<p>如上面实例：</p>
<p>vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<p>4.5 偏向锁<br>偏向锁是JDK6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p>
<p>偏向锁是在单线程执行代码块时使用的机制，如果在多线程并发的环境下（即线程A尚未执行完同步代码块，线程B发起了申请锁的申请），则一定会转化为轻量级锁或者重量级锁。</p>
<p>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。如果并发数较大同时同步代码块执行时间较长，则被多个线程同时访问的概率就很大，就可以使用参数-XX:-UseBiasedLocking来禁止偏向锁(但这是个JVM参数，不能针对某个对象锁来单独设置)。</p>
<p>引入偏向锁主要目的是：为了在没有多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。因为轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗也必须小于节省下来的CAS原子指令的性能消耗）。</p>
<p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<p>那么偏向锁是如何来减少不必要的CAS操作呢？首先我们看下无竞争下锁存在什么问题：</p>
<p>现在几乎所有的锁都是可重入的，即已经获得锁的线程可以多次锁住/解锁监视对象，按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，因此偏向锁的想法是 一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。</p>
<p>CAS为什么会引入本地延迟？这要从SMP（对称多处理器）架构说起，下图大概表明了SMP的结构：</p>
<p>SMP（对称多处理器）架构<br>其意思是 所有的CPU会共享一条系统总线（BUS），靠此总线连接主存。每个核都有自己的一级缓存，各核相对于BUS对称分布，因此这种结构称为“对称多处理器”。</p>
<p>而CAS的全称为Compare-And-Swap，是一条CPU的原子指令，其作用是让CPU比较后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。</p>
<p>例如：Core1和Core2可能会同时把主存中某个位置的值Load到自己的L1 Cache中，当Core1在自己的L1 Cache中修改这个位置的值时，会通过总线，使Core2中L1 Cache对应的值“失效”，而Core2一旦发现自己L1 Cache中的值失效（称为Cache命中缺失）则会通过总线从内存中加载该地址最新的值，大家通过总线的来回通信称为“Cache一致性流量”，因为总线被设计为固定的“通信能力”，如果Cache一致性流量过大，总线将成为瓶颈。而当Core1和Core2中的值再次一致时，称为“Cache一致性”，从这个层面来说，锁设计的终极目标便是减少Cache一致性流量。</p>
<p>而CAS恰好会导致Cache一致性流量，如果有很多线程都共享同一个对象，当某个Core CAS成功时必然会引起总线风暴，这就是所谓的本地延迟，本质上偏向锁就是为了消除CAS，降低Cache一致性流量。</p>
<p>Cache一致性：</p>
<p>上面提到Cache一致性，其实是有协议支持的，现在通用的协议是MESI（最早由Intel开始支持），具体参考：<a href="http://en.wikipedia.org/wiki/MESI_protocol。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/MESI_protocol。</a></p>
<p>Cache一致性流量的例外情况：</p>
<p>其实也不是所有的CAS都会导致总线风暴，这跟Cache一致性协议有关，具体参考：<a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot" target="_blank" rel="noopener">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a></p>
<p>NUMA(Non Uniform Memory Access Achitecture）架构：</p>
<p>与SMP对应还有非对称多处理器架构，现在主要应用在一些高端处理器上，主要特点是没有总线，没有公用主存，每个Core有自己的内存，针对这种结构此处不做讨论。</p>
<p>所以，当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步块时不需要花费CAS操作来争夺锁资源，只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：</p>
<p>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；<br>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；<br>如果测试线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；<br>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；<br>执行同步代码块；<br>偏向锁的释放采用了 一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要 等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<p>暂停拥有偏向锁的线程；<br>判断锁对象是否还处于被锁定状态，否，则恢复到无锁状态（01），以允许其余线程竞争。是，则挂起持有锁的当前线程，并将指向当前线程的锁记录地址的指针放入对象头Mark Word，升级为轻量级锁状态（00），然后恢复持有锁的当前线程，进入轻量级锁的竞争模式；<br>注意：此处将 当前线程挂起再恢复的过程中并没有发生锁的转移，仍然在当前线程手中，只是穿插了个 “将对象头中的线程ID变更为指向锁记录地址的指针” 这么个事。</p>
<p>偏向锁的获取和释放过程<br>4.6 轻量级锁<br>引入轻量级锁的主要目的是 在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p>
<p>在线程进入同步块时，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。此时线程堆栈与对象头的状态如下图所示：</p>
<p>轻量级锁CAS操作之前线程堆栈与对象的状态<br>拷贝对象头中的Mark Word复制到锁记录（Lock Record）中；</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象Mark Word中的Lock Word更新为指向当前线程Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（4），否则执行步骤（5）；</p>
<p>如果这个更新动作成功了，那么当前线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，此时线程堆栈与对象头的状态如下图所示：</p>
<p>轻量级锁CAS操作之后线程堆栈与对象的状态<br>如果这个更新操作失败了，虚拟机首先会检查对象Mark Word中的Lock Word是否指向当前线程的栈帧，如果是，就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，进入自旋执行（3），若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</p>
<p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<p>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word；<br>如果替换成功，整个同步过程就完成了，恢复到无锁状态（01）；<br>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程；<br>对于轻量级锁，其性能提升的依据是 “对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<p>轻量级锁的获取和释放过程<br>为什么升级为轻量锁时要把对象头里的Mark Word复制到线程栈的锁记录中呢？</p>
<p>因为在申请对象锁时 需要以该值作为CAS的比较条件，同时在升级到重量级锁的时候，能通过这个比较判定是否在持有锁的过程中此锁被其他线程申请过，如果被其他线程申请了，则在释放锁的时候要唤醒被挂起的线程。</p>
<p>为什么会尝试CAS不成功以及什么情况下会不成功？</p>
<p>CAS本身是不带锁机制的，其是通过比较而来。假设如下场景：线程A和线程B都在对象头里的锁标识为无锁状态进入，那么如线程A先更新对象头为其锁记录指针成功之后，线程B再用CAS去更新，就会发现此时的对象头已经不是其操作前的对象HashCode了，所以CAS会失败。也就是说，只有两个线程并发申请锁的时候会发生CAS失败。</p>
<p>然后线程B进行CAS自旋，等待对象头的锁标识重新变回无锁状态或对象头内容等于对象HashCode（因为这是线程B做CAS操作前的值），这也就意味着线程A执行结束（参见后面轻量级锁的撤销，只有线程A执行完毕撤销锁了才会重置对象头），此时线程B的CAS操作终于成功了，于是线程B获得了锁以及执行同步代码的权限。如果线程A的执行时间较长，线程B经过若干次CAS时钟没有成功，则锁膨胀为重量级锁，即线程B被挂起阻塞、等待重新调度。</p>
<p>此处，如何理解“轻量级”？“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。</p>
<p>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，必然就会导致轻量级锁膨胀为重量级锁。</p>
<p>4.7 重量级锁<br>Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。</p>
<p>4.8 重量级锁、轻量级锁和偏向锁之间转换<br>重量级锁、轻量级锁和偏向锁之间转换<br>Synchronized偏向锁、轻量级锁及重量级锁转换流程</p>
<h5 id="5-锁的优劣"><a href="#5-锁的优劣" class="headerlink" title="5 锁的优劣"></a>5 锁的优劣</h5><p>各种锁并不是相互代替的，而是在不同场景下的不同选择，绝对不是说重量级锁就是不合适的。每种锁是只能升级，不能降级，即由偏向锁-&gt;轻量级锁-&gt;重量级锁，而这个过程就是开销逐渐加大的过程。</p>
<p>如果是单线程使用，那偏向锁毫无疑问代价最小，并且它就能解决问题，连CAS都不用做，仅仅在内存中比较下对象头就可以了；<br>如果出现了其他线程竞争，则偏向锁就会升级为轻量级锁；<br>如果其他线程通过一定次数的CAS尝试没有成功，则进入重量级锁；<br>在第3种情况下进入同步代码块就 要做偏向锁建立、偏向锁撤销、轻量级锁建立、升级到重量级锁，最终还是得靠重量级锁来解决问题，那这样的代价就比直接用重量级锁要大不少了。所以使用哪种技术，一定要看其所处的环境及场景，在绝大多数的情况下，偏向锁是有效的，这是基于HotSpot作者发现的“大多数锁只会由同一线程并发申请”的经验规律。</p>
<p>锁的优劣<br>6 扩展资料<br>JVM源码分析之synchronized实现<br>自旋锁、排队自旋锁、MCS锁、CLH锁<br>深入理解Java并发之synchronized实现原理</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">啃碎并发（六）：Java线程同步与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:30:50 / 修改时间：20:43:38" itemprop="dateCreated datePublished" datetime="2020-06-01T20:30:50+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p><strong>为何要使用Java线程同步？</strong> Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时，将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。</p>
<p><strong>但其并发编程的根本，就是使线程间进行正确的通信。</strong>其中两个比较重要的关键点，如下：</p>
<blockquote>
<p>1.线程通信：重点关注线程同步的几种方式；<br>2.正确通信：重点关注是否有线程安全问题；</p>
</blockquote>
<p>Java中提供了很多线程同步操作，比如：<strong>synchronized关键字、wait/notifyAll、ReentrantLock、Condition、一些并发包下的工具类、Semaphore，ThreadLocal、AbstractQueuedSynchronizer等。</strong>本文主要说明一下这几种同步方式的使用及优劣。</p>
<h4 id="1-ReentrantLock可重入锁"><a href="#1-ReentrantLock可重入锁" class="headerlink" title="1 ReentrantLock可重入锁"></a>1 ReentrantLock可重入锁</h4><p>自JDK5开始，新增了Lock接口以及它的一个实现类ReentrantLock。ReentrantLock可重入锁是J.U.C包内置的一个锁对象，可以用来实现同步，基本使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line">    private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(5000l);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLockTest reentrantLockTest &#x3D; new ReentrantLockTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子表示 同一时间段只能有1个线程执行execute方法，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br></pre></td></tr></table></figure>
<p>可重入锁中可重入表示的意义在于<strong>对于同一个线程，可以继续调用加锁的方法，而不会被挂起。</strong>可重入锁内部维护一个计数器，对于同一个线程调用lock方法，计数器+1，调用unlock方法，计数器-1。</p>
<p>举个例子再次说明一下可重入的意思：在一个加锁方法execute中调用另外一个加锁方法anotherLock并不会被挂起，可以直接调用(调用execute方法时计数器+1，然后内部又调用了anotherLock方法，计数器+1，变成了2)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void execute() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void anotherLock() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 do something synchronize</span><br><span class="line">Thread-0 invoke anotherLock</span><br><span class="line">&#x2F;&#x2F; 隔了5秒钟 输入下面</span><br><span class="line">Thread-1 do something synchronize</span><br><span class="line">Thread-1 invoke anotherLock</span><br></pre></td></tr></table></figure>

<h5 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2 synchronized"></a>2 synchronized</h5><p>synchronized跟ReentrantLock一样，也支持可重入锁。但是它是 一个关键字，是一种语法级别的同步方式，称为内置锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedKeyWordTest &#123;</span><br><span class="line">    public synchronized void execute() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; do something synchronize&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            anotherLock();</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void anotherLock() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; invoke anotherLock&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SynchronizedKeyWordTest reentrantLockTest &#x3D; new SynchronizedKeyWordTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                reentrantLockTest.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果跟ReentrantLock一样，这个例子说明内置锁可以作用在方法上。synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。</p>
<p>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</p>
<p><strong>synchronized跟ReentrantLock相比，有几点局限性：</strong></p>
<blockquote>
<p>1.加锁的时候不能设置超时。ReentrantLock有提供tryLock方法，可以设置超时时间，如果超过了这个时间并且没有获取到锁，就会放弃，而synchronized却没有这种功能；<br>2.ReentrantLock可以使用多个Condition，而synchronized却只能有1个<br>3.不能中断一个试图获得锁的线程；<br>4.ReentrantLock可以选择公平锁和非公平锁；<br>5.ReentrantLock可以获得正在等待线程的个数，计数器等；</p>
</blockquote>
<p>所以，Lock的操作与synchronized相比，灵活性更高，而且Lock提供多种方式获取锁，有Lock、ReadWriteLock接口，以及实现这两个接口的ReentrantLock类、ReentrantReadWriteLock类。</p>
<p><strong>关于Lock对象和synchronized关键字选择的考量：</strong></p>
<blockquote>
<p>1.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。<br>2.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码。<br>3.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁。</p>
</blockquote>
<p>在性能考量上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<h5 id="3-Condition条件对象"><a href="#3-Condition条件对象" class="headerlink" title="3 Condition条件对象"></a>3 Condition条件对象</h5><p>Condition条件对象的意义在于 对于一个已经获取Lock锁的线程，如果还需要等待其他条件才能继续执行的情况下，才会使用Condition条件对象。</p>
<p>Condition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。</p>
<p>为什么方法名不直接叫wait()/notify()/nofityAll()？因为Object的这几个方法是final的，不可重写！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">        Condition condition &#x3D; lock.newCondition();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中thread1执行到condition.await()时，当前线程会被挂起，直到thread2调用了condition.signalAll()方法之后，thread1才会重新被激活执行。</p>
<p>这里需要注意的是thread1调用Condition的await方法之后，thread1线程释放锁，然后马上加入到Condition的等待队列，由于thread1释放了锁，thread2获得锁并执行，thread2执行signalAll方法之后，Condition中的等待队列thread1被取出并加入到AQS中，接下来thread2执行完毕之后释放锁，由于thread1已经在AQS的等待队列中，所以thread1被唤醒，继续执行。</p>
<p>传统线程的通信方式，Condition都可以实现。Condition的强大之处在于它可以为多个线程间建立不同的Condition。</p>
<p>注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
<h5 id="4-wait-amp-notify-notifyAll方式"><a href="#4-wait-amp-notify-notifyAll方式" class="headerlink" title="4 wait&amp;notify/notifyAll方式"></a>4 wait&amp;notify/notifyAll方式</h5><p>Java线程的状态转换图与相关方法，如下：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2fb881c9f4656c80.png" alt="线程状态转换图"></p>
<p>在图中，红框标识的部分方法，可以认为已过时，不再使用。上图中的方法能够参与到线程同步中的方法，如下：</p>
<p><strong>1. wait、notify、notifyAll方法：线程中通信可以使用的方法。线程中调用了wait方法，则进入阻塞状态，只有等另一个线程调用与wait同一个对象的notify方法。这里有个特殊的地方，调用wait或者notify，前提是需要获取锁，也就是说，需要在同步块中做以上操作。</strong></p>
<blockquote>
<p>wait/notifyAll方式跟ReentrantLock/Condition方式的原理是一样的。</p>
<p>Java中每个对象都拥有一个内置锁，在内置锁中调用wait，notify方法相当于调用锁的Condition条件对象的await和signalAll方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyAllTest &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; wait for condition&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            this.wait();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; sleep 5 secs&quot;);</span><br><span class="line">            Thread.sleep(5000l);</span><br><span class="line">            this.notifyAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WaitNotifyAllTest waitNotifyAllTest &#x3D; new WaitNotifyAllTest();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                waitNotifyAllTest.doNotify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 调用wait/notifyAll方法的时候一定要获得当前线程的锁，否则会发生IllegalMonitorStateException异常。</p>
<p><strong>2.join方法：该方法主要作用是在该线程中的run方法结束后，才往下执行。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.thread.simple;</span><br><span class="line">public class ThreadJoin &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread&#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                   System.err.println(&quot;线程&quot;+Thread.currentThread().getId()+&quot; 打印信息&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">     </span><br><span class="line">        try &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(&quot;主线程打印信息&quot;);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. yield方法：线程本身的调度方法，使用时线程可以在run方法执行完毕时，调用该方法，告知线程已可以出让CPU资源。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. sleep方法：通过sleep(millis)</strong>使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep方法告诉操作系统 至少在指定时间内不需为线程调度器为该线程分配执行时间片，并不释放锁（如果当前已经持有锁）。实际上，调用sleep方法时并不要求持有任何锁。</p>
<p>所以，sleep方法并不需要持有任何形式的锁，也就不需要包裹在synchronized中。</p>
<h5 id="5-ThreadLocal"><a href="#5-ThreadLocal" class="headerlink" title="5 ThreadLocal"></a>5 ThreadLocal</h5><p>ThreadLocal是一种把变量放到线程本地的方式来实现线程同步的。比如：SimpleDateFormat不是一个线程安全的类，可以使用ThreadLocal实现同步，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal &#x3D; new ThreadLocal&lt;SimpleDateFormat&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected SimpleDateFormat initialValue() &#123;</span><br><span class="line">            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Date date &#x3D; new Date();</span><br><span class="line">                System.out.println(dateFormatThreadLocal.get().format(date));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为何SimpleDateFormat不是线程安全的类？具体请参考：</strong></p>
<p><a href="https://blog.csdn.net/zdp072/article/details/41044059" target="_blank" rel="noopener">https://blog.csdn.net/zdp072/article/details/41044059</a><br><a href="https://blog.csdn.net/zq602316498/article/details/40263083" target="_blank" rel="noopener">https://blog.csdn.net/zq602316498/article/details/40263083</a></p>
<p>ThreadLocal与同步机制的对比选择：</p>
<blockquote>
<p>ThreadLocal与同步机制都是 为了解决多线程中相同变量的访问冲突问题。<br>前者采用以 “空间换时间” 的方法，后者采用以 “时间换空间” 的方式。</p>
</blockquote>
<h5 id="6-volatile修饰变量"><a href="#6-volatile修饰变量" class="headerlink" title="6 volatile修饰变量"></a>6 volatile修饰变量</h5><p>volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;只给出要修改的代码，其余代码与上同</span><br><span class="line">public class Bank &#123;</span><br><span class="line">    &#x2F;&#x2F;需要同步的变量加上volatile</span><br><span class="line">    private volatile int account &#x3D; 100;</span><br><span class="line">    public int getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这里不再需要synchronized </span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account +&#x3D; money;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。</p>
<h5 id="7-Semaphore信号量"><a href="#7-Semaphore信号量" class="headerlink" title="7 Semaphore信号量"></a>7 Semaphore信号量</h5><p>Semaphore信号量被用于控制特定资源在同一个时间被访问的个数。类似连接池的概念，保证资源可以被合理的使用。可以使用构造器初始化资源个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class SemaphoreTest &#123;</span><br><span class="line"></span><br><span class="line">    private static Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date());</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-0 Mon Apr 18 18:03:46 CST 2016</span><br><span class="line">Thread-3 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-2 Mon Apr 18 18:03:51 CST 2016</span><br><span class="line">Thread-4 Mon Apr 18 18:03:56 CST 2016</span><br></pre></td></tr></table></figure>

<h5 id="8-并发包下的工具类"><a href="#8-并发包下的工具类" class="headerlink" title="8 并发包下的工具类"></a>8 并发包下的工具类</h5><h5 id="8-1-CountDownLatch"><a href="#8-1-CountDownLatch" class="headerlink" title="8.1 CountDownLatch"></a>8.1 CountDownLatch</h5><p>CountDownLatch是一个计数器，它的构造方法中需要设置一个数值，用来设定计数的次数。每次调用countDown()方法之后，这个计数器都会减去1，CountDownLatch会一直阻塞着调用await()方法的线程，直到计数器的值变为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;all thread over&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-2 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-3 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-4 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-0 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">Thread-1 Mon Apr 18 18:18:30 CST 2016 run</span><br><span class="line">all thread over</span><br></pre></td></tr></table></figure>

<h5 id="8-2-CyclicBarrier"><a href="#8-2-CyclicBarrier" class="headerlink" title="8.2 CyclicBarrier"></a>8.2 CyclicBarrier</h5><p>CyclicBarrier阻塞调用的线程，直到条件满足时，阻塞的线程同时被打开。</p>
<p>调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。</p>
<p>在CyclicBarrier的构造方法中，还可以设置一个barrierAction。在所有的屏障都到达之后，会启动一个线程来运行这里面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(5);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 5; i ++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int secs &#x3D; random.nextInt(5);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; run, sleep &quot; + secs + &quot; secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(secs * 1000);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; &quot; + new Date() + &quot; runs over&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比CountDownLatch，CyclicBarrier是可以被循环使用的，而且遇到线程中断等情况时，还可以利用reset()方法，重置计数器，从这些方面来说，CyclicBarrier会比CountDownLatch更加灵活一些。</p>
<h5 id="9-使用原子变量实现线程同步"><a href="#9-使用原子变量实现线程同步" class="headerlink" title="9 使用原子变量实现线程同步"></a>9 使用原子变量实现线程同步</h5><p>有时需要使用线程同步的根本原因在于 对普通变量的操作不是原子的。那么什么是原子操作呢？</p>
<p>原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作<br>即-这几种行为要么同时完成，要么都不完成。</p>
<p>在java.util.concurrent.atomic包中提供了创建原子类型变量的工具类，使用该类可以简化线程同步。比如：其中AtomicInteger以原子方式更新int的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Bank &#123;</span><br><span class="line">    private AtomicInteger account &#x3D; new AtomicInteger(100);</span><br><span class="line"></span><br><span class="line">    public AtomicInteger getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save(int money) &#123;</span><br><span class="line">        account.addAndGet(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-AbstractQueuedSynchronizer"><a href="#10-AbstractQueuedSynchronizer" class="headerlink" title="10 AbstractQueuedSynchronizer"></a>10 AbstractQueuedSynchronizer</h5><p>AQS是很多同步工具类的基础，比如：ReentrantLock里的公平锁和非公平锁，Semaphore里的公平锁和非公平锁，CountDownLatch里的锁等他们的底层都是使用AbstractQueuedSynchronizer完成的。</p>
<p>基于AbstractQueuedSynchronizer自定义实现一个独占锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class MySynchronizer extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">        if(compareAndSetState(0, 1)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean tryRelease(int arg) &#123;</span><br><span class="line">        setState(0);</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MySynchronizer mySynchronizer &#x3D; new MySynchronizer();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; will sleep 5 secs&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(5000l);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot; continue&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        System.err.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mySynchronizer.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; run&quot;);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mySynchronizer.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-使用阻塞队列实现线程同步"><a href="#11-使用阻塞队列实现线程同步" class="headerlink" title="11 使用阻塞队列实现线程同步"></a>11 使用阻塞队列实现线程同步</h5><p>前面几种同步方式都是基于底层实现的线程同步，但是在实际开发当中，应当尽量远离底层结构。本节主要是使用LinkedBlockingQueue<E>来实现线程的同步。</p>
<p>LinkedBlockingQueue<E>是一个基于链表的队列，先进先出的顺序（FIFO），范围任意的blocking queue。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.xhj.thread;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BlockingSynchronizedThread &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义一个阻塞队列用来存储生产出来的商品</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private LinkedBlockingQueue&lt;Integer&gt; queue &#x3D; new LinkedBlockingQueue&lt;Integer&gt;();</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义生产商品个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final int size &#x3D; 10;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int flag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    private class LinkBlockThread implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            int new_flag &#x3D; flag++;</span><br><span class="line">            System.out.println(&quot;启动线程 &quot; + new_flag);</span><br><span class="line">            if (new_flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                    int b &#x3D; new Random().nextInt(255);</span><br><span class="line">                    System.out.println(&quot;生产商品：&quot; + b + &quot;号&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(b);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; size &#x2F; 2; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int n &#x3D; queue.take();</span><br><span class="line">                        System.out.println(&quot;消费者买去了&quot; + n + &quot;号商品&quot;);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;仓库中还有商品：&quot; + queue.size() + &quot;个&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; TODO: handle exception</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingSynchronizedThread bst &#x3D; new BlockingSynchronizedThread();</span><br><span class="line">        LinkBlockThread lbt &#x3D; bst.new LinkBlockThread();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(lbt);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(lbt);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">啃碎并发（五）：Java线程安全特性与问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 20:09:11 / 修改时间：20:30:20" itemprop="dateCreated datePublished" datetime="2020-06-01T20:09:11+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在单线程中不会出现线程安全问题，而在多线程编程中，有可能会出现同时访问同一个<strong>共享、可变资源</strong>的情况，这种资源可以是：<strong>一个变量、一个对象、一个文件等。</strong>特别注意两点：</p>
<blockquote>
<p>1.共享： 意味着该资源可以由多个线程同时访问；<br>2.可变： 意味着该资源可以在其生命周期内被修改；</p>
</blockquote>
<p>简单的说，<strong>如果你的代码在单线程下执行和在多线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</strong>那么，当进行多线程编程时，我们又会面临哪些线程安全的要求呢？又是要如何去解决的呢？</p>
<h4 id="1-线程安全特性"><a href="#1-线程安全特性" class="headerlink" title="1 线程安全特性"></a>1 线程安全特性</h4><h5 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h5><p>跟数据库事务的原子性概念差不多，<strong>即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。</strong></p>
<p>关于原子性，一个非常经典的例子就是银行转账问题：</p>
<blockquote>
<p>比如：A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。</p>
</blockquote>
<h5 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a>1.2 可见性</h5><p>可见性是指，<strong>当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。</strong>可见性问题是好多人忽略或者理解错误的一点。</p>
<p>CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。<strong>每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。</strong>此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p><strong>这一点是操作系统或者说是硬件层面的机制，</strong>所以很多应用开发人员经常会忽略。</p>
<h5 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3 有序性"></a>1.3 有序性</h5><p>有序性指的是，<strong>程序执行的顺序按照代码的先后顺序执行。</strong>以下面这段代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean started &#x3D; false; &#x2F;&#x2F; 语句1</span><br><span class="line">long counter &#x3D; 0L; &#x2F;&#x2F; 语句2</span><br><span class="line">counter &#x3D; 1; &#x2F;&#x2F; 语句3</span><br><span class="line">started &#x3D; true; &#x2F;&#x2F; 语句4</span><br></pre></td></tr></table></figure>

<p>从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。</p>
<p><strong>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。</strong></p>
<p>讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，<strong>CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。</strong></p>
<h4 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2 线程安全问题"></a>2 线程安全问题</h4><h5 id="2-1-竞态条件与临界区"><a href="#2-1-竞态条件与临界区" class="headerlink" title="2.1 竞态条件与临界区"></a>2.1 竞态条件与临界区</h5><p>线程之间共享堆空间，在编程的时候就要格外注意避免竞态条件。危险在于多个线程同时访问相同的资源并进行读写操作。<strong>当其中一个线程需要根据某个变量的状态来相应执行某个操作的之前，该变量很可能已经被其它线程修改。</strong></p>
<blockquote>
<p>也就是说，当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在<strong>竞态条件</strong>。导致竟态条件发生的代码称作<strong>临界区</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 以下这段代码就存在竞态条件，其中return ++count就是临界区。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Obj &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public int incr()&#123;</span><br><span class="line">        return ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-死锁"><a href="#2-2-死锁" class="headerlink" title="2.2 死锁"></a>2.2 死锁</h5><p>死锁：<strong>指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</strong>此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>关于死锁发生的条件：</strong></p>
<blockquote>
<p><strong>1.互斥条件：</strong>线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。<br><strong>2.请求和保持条件：</strong>线程T1至少已经保持了一个资源R1占用，但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。<br><strong>3.不剥夺条件：</strong>线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。<br><strong>4.环路等待条件：</strong>在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn}，进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。<strong>（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）。</strong></p>
</blockquote>
<h5 id="2-3-活锁"><a href="#2-3-活锁" class="headerlink" title="2.3 活锁"></a>2.3 活锁</h5><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。<strong>这样你让我，我让你，最后两个线程都无法使用资源。</strong></p>
<p><strong>关于“死锁与活锁”的比喻：</strong></p>
<blockquote>
<p><strong>死锁：</strong>迎面开来的汽车A和汽车B过马路，汽车A得到了半条路的资源（满足死锁发生条件1：资源访问是排他性的，我占了路你就不能上来，除非你爬我头上去），汽车B占了汽车A的另外半条路的资源，A想过去必须请求另一半被B占用的道路（死锁发生条件2：必须整条车身的空间才能开过去，我已经占了一半，尼玛另一半的路被B占用了），B若想过去也必须等待A让路，A是辆兰博基尼，B是开奇瑞QQ的屌丝，A素质比较低开窗对B狂骂：快给老子让开，B很生气，你妈逼的，老子就不让（死锁发生条件3：在未使用完资源前，不能被其他线程剥夺），于是两者相互僵持一个都走不了（死锁发生条件4：环路等待条件），而且导致整条道上的后续车辆也走不了。</p>
<p><strong>活锁：</strong>马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。</p>
</blockquote>
<h5 id="2-4-饥饿"><a href="#2-4-饥饿" class="headerlink" title="2.4 饥饿"></a>2.4 饥饿</h5><p>饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，<strong>T2可能永远等待。</strong></p>
<p>也就是，如果一个线程因为CPU时间全部被其他线程抢走而得不到CPU运行时间，<strong>这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</strong></p>
<p><strong>关于“饥饿”的比喻：</strong></p>
<blockquote>
<p>在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的却没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p>
</blockquote>
<p>在Java中，下面三个常见的原因会导致线程饥饿，如下：</p>
<p><strong>1.高优先级线程吞噬所有的低优先级线程的CPU时间</strong></p>
<blockquote>
<p>你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。</p>
</blockquote>
<p><strong>2.线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问</strong></p>
<blockquote>
<p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p>
</blockquote>
<p><strong>3.线程在等待一个本身（在其上调用wait()）也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒</strong></p>
<blockquote>
<p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
</blockquote>
<h5 id="2-5-公平"><a href="#2-5-公平" class="headerlink" title="2.5 公平"></a>2.5 公平</h5><p><strong>解决饥饿的方案被称之为“公平性” – 即所有线程均能公平地获得运行机会。</strong>在Java中实现公平性方案，需要：</p>
<blockquote>
<p>1.使用锁，而不是同步块；<br>2.使用公平锁；<br>3.注意性能方面；</p>
</blockquote>
<p>在Java中实现公平性，虽Java不可能实现100%的公平性，依然可以通过同步结构在线程间实现公平性的提高。</p>
<p>首先来学习一段简单的同步态代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    public synchronized void doSynchronized () &#123;</span><br><span class="line">        &#x2F;&#x2F; do a lot of work which takes a long time</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个线程调用doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。</p>
<p>改为 使用锁方式替代同步块，为了提高等待线程的公平性，我们使用锁方式来替代同步块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Synchronizer&#123;</span><br><span class="line">    Lock lock &#x3D; new Lock();</span><br><span class="line">    public void doSynchronized() throws InterruptedException&#123;</span><br><span class="line">        this.lock.lock();</span><br><span class="line">        &#x2F;&#x2F;critical section, do a lot of work which takes a long time</span><br><span class="line">        this.lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。下面是用Lock类做的一个实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Lock&#123;</span><br><span class="line"></span><br><span class="line">    private boolean isLocked      &#x3D; false;</span><br><span class="line"></span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public synchronized void lock() throws InterruptedException&#123;</span><br><span class="line">        while(isLocked)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; true;</span><br><span class="line">        lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line"></span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果锁已经锁上（校对注：这里指的是isLocked等于true时），这些线程将阻塞在while(isLocked)循环的wait()调用里面。要记住的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。</p>
<p>这回看下doSynchronized()，你会注意到在lock()和unlock()之间的注释：在这两个调用之间的代码将运行很长一段时间。进一步设想，这段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。</p>
<p>在早些时候提到过，同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。</p>
<p>但我们能够改变这种情况，如下：</p>
<blockquote>
<p>当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。</p>
</blockquote>
<p>下面将上面Lock类转变为公平锁FairLock。你会注意到新的实现和之前的Lock类中的同步和wait()/notify()稍有不同。重点是，每一个调用lock()的线程都会进入一个队列，当解锁时，只有队列里的第一个线程被允许锁住FairLock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class FairLock &#123;</span><br><span class="line">    private boolean isLocked &#x3D; false;</span><br><span class="line">    private Thread lockingThread &#x3D; null;</span><br><span class="line">    private List&lt;QueueObject&gt; waitingThreads &#x3D; new ArrayList&lt;QueueObject&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() throws InterruptedException&#123;</span><br><span class="line">        &#x2F;&#x2F; 当前线程创建“令牌”</span><br><span class="line">        QueueObject queueObject &#x3D; new QueueObject();</span><br><span class="line">        boolean isLockedForThisThread &#x3D; true;</span><br><span class="line">        synchronized(this)&#123;</span><br><span class="line">            &#x2F;&#x2F; 所有线程的queueObject令牌，入队</span><br><span class="line">            waitingThreads.add(queueObject);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(isLockedForThisThread)&#123;</span><br><span class="line">            synchronized(this)&#123;</span><br><span class="line">                &#x2F;&#x2F; 1. 判断是否已被锁住：是否已有线程获得锁，正在执行同步代码块</span><br><span class="line">                &#x2F;&#x2F; 2. 判断头部令牌与当前线程令牌是否一致：也就是只锁住头部令牌对应的线程；</span><br><span class="line">                isLockedForThisThread &#x3D; isLocked || waitingThreads.get(0) !&#x3D; queueObject;</span><br><span class="line">                if(!isLockedForThisThread)&#123;</span><br><span class="line">                    isLocked &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; 移除头部令牌</span><br><span class="line">                    waitingThreads.remove(queueObject);</span><br><span class="line">                    lockingThread &#x3D; Thread.currentThread();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                &#x2F;&#x2F; 其他线程执行doWait()，进行等待</span><br><span class="line">                queueObject.doWait();</span><br><span class="line">            &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                synchronized(this) &#123; waitingThreads.remove(queueObject); &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void unlock()&#123;</span><br><span class="line">        if(this.lockingThread !&#x3D; Thread.currentThread())&#123;</span><br><span class="line">            throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked &#x3D; false;</span><br><span class="line">        lockingThread &#x3D; null;</span><br><span class="line">        if(waitingThreads.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 唤醒头部令牌对应的线程，可以执行</span><br><span class="line">            waitingThreads.get(0).doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class QueueObject &#123;</span><br><span class="line">    private boolean isNotified &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public synchronized void doWait() throws InterruptedException &#123;</span><br><span class="line">        while(!isNotified)&#123;</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        this.isNotified &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doNotify() &#123;</span><br><span class="line">        this.isNotified &#x3D; true;</span><br><span class="line">        this.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        return this &#x3D;&#x3D; o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先注意到lock()方法不在声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。</p>
<blockquote>
<p>FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程进行入队操作。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p>
</blockquote>
<p>还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个线程调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。</p>
<p>最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p>
<h4 id="3-如何确保线程安全特性"><a href="#3-如何确保线程安全特性" class="headerlink" title="3 如何确保线程安全特性"></a>3 如何确保线程安全特性</h4><h5 id="3-1-如何确保原子性"><a href="#3-1-如何确保原子性" class="headerlink" title="3.1 如何确保原子性"></a>3.1 如何确保原子性</h5><h5 id="3-1-1-锁和同步"><a href="#3-1-1-锁和同步" class="headerlink" title="3.1.1 锁和同步"></a>3.1.1 锁和同步</h5><p>常用的保证Java操作原子性的工具是 锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与锁类似的是同步方法或者同步代码块。使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testLock () &#123;</span><br><span class="line">    synchronized (anyObject)&#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        i &#x3D; j + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论使用锁还是synchronized，本质都是一样，通过锁或同步来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。</p>
<h5 id="3-1-2-CAS（compare-and-swap）"><a href="#3-1-2-CAS（compare-and-swap）" class="headerlink" title="3.1.2 CAS（compare and swap）"></a>3.1.2 CAS（compare and swap）</h5><p>基础类型变量自增（i++）是一种常被新手误以为是原子操作而实际不是的操作。Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger atomicInteger &#x3D; new AtomicInteger();</span><br><span class="line">for(int b &#x3D; 0; b &lt; numThreads; b++) &#123;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">        for(int a &#x3D; 0; a &lt; iteration; a++) &#123;</span><br><span class="line">            atomicInteger.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-如何确保可见性"><a href="#3-2-如何确保可见性" class="headerlink" title="3.2 如何确保可见性"></a>3.2 如何确保可见性</h5><p>Java提供了volatile关键字来保证可见性。当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它线程缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</p>
<p>volatile适用场景：volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isRunning &#x3D; false;</span><br><span class="line">public void start () &#123;</span><br><span class="line">    new Thread( () -&gt; &#123;</span><br><span class="line">        while(isRunning) &#123;</span><br><span class="line">            someOperation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">public void stop () &#123;</span><br><span class="line">    isRunning &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种实现方式下，即使其它线程通过调用stop()方法将isRunning设置为false，循环也不一定会立即结束。可以通过volatile关键字，保证while循环及时得到isRunning最新的状态从而及时停止循环，结束线程。</p>
<h5 id="3-3-如何确保有序性"><a href="#3-3-如何确保有序性" class="headerlink" title="3.3 如何确保有序性"></a>3.3 如何确保有序性</h5><p>上文讲过编译器和处理器对指令进行重新排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序过程并不会影响单线程程序的执行，却可能影响多线程程序并发执行的正确性。</p>
<blockquote>
<p>Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。</p>
</blockquote>
<p>synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。</p>
<p>除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。</p>
<p>happens-before原则（先行发生原则），如下：</p>
<blockquote>
<p><strong>1.传递规则：</strong>如果操作1在操作2前面，而操作2在操作3前面，则操作1肯定会在操作3前发生。该规则说明了happens-before原则具有传递性。<br><strong>2.锁定规则：</strong>一个unlock操作肯定会在后面对同一个锁的lock操作前发生。这个很好理解，锁只有被释放了才会被再次获取。<br><strong>3.volatile变量规则：</strong>对一个被volatile修饰的写操作先发生于后面对该变量的读操作。<br><strong>4.程序次序规则：</strong>一个线程内，按照代码顺序执行。<br><strong>5.线程启动规则：</strong>Thread对象的start()方法先发生于此线程的其它动作。<br><strong>6.线程终结原则：</strong>线程的终止检测后发生于线程中其它的所有操作。<br><strong>7.线程中断规则： *<em>对线程interrupt()方法的调用先发生于对该中断异常的获取。<br>*</em>8.对象终结规则：</strong>一个对象构造先于它的finalize发生。</p>
</blockquote>
<h5 id="4-关于线程安全的几个为什么"><a href="#4-关于线程安全的几个为什么" class="headerlink" title="4 关于线程安全的几个为什么"></a>4 关于线程安全的几个为什么</h5><p><strong>1.平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？</strong></p>
<blockquote>
<p>锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。</p>
</blockquote>
<p><strong>2.锁和synchronized为何能保证可见性？</strong></p>
<blockquote>
<p>根据JDK 7的Java doc中对concurrent包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由happen-before原则推断出在读操作之前发生。</p>
</blockquote>
<p><strong>3.既然锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？</strong></p>
<blockquote>
<p>synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。</p>
</blockquote>
<p><strong>4.既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？</strong></p>
<blockquote>
<p>锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。</p>
</blockquote>
<p><strong>5.还有没有别的办法保证线程安全？</strong></p>
<blockquote>
<p>有。尽可能避免引起非线程安全的条件——共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。</p>
</blockquote>
<p><strong>6.synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？</strong></p>
<blockquote>
<p>synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">Android基础 -- 四大组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 15:33:18 / 修改时间：15:33:19" itemprop="dateCreated datePublished" datetime="2020-06-01T15:33:18+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/FrameWork/" itemprop="url" rel="index"><span itemprop="name">FrameWork</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="Activity生命周期.png"/>

<p>注意：当activityB在activityA之前启动时，将在A上调用onPause()回调。在A的onPause()返回之前，将不会创建B，因此请确保onPause()中不要做任何冗长的操作。</p>
<ol>
<li><p>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为entire lifetime。</p>
</li>
<li><p>当执行onStart回调方法时，Activity开始被用户所见（也就是说，onCreate时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到onStop之前，此阶段Activity都是被用户可见，称之为visible lifetime。</p>
</li>
<li><p>当执行到onResume回调方法时，Activity可以响应用户交互，一直到onPause方法之前，此阶段Activity称之为foreground lifetime。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序启动</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.687</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.819</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.823</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.802</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.815</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.824</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">54.156</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.672</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.716</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.717</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br><span class="line"><span class="comment">// 按下home键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.703</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.722</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.723</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 返回应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.968</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">20.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.274</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.925</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.959</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.963</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入task</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.056</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.068</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.088</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 后台终止</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">51.310</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="打印生命周期"><a href="#打印生命周期" class="headerlink" title="打印生命周期"></a>打印生命周期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BaseActivity"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onCreate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onResume"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onPause"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onRestart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStop"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onNewIntent"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onActivityResult"><a href="#onActivityResult" class="headerlink" title="onActivityResult"></a>onActivityResult</h2><p>MainActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>), 0)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"MainActivity-onActivityResult"</span>);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"result = "</span> + data.getStringExtra(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecondActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"value"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">setResult(<span class="number">1</span>, intent);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.038</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.070</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.166</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.170</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.659</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.672</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.679</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.682</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">40.015</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">48.965</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onActivityResult</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: result = hearing</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.395</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.396</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br></pre></td></tr></table></figure>

<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>通过android:launchMode配置</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是Activity默认的启动模式，在不指定Activity启动模式的情况下，所有Activity使用的都是standard模式。</p>
<p>在standard模式下，每当启动一个新的Activity，它就会进入任务栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会判断该Activity在栈中是否存在，每次启动都会创建一个新的实例。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop模式与standard类似，不同的是，当启动的Activity已经位于栈顶时，则直接使用它不创建新的实例，此时栈顶的Activity实例会调onNewIntent方法。如果启动的Activity没有位于栈顶时，则创建一个新的实例位于栈顶。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>如果希望Activity在整个应用程序中只存在一个实例，可以使用singleTask模式，当Activity的启动模式指定为 singleTask，每次启动该Activity时，系统首先会检查栈中是否存在该Activity的实例，如果发现已经存在则直接使用该实例，此时栈顶的Activity实例会调onNewIntent方法，并将当前Activity之上的所有Activity出栈，如果没有发现则创建一个新的实例。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>在程序开发过程中，如果需要Activity在整个系统中都只有一个实例，这时就需要用到singleInstance模式。指定为singleInstance模式的Activity会启动一个新的任务栈来管理这个Activity。</p>
<p>singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。采用这种模式启动Activity会分为一下两种情况：</p>
<ul>
<li>如果要启动的Activity不存在，系统会创建一个新的任务栈，在创建该Activity的实例，并把该Activity加入栈顶.</li>
<li>如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。</li>
</ul>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a>allowTaskReparenting</h3><p>如果该Activity的allowTaskReparenting设置为true，它进入后台，当一个和它有相同affinity的Task进入前台时，它会重新宿主，进入到该前台的task中。</p>
<table>
<thead>
<tr>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">taskAffinity</th>
<th align="center">allowTaskReparenting</th>
</tr>
</thead>
<tbody><tr>
<td align="center">application1</td>
<td align="center">Activity1</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">application2</td>
<td align="center">Activity2</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>创建两个工程：application1和application2，分别含有Activity1和Activity2，它们的taskAffinity相同，Activity1的allowTaskReparenting为true。</p>
<p>首先，我们启动application1,加载Activity1，然后按Home键，使该task（假设为task1）进入后台。然后启动application2，默认加载Activity2。本来应该是显示Activity2，但是我们却看到了Activity1。实际上Activity2也被加载了，只是Activity1重新宿主，所以看到了Activity1。</p>
<h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>如果加载某个Activity的intent，Flag被设置成FLAG_ACTIVITY_NEW_TASK时，它会首先检查是否存在与自己taskAffinity相同的Task，如果存在，那么它会直接宿主到该Task中，如果不存在则重新创建Task。</p>
<p>写一个应用，包含两个Activity：Activity1的taskAffinity为<code>com.hearing.task</code>，Activity2为入口，且点击Activity2会以FLAG_ACTIVITY_NEW_TASK启动Activity1。再写一个应用MyActivity，它包含一个Activity（MyActivity），其taskAffinity为<code>com.hearing.task</code>。</p>
<p>首先启动MyActivity，然后Home回桌面，然后打开Activity2，点击Activity2，进入Activity1。然后按返回键。进入Activity的顺序为Activity2-&gt;Activity1，而返回时顺序为Activity1-&gt;MyActivity。这就说明了一个问题，Activity1在启动时，重新宿主到了MyActivity所在的Task中去了。</p>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul>
<li>当一个应用程序加载一个singleTask模式的Activity时，首先该Activity会检查是否存在与它的taskAffinity相同的Task。如果存在，那么检查是否实例化，如果已经实例化，那么销毁在该Activity以上的Activity并调用onNewIntent。如果没有实例化，那么该Activity实例化并入栈。如果不存在，那么就重新创建Task，并入栈。</li>
<li>当一个应用程序加载一个singleInstance模式的Activity时，如果该Activity没有被实例化，那么就重新创建一个Task，并入栈，如果已经被实例化，那么就调用该Activity的onNewIntent.singleInstance的Activity所在的Task不允许存在其他Activity，任何从该Activity加载的其它Activity（假设为Activity2）都会被放入其它的Task中，如果存在与Activity2相同affinity的Task，则在该Task内创建Activity2。如果不存在，则重新生成新的Task并入栈。</li>
</ul>
<h2 id="onSaveInstanceState与onRestoreInstanceState方法"><a href="#onSaveInstanceState与onRestoreInstanceState方法" class="headerlink" title="onSaveInstanceState与onRestoreInstanceState方法"></a>onSaveInstanceState与onRestoreInstanceState方法</h2><p>onSaveInstanceState主要是用于保存一些临时数据，当Activity恢复时，可以恢复对应的数据，onRestoreInstanceState当Activity被重新创建时调用，可以从该 方法中恢复一些之前保存过的数据。</p>
<p>onSaveInstanceState一般是在Activity被“打断”的情况下被调用，例如被覆盖，包括全覆盖或者部分覆盖，或者按home退到后台，或者灭屏。另外一种情况就是Activity被重新创建会调用，例如用户在当前Activity旋转屏幕，或者用户调用recreate方法。点击返回键该方法不会被调用。onSaveInstanceState的调用顺序是在onPause之后，onStop之前。</p>
<p>onRestoreInstanceState一般是在Activty被重新创建恢复时会被调用，例如用户切换横竖屏。用户将Activty挂后台，切换系统设置，然后再启动该Activity。</p>
<h2 id="启动方式的问题"><a href="#启动方式的问题" class="headerlink" title="启动方式的问题"></a>启动方式的问题</h2><p>MainActivity是SingleTask或者SingleInstance模式，启动TestActivity，TestActivity马上跳转到MainActivity，这种情况下，MainActivity的onResume会回调两次。日志如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onCreate</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onStart</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">TestActivity onCreate</span><br><span class="line">TestActivity onStart</span><br><span class="line">TestActivity onResume</span><br><span class="line">TestActivity onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onNewIntent</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">TestActivity onStop</span><br></pre></td></tr></table></figure>

<p>适当延时500ms再跳转回MainActivity可以解决这个问题（可能由于业务场景不同，会带来新的问题）。</p>
<p>在<a href="https://stackoverflow.com/questions/11092101/startactivity-on-foreground-application-causes-onpause-onresume" target="_blank" rel="noopener">stackoverflow</a>上也有人发现过类似的问题。</p>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>普通广播（Normal Broadcast）</li>
<li>系统广播（System Broadcast）</li>
<li>有序广播（Ordered Broadcast）</li>
<li>粘性广播（Sticky Broadcast）（已弃用）</li>
<li>App应用内广播（Local Broadcast）</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="BroadcastReceiver-1"><a href="#BroadcastReceiver-1" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><ul>
<li>继承BroadcastReceivre基类</li>
<li>必须复写抽象方法onReceive()方法</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><ul>
<li>常驻：不受任何组件声明周期影响</li>
<li>耗电，占内存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    //此<span class="attr">broadcastReceiver</span>能否接收其他<span class="attr">App</span>的发出的广播</span></span><br><span class="line"><span class="tag">    //默认值是由<span class="attr">receiver</span>中有无<span class="attr">intent-filter</span>决定的：如果有<span class="attr">intent-filter</span>，默认值为<span class="attr">true</span>，否则为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    //继承<span class="attr">BroadcastReceiver</span>子类的类名</span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".mBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">    //具有相应权限的广播发送者发送的广播才能被此<span class="attr">BroadcastReceiver</span>所接收；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">BroadcastReceiver</span>运行所处的进程</span></span><br><span class="line"><span class="tag">    //默认为<span class="attr">app</span>的进程，可以指定独立的进程</span></span><br><span class="line"><span class="tag">    //注：<span class="attr">Android</span>四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    //用于指定此广播接收器将接收的广播类型</span><br><span class="line">    //本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><ul>
<li>非常驻，灵活</li>
<li>手动释放</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">    mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> mBroadcastReceiver();</span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中</span></span><br><span class="line"><span class="comment">// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</li>
<li>假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>生命周期:</p>
<ol>
<li><p>startService()</p>
<ul>
<li>作用：启动Service服务</li>
<li>手动调用startService()后，自动调用内部方法：onCreate()、onStartCommand() </li>
<li>如果一个service被startService多次启动，onCreate()只会调用一次 </li>
<li>onStartCommand()调用次数=startService()次数</li>
</ul>
</li>
<li><p>stopService()</p>
<ul>
<li>作用：关闭Service服务 </li>
<li>手动调用stopService()后，自动调用内部方法：onDestory() </li>
<li>如果一个service被启动且被绑定，如果没有在绑定的前提下stopService()是无法停止服务的。</li>
</ul>
</li>
<li><p>bindService()</p>
<ul>
<li>作用：绑定Service服务 </li>
<li>手动调用bindService()后，自动调用内部方法：onCreate()、onBind()</li>
</ul>
</li>
<li><p>unbindService()</p>
<ul>
<li>作用：解绑Service服务 </li>
<li>手动调用unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory()</li>
</ul>
</li>
</ol>
<p>接口函数：</p>
<ul>
<li>onStartCommand()：当其他组件调用startService()方法请求启动Service时，该方法被回调。一旦Service启动，它会在后台独立运行。当Service执行完以后，需调用stopSelf() 或 stopService()方法停止Service。（若您只希望bind Service，则无需调用这些方法）</li>
<li>onBind()：当其他组件调用bindService()方法请求绑定Service时，该方法被回调。该方法返回一个IBinder接口，该接口是Service与绑定的组件进行交互的桥梁。若Service未绑定其他组件，该方法应返回null。</li>
<li>onCreate()：当Service第一次创建时，回调该方法。该方法只被回调一次，并在onStartCommand() 或 onBind()方法被回调之前执行。若Service处于运行状态，该方法不会回调。</li>
<li>onDestroy()：当Service被销毁时回调，在该方法中应清除一些占用的资源，如停止线程、接触绑定注册的监听器或broadcast receiver 等。该方法是Service中的最后一个回调。</li>
</ul>
<p>启动方式：</p>
<ul>
<li>Started：其他组件调用startService()方法启动一个Service。一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。通常，一个被start的Service会在后台执行单独的操作，也并不给启动它的组件返回结果。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</li>
<li>Bound：其他组件调用bindService()方法绑定一个Service。通过绑定方式启动的Service是一个client-server结构，该Service可以与绑定它的组件进行交互。一个bound service仅在有组件与其绑定时才会运行（A bound service runs only as long as another application component is bound to it），多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。</li>
</ul>
<p>注意：</p>
<ul>
<li>Service运行在主线程中（A service runs in the main thread of its hosting process），Service并不是一个新的线程，也不是新的进程。也就是说，若您需要在Service中执行较为耗时的操作（如播放音乐、执行网络请求等），需要在Service中创建一个新的线程。这可以防止ANR的发生，同时主线程可以执行正常的UI操作。</li>
<li>如果某个组件通过调用startService()启动了Service（系统会回调onStartCommand()方法），那么直到在Service中手动调用stopSelf()方法、或在其他组件中手动调用stopService()方法，该Service才会停止。</li>
<li>如果某个组件通过调用bindService()绑定了Service（系统不会回调onStartCommand()方法），只要该组件与Service处于绑定状态，Service就会一直运行，当Service不再与组件绑定时，该Service将被destroy。</li>
<li>当系统内存低时，系统将强制停止Service的运行；若Service绑定了正在与用户交互的activity，那么该Service将不大可能被系统kill（ less likely to be killed）。如果创建的是前台Service，那么该Service几乎不会被kill（almost never be killed）。否则，当创建了一个长时间在后台运行的Service后，系统会降低该Service在后台任务栈中的级别——这意味着它容易被kill（lower its position in the list of background tasks over time and the service will become highly susceptible to killing），所以在开发Service时，需要使Service变得容易被restart，因为一旦Service被kill，再restart它需要其资源可用时才行</li>
</ul>
<h2 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.servicetest.MyService"</span> &gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承IntentService类"><a href="#继承IntentService类" class="headerlink" title="继承IntentService类"></a>继承IntentService类</h2><ul>
<li>默认在子线程中处理回传到onStartCommand()方法中的Intent；</li>
<li>在重写的onHandleIntent()方法中处理按时间排序的Intent队列，所以不用担心多线程（multi-threading）带来的问题。</li>
<li>当所有请求处理完成后，自动停止service，无需手动调用stopSelf()方法；</li>
<li>默认实现了onBind()方法，并返回null；</li>
<li>默认实现了onStartCommand()方法，并将回传的Intent以序列的形式发送给onHandleIntent()，只需重写该方法并处理Intent即可。</li>
</ul>
<h2 id="继承Service类"><a href="#继承Service类" class="headerlink" title="继承Service类"></a>继承Service类</h2><p>如果需要在Service中执行多线程而不是处理一个请求队列，那么需要继承Service类，分别处理每个Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Log.d(TAG, <span class="string">"onCreate() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">		Log.d(TAG, <span class="string">"onStartCommand() executed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">		Log.d(TAG, <span class="string">"onDestroy() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mBinder;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="string">"TAG"</span>, <span class="string">"startDownload() executed"</span>);</span><br><span class="line">			<span class="comment">// 执行具体的下载任务</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onStartCommand()返回一个整形变量，该变量必须是下列常量之一：</p>
<ul>
<li>START_NOT_STICKY：若执行完onStartCommand()方法后，系统就kill了service，不要再重新创建service，除非系统回传了一个pending intent。这避免了在不必要的时候运行service，您的应用也可以restart任何未完成的操作。</li>
<li>START_STICKY：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()。dangerous不要重新传递最后一个Intent（do not redeliver the last intent）。相反，系统回调onStartCommand()时回传一个空的Intent，除非有 pending intents传递，否则Intent将为null。该模式适合做一些类似播放音乐的操作。</li>
<li>START_REDELIVER_INTENT：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()并将最后一个Intent回传至该方法。任何 pending intents都会被轮流传递。该模式适合做一些类似下载文件的操作。</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>startService(intent)方法将立即返回，并回调onStartCommand()（请不要手动调用该方法），若该Service未处于运行状态，系统将首先回调onCreate()，接着再回调onStartCommand()。若您希望Service可以返回结果，那么需要通过调用getBroadcast 返回的PendingIntent启动Service（将PendingIntent包装为Intent），service可使用broadcast 传递结果。</p>
<p>多个启动Service的请求可能导致onStartCommand()多次调用，但只需调用stopSelf() 、 stopService()这两个方法之一，就可停止该服务。</p>
<h2 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h2><ul>
<li>通过其他组件调用bindService()方法可以绑定一个Service以保持长连接（long-standing connection），这时一般不允许其他组件调用startService()启动Service。</li>
<li>当其他组件需要与Service交互或者需要跨进程通信时，可以创建一个bound Service。</li>
<li>为创建一个bound Service，必须重写onBind()回调，该方法返回一个IBinder接口。该接口时组件与Service通信的桥梁。组件调用bindService()与Service绑定，该组件可获取IBinder接口，一旦获取该接口，就可以调用Service中的方法。一旦没有组件与Service绑定，系统将destroy它，您不必手动停止它。</li>
<li>为创建一个bound Service，必须定义一个接口 ，该接口指定组件与Service如何通信。定义的接口在组件与Service之间，且必须实现IBinder接口。这正是onBind()的返回值。一旦组件接收了IBinder，组件与Service便可以开始通信。</li>
<li>多个组件可同时与Service绑定，当组件与Service交互结束后，可调用unbindService()方法解绑。bound Service比start Service要复杂，故我将在后续单独翻译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyService.MyBinder myBinder;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">			myBinder = (MyService.MyBinder) service;</span><br><span class="line">			myBinder.startDownload();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.start_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			startService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">			Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			stopService(stopIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">			Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">			unbindService(connection);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行前台Service"><a href="#运行前台Service" class="headerlink" title="运行前台Service"></a>运行前台Service</h2><ul>
<li>前台Service用于动态通知消息，如天气预报。该Service不易被kill。前台Service必须提供status bar，只有前台Service被destroy后，status bar才能消失。</li>
<li>举例来说，一个播放音乐的Service必须是前台Service，只有这样用户才能确知其运行状态。为前台Service提供的status bar可以显示当前音乐的播放状态，并可以启动播放音乐的Activity。</li>
<li>调用startForeground()可以启动前台Service。该方法接收两个参数，参数一是一个int型变量，用户指定该通知的唯一性标识，而参数而是一个Notification用于配置status bar</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ContentProvider为不同的应用之间数据共享提供统一的接口，Android系统中应用内部的数据是对外隔离的，要想让其它应用能够访问自己的数据，可以使用ContentProvider，其底层采用Binder机制实现跨进程共享数据。</p>
<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p>Uri的四个组成部分：content://contacts/people/5</p>
<ul>
<li>schema：已由Android固定设置为content://</li>
<li>authority：ContentProvider权限，在AndroidMenifest中设置权限</li>
<li>path：要操作的数据库表</li>
<li>id：查询的关键字（可选字段）</li>
</ul>
<p>Uri匹配模式：Uri的匹配表示要查询的数据，对于单个数据查询，可直接使用Uri定位具体的资源位置，但当范围查询时就需要结合通配符的使用，Uri提供以下两种通配符：</p>
<ul>
<li><code>*</code>：匹配由任意长度的任何有效字符组成的字符串</li>
<li><code>#</code>：匹配由任意长度的数字字符组成的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table2/*  //多数据查询</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/#</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/6  //单数据查询</span></span><br></pre></td></tr></table></figure>

<p>Uri的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(“content:<span class="comment">//contacts/people/5")</span></span><br></pre></td></tr></table></figure>

<p>Uri创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过将 ID 值追加到 URI 末尾来访问表中的单个行</span></span><br><span class="line">Uri singleUri = ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ContentUris"><a href="#ContentUris" class="headerlink" title="ContentUris"></a>ContentUris</h2><p>核心方法有两个：</p>
<ul>
<li>withAppendedId()：向Uri追加一个id</li>
<li>parseId()：从Uri中获取id</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>)</span><br><span class="line"><span class="comment">// 生成的Uri为：content://cn.scu.myprovider/user/7</span></span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user/7"</span>)</span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>

<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p>UriMatcher的作用：</p>
<ul>
<li>在ContentProvider 中注册Uri</li>
<li>根据 Uri 匹配 ContentProvider 中对应的数据表</li>
</ul>
<p>使用步骤：</p>
<ol>
<li>初始化UriMatcher对象</li>
<li>在ContentProvider 中注册URI（addURI()）</li>
<li>根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match()）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line"><span class="comment">// 常量UriMatcher.NO_MATCH：不匹配任何路径的返回码</span></span><br><span class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI</span></span><br><span class="line"><span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user1"</span>, URI_CODE_a); </span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user2"</span>, URI_CODE_b); </span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a</span></span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(matcher.match(uri)) &#123;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_a:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser1;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_b:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentProvider-1"><a href="#ContentProvider-1" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>ContentProvider主要以表格的形式组织数据，同时也支持文件数据。它一般配合数据库共同使用，实现对外共享数据的目的，所以它需要对数据库的增删改查操作，ContentProvider也为我们提供了相应的操作方法，使用时只需实现即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后或打开系统后其它进程第一次访问该ContentProvider时由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前 Uri 所代表数据的MIME类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>上述CRUD方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</li>
<li>存在多线程并发访问，需要实现线程同步<ul>
<li>若ContentProvider的数据存储方式是使用一个SQLite，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</li>
<li>若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</li>
</ul>
</li>
</ol>
<h2 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a>ContentResolver</h2><p>外部进程通过 ContentResolver类，从而与ContentProvider类进行交互。一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大，所以在ContentProvider类上加多了一个 ContentResolver类对所有的ContentProvider进行统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.hearing.provider.myprovider/tablename"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条记录</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">values.put(<span class="string">"age"</span>, <span class="number">26</span>);</span><br><span class="line">resolver.insert(uri, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tablename表中所有记录</span></span><br><span class="line">Cursor cursor = resolver.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"tablename data"</span>);</span><br><span class="line"><span class="keyword">while</span>(cursor.moveToNext()) &#123;</span><br><span class="line">   Log.i(<span class="string">"ContentTest"</span>, <span class="string">"tablename_id="</span>+ cursor.getInt(<span class="number">0</span>)+ <span class="string">", name="</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把id为1的记录的name字段值更改新为zhang1</span></span><br><span class="line">ContentValues updateValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">updateValues.put(<span class="string">"name"</span>, <span class="string">"zhang1"</span>);</span><br><span class="line">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.update(updateIdUri, updateValues, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除id为2的记录，即字段age</span></span><br><span class="line">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.delete(deleteIdUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>com.hearing.provider.myprovider需要在 AndroidManifest.xml 中进行注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"com.hearing.provider.myprovider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ContentObserver"><a href="#ContentObserver" class="headerlink" title="ContentObserver"></a>ContentObserver</h2><p>观察者模式：当ContentProvider中指定Uri中的数据变化时通知外界。</p>
<p>自定义ContentObserver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, myOberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">        db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values); </span><br><span class="line">        getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line">getContentResolver().unregisterContentObserver(myOberver);</span><br></pre></td></tr></table></figure>

<h2 id="MimeType"><a href="#MimeType" class="headerlink" title="MimeType"></a>MimeType</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>ContentProvider 类具有两个返回 MIME 类型的方法：</p>
<ul>
<li>getType()：任何ContentProvider程序都需要实现的方法</li>
<li>getStreamTypes()：当ContentProvider程序提供文件时要求实现</li>
</ul>
<h3 id="table的-MIME-类型"><a href="#table的-MIME-类型" class="headerlink" title="table的 MIME 类型"></a>table的 MIME 类型</h3><p>getType() 方法会返回一个 MIME 格式的 String，后者描述内容 URI 参数返回的数据类型。Uri 参数可以是pattern，而不是特定 URI；在这种情况下应该返回与匹配该模式的内容 URI 关联的数据类型。</p>
<p>对于文本、HTML 或 JPEG 等常见数据类型，getType() 应该为该数据返回标准 MIME 类型。</p>
<p>对于指向一个或多个表数据行的内容 URI，getType() 应该以 Android 供应商特有 MIME 格式返回 MIME 类型：</p>
<ol>
<li>类型部分：vnd</li>
<li>子类型部分：<ul>
<li>如果 URI 模式用于单个行：android.cursor.item/</li>
<li>如果 URI 模式用于多个行：android.cursor.dir/</li>
</ul>
</li>
<li>程序特有部分：<code>vnd.&lt;name&gt;.&lt;type&gt;</code><br> <code>&lt;name&gt;</code>值应具有全局唯一性，<type> 值应在对应的 URI pattern 中具有唯一性。通常使用包名或者公司域名作为<code>&lt;name&gt;</code>。适合选择 URI 关联表的标识字符串作为<code>&lt;type&gt;</code>。</li>
</ol>
<p>例如，如果ContentProvider的authority是 com.example.app.provider，并且它公开了一个名为 table1 的表，则 table1 中多个行的 MIME 类型是：<code>vnd.android.cursor.dir/vnd.com.example.provider.table1</code>；对于 table1 的单个行，MIME 类型是：<code>vnd.android.cursor.item/vnd.com.example.provider.table1</code>。</p>
<h3 id="文件的-MIME-类型"><a href="#文件的-MIME-类型" class="headerlink" title="文件的 MIME 类型"></a>文件的 MIME 类型</h3><p>如果 ContentProvider 程序提供文件，则需要实现 getStreamTypes()。该方法返回一个 MIME 类型的 String 数组，表示给定的 URI 返回的文件类型。</p>
<p>例如，假设提供程序以 .jpg、.png 和 .gif 格式文件形式提供照片图像。如果应用调用 ContentResolver.getStreamTypes() 时使用了过滤器字符串 image/*，则 ContentProvider.getStreamTypes() 方法应返回数组：<code>{ &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;}</code></p>
<p>如果应用只对 .jpg 文件感兴趣，则可以在调用 ContentResolver.getStreamTypes() 时使用过滤器字符串 */jpeg，ContentProvider.getStreamTypes() 应返回：<code>{&quot;image/jpeg&quot;}</code></p>
<p>如果程序未提供过滤器字符串中请求的任何 MIME 类型，则 getStreamTypes() 应返回 null。</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>指定其他应用访问提供程序的数据所必须具备权限的属性。</p>
<h3 id="grantUriPermssions"><a href="#grantUriPermssions" class="headerlink" title="grantUriPermssions"></a>grantUriPermssions</h3><p><code>android:grantUriPermssions</code>：表示是否可以通过临时权限访问数据，默认为false，在开发中可以只对限定的内容提供临时权限，如对照片的内容 URI 设置临时权限。</p>
<ul>
<li><p>true：系统会向整个系统授予临时权限，并替代其他设置的权限。</p>
</li>
<li><p>false：需添加<code>&lt;grant-uri-permission&gt;</code>并表明可以授权临时权限所对应的URI</p>
<ul>
<li><p>path：表示绝对路径Uri</p>
</li>
<li><p>pathPattern：表示限定完整的路径但可以使用./*通配符匹配</p>
</li>
<li><p>pathPrefix：限定路径的初始部分后面可以变化，只要初始部分符合即可授权</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:grantUriPermissions="false"</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">grant-uri-permission</span> <span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h3><ul>
<li>android:permission：统一提供程序范围读取/写入权限</li>
<li>android:readPermission：提供程序范围读取权限，优先于permission权限</li>
<li>android:writePermission：提供程序范围写入权限，优先于permission权限</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:readPermission="com.hearing.provider.permission.READ_PERMISSION"</span><br><span class="line">android:writePermission="com.hearing.provider.permission.WRITE_PERMISSION"</span><br><span class="line">android:permission="com.hearing.provider.permission.PERMISSION"</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建两个程序A和B，在程序A中使用ContentProvider保存数据，在程序B中进行查询，在开始A程序中不设置任何权限，B程序进行访问数据会报错；</li>
<li>修改A程序清单文件添加android:exported=”true”，再次访问数据访问成功；</li>
<li>在A程序的清单文件中，为Provider添加两个读写权限，添加完权限后再次在B程序中获取数据，还是会报错，也很正常因为已经对数据的访问设置了门槛，所以在B程序中声明读写权限即可。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A程序 --&gt;</span></span><br><span class="line">android:writePermission="com.alex.kotlin.job.provider.WRITE"</span><br><span class="line">android:readPermission="com.alex.kotlin.job.provider.READ"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- B程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.READ"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.WRITE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="系统ContentProvider"><a href="#系统ContentProvider" class="headerlink" title="系统ContentProvider"></a>系统ContentProvider</h2><p>举几个实例：铃声，联系人部分操作。</p>
<h3 id="铃声"><a href="#铃声" class="headerlink" title="铃声"></a>铃声</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改系统铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File sdFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    values.put(MediaStore.MediaColumns.DATA, sdFile.getAbsolutePath());</span><br><span class="line">    values.put(MediaStore.MediaColumns.TITLE, sdFile.getName());</span><br><span class="line">    values.put(MediaStore.MediaColumns.MIME_TYPE, <span class="string">"audio/*"</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_RINGTONE, <span class="keyword">true</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_NOTIFICATION, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_ALARM, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_MUSIC, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Uri uri = MediaStore.Audio.Media.getContentUriForPath(sdFile.getAbsolutePath());</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"uri is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String delete = MediaStore.MediaColumns.DATA + <span class="string">"=\""</span> + sdFile.getAbsolutePath() + <span class="string">"\""</span>;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + delete);</span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + context.getContentResolver().delete(uri, delete, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    Uri newUri = context.getContentResolver().insert(uri, values);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"uri = "</span> + uri);</span><br><span class="line">    Log.d(TAG, <span class="string">"new uri = "</span> + newUri);</span><br><span class="line"></span><br><span class="line">    RingtoneManager.setActualDefaultRingtoneUri(context, RingtoneManager.TYPE_RINGTONE, newUri);</span><br><span class="line">    Toast.makeText(context, <span class="string">"设置来电铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定电话号码的来电铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, number);</span><br><span class="line">    <span class="keyword">final</span> String[] projection = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            ContactsContract.Contacts._ID, ContactsContract.Contacts.LOOKUP_KEY</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> Cursor data = context.getContentResolver().query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.moveToFirst()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> contactId = data.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> String lookupKey = data.getString(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> Uri contactUri = ContactsContract.Contacts.getLookupUri(contactId, lookupKey);</span><br><span class="line">            <span class="keyword">if</span> (contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Invalid arguments"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">final</span> String value = Uri.fromFile(file).toString();</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"uri = "</span> + contactUri);</span><br><span class="line">            Log.d(TAG, <span class="string">"value = "</span> + value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ContentValues values = <span class="keyword">new</span> ContentValues(<span class="number">1</span>);</span><br><span class="line">            values.put(ContactsContract.Contacts.CUSTOM_RINGTONE, value);</span><br><span class="line">            context.getContentResolver().update(contactUri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Toast.makeText(context, <span class="string">"设置联系人铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联系人"><a href="#联系人" class="headerlink" title="联系人"></a>联系人</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据uri查询指定联系人电话(uri可以通过跳转联系人页面返回得到：intent.getData())</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContacts</span><span class="params">(Context context, Uri contactUri)</span> </span>&#123;</span><br><span class="line">    String phoneNumber = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor cursor = context.getContentResolver().query(contactUri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        String id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));</span><br><span class="line">        Cursor phones = context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,</span><br><span class="line">                <span class="keyword">null</span>, ContactsContract.CommonDataKinds.Phone.CONTACT_ID</span><br><span class="line">                        + <span class="string">"="</span> + id, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (phones != <span class="keyword">null</span> &amp;&amp; phones.moveToNext()) &#123;</span><br><span class="line">            phoneNumber = phones.getString(phones.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">            phones.close();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, <span class="string">"number = "</span> + phoneNumber);</span><br><span class="line">    <span class="keyword">return</span> phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据电话获取联系人名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContactName</span><span class="params">(Context context, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">    Uri lookupUri;</span><br><span class="line">    String[] projection = <span class="keyword">new</span> String[]&#123;ContactsContract.PhoneLookup._ID, ContactsContract.PhoneLookup.DISPLAY_NAME&#125;;</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));</span><br><span class="line">        cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lookupUri = Uri.withAppendedPath(android.provider.Contacts.Phones.CONTENT_FILTER_URL,</span><br><span class="line">                    Uri.encode(number));</span><br><span class="line">            cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = context.getResources().getString(R.string.unknown_contract);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.getCount() &gt; <span class="number">0</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        ret = cursor.getString(<span class="number">1</span>);</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h2><h3 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"finch.db"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_TABLE_NAME = <span class="string">"job"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 数据库版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DATABASE_NAME, <span class="keyword">null</span>, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个表格:用户表 和职业表</span></span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" name TEXT)"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + JOB_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" job TEXT)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义ContentProvider"><a href="#自定义ContentProvider" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    DBHelper mDbHelper = <span class="keyword">null</span>;</span><br><span class="line">    SQLiteDatabase db = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOHORITY = <span class="string">"cn.scu.myprovider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> User_Code = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Job_Code = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UriMatcher类使用:在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher mMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        mMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        mMatcher.addURI(AUTOHORITY,<span class="string">"user"</span>, User_Code);</span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">"job"</span>, Job_Code);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化ContentProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">// 在ContentProvider创建时对数据库进行初始化，不能做耗时操作，此处仅作展示</span></span><br><span class="line">        mDbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(1,'Carson');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(2,'Kobe');"</span>);</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from job"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(1,'Android');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(2,'iOS');"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">return</span> db.query(table,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> User_Code:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Job_Code:</span><br><span class="line">                tableName = DBHelper.JOB_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册ContentProvider"><a href="#注册ContentProvider" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"cn.scu.myprovider"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="访问ContentProvider的数据"><a href="#访问ContentProvider的数据" class="headerlink" title="访问ContentProvider的数据"></a>访问ContentProvider的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Iverson"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user, values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://cn.scu.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程1"><a href="#进程1" class="headerlink" title="进程1"></a>进程1</h3><h4 id="创建数据库类-1"><a href="#创建数据库类-1" class="headerlink" title="创建数据库类"></a>创建数据库类</h4><p>同上。</p>
<h4 id="自定义ContentProvider-1"><a href="#自定义ContentProvider-1" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h4><p>同上。</p>
<h4 id="注册ContentProvider-1"><a href="#注册ContentProvider-1" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"scut.carson_ho.myprovider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"scut.carson_ho.PROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span> = <span class="string">"scut.carson_ho.Read"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:writePermission</span> = <span class="string">"scut.carson_ho.Write"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="进程2"><a href="#进程2" class="headerlink" title="进程2"></a>进程2</h3><h4 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="访问ContentProvider"><a href="#访问ContentProvider" class="headerlink" title="访问ContentProvider"></a>访问ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Jordan"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user,values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>对于面向Android 7.0及以上的应用，Android禁止在应用外部公开<code>file://url</code>。如果一项包含文件URI的intent离开应用，则应用会抛出FileUriExposedException异常。</p>
<p>解决方案：要在应用间共享文件，应发送一项content://URI，并授予URI临时访问权限。进行此授权的最简单方式是使用FileProvider类。FileProvider是ContentProvider的一个特殊的子类，它让应用间共享文件变得更加容易，其通过创建一个Content URI来代替File URI。</p>
<h3 id="注册FileProvider"><a href="#注册FileProvider" class="headerlink" title="注册FileProvider"></a>注册FileProvider</h3><p>由于FileProvider中已经包含了为file生成Content URI的基本代码了，所以开发者不必再去定义一个FileProvider的子类。你可以在XML文件中指定一个FileProvider：在manifest中使用<code>&lt;provider&gt;</code>标签来指定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.hearing.fileprovider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name的值一般都固定为android.support.v4.content.FileProvider。如果开发者继承了FileProvider，则可以写上其绝对路径。</li>
<li>authorities字段的值用来表明使用的使用者，在FileProvider的函数getUriForFile需要传入该参数。</li>
<li>exported 的值为false，表示该FileProvider只能本应用使用，不是public的。</li>
<li>grantUriPermissions 的值为true，表示允许赋予临时权限。</li>
</ul>
<h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>只有事先指定了目录，一个FileProvider才可以为文件生成一个对应的Content URI。要指定一个路径，需要在XML文件中指定其存储的路径。使用<code>&lt;paths&gt;</code>标签。例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/files/path/</code></li>
<li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalFilesDir(null) + &quot;/path/&quot;</code>，<code>/storage/emulated/0/Android/data/&lt;package_name&gt;/files/path/</code></li>
<li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalCacheDir() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/Android/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Environment.getExternalStorageDirectory() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/path/</code></li>
</ul>
<p>在res目录下新建xml目录，然后新建文件file_paths.xml，根据上述内容编写。</p>
<h3 id="获取Content-Uri"><a href="#获取Content-Uri" class="headerlink" title="获取Content Uri"></a>获取Content Uri</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">Uri data;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    data = FileProvider.getUriForFile(mContext, <span class="string">"com.hearing.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋予临时权限"><a href="#赋予临时权限" class="headerlink" title="赋予临时权限"></a>赋予临时权限</h3><p>两种方法：（通常使用第2种）</p>
<ol>
<li>Context.grantUriPermission(package, Uri, mode_flags)</li>
<li>Intent.setFlags()：<code>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);</code></li>
</ol>
<p>Flag意义如下：</p>
<ul>
<li>FLAG_GRANT_READ_URI_PERMISSION：表示读取权限； </li>
<li>FLAG_GRANT_WRITE_URI_PERMISSION：表示写入权限。</li>
</ul>
<h3 id="分享文件URI"><a href="#分享文件URI" class="headerlink" title="分享文件URI"></a>分享文件URI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"shareFile: "</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="string">"com.hearing.fileproviderclient"</span>,</span><br><span class="line">            <span class="string">"com.hearing.fileproviderclient.MainActivity"</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">    Uri data;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        data = FileProvider.getUriForFile(mContext, FILE_PROVIDER_AUTHORITIES, file);</span><br><span class="line">        <span class="comment">// 给目标应用一个临时授权</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">    intent.setData(data);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>安全</p>
<p>  ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据根据需求开放给 其他应用进行增、删、改、查，而不用担心因为直接开放数据库权限而带来的安全问题</p>
</li>
<li><p>访问简单 &amp; 高效</p>
</li>
</ul>
<h1 id="Mime-Type"><a href="#Mime-Type" class="headerlink" title="Mime Type"></a>Mime Type</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>MIME：多用途互联网邮件扩展（Multipurpose Internet Mail Extensions）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。</p>
<p>MIME TYPE一般以这种形式出现：<code>[type]/[subtype]</code></p>
<p>type标识内容type，有下面的形式：</p>
<ul>
<li>Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</li>
<li>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</li>
<li>Application：用于传输应用程序数据或者二进制数据；</li>
<li>Message：用于包装一个E-mail消息；</li>
<li>Image：用于传输静态图片数据；</li>
<li>Audio：用于传输音频或者音声数据；</li>
<li>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。</li>
</ul>
<p>subtype用于指定type的详细形式。<code>content-type/subtype</code>配对的集合和与此相关的参数，将随着时间而增长。为了确保这些值在一个有序而且公开的状态下开发，MIME使用Internet Assigned Numbers Authority (IANA)作为中心的注册机制来管理这些值。常用的subtype值如下所示：</p>
<ul>
<li>text/plain（纯文本）</li>
<li>text/html（HTML文档）</li>
<li>application/xhtml+xml（XHTML文档）</li>
<li>image/gif（GIF图像）</li>
<li>image/jpeg（JPEG图像）</li>
<li>image/png（PNG图像）</li>
<li>video/mpeg（MPEG动画）</li>
<li>application/octet-stream（任意的二进制数据）</li>
<li>application/pdf（PDF文档）</li>
<li>application/msword（Microsoft Word文件）</li>
<li>message/rfc822（RFC 822形式）</li>
<li>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）</li>
<li>application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）</li>
<li>multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>当Android系统接收到一个隐式Intent要启动一个Activity(或其他组件)时，Android会根据以下三个信息比较Intent的信息与注册的组件的intent-filter的信息，从而为该Intent选择出最匹配的Activity(或其他组件)：</p>
<ul>
<li>intent中的action</li>
<li>intent中的category</li>
<li>intent中的data（包含Uri以及data的MIME类型）</li>
</ul>
<p>也就是隐式intent对象要满足要启动的目标组件中注册的intent-filter中的<code>&lt;action/&gt;</code>、<code>&lt;category/&gt;</code>、<code>&lt;data/&gt;</code>三个标签中的信息，即要分别通过action测试、category测试以及data测试。</p>
<p>MINI类型即在data中指定。</p>
<h1 id="Intent和Intent-filter"><a href="#Intent和Intent-filter" class="headerlink" title="Intent和Intent-filter"></a>Intent和Intent-filter</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Intent 是一个消息传递对象，可以用来从其他应用组件请求操作，尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ol>
<li>启动 Activity：通过将 Intent 传递给 startActivity()，可以启动新的 Activity 实例，Intent 用于描述要启动的 Activity，并携带任何必要的数据。</li>
<li>启动 Service：使用 Android 5.0（API 级别 21）及更高版本，可以启动包含 JobScheduler 的服务。对于 Android 5.0（API 级别 21）之前的版本，可以使用 Service 类的方法来启动服务，通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 用于描述要启动的服务，并携带任何必要的数据。如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，可以从其他组件绑定到此服务。</li>
<li>传递 BroadCast：广播是任何应用均可接收的消息，系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播，通过将 Intent 传递给 sendBroadcast() 或 sendOrderedBroadcast()，可以将广播传递给其他应用。</li>
</ol>
<h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><ul>
<li>显式 Intent：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。例如，启动应用内的新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li>隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent-filter进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent-filter匹配，则系统将启动该组件，并向其传递 Intent 对象。如果多个 Intent-filter兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</li>
</ul>
<p>Intent-filter是应用清单文件中的一个表达式，用于指定该组件要接收的 Intent 类型。例如，通过为 Activity 声明 Intent-filter，可以使其他应用能够直接使用某一特定类型的 Intent 启动 Activity。同样，如果您没有为 Activity 声明任何 Intent-filter，则 Activity 只能通过显式 Intent 启动。</p>
<p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent-filter。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p>
<h2 id="构建Intent"><a href="#构建Intent" class="headerlink" title="构建Intent"></a>构建Intent</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>如Component name，Action，Data以及Category，这些属性（组件名称、操作、数据和category）表示 Intent 的既定特征。通过读取这些属性，Android 系统能够解析应当启动哪个应用组件。但是，Intent 也有可能会携带一些不影响其如何解析为应用组件的信息。Intent 还可以提供以下信息：Extras和Flags。</p>
<h4 id="Component-name"><a href="#Component-name" class="headerlink" title="Component name"></a>Component name</h4><p>这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。如果没有组件名称，则 Intent 则为隐式，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和category）决定哪个组件应当接收 Intent。如需在应用中启动特定的组件，则应指定该组件的名称。</p>
<p>启动 Service 时，应始终指定组件名称。否则无法确定哪项服务会响应 Intent，且用户无法看到哪项服务已启动。</p>
<p>Intent 的这一字段是 ComponentName 对象，可以使用目标组件的完全限定类名指定此对象，其中包括应用的软件包名称。例如，com.example.ExampleActivity，可以使用 setComponent()、setClass()、setClassName()，或 Intent 构造函数设置组件名称。</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>指定要执行的通用操作（例如，查看或选取）的字符串。</p>
<p>对于广播 Intent，这是指已发生且正在报告的操作。action会在很大程度上决定其余 Intent 的构成，特别是 data 和 extra 中包含的内容。可以指定自己的操作，供 Intent 在您的应用内使用（或者供其他应用在您的应用中调用组件）。但是，您通常应该使用由Intent 类或其他框架类定义的操作常量。以下是一些用于启动 Activity 的常见操作：</p>
<ol>
<li>ACTION_VIEW：如果您拥有一些某项 Activity 可向用户显示的信息（例如，要使用图库应用查看的照片；或者要使用地图应用查看的地址），请通过 Intent 将此操作与 startActivity() 结合使用。</li>
<li>ACTION_SEND：这也称为共享 Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此操作与 startActivity() 结合使用。</li>
</ol>
<p>可以使用 setAction() 或 Intent 构造函数为 Intent 指定操作。</p>
<p>如以下示例所示，如果定义自己的操作，请确保加入应用的软件包名称作为前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ACTION_TIMETRAVEL = <span class="string">"com.example.action.TIMETRAVEL"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。</p>
<p>创建 Intent 时，除了指定 URI 以外，指定数据类型（MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件。但有时 MIME 类型可以从 URI 中推断得出，特别当数据是 content:URI 时尤其如此。content:URI 表明数据位于设备中，且由 ContentProvider 控制，这使得数据 MIME 类型对系统可见。</p>
<p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，您可以使用 setDataAndType() 同时显式设置二者。</p>
<p>注意：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType() 同时设置 URI 和 MIME 类型。</p>
<h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的Category放入一个 Intent 中，但大多数 Intent 均不需要 Category。以下是一些常见category：</p>
<ul>
<li>CATEGORY_BROWSABLE：目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。</li>
<li>CATEGORY_LAUNCHER：该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</li>
<li>CATEGORY_HOME：桌面应用需要声明。</li>
<li>CATEGORY_DEFAULT：通过隐式启动Activity时，Android会默认加上一个CATEGORY_DEFAULT，所以如果Activity要支持隐式启动的话，除了默认LaunchActivity，其余都需要加上CATEGORY_DEFAULT。</li>
</ul>
<p>可以使用 addCategory() 指定category。</p>
<h4 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h4><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。可以使用各种 putExtra() 方法添加 extra 数据，每种方法均接受两个参数：键名和值。还可以创建一个包含所有 extra 数据的 Bundle 对象，然后使用 putExtras() 将 Bundle 插入 Intent 中。</p>
<p>例如，使用 ACTION_SEND 创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL 键指定目标收件人，并使用 EXTRA_SUBJECT 键指定主题。</p>
<p>Intent 类将为标准化的数据类型指定多个 EXTRA_* 常量。如需声明自己的 extra 键（对于应用接收的 Intent），请确保将应用的软件包名称作为前缀，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_GIGAWATTS = <span class="string">"com.example.EXTRA_GIGAWATTS"</span>;</span><br></pre></td></tr></table></figure>

<p>注意：在发送您希望另一个应用接收的 Intent 时，请勿使用 Parcelable 或 Serializable 数据。如果某个应用尝试访问 Bundle 对象中的数据，但没有对打包或序列化类的访问权限，则系统将提出一个 RuntimeException。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><p>Flags 在 Intent 类中定义，充当 Intent 的元数据。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理（例如，Activity 是否属于最近的 Activity 列表）。</p>
<p>可以使用 setFlags() 方法添加Flags。</p>
<h3 id="显式-Intent-示例"><a href="#显式-Intent-示例" class="headerlink" title="显式 Intent 示例"></a>显式 Intent 示例</h3><p>显式 Intent 是指用于启动某个特定应用组件（例如，应用中的某个特定 Activity 或服务）的 Intent，要创建显式 Intent，需要为 Intent 对象定义组件名称，Intent 的所有其他属性均为可选属性。</p>
<p>例如，如果在应用中构建一个名为 DownloadService、旨在从网页下载文件的服务，则可使用以下代码启动该服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed in an Activity, so 'this' is the Context</span></span><br><span class="line"><span class="comment">// The fileUrl is a string URL, such as "http://www.example.com/image.png"</span></span><br><span class="line">Intent downloadIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DownloadService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">downloadIntent.setData(Uri.parse(fileUrl));</span><br><span class="line">startService(downloadIntent);</span><br></pre></td></tr></table></figure>

<p>Intent(Context, Class) 构造函数分别为应用和组件提供 Context 和 Class 对象。因此，此 Intent 将显式启动该应用中的 DownloadService 类。</p>
<h3 id="隐式-Intent-示例"><a href="#隐式-Intent-示例" class="headerlink" title="隐式 Intent 示例"></a>隐式 Intent 示例</h3><p>隐式 Intent 指定能够在可以执行相应操作的设备上调用任何应用的操作。如果您的应用无法执行该操作而其他应用可以，且您希望用户选取要使用的应用，则使用隐式 Intent 非常有用。例如，如果您希望用户与他人分享您的内容，请使用 ACTION_SEND 操作创建 Intent，并添加指定共享内容的 extra。使用该 Intent 调用 startActivity() 时，用户可以选取分享内容所使用的应用。</p>
<p>注意：用户可能没有任何应用处理您发送到 startActivity() 的隐式 Intent。或者，由于配置文件限制或管理员执行的设置，可能无法访问应用。如果发生这样的情况，调用失败，应用也会崩溃。要验证 Activity 是否会接收 Intent，请对 Intent 对象调用 resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，并且可以安全调用 startActivity()。如果结果为空，不要使用该 Intent。以下示例说明如何验证 Intent 是否解析为 Activity。此示例没有使用 URI，但已声明 Intent 的数据类型，用于指定 extra 携带的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the text message with a string</span></span><br><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</span><br><span class="line">sendIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the intent will resolve to an activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(sendIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 startActivity() 时，系统将检查已安装的所有应用，确定哪些应用能够处理这种 Intent（即：含 ACTION_SEND 操作并携带“text/plain”数据的 Intent）。如果只有一个应用能够处理，则该应用将立即打开并为其提供 Intent。如果多个 Activity 接受 Intent，则系统将显示一个对话框，使用户能够选取要使用的应用。</p>
<h3 id="强制使用应用选择器"><a href="#强制使用应用选择器" class="headerlink" title="强制使用应用选择器"></a>强制使用应用选择器</h3><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。如果用户可能希望每次使用相同的应用执行某项操作（例如，打开网页时，用户往往倾向于仅使用一种网络浏览器），则选择默认选项的功能十分有用。</p>
<p>但是，如果多个应用可以响应 Intent，且用户可能希望每次使用不同的应用，则应采用显式方式显示选择器对话框。选择器对话框会要求用户选择用于操作的应用（用户无法为该操作选择默认应用）。例如，当应用使用 ACTION_SEND 操作执行“共享”时，用户根据目前的状况可能需要使用另一不同的应用，因此应当始终使用选择器对话框。</p>
<p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()，如下例所示。此示例将显示一个对话框，其中有响应传递给 createChooser() 方法的 Intent 的应用列表，并且将提供的文本用作对话框标题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always use string resources for UI text.</span></span><br><span class="line"><span class="comment">// This says something like "Share this photo with"</span></span><br><span class="line">String title = getResources().getString(R.string.chooser_title);</span><br><span class="line"><span class="comment">// Create intent to show the chooser dialog</span></span><br><span class="line">Intent chooser = Intent.createChooser(sendIntent, title);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the original intent will resolve to at least one activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><h3 id="接收隐式-Intent-1"><a href="#接收隐式-Intent-1" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，请在 Manifest 文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent-filter。每个 Intent-filter均根据 Intent 的操作、数据和category指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent-filter之一传递时，系统才会将该 Intent 传递给应用组件。</p>
<p>请注意：显式 Intent 始终会传递给其目标，无论组件声明的 Intent-filter如何均是如此。</p>
<p>应用组件应当为自身可执行的每个独特作业声明单独的filter。例如，图像库应用中的一个 Activity 可能会有两个filter，分别用于查看图像和编辑图像。当 Activity 启动时，将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。</p>
<p>每个 Intent-filter均由应用Manifest文件中的 <code>&lt;intent-filter&gt;</code> 元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code> 元素）中。在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<ul>
<li><code>&lt;action&gt;</code>：在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。</li>
<li><code>&lt;data&gt;</code>：使用一个或多个指定数据 URI（scheme、host、port、path）各个方面和 MIME 类型的属性，声明接受的数据类型。</li>
<li><code>&lt;category&gt;</code>：在 name 属性中，声明接受的 Intent category。该值必须是操作的文本字符串值，而不是类常量。</li>
</ul>
<p>请注意：要接收隐式 Intent，必须将 CATEGORY_DEFAULT category包括在 Intent-filter中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT category的方式处理所有 Intent。如果未在 Intent-filter中声明此category，则隐式 Intent 不会解析为您的 Activity。</p>
<p>例如，以下是一个使用包含 Intent-filter的 Activity 声明，当数据类型为文本时，系统将接收 ACTION_SEND Intent ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您可以创建一个包括多个 <code>&lt;action&gt;</code>、<code>&lt;data&gt;</code> 或 <code>&lt;category&gt;</code> 实例的filtet。创建时，需确定组件能够处理这些filter元素的任何及所有组合。</p>
<p>如需仅以操作、数据和类别类型的特定组合来处理多种 Intent，则需创建多个 Intent-filter。</p>
<p>系统通过将 Intent 与所有这三个元素进行比较，根据filter测试隐式 Intent。隐式 Intent 若要传递给组件，必须通过所有这三项测试。如果 Intent 无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件。但是，由于一个组件可能有多个 Intent-filter，因此未能通过某一组件filter的 Intent 可能会通过另一filter。</p>
<p>注意：使用 Intent-filter时，无法安全地防止其他应用启动组件。尽管 Intent-filter将组件限制为仅响应特定类型的隐式 Intent，但如果开发者确定您的组件名称，则其他应用有可能通过使用显式 Intent 启动您的应用组件。如果必须确保只有您自己的应用才能启动您的某一组件，请勿在您的清单中声明 Intent-filter，将该组件的 exported 属性设置为 “false”。</p>
<p>同样，为了避免无意中运行不同应用的 Service，请始终使用显式 Intent 启动您自己的服务。</p>
<p>请注意：对于所有 Activity，您必须在清单文件中声明 Intent-filter。但是，广播接收器的filter可以通过调用 registerReceiver() 动态注册。这样一来，应用便可仅在应用运行时的某一指定时间段内侦听特定的广播。</p>
<h3 id="filter示例"><a href="#filter示例" class="headerlink" title="filter示例"></a>filter示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity is the main entry, should appear in app launcher --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity handles "SEND" actions with text data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND_MULTIPLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.google.panorama360+jpg"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开：</p>
<ul>
<li>ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。</li>
<li>CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。如果 <code>&lt;activity&gt;</code> 元素未使用 icon 指定图标，则系统将使用 <code>&lt;application&gt;</code> 元素中的图标。</li>
</ul>
<p>这两个元素必须配对使用，Activity 才会显示在应用启动器中。</p>
<p>第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent-filter之一匹配）的另一应用中直接进入 ShareActivity。</p>
<h2 id="使用PendingIntent"><a href="#使用PendingIntent" class="headerlink" title="使用PendingIntent"></a>使用PendingIntent</h2><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p>
<p>PendingIntent 的主要用例包括：</p>
<ul>
<li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用您的应用微件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li>
</ul>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建 PendingIntent。使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent 时，您必须声明所需的组件类型：</p>
<ul>
<li>PendingIntent.getActivity()，适用于启动 Activity 的 Intent。</li>
<li>PendingIntent.getService()，适用于启动 Service 的 Intent。</li>
<li>PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。</li>
</ul>
<p>除非您的应用正在从其他应用中接收待定 Intent，否则上述用于创建 PendingIntent 的方法可能是您所需的唯一 PendingIntent 方法。</p>
<p>每种方法均会提取当前的应用 Context、您要封装的 Intent 以及一个或多个指定应如何使用该 Intent 的标志（例如，是否可以多次使用该 Intent）。</p>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该 Intent 与 Intent-filter进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Action</li>
<li>Data（URI 和数据类型）。</li>
<li>Category</li>
</ul>
<h3 id="Action测试"><a href="#Action测试" class="headerlink" title="Action测试"></a>Action测试</h3><p>要指定接受的 Intent action，Intent-filter既可以不声明任何 <code>&lt;action&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.EDIT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要通过此filter，Intent 中指定的action必须与filter中列出的某一action匹配。</p>
<h3 id="Category测试"><a href="#Category测试" class="headerlink" title="Category测试"></a>Category测试</h3><p>要指定接受的 Intent category，Intent-filter既可以不声明任何 <code>&lt;category&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若要使 Intent 通过category测试，则 Intent 中的每个category均必须与filter中的category匹配。Intent-filter声明的category可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。因此，不含category的 Intent 应当始终会通过此测试，无论filter中声明何种category均是如此。</p>
<p>请注意：Android 会自动将 CATEGORY_DEFAULT category应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent。如需 Activity 接收显示 Intent，则必须将 “android.intent.category.DEFAULT” 的category包括在其 Intent-filter中。</p>
<h3 id="Data测试"><a href="#Data测试" class="headerlink" title="Data测试"></a>Data测试</h3><p>要指定接受的 Intent 数据，Intent-filter既可以不声明任何 <code>&lt;data&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：scheme、host、port 和 path：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>在 <code>&lt;data&gt;</code> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p>
<ul>
<li>如果未指定scheme，则会忽略host。</li>
<li>如果未指定host，则会忽略port。</li>
<li>如果未指定scheme和host，则会忽略path。</li>
</ul>
<p>将 Intent 中的 URI 与filter中的 URI 规范进行比较时，它仅与filter中包含的部分 URI 进行比较。例如：</p>
<ul>
<li>如果filter仅指定scheme，则具有该scheme的所有 URI 均与该filter匹配。</li>
<li>如果filter指定scheme和host，但未指定path，则具有相同scheme和host的所有 URI 都会通过filter，无论其path如何均是如此。</li>
<li>如果filter指定scheme、host和path，则仅具有相同scheme、host和path的 URI 才会通过filter。</li>
</ul>
<p>请注意：path规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。</p>
<p>数据测试会将 Intent 中的 URI 和 MIME 类型与filter中指定的 URI 和 MIME 类型进行比较。规则如下：</p>
<ul>
<li>仅当filter未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与filter的 URI 格式匹配、且filter同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当filter列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与filter中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与filter中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且filter未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果filter只是列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<p>请注意：如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <code>&lt;intent-filter&gt;</code> 中没有 <code>&lt;data&gt;</code> 元素时失败。</p>
<p>最后一条规则反映出对组件能够从文件中或内容提供程序处获得本地数据的预期。因此，其filter只能列出数据类型，不需要显式命名 content: 和 file: scheme。以下是一个典型示例，说明 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从内容提供程序处获得并显示图像数据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于大部分可用数据均由内容提供程序分发，因此指定数据类型（而非 URI）的filter也许最为常见。</p>
<p>另一常见的配置是具有scheme和数据类型的filter。例如，下文中的 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从网络中检索视频数据以执行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent-filter匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。例如，主页应用通过使用指定 ACTION_MAIN action和 CATEGORY_LAUNCHER category的 Intent-filter查找所有 Activity，以此填充应用启动器。如 IntentFilter 类文档所述，只有当 Intent 中的操作和category与filter匹配时，匹配才会成功。</p>
<p>您的应用可以使用类似于主页应用的方式使用 Intent 匹配。PackageManager 提供一整套 query…() 方法来返回所有能够接受特定 Intent 的组件。此外，还会提供一系列类似的 resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities() 将返回能够执行作为参数传递的 Intent 中列出的所有 Activity，而 queryIntentServices() 则可返回类似的一系列服务。这两种方法均不会激活组件；而只是列出能够响应的组件。对于广播接收器，有一种类似的方法：queryBroadcastReceivers()。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
