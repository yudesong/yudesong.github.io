<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/Service%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/Service%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Service的启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 11:17:27" itemprop="dateCreated datePublished" datetime="2020-08-10T11:17:27+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h4><h5 id="startService启动流程"><a href="#startService启动流程" class="headerlink" title="startService启动流程"></a>startService启动流程</h5><p><strong>startService启动服务特点</strong>：Service会经历onCreate()——-&gt;onStartCommand()。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再次启动仍然可以stopService。<br>多次调用startService，该Service只能被创建一次，即该Service的onCreate()只会被调用一次。但是每次调用startService，onStartCommand()都会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [ContextWrapper.java]</span><br><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        return mBase.startService(service);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContextImpl.java]</span><br><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        return startServiceCommon(service, false, mUser);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private ComponentName startServiceCommon(Intent service, boolean requireForeground,</span><br><span class="line">            UserHandle user) &#123;</span><br><span class="line">        ComponentName cn &#x3D; ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                getContentResolver()), requireForeground,</span><br><span class="line">                getOpPackageName(), user.getIdentifier());        </span><br><span class="line">        return cn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityManagerService.java]</span><br><span class="line">public class ActivityManagerService extends IActivityManager.Stub &#123;</span><br><span class="line">    final ActiveServices mServices;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public ComponentName startService(IApplicationThread caller, Intent service,</span><br><span class="line">            String resolvedType, boolean requireForeground, String callingPackage, int userId)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            final int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final int callingUid &#x3D; Binder.getCallingUid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            ComponentName res;</span><br><span class="line">            try &#123;</span><br><span class="line">                res &#x3D; mServices.startServiceLocked(caller, service,</span><br><span class="line">                        resolvedType, callingPid, callingUid,</span><br><span class="line">                        requireForeground, callingPackage, userId);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActiveServices.java]</span><br><span class="line">public final class ActiveServices &#123;</span><br><span class="line"></span><br><span class="line">    ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,</span><br><span class="line">            int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">        ServiceLookupResult res &#x3D;</span><br><span class="line">            retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, true, callerFg, false, false);</span><br><span class="line">        </span><br><span class="line">        ComponentName cmp &#x3D; startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">        return cmp;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="line">        boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123;</span><br><span class="line">        String error &#x3D; bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);</span><br><span class="line">        return r.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,</span><br><span class="line">            boolean whileRestarting, boolean permissionsReviewRequired)</span><br><span class="line">            throws TransactionTooLargeException &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 个人理解:</span><br><span class="line">         * 由本方法的参数可知，r是ServiceRecord的对象，ServiceRecord代表着一个Service记录</span><br><span class="line">         * 联系整个Service的启动过程可知：</span><br><span class="line">         * 首次调用bindService()启动一个Service时候，r.app应该为null,下面的if判断不成立</span><br><span class="line">         * 如果不是首次调用bindService()方法，则下面的if判断成立，调用</span><br><span class="line">           sendServiceArgsLocked()方法，然后return,</span><br><span class="line">         * 针对bindService()这个过程，在sendServiceArgsLocked()方法的开始处就已经return了，</span><br><span class="line">           并没有往下执行，可以说sendServiceArgsLocked()方法和bindService()这个过程无关</span><br><span class="line">         * 此处不对sendServiceArgsLocked()方法做过多解释，因为该方法主要是针对startService()</span><br><span class="line">           这个过程的，稍后下文中会讲到</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (r.app !&#x3D; null &amp;&amp; r.app.thread !&#x3D; null) &#123;</span><br><span class="line">            sendServiceArgsLocked(r, execInFg, false);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        app &#x3D; mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);</span><br><span class="line">        if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">            app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">            realStartServiceLocked(r, app, execInFg);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;        </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the service is in the started state, and there are no</span><br><span class="line">        &#x2F;&#x2F; pending arguments, then fake up one so its onStartCommand() will</span><br><span class="line">        &#x2F;&#x2F; be called.</span><br><span class="line">        &#x2F;&#x2F; 只有startService才会走这里</span><br><span class="line">        if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),</span><br><span class="line">                    null, null, 0));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; startService这里会走到onStartCommand()</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, true);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg,</span><br><span class="line">            boolean oomAdjusted) throws TransactionTooLargeException &#123;</span><br><span class="line">        &#x2F;&#x2F; bindService的时候N&#x3D;0,不会往下走</span><br><span class="line">        final int N &#x3D; r.pendingStarts.size();</span><br><span class="line">        if (N &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        r.app.thread.scheduleServiceArgs(r, slice);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityThread.java]</span><br><span class="line">public final class ActivityThread extends ClientTransactionHandler &#123;</span><br><span class="line">    final ArrayMap&lt;IBinder, Service&gt; mServices &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">    </span><br><span class="line">        public final void scheduleCreateService(IBinder token,</span><br><span class="line">                ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123;</span><br><span class="line">            updateProcessState(processState, false);</span><br><span class="line">            CreateServiceData s &#x3D; new CreateServiceData();</span><br><span class="line">            s.token &#x3D; token;</span><br><span class="line">            s.info &#x3D; info;</span><br><span class="line">            s.compatInfo &#x3D; compatInfo;</span><br><span class="line">            sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final void scheduleServiceArgs(IBinder token, ParceledListSlice args) &#123;</span><br><span class="line">            ServiceArgsData s &#x3D; new ServiceArgsData();</span><br><span class="line">            s.token &#x3D; token;</span><br><span class="line">            s.startId &#x3D; ssa.startId;</span><br><span class="line">            s.flags &#x3D; ssa.flags;</span><br><span class="line">            s.args &#x3D; ssa.args;</span><br><span class="line">            sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void handleCreateService(CreateServiceData data) &#123;</span><br><span class="line">        LoadedApk packageInfo &#x3D; getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">        Service service &#x3D; null;</span><br><span class="line">        java.lang.ClassLoader cl &#x3D; packageInfo.getClassLoader();</span><br><span class="line">        service &#x3D; packageInfo.getAppFactory()</span><br><span class="line">                .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">        &#x2F;&#x2F;AppComponentFactory.instantiateService() --&gt; return (Service) cl.loadClass(className).newInstance();</span><br><span class="line">    </span><br><span class="line">        ContextImpl context &#x3D; ContextImpl.createAppContext(this, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">        Application app &#x3D; packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        service.attach(context, this, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        service.onCreate(); &#x2F;&#x2F; 执行onCreate方法</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行onStartCommand</span><br><span class="line">    private void handleServiceArgs(ServiceArgsData data) &#123;</span><br><span class="line">        Service s &#x3D; mServices.get(data.token);</span><br><span class="line">        res &#x3D; s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="bindService启动流程"><a href="#bindService启动流程" class="headerlink" title="bindService启动流程"></a>bindService启动流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [ContextWrapper.java]</span><br><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean bindService(Intent service, ServiceConnection conn, int flags) &#123;</span><br><span class="line">        return mBase.bindService(service, conn, flags);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContextImpl.java]</span><br><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public boolean bindService(Intent service, ServiceConnection conn,</span><br><span class="line">            int flags) &#123;</span><br><span class="line">        return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), getUser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler</span><br><span class="line">            handler, UserHandle user) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建IServiceConnection Binder对象</span><br><span class="line">        IServiceConnection sd;</span><br><span class="line">        &#x2F;&#x2F; sd其实指向的是一个ServiceDispatch.InnerConnection的对象</span><br><span class="line">        &#x2F;&#x2F; 最终调用ServiceConnection的onServiceConnected()方法也是通过这个对象</span><br><span class="line">        sd &#x3D; mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        int res &#x3D; ActivityManager.getService().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        return res !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityManagerService.java]</span><br><span class="line">public class ActivityManagerService extends IActivityManager.Stub &#123;</span><br><span class="line">    final ActiveServices mServices;</span><br><span class="line">    </span><br><span class="line">    public int bindService(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">            String resolvedType, IServiceConnection connection, int flags, String callingPackage,</span><br><span class="line">            int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            return mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">               resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void publishService(IBinder token, Intent intent, IBinder service) &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActiveServices.java]</span><br><span class="line">public final class ActiveServices &#123;</span><br><span class="line"></span><br><span class="line">    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,</span><br><span class="line">            String resolvedType, final IServiceConnection connection, int flags,</span><br><span class="line">            String callingPackage, final int userId) throws TransactionTooLargeException &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据用户传递进来Intent来检索相对应的服务</span><br><span class="line">        ServiceLookupResult res &#x3D;</span><br><span class="line">             retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(),</span><br><span class="line">                     Binder.getCallingUid(), userId, true, callerFg, isBindExternal, allowInstant);</span><br><span class="line">        ServiceRecord s &#x3D; res.record;</span><br><span class="line">        &#x2F;&#x2F; 创建AppBindRecord对象记录着当前ServiceRecord,intent以及发起方的进程信息</span><br><span class="line">        AppBindRecord b &#x3D; s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        ConnectionRecord c &#x3D; new ConnectionRecord(b, activity,</span><br><span class="line">            connection, flags, clientLabel, clientIntent);</span><br><span class="line"></span><br><span class="line">        IBinder binder &#x3D; connection.asBinder();</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist &#x3D; s.connections.get(binder);</span><br><span class="line">        if (clist &#x3D;&#x3D; null) &#123;</span><br><span class="line">            clist &#x3D; new ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">            s.connections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);</span><br><span class="line">        b.connections.add(c);</span><br><span class="line">        if (activity !&#x3D; null) &#123;</span><br><span class="line">            if (activity.connections &#x3D;&#x3D; null) &#123;</span><br><span class="line">                activity.connections &#x3D; new HashSet&lt;ConnectionRecord&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            activity.connections.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        b.client.connections.add(c);        </span><br><span class="line">        </span><br><span class="line">        if ((flags&amp;Context.BIND_AUTO_CREATE) !&#x3D; 0) &#123;</span><br><span class="line">            s.lastActivity &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            &#x2F;&#x2F; 启动Service,这个过程和startService()一致</span><br><span class="line">            &#x2F;&#x2F; 只不过会区分bindService()和startService()，来执行不同的代码逻辑</span><br><span class="line">            &#x2F;&#x2F; 对于bindService从这进入执行onCreate方法</span><br><span class="line">            if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,</span><br><span class="line">                    permissionsReviewRequired) !&#x3D; null) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        </span><br><span class="line">        if (s.app !&#x3D; null &amp;&amp; b.intent.received) &#123;</span><br><span class="line">            &#x2F;** c.conn就是上文中我们提到的ServiceDispatcher.InnerConnection的对象</span><br><span class="line">             *  如果Service正在运行，会直接调用他的connected()方法，</span><br><span class="line">             *  具体connected()中代码是怎么执行的，上文中已经提到。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            c.conn.connected(s.name, b.intent.binder, false);</span><br><span class="line">            if (b.intent.apps.size() &#x3D;&#x3D; 1 &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                &#x2F;&#x2F; 当第一个app连接到该binding, 且之前已被bind过, 则回调onRebind()方法</span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (!b.intent.requested) &#123;</span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">            boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">        r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                        r.app.repProcState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123;</span><br><span class="line">        for (int conni&#x3D;r.connections.size()-1; conni&gt;&#x3D;0; conni--) &#123;</span><br><span class="line">            ArrayList&lt;ConnectionRecord&gt; clist &#x3D; r.connections.valueAt(conni);</span><br><span class="line">            for (int i&#x3D;0; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                ConnectionRecord c &#x3D; clist.get(i);</span><br><span class="line">                c.conn.connected(r.name, service, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityThread.java]</span><br><span class="line">public final class ActivityThread extends ClientTransactionHandler &#123;</span><br><span class="line">    final ArrayMap&lt;IBinder, Service&gt; mServices &#x3D; new ArrayMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">   </span><br><span class="line">        public final void scheduleBindService(IBinder token, Intent intent,</span><br><span class="line">                boolean rebind, int processState) &#123;</span><br><span class="line">            updateProcessState(processState, false);</span><br><span class="line">            BindServiceData s &#x3D; new BindServiceData();</span><br><span class="line">            s.token &#x3D; token;</span><br><span class="line">            s.intent &#x3D; intent;</span><br><span class="line">            s.rebind &#x3D; rebind;</span><br><span class="line">            sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void handleBindService(BindServiceData data) &#123;</span><br><span class="line">        Service s &#x3D; mServices.get(data.token);</span><br><span class="line">        IBinder binder &#x3D; s.onBind(data.intent);</span><br><span class="line">        ActivityManager.getService().publishService(data.token, data.intent, binder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h4><p><a href="https://blog.csdn.net/verymrq/article/details/78488297" target="_blank" rel="noopener">Android Service启动（二） bindService()启动过程以及原理解析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/ContentProvider%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/ContentProvider%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">ContentProvider的启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 11:17:27" itemprop="dateCreated datePublished" datetime="2020-08-10T11:17:27+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ContentProvider-简介"><a href="#ContentProvider-简介" class="headerlink" title="ContentProvider 简介"></a>ContentProvider 简介</h2><p>ContentProvider 作为 Android 四大组件中的一种，为我们提供了不同进程甚至是不同应用程序之间共享数据的机制。<br>ContentProvider 的生命周期默认在 Application onCreate() 之前，而且都是在主线程创建的，这和其他四大组件是不同的<br>ContentProvider 多进程模式，它可以和 AndroidManifest 中的 multiprocess 属性结合使用<br>ContentProvider 进行跨进程数据传递时，利用Binder与内存共享机制，就是通过 Binder 传递 CursorWindow 对象内部的匿名共享内存的文件描述符。这样在跨进程传输中，结果数据并不需要跨进程传输，而是在不同进程中通过传输的匿名共享内存文件描述符来操作同一块匿名内存，这样来实现不同进程访问相同数据的目的。</p>
<p>ContentProvider 、 ContentResolver 、 ContentObserver 之间的关系:</p>
<ol>
<li>ContentProvider 内容提供者,用于对外提供数据</li>
<li>ContentResolver.notifyChange(uri)发出消息</li>
<li>ContentResolver 内容解析者,用于获取内容提供者提供的数据</li>
<li>ContentResolver.registerContentObserver()监听消息。</li>
<li>ContentObserver 内容监听器,可以监听数据的改变状态</li>
</ol>
<p>问题： </p>
<ol>
<li>ContentProvider的onCreate发生在主线程，而其他的方法发生在Binder线程池中了。</li>
<li></li>
</ol>
<h2 id="ContentProvider-创建源码分析"><a href="#ContentProvider-创建源码分析" class="headerlink" title="ContentProvider 创建源码分析"></a>ContentProvider 创建源码分析</h2><p>ContentProvider 启动会伴随进程的启动，在ActivityManagerService中，启动进程是由startProcessLocked方法来完成的，内部通过Process的start方法来完成一个新的进程启动。 ActivityThread的main方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法是一个静态方法，首先创建ActivityThread，然后调用attach方法进行一系列的数据操作，再开启主线程Looper循环。 attach方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    final IActivityManager mgr &#x3D; ActivityManager.getService();</span><br><span class="line">    mgr.attachApplication(mAppThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityManager.getService()实质上就是ActivityManagerService，所以最终调用的是ActivityManagerService的attachApplication方法 ，内部调用attachApplicationLocked，然后又调用ApplicationThread的bindApplication方法进行进程间调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void bindApplication(...) &#123;</span><br><span class="line">    AppBindData data &#x3D; new AppBindData();</span><br><span class="line">    data.processName &#x3D; processName;</span><br><span class="line">    data.appInfo &#x3D; appInfo;</span><br><span class="line">    data.providers &#x3D; providers;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过handler发送一个消息，调用ActivityTread的handleBindApplication方法。 1. 首先创建ContextImpl与Instrumentation对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    final ContextImpl instrContext &#x3D; ContextImpl.createAppContext(this, pi);</span><br><span class="line">    final ClassLoader cl &#x3D; instrContext.getClassLoader();</span><br><span class="line">    mInstrumentation &#x3D; (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">    Application app;</span><br><span class="line">    app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">    installContentProviders(app, data.providers);</span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动当前进程ContentProvider并调用onCreate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void installContentProviders(Context context, List&lt;ProviderInfo&gt; providers) &#123;</span><br><span class="line">    final ArrayList&lt;ContentProviderHolder&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        ContentProviderHolder cph &#x3D; installProvider(context, null, cpi,false &#x2F;*noisy*&#x2F;, true &#x2F;*noReleaseNeeded*&#x2F;, true &#x2F;*stable*&#x2F;);</span><br><span class="line">        if (cph !&#x3D; null) &#123;</span><br><span class="line">            cph.noReleaseNeeded &#x3D; true;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityManager.getService().publishContentProviders(getApplicationThread(), results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ContentProviderHolder installProvider(Context context,</span><br><span class="line">        ContentProviderHolder holder, ProviderInfo info,</span><br><span class="line">        boolean noisy, boolean noReleaseNeeded, boolean stable) &#123;</span><br><span class="line">    final java.lang.ClassLoader cl &#x3D; c.getClassLoader();</span><br><span class="line">    LoadedApk packageInfo &#x3D; peekPackageInfo(ai.packageName, true);</span><br><span class="line">    localProvider &#x3D; packageInfo.getAppFactory().instantiateProvider(cl, info.name);</span><br><span class="line">    localProvider &#x3D; (ContentProvider)cl.loadClass(info.name).newInstance();</span><br><span class="line">    provider &#x3D; localProvider.getIContentProvider();</span><br><span class="line">    localProvider.attachInfo(c, info); &#x2F;&#x2F; 完成ContentProvider的onCreate操作   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>installContentProviders完成ContentProvider启动操作，遍历ProviderInfo列表通过installProvider进行启动操作，然后将已经启动的ContentProvider通过进程的方式发布到AMS中。 通过ClassLoader进行加载ContentProvider，完成ContentProvider对象创建       </p>
<h4 id="ContentProvider的启动过程"><a href="#ContentProvider的启动过程" class="headerlink" title="ContentProvider的启动过程"></a>ContentProvider的启动过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [Context.java]</span><br><span class="line">public abstract class Context &#123;</span><br><span class="line">    public abstract ContentResolver getContentResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContextImpl.java]</span><br><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    private final ApplicationContentResolver mContentResolver;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public ContentResolver getContentResolver() &#123;</span><br><span class="line">        return mContentResolver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private ContextImpl(@Nullable ContextImpl container, @NonNull ActivityThread mainThread,</span><br><span class="line">            @NonNull LoadedApk packageInfo, @Nullable String splitName,</span><br><span class="line">            @Nullable IBinder activityToken, @Nullable UserHandle user, int flags,</span><br><span class="line">            @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mContentResolver &#x3D; new ApplicationContentResolver(this, mainThread);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static final class ApplicationContentResolver extends ContentResolver &#123;</span><br><span class="line">        private final ActivityThread mMainThread;</span><br><span class="line">        private final UserHandle mUser;</span><br><span class="line">        ...</span><br><span class="line">        @Override</span><br><span class="line">        protected IContentProvider acquireUnstableProvider(Context c, String auth) &#123;</span><br><span class="line">            return mMainThread.acquireProvider(c,</span><br><span class="line">                    ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">                    resolveUserIdFromAuthority(auth), false);</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContentResolver.java]</span><br><span class="line">public abstract class ContentResolver &#123;</span><br><span class="line"></span><br><span class="line">    public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri,</span><br><span class="line">            @Nullable String[] projection, @Nullable String selection,</span><br><span class="line">            @Nullable String[] selectionArgs, @Nullable String sortOrder,</span><br><span class="line">            @Nullable CancellationSignal cancellationSignal) &#123;</span><br><span class="line">        IContentProvider unstableProvider &#x3D; acquireUnstableProvider(uri);</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            qCursor &#x3D; unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125; catch (DeadObjectException e) &#123;</span><br><span class="line">            stableProvider &#x3D; acquireProvider(uri);</span><br><span class="line">            qCursor &#x3D; stableProvider.query(</span><br><span class="line">                        mPackageName, uri, projection, queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityThread.java]</span><br><span class="line">public final class ActivityThread &#123;</span><br><span class="line">    &#x2F;&#x2F; 保存Provider集合</span><br><span class="line">    final ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap &#x3D; new ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;();</span><br><span class="line"></span><br><span class="line">    public final IContentProvider acquireProvider(</span><br><span class="line">            Context c, String auth, int userId, boolean stable) &#123;</span><br><span class="line">        final IContentProvider provider &#x3D; acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">        if (provider !&#x3D; null) &#123;</span><br><span class="line">            return provider;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        IActivityManager.ContentProviderHolder holder &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            holder &#x3D; ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                    getApplicationThread(), auth, userId, stable);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        holder &#x3D; installProvider(c, holder, holder.info,</span><br><span class="line">                true &#x2F;*noisy*&#x2F;, holder.noReleaseNeeded, stable);</span><br><span class="line">        return holder.provider;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final IContentProvider acquireExistingProvider(</span><br><span class="line">            Context c, String auth, int userId, boolean stable) &#123;</span><br><span class="line">        synchronized (mProviderMap) &#123;</span><br><span class="line">            final ProviderKey key &#x3D; new ProviderKey(auth, userId);</span><br><span class="line">            final ProviderClientRecord pr &#x3D; mProviderMap.get(key);</span><br><span class="line">            ...</span><br><span class="line">            IContentProvider provider &#x3D; pr.mProvider;</span><br><span class="line">            ...            </span><br><span class="line">            return provider;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void installContentProviders(Context context, List&lt;ProviderInfo&gt; providers) &#123;</span><br><span class="line">        final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results &#x3D;</span><br><span class="line">            new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line">        for (ProviderInfo cpi : providers) &#123;            </span><br><span class="line">            IActivityManager.ContentProviderHolder cph &#x3D; installProvider(context, null, cpi,</span><br><span class="line">                    false, true , true );</span><br><span class="line">            if (cph !&#x3D; null) &#123;</span><br><span class="line">                cph.noReleaseNeeded &#x3D; true;</span><br><span class="line">                results.add(cph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().publishContentProviders(</span><br><span class="line">                getApplicationThread(), results);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private IActivityManager.ContentProviderHolder installProvider(Context context,</span><br><span class="line">            IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span><br><span class="line">            boolean noisy, boolean noReleaseNeeded, boolean stable) &#123;</span><br><span class="line">        ContentProvider localProvider &#x3D; null;</span><br><span class="line">        IContentProvider provider;</span><br><span class="line">        if (holder &#x3D;&#x3D; null || holder.provider &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Context c &#x3D; null;</span><br><span class="line">            ApplicationInfo ai &#x3D; info.applicationInfo;</span><br><span class="line">            if (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">                c &#x3D; context;</span><br><span class="line">            &#125; else if (mInitialApplication !&#x3D; null &amp;&amp;mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">                c &#x3D; mInitialApplication;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    c &#x3D; context.createPackageContext(ai.packageName,</span><br><span class="line">                            Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;            </span><br><span class="line">            try &#123;</span><br><span class="line">                final java.lang.ClassLoader cl &#x3D; c.getClassLoader();</span><br><span class="line">                localProvider &#x3D; (ContentProvider)cl.</span><br><span class="line">                    loadClass(info.name).newInstance();</span><br><span class="line">                provider &#x3D; localProvider.getIContentProvider();            </span><br><span class="line">                localProvider.attachInfo(c, info);</span><br><span class="line">            &#125; catch (java.lang.Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            provider &#x3D; holder.provider;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager.ContentProviderHolder retHolder;</span><br><span class="line">        synchronized (mProviderMap) &#123;</span><br><span class="line">            IBinder jBinder &#x3D; provider.asBinder();</span><br><span class="line">            if (localProvider !&#x3D; null) &#123;</span><br><span class="line">                ComponentName cname &#x3D; new ComponentName(info.packageName, info.name);</span><br><span class="line">                ProviderClientRecord pr &#x3D; mLocalProvidersByName.get(cname);</span><br><span class="line">                if (pr !&#x3D; null) &#123;</span><br><span class="line">                    provider &#x3D; pr.mProvider;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    holder &#x3D; new IActivityManager.ContentProviderHolder(info);</span><br><span class="line">                    holder.provider &#x3D; provider;</span><br><span class="line">                    holder.noReleaseNeeded &#x3D; true;</span><br><span class="line">                    pr &#x3D; installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                    mLocalProviders.put(jBinder, pr);</span><br><span class="line">                    mLocalProvidersByName.put(cname, pr);</span><br><span class="line">                &#125;</span><br><span class="line">                retHolder &#x3D; pr.mHolder;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return retHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">        ...</span><br><span class="line">        final ContextImpl appContext &#x3D; ContextImpl.createAppContext(this, data.info);</span><br><span class="line">        ...    </span><br><span class="line">        if (ii !&#x3D; null) &#123;</span><br><span class="line">            final ApplicationInfo instrApp &#x3D; new ApplicationInfo();</span><br><span class="line">            ii.copyTo(instrApp);</span><br><span class="line">            instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">            final LoadedApk pi &#x3D; getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                    appContext.getClassLoader(), false, true, false);</span><br><span class="line">            final ContextImpl instrContext &#x3D; ContextImpl.createAppContext(this, pi);</span><br><span class="line">            try &#123;</span><br><span class="line">                final ClassLoader cl &#x3D; instrContext.getClassLoader();</span><br><span class="line">                mInstrumentation &#x3D; (Instrumentation)</span><br><span class="line">                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">            &#125;</span><br><span class="line">            final ComponentName component &#x3D; new ComponentName(ii.packageName, ii.name);</span><br><span class="line">            mInstrumentation.init(this, instrContext, appContext, component,</span><br><span class="line">                    data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; If the app is being launched for full backup or restore, bring it up in</span><br><span class="line">            &#x2F;&#x2F; a restricted environment with the base application class.</span><br><span class="line">            Application app &#x3D; data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">            mInitialApplication &#x3D; app;</span><br><span class="line">            &#x2F;&#x2F; don&#39;t bring up providers in restricted mode; they may depend on the</span><br><span class="line">            &#x2F;&#x2F; app&#39;s custom Application class</span><br><span class="line">            if (!data.restrictedBackupMode) &#123;</span><br><span class="line">                if (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                    installContentProviders(app, data.providers);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityManagerService.java]</span><br><span class="line">public final class ActivityManagerService extends ActivityManagerNative</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    public final ContentProviderHolder getContentProvider(</span><br><span class="line">            IApplicationThread caller, String name, int userId, boolean stable) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; The incoming user check is now handled in checkContentProviderPermissionLocked() to deal</span><br><span class="line">        &#x2F;&#x2F; with cross-user grant.</span><br><span class="line">        return getContentProviderImpl(caller, name, null, stable, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private ContentProviderHolder getContentProviderImpl(IApplicationThread caller,</span><br><span class="line">            String name, IBinder token, boolean stable, int userId) &#123;</span><br><span class="line">        ContentProviderRecord cpr;</span><br><span class="line">        ContentProviderConnection conn &#x3D; null;</span><br><span class="line">        ProviderInfo cpi &#x3D; null;</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            long startTime &#x3D; SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">            ProcessRecord r &#x3D; null;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; First check if this content provider has been published...</span><br><span class="line">            cpr &#x3D; mProviderMap.getProviderByName(name, userId);</span><br><span class="line">            ...</span><br><span class="line">            boolean providerRunning &#x3D; cpr !&#x3D; null &amp;&amp; cpr.proc !&#x3D; null &amp;&amp; !cpr.proc.killed;</span><br><span class="line">            if (providerRunning) &#123;</span><br><span class="line">                cpi &#x3D; cpr.info;</span><br><span class="line">                ...</span><br><span class="line">                if (r !&#x3D; null &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; This provider has been published or is in the process</span><br><span class="line">                    &#x2F;&#x2F; of being published...  but it is also allowed to run</span><br><span class="line">                    &#x2F;&#x2F; in the caller&#39;s process, so don&#39;t make a connection</span><br><span class="line">                    &#x2F;&#x2F; and just let the caller instantiate its own instance.</span><br><span class="line">                    ContentProviderHolder holder &#x3D; cpr.newHolder(null);</span><br><span class="line">                    &#x2F;&#x2F; don&#39;t give caller the provider object, it needs</span><br><span class="line">                    &#x2F;&#x2F; to make its own.</span><br><span class="line">                    holder.provider &#x3D; null;</span><br><span class="line">                    return holder;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!providerRunning) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cpi &#x3D; AppGlobals.getPackageManager().</span><br><span class="line">                        resolveContentProvider(name,</span><br><span class="line">                            STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ApplicationInfo ai &#x3D;</span><br><span class="line">                            AppGlobals.getPackageManager().</span><br><span class="line">                                getApplicationInfo(</span><br><span class="line">                                        cpi.applicationInfo.packageName,</span><br><span class="line">                                        STOCK_PM_FLAGS, userId);                        </span><br><span class="line">                        ai &#x3D; getAppInfoForUser(ai, userId);</span><br><span class="line">                        cpr &#x3D; new ContentProviderRecord(this, cpi, ai, comp, singleton);</span><br><span class="line">                    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                       ...</span><br><span class="line">                    &#125;</span><br><span class="line">               ...</span><br><span class="line">                final int N &#x3D; mLaunchingProviders.size();</span><br><span class="line">                int i;</span><br><span class="line">                for (i &#x3D; 0; i &lt; N; i++) &#123;</span><br><span class="line">                    if (mLaunchingProviders.get(i) &#x3D;&#x3D; cpr) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; If the provider is not already being launched, then get it</span><br><span class="line">                &#x2F;&#x2F; started.</span><br><span class="line">                if (i &gt;&#x3D; N) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        ProcessRecord proc &#x3D; getProcessRecordLocked(</span><br><span class="line">                                cpi.processName, cpr.appInfo.uid, false);</span><br><span class="line">                        if (proc !&#x3D; null &amp;&amp; proc.thread !&#x3D; null &amp;&amp; !proc.killed) &#123;</span><br><span class="line">                            if (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">                                checkTime(startTime, &quot;getContentProviderImpl: scheduling install&quot;);</span><br><span class="line">                                proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            proc &#x3D; startProcessLocked(cpi.processName,</span><br><span class="line">                                    cpr.appInfo, false, 0, &quot;content provider&quot;,</span><br><span class="line">                                    new ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                            cpi.name), false, false, false);</span><br><span class="line">                            ...</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        cpr.launchingApp &#x3D; proc;</span><br><span class="line">                        mLaunchingProviders.add(cpr);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        Binder.restoreCallingIdentity(origId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                mProviderMap.putProviderByName(name, cpr);</span><br><span class="line">                conn &#x3D; incProviderCountLocked(r, cpr, token, stable);</span><br><span class="line">                if (conn !&#x3D; null) &#123;</span><br><span class="line">                    conn.waiting &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Wait for the provider to be published...</span><br><span class="line">        synchronized (cpr) &#123;</span><br><span class="line">            while (cpr.provider &#x3D;&#x3D; null) &#123;</span><br><span class="line">               ...</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (conn !&#x3D; null) &#123;</span><br><span class="line">                        conn.waiting &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cpr.wait();</span><br><span class="line">                &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    if (conn !&#x3D; null) &#123;</span><br><span class="line">                        conn.waiting &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cpr !&#x3D; null ? cpr.newHolder(conn) : null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid) &#123;</span><br><span class="line">        ...</span><br><span class="line">            ProfilerInfo profilerInfo &#x3D; profileFile &#x3D;&#x3D; null ? null</span><br><span class="line">                    : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                    app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(mConfiguration), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        ...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">IActivityManager.java:</span><br><span class="line">public interface IActivityManager extends IInterface &#123;</span><br><span class="line">    public static class ContentProviderHolder implements Parcelable &#123;</span><br><span class="line">        public final ProviderInfo info;</span><br><span class="line">        public IContentProvider provider;</span><br><span class="line">        public IBinder connection;</span><br><span class="line">        public boolean noReleaseNeeded;</span><br><span class="line">        ...</span><br><span class="line">        public static final Parcelable.Creator&lt;ContentProviderHolder&gt; CREATOR</span><br><span class="line">                &#x3D; new Parcelable.Creator&lt;ContentProviderHolder&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ContentProviderHolder createFromParcel(Parcel source) &#123;</span><br><span class="line">                return new ContentProviderHolder(source);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public ContentProviderHolder[] newArray(int size) &#123;</span><br><span class="line">                return new ContentProviderHolder[size];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        private ContentProviderHolder(Parcel source) &#123;</span><br><span class="line">            info &#x3D; ProviderInfo.CREATOR.createFromParcel(source);</span><br><span class="line">            provider &#x3D; ContentProviderNative.asInterface(</span><br><span class="line">                    source.readStrongBinder());</span><br><span class="line">            connection &#x3D; source.readStrongBinder();</span><br><span class="line">            noReleaseNeeded &#x3D; source.readInt() !&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A应用发送信息给AMS（ActivityManagerService,进程system_server）要访问B应用的XXXContentProvider<br>AMS检查B应用没有被启动过，则新开一个进程启动B应用<br>启动应用B后，AMS向B应用启动XXXContentProvider，并实行相应的onCreate，返回IActivityManager.ContentProviderHolder，其中实现IContentProvider接口的Transact<br>AMS 把IActivityManager.ContentProviderHolder对象返回给A应用，A应用改造成代理ContentProviderProxy（即IContentProvider），此时A应用就可以调用增删改查等接口到B应用了。<br>照着类图和时序图的步数来分析：<br>在A应用进程处理：Step1、2、3、4、5、6、18、19<br>在AMS system_server进程处理：Step7、10、11、12、17<br>在B应用进程处理：Step8、9、13、14、15、16、20</p>
<p>Step1：<br>ContentResolver contentResolver = Conext.getContentResolver();<br>返回是ApplicationContentResolver,定义在ContextImpl内部静态类。</p>
<p>Step2：<br>Uri uri = Uri.parse(“content://cn.umbrella.providers.contact/item”);<br>Cursor cursor = contentResolver.query(uri, new String[]{“id”,”name”,”phone”}, null, null, “id asc”);<br>在ApplicationContentResolver.acquireProvider()调用ActivityThread类的acquireProvider函数进一步执行获取Content Provider接口的操作。</p>
<p>Step3、4、5：<br>ActivityThread. acquireProvider:先本地查找，若有，则直接返回，没有则调用ActivityManagerNative.getDefault().getContentProvider(getApplicationThread(), auth, userId, stable)即ActivityManagerProxy到AMS的getContentProvider()。</p>
<p>Step6：<br>在AMS. getContentProvider()调用getContentProviderImpl进一步处理，<br>在AMS中：ProviderMap mProviderMap成员变量是保存系统中的ContentProvider信息，boolean providerRunning = cpr != null &amp;&amp; cpr.proc != null &amp;&amp; !cpr.proc.killed先检查XXXContentProvider存在、宿主进程以及没有被杀的情况下，就直接返回。<br>若不存在，则会通过AppGlobals.getPackageManage().resolveContentProvider和getApplicationInfo来分别获取XXXProvider应用程序的相关信息，并保存cpi和cpr变量中。接下来会判断mLaunchingProviders（系统中所有正在加载的Content Provider都保到这里面）是不是正在被其它应用程序加载XXXContentProvider，如果B应用进程已开启，但对应的contentprovider未初始化过，则会走proc.thread.scheduleInstallProvider(cpi)，到B应用的ActivityThread的handleInstallProvider、installContentProviders初始化contentProvider，略过Step7-13步直接Step14。<br>如果B应用进程未启动，则继续走Step7 调用startProcessLocked函数来启动新进程并加装XXXContentProvider，并且把这个正在加载的信息增加到mLaunchingProviders中去，同步等到XXXContentProvider初始化完，while循环cpr.provider判空，然后cpr.wait()，等到Step17步publishContentProviders会dst.notifyAll()过来。</p>
<p>Step7、8、9、10：<br>  ActivityManagerService.startProcessLocked、Process.start、ActivityThread.main、ActivityThread.attach、ActivityManagerService.attachApplication 新进程的创建完回到AMS的过程，可参考startService源码从AMS进程到service的新进程启动过程分析</p>
<p>Step11：<br>AMS. attachApplicationLocked, 会对这个B应用进程记录块做一些初始化，并获得需要加装的ContentProvider列表，即包括XXXContentProvider，然后调用从参数传进来的IApplicationThread对象thread（即ApplicationThreadProxy）的bindApplication进入到B应用程序XXXContentProvider进程中的ApplicationThread对象的bindApplication函数中去。</p>
<p>Step12、13：<br>ApplicationThread（ActivityThread 变量）. bindApplication通过H（Handler）到ActivityThread主进程中handleBindApplication处理,调用installContentProviders函数来在初始化XXXContent Providers信息,以及Application等初始化工作。</p>
<p>Step14、15：<br>ActivityThread.installContentProviders 先调用installContentProviders对XXXContentProvider的初始化attachInfo，并调用onCreate，并把ContextProvider的成员变量Transport（父类ContentProviderNative，是binder对象，并且实现了IContentProvider接口）然后调用ActivityManagerNative.getDefault().publishContentProviders(getApplicationThread(), results)，到Step16.</p>
<p>Step16：<br>ActivityManagerProxy.publishContentProviders(IApplicationThread caller, List<ContentProviderHolder> providers)通知AMS进程 ，B应用进程及XXXContentProvider都已初始化完毕，并把相应的IContentProvider给过去。</p>
<p>Step17 :<br>AMS. publishContentProviders：会把B应用进程的的ContentProvider保存起来，并移除mLaunchingProviders里面相应的值，然后通知dst.notifyAll();到Step6的getContentProviderImpl，接着返回给A应用进程的ContentProviderHolder对象。</p>
<p>Step18：<br>在AMS进程通过binder返回给A应用对象ContentProviderHolder，会把B应用进程的IContentProvider接口（即Transport）通过ContentProviderNative.asInterface(source.readStrongBinder())改造为ContentProviderProxy。</p>
<p>Step19、20：<br>A应用进程拿到B应用进程的Transport后， ContentResolver.query()中调用ContentProviderProxy.query，这里面会BulkCursorToCursorAdaptor，包含CursorWindow等匿名共享内存方式读取数据。</p>
<h4 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h4><p><a href=""></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/Broadcast%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/Broadcast%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Broadcast启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 11:17:27" itemprop="dateCreated datePublished" datetime="2020-08-10T11:17:27+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="BroadcastReceiver的启动过程"><a href="#BroadcastReceiver的启动过程" class="headerlink" title="BroadcastReceiver的启动过程"></a>BroadcastReceiver的启动过程</h4><h5 id="广播注册过程"><a href="#广播注册过程" class="headerlink" title="广播注册过程"></a>广播注册过程</h5><p>1、通过ContextWrapper开始，具体实现在ContextImpl，和Activity以及Service的开始过程一致。<br>2、在ContextImpl中，先从mPackageInfo中获取IIntentReceiver对象，然后采取跨进程的方式向AMS发送广播注册的请求。采用IIntentReceiver的原因是注册过程是跨进程的，BroadCastReceiver作为acitivity内部组件是不能直接跨进程传递的，需要IIntentReceiver中转一下，类似于Service的绑定过程中的ServiceDipatcher。这里会通过mPackageInfo获取receiverDispatcher，里面封装了BroadcastReceiver和IIntentReceiver的实现类InnerReceiver，这样在收到广播时，receiverDispatcher就能轻松调用BroadcastReceiver中的onreceive方法。<br>3、通过AMS进行具体的广播注册，核心是将远程的IIntetnReceiver和IntentFilter对象存储起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [Context.java]</span><br><span class="line">public abstract class Context &#123;</span><br><span class="line">    public abstract Intent registerReceiver(@Nullable BroadcastReceiver receiver,</span><br><span class="line">                                            IntentFilter filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContextWrapper.java]</span><br><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    </span><br><span class="line">    public ContextWrapper(Context base) &#123;</span><br><span class="line">        mBase &#x3D; base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        mBase &#x3D; base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">        return mBase.registerReceiver(receiver, filter);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContextImpl.java]</span><br><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    final LoadedApk mPackageInfo;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">        return registerReceiver(receiver, filter, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">            String broadcastPermission, Handler scheduler) &#123;</span><br><span class="line">        return registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">                filter, broadcastPermission, scheduler, getOuterContext(), 0);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,</span><br><span class="line">            IntentFilter filter, String broadcastPermission,</span><br><span class="line">            Handler scheduler, Context context, int flags) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 创建IIntentReceiver Binder对象，主要方法为performReceive()</span><br><span class="line">        IIntentReceiver rd &#x3D; null;</span><br><span class="line">        if (receiver !&#x3D; null) &#123;</span><br><span class="line">            if (mPackageInfo !&#x3D; null &amp;&amp; context !&#x3D; null) &#123;</span><br><span class="line">                if (scheduler &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    scheduler &#x3D; mMainThread.getHandler();</span><br><span class="line">                &#125;</span><br><span class="line">                rd &#x3D; mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler,</span><br><span class="line">                    mMainThread.getInstrumentation(), true);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (scheduler &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    scheduler &#x3D; mMainThread.getHandler();</span><br><span class="line">                &#125;</span><br><span class="line">                rd &#x3D; new LoadedApk.ReceiverDispatcher(</span><br><span class="line">                        receiver, context, scheduler, null, true).getIIntentReceiver();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2. 向ASM注册广播(rd、filter)</span><br><span class="line">        try &#123;</span><br><span class="line">            final Intent intent &#x3D; ActivityManager.getService().registerReceiver(</span><br><span class="line">                    mMainThread.getApplicationThread(), mBasePackageName, rd, filter,</span><br><span class="line">                    broadcastPermission, userId, flags);</span><br><span class="line">            if (intent !&#x3D; null) &#123;</span><br><span class="line">                intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">                intent.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            return intent;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityManagerService.java]</span><br><span class="line">public class ActivityManagerService extends IActivityManager.Stub &#123;</span><br><span class="line">    &#x2F;&#x2F; 系统中粘性广播集合(key: userId, value: ArrayList&lt;Intent&gt;)</span><br><span class="line">    final SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts &#x3D;</span><br><span class="line">            new SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 系统中保存的广播接收者的IIntentReceiver对象以及</span><br><span class="line">    final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 【重点】</span><br><span class="line">    public Intent registerReceiver(IApplicationThread caller, String callerPackage,</span><br><span class="line">            IIntentReceiver receiver, IntentFilter filter, String permission, int userId,</span><br><span class="line">            int flags) &#123;</span><br><span class="line">        &#x2F;&#x2F; 粘性广播</span><br><span class="line">        ArrayList&lt;Intent&gt; stickyIntents &#x3D; null;</span><br><span class="line">        ProcessRecord callerApp &#x3D; null;</span><br><span class="line">        final boolean visibleToInstantApps</span><br><span class="line">                &#x3D; (flags &amp; Context.RECEIVER_VISIBLE_TO_INSTANT_APPS) !&#x3D; 0;</span><br><span class="line">        int callingUid;</span><br><span class="line">        int callingPid;</span><br><span class="line">        boolean instantApp;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (caller !&#x3D; null) &#123;</span><br><span class="line">                callerApp &#x3D; getRecordForAppLocked(caller);</span><br><span class="line">                callingUid &#x3D; callerApp.info.uid;</span><br><span class="line">                callingPid &#x3D; callerApp.pid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            instantApp &#x3D; isInstantApp(callerApp, callerPackage, callingUid);</span><br><span class="line">            userId &#x3D; mUserController.handleIncomingUser(callingPid, callingUid, userId, true,</span><br><span class="line">                    ALLOW_FULL_ONLY, &quot;registerReceiver&quot;, callerPackage);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 获取filter中所有的Action</span><br><span class="line">            Iterator&lt;String&gt; actions &#x3D; filter.actionsIterator();</span><br><span class="line">            &#x2F;&#x2F; 收集所有用户和当前注册用户的已经发送过的粘性广播保存到stickyIntents</span><br><span class="line">            int[] userIds &#x3D; &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">            while (actions.hasNext()) &#123;</span><br><span class="line">                String action &#x3D; actions.next();</span><br><span class="line">                for (int id : userIds) &#123;</span><br><span class="line">                    ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies &#x3D; mStickyBroadcasts.get(id);</span><br><span class="line">                    if (stickies !&#x3D; null) &#123;</span><br><span class="line">                        ArrayList&lt;Intent&gt; intents &#x3D; stickies.get(action);</span><br><span class="line">                        if (intents !&#x3D; null) &#123;</span><br><span class="line">                            if (stickyIntents &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                stickyIntents &#x3D; new ArrayList&lt;Intent&gt;();</span><br><span class="line">                            &#125;</span><br><span class="line">                            stickyIntents.addAll(intents);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 进一步精准匹配粘性广播(包括action、type、scheme、data、categories等)</span><br><span class="line">        ArrayList&lt;Intent&gt; allSticky &#x3D; null;</span><br><span class="line">        if (stickyIntents !&#x3D; null) &#123;</span><br><span class="line">            for (int i &#x3D; 0, N &#x3D; stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">                Intent intent &#x3D; stickyIntents.get(i);</span><br><span class="line"></span><br><span class="line">                if (instantApp &amp;&amp;</span><br><span class="line">                        (intent.getFlags() &amp; Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (filter.match(resolver, intent, true, TAG) &gt;&#x3D; 0) &#123;</span><br><span class="line">                    if (allSticky &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        allSticky &#x3D; new ArrayList&lt;Intent&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    allSticky.add(intent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Intent sticky &#x3D; allSticky !&#x3D; null ? allSticky.get(0) : null;</span><br><span class="line"></span><br><span class="line">        if (receiver &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return sticky;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (callerApp !&#x3D; null &amp;&amp; (callerApp.thread &#x3D;&#x3D; null</span><br><span class="line">                    || callerApp.thread.asBinder() !&#x3D; caller.asBinder())) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 将普通注册广播添加到mRegisteredReceivers集合中</span><br><span class="line">            &#x2F;&#x2F; final class ReceiverList extends ArrayList&lt;BroadcastFilter&gt;</span><br><span class="line">            &#x2F;&#x2F; ReceiverList本质就是ArrayList集合</span><br><span class="line">            ReceiverList rl &#x3D; mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">            if (rl &#x3D;&#x3D; null) &#123;</span><br><span class="line">                rl &#x3D; new ReceiverList(this, callerApp, callingPid, callingUid,</span><br><span class="line">                        userId, receiver);</span><br><span class="line">                if (rl.app !&#x3D; null) &#123;</span><br><span class="line">                    rl.app.receivers.add(rl);</span><br><span class="line">                &#125;</span><br><span class="line">                mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            BroadcastFilter bf &#x3D; new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                    permission, callingUid, userId, instantApp, visibleToInstantApps);</span><br><span class="line">            if (rl.containsFilter(filter)) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rl.add(bf);</span><br><span class="line">                mReceiverResolver.addFilter(bf);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 处理粘性广播事件</span><br><span class="line">            if (allSticky !&#x3D; null) &#123;</span><br><span class="line">                ArrayList receivers &#x3D; new ArrayList();</span><br><span class="line">                receivers.add(bf);</span><br><span class="line"></span><br><span class="line">                final int stickyCount &#x3D; allSticky.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; stickyCount; i++) &#123;</span><br><span class="line">                    Intent intent &#x3D; allSticky.get(i);</span><br><span class="line">                    BroadcastQueue queue &#x3D; broadcastQueueForIntent(intent);</span><br><span class="line">                    BroadcastRecord r &#x3D; new BroadcastRecord(queue, intent, null,</span><br><span class="line">                            null, -1, -1, false, null, null, OP_NONE, null, receivers,</span><br><span class="line">                            null, 0, null, null, false, true, true, -1);</span><br><span class="line">                    queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">                    queue.scheduleBroadcastsLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return sticky;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是动态广播注册的整个过程，主要将当前注册的动态广播接收器以及对应的广播筛选器BroadcastFilter添加到AMS. mRegisteredReceivers里面，同时处理了与stricky广播的相关逻辑，从这里可以看到对于注册stricky广播而言，在注册结束以后，系统会立马发送与之匹配的stricky广播。</p>
<h5 id="广播发送过程"><a href="#广播发送过程" class="headerlink" title="广播发送过程"></a>广播发送过程</h5><p>一般发送广播都是通过context.sendBroadcast等相关接口进行的，然后Binder远程调用到AMS的相关函数，AMS根据各个应用注册的所有的filters经过筛选以后，将广播发送给指定的进程。</p>
<p>1、通过ContextWrapper 到ComtextImpl调用sendBroadcast方法，向AMS发起一个异步请求用于发送广播，即broadcastIntent(),会给广播的intent添加排除/添加死亡的进程的flag，表示是否要对处于停止状态的应用起作用。<br>2、在broadcastIntentLocked内部，根据intent-filter查找出匹配的广播并经过一系列的条件过滤。最终满足条件的接受者会被添加到BroadcastQueue中，然后BroadcastQueue就会发送广播给响应的广播接收者。<br>3、系统遍历mParallelBroadcasts并将其中的广播发送给所有的接收者，具体的发送过程通过app.thread的跨进程调用方式实现，在ApplicationThread中调用IntentReceiver的performReceive方法。<br>4、通过LoadedApk.ReceiverDispatcher来处理performReceive方法，利用H.post跳转到主线程中运行，最终调用的是该IntentReceiver对应Receiver的onReceive方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [Context.java]</span><br><span class="line">public abstract class Context &#123;</span><br><span class="line">    public abstract void sendBroadcast(@RequiresPermission Intent intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContextWrapper.java]</span><br><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    </span><br><span class="line">    public ContextWrapper(Context base) &#123;</span><br><span class="line">        mBase &#x3D; base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        mBase &#x3D; base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">        mBase.sendBroadcast(intent);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ContextImpl.java]</span><br><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    final LoadedApk mPackageInfo;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">        String resolvedType &#x3D; intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.prepareToLeaveProcess(this);</span><br><span class="line">            ActivityManager.getService().broadcastIntent(</span><br><span class="line">                    mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,</span><br><span class="line">                    getUserId());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityManagerService.java]</span><br><span class="line">public class ActivityManagerService extends IActivityManager.Stub &#123;</span><br><span class="line">    </span><br><span class="line">    BroadcastQueue mFgBroadcastQueue; &#x2F;&#x2F; 前台广播执行器</span><br><span class="line">    BroadcastQueue mBgBroadcastQueue; &#x2F;&#x2F; 后台广播执行器</span><br><span class="line">    final BroadcastQueue[] mBroadcastQueues &#x3D; new BroadcastQueue[2];</span><br><span class="line">    </span><br><span class="line">    public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mFgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">                &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false);</span><br><span class="line">        mBgBroadcastQueue &#x3D; new BroadcastQueue(this, mHandler,</span><br><span class="line">                &quot;background&quot;, BROADCAST_BG_TIMEOUT, true);</span><br><span class="line">        mBroadcastQueues[0] &#x3D; mFgBroadcastQueue;</span><br><span class="line">        mBroadcastQueues[1] &#x3D; mBgBroadcastQueue;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BroadcastQueue broadcastQueueForIntent(Intent intent) &#123;</span><br><span class="line">        final boolean isFg &#x3D; (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) !&#x3D; 0;</span><br><span class="line">        return (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final int broadcastIntent(IApplicationThread caller,</span><br><span class="line">            Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">            int resultCode, String resultData, Bundle resultExtras,</span><br><span class="line">            String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">            boolean serialized, boolean sticky, int userId) &#123;</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            intent &#x3D; verifyBroadcastLocked(intent);</span><br><span class="line">            final ProcessRecord callerApp &#x3D; getRecordForAppLocked(caller);</span><br><span class="line">            final int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final int callingUid &#x3D; Binder.getCallingUid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            int res &#x3D; broadcastIntentLocked(callerApp,</span><br><span class="line">                    callerApp !&#x3D; null ? callerApp.info.packageName : null,</span><br><span class="line">                    intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                    requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                    callingPid, callingUid, userId);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final int broadcastIntentLocked(ProcessRecord callerApp,</span><br><span class="line">            String callerPackage, Intent intent, String resolvedType,</span><br><span class="line">            IIntentReceiver resultTo, int resultCode, String resultData,</span><br><span class="line">            Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions,</span><br><span class="line">            boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123;</span><br><span class="line">        intent &#x3D; new Intent(intent);</span><br><span class="line">        final String action &#x3D; intent.getAction();</span><br><span class="line">        final BroadcastQueue queue &#x3D; broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r &#x3D; new BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, callerInstantApp, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, registeredReceivers, resultTo,</span><br><span class="line">                resultCode, resultData, resultExtras, ordered, sticky, false, userId);</span><br><span class="line">        final boolean replaced &#x3D; replacePending &amp;&amp; (queue.replaceParallelBroadcastLocked(r) !&#x3D; null);</span><br><span class="line">        if (!replaced) &#123;</span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [BroadcastQueue.java]</span><br><span class="line">public final class BroadcastQueue &#123;</span><br><span class="line">    final ActivityManagerService mService;</span><br><span class="line">    &#x2F;&#x2F; 并行广播</span><br><span class="line">    final ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 有序广播</span><br><span class="line">    final ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    boolean mBroadcastsScheduled &#x3D; false;</span><br><span class="line">    final BroadcastHandler mHandler;</span><br><span class="line"></span><br><span class="line">    private final class BroadcastHandler extends Handler &#123;</span><br><span class="line">        public BroadcastHandler(Looper looper) &#123;</span><br><span class="line">            super(looper, null, true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                    processNextBroadcast(true);</span><br><span class="line">                &#125; break;</span><br><span class="line">                case BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                    synchronized (mService) &#123;</span><br><span class="line">                        broadcastTimeoutLocked(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 添加并行广播</span><br><span class="line">    public void enqueueParallelBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">        mParallelBroadcasts.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enqueueOrderedBroadcastLocked(BroadcastRecord r) &#123;</span><br><span class="line">        mOrderedBroadcasts.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前正在处理广播，则直接返回，保证广播都是串行执行</span><br><span class="line">        if (mBroadcastsScheduled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">        mBroadcastsScheduled &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">        synchronized (mService) &#123;</span><br><span class="line">            processNextBroadcastLocked(fromMsg, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void processNextBroadcastLocked(boolean fromMsg, boolean skipOomAdj) &#123;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 执行并行广播</span><br><span class="line">        while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 取出队列头部的BroadcastRecord, 遍历所有的广播接收者</span><br><span class="line">            r &#x3D; mParallelBroadcasts.remove(0);</span><br><span class="line">            final int N &#x3D; r.receivers.size();</span><br><span class="line">            for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                Object target &#x3D; r.receivers.get(i);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);</span><br><span class="line">            &#125;</span><br><span class="line">            addBroadcastToHistoryLocked(r);            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行有序广播</span><br><span class="line">        &#x2F;&#x2F; 串行化广播都存储在mOrderedBroadcasts里面，并且每个接收者是以同步的方式处理，</span><br><span class="line">        &#x2F;&#x2F; 只有前面一个接收者处理完并且返回结果以后才会将广播发送给后面的接收者。</span><br><span class="line">        do &#123;</span><br><span class="line">            if (mOrderedBroadcasts.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                mService.scheduleAppGcsLocked();</span><br><span class="line">                if (looped) &#123;</span><br><span class="line">                    mService.updateOomAdjLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 从队列取出对头有序广播</span><br><span class="line">            r &#x3D; mOrderedBroadcasts.get(0);</span><br><span class="line">            boolean forceReceive &#x3D; false;</span><br><span class="line">            int numReceivers &#x3D; (r.receivers !&#x3D; null) ? r.receivers.size() : 0;</span><br><span class="line">            if (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123;</span><br><span class="line">                long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">                if ((numReceivers &gt; 0) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 出现超时</span><br><span class="line">                    broadcastTimeoutLocked(false); &#x2F;&#x2F; forcibly finish this broadcast</span><br><span class="line">                    forceReceive &#x3D; true;</span><br><span class="line">                    r.state &#x3D; BroadcastRecord.IDLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (r.state !&#x3D; BroadcastRecord.IDLE) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (r.receivers &#x3D;&#x3D; null || r.nextReceiver &gt;&#x3D; numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                if (r.resultTo !&#x3D; null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                            new Intent(r.intent), r.resultCode,</span><br><span class="line">                            r.resultData, r.resultExtras, false, false, r.userId);</span><br><span class="line">                        r.resultTo &#x3D; null;</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        r.resultTo &#x3D; null;</span><br><span class="line">                        Slog.w(TAG, &quot;Failure [&quot;</span><br><span class="line">                                + mQueueName + &quot;] sending broadcast result of &quot;</span><br><span class="line">                                + r.intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                addBroadcastToHistoryLocked(r);</span><br><span class="line">                if (r.intent.getComponent() &#x3D;&#x3D; null &amp;&amp; r.intent.getPackage() &#x3D;&#x3D; null</span><br><span class="line">                        &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; This was an implicit broadcast... let&#39;s record it for posterity.</span><br><span class="line">                    mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                            r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                &#125;</span><br><span class="line">                mOrderedBroadcasts.remove(0);</span><br><span class="line">                r &#x3D; null;</span><br><span class="line">                looped &#x3D; true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (r &#x3D;&#x3D; null);        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void deliverToRegisteredReceiverLocked(BroadcastRecord r,</span><br><span class="line">            BroadcastFilter filter, boolean ordered, int index) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">            new Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">            r.resultExtras, r.ordered, r.initialSticky, r.userId);        </span><br><span class="line">        ...            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">            Intent intent, int resultCode, String data, Bundle extras,</span><br><span class="line">            boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123;</span><br><span class="line">        ...</span><br><span class="line">        app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">            data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityThread.java]</span><br><span class="line">public final class ActivityThread extends ClientTransactionHandler &#123;</span><br><span class="line"></span><br><span class="line">    private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">    </span><br><span class="line">        public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,</span><br><span class="line">                int resultCode, String dataStr, Bundle extras, boolean ordered,</span><br><span class="line">                boolean sticky, int sendingUser, int processState) throws RemoteException &#123;</span><br><span class="line">            updateProcessState(processState, false);</span><br><span class="line">            receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">                    sticky, sendingUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [LoadedApk.java]</span><br><span class="line">public final class LoadedApk &#123;</span><br><span class="line"></span><br><span class="line">    static final class ReceiverDispatcher &#123;</span><br><span class="line">        </span><br><span class="line">        final BroadcastReceiver mReceiver;</span><br><span class="line">        final Handler mActivityThread;</span><br><span class="line">        final Instrumentation mInstrumentation;</span><br><span class="line">        </span><br><span class="line">        ReceiverDispatcher(BroadcastReceiver receiver, Context context,</span><br><span class="line">                Handler activityThread, Instrumentation instrumentation,</span><br><span class="line">                boolean registered) &#123;</span><br><span class="line">            mReceiver &#x3D; receiver;</span><br><span class="line">            mActivityThread &#x3D; activityThread;</span><br><span class="line">            mInstrumentation &#x3D; instrumentation;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        final static class InnerReceiver extends IIntentReceiver.Stub &#123;</span><br><span class="line">            final WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</span><br><span class="line">            final LoadedApk.ReceiverDispatcher mStrongRef;</span><br><span class="line"></span><br><span class="line">            InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123;</span><br><span class="line">                mDispatcher &#x3D; new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</span><br><span class="line">                mStrongRef &#x3D; strong ? rd : null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">                    Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">                final LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">                if (intent &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    rd &#x3D; null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    rd &#x3D; mDispatcher.get();</span><br><span class="line">                &#125;</span><br><span class="line">                if (rd !&#x3D; null) &#123;</span><br><span class="line">                    rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                            ordered, sticky, sendingUser);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    IActivityManager mgr &#x3D; ActivityManager.getService();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (extras !&#x3D; null) &#123;</span><br><span class="line">                            extras.setAllowFds(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags());</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        throw e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void performReceive(Intent intent, int resultCode, String data,</span><br><span class="line">                Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123;</span><br><span class="line">            final Args args &#x3D; new Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">                    sticky, sendingUser);</span><br><span class="line">            &#x2F;&#x2F; 通过ActivityThread的mH的post方法</span><br><span class="line">            if (intent &#x3D;&#x3D; null || !mActivityThread.post(args.getRunnable())) &#123;</span><br><span class="line">                if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                    IActivityManager mgr &#x3D; ActivityManager.getService();</span><br><span class="line">                    args.sendFinished(mgr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final class Args extends BroadcastReceiver.PendingResult &#123;</span><br><span class="line">            public final Runnable getRunnable() &#123;</span><br><span class="line">                return () -&gt; &#123;</span><br><span class="line">                    final BroadcastReceiver receiver &#x3D; mReceiver;</span><br><span class="line">                    final boolean ordered &#x3D; mOrdered;</span><br><span class="line"></span><br><span class="line">                    final IActivityManager mgr &#x3D; ActivityManager.getService();</span><br><span class="line">                    final Intent intent &#x3D; mCurIntent;</span><br><span class="line"></span><br><span class="line">                    mCurIntent &#x3D; null;</span><br><span class="line">                    mDispatched &#x3D; true;</span><br><span class="line">                    mPreviousRunStacktrace &#x3D; new Throwable(&quot;Previous stacktrace&quot;);</span><br><span class="line">                    if (receiver &#x3D;&#x3D; null || intent &#x3D;&#x3D; null || mForgotten) &#123;</span><br><span class="line">                        if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                            sendFinished(mgr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ClassLoader cl &#x3D; mReceiver.getClass().getClassLoader();</span><br><span class="line">                        intent.setExtrasClassLoader(cl);</span><br><span class="line">                        intent.prepareToEnterProcess();</span><br><span class="line">                        setExtrasClassLoader(cl);</span><br><span class="line">                        receiver.setPendingResult(this);</span><br><span class="line">                        receiver.onReceive(mContext, intent);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        if (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">                            sendFinished(mgr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (receiver.getPendingResult() !&#x3D; null) &#123;</span><br><span class="line">                        finish();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h4><p><a href="https://blog.csdn.net/verymrq/article/details/78518777?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">【Android源码系列】BroadcastReceiver启动源码解析</a><br><a href="https://blog.csdn.net/houliang120/article/details/51607170/" target="_blank" rel="noopener">Android广播机制详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/ANR%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/ANR%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">ANR机制以及问题分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 11:17:27" itemprop="dateCreated datePublished" datetime="2020-08-10T11:17:27+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ANR机制以及问题分析"><a href="#ANR机制以及问题分析" class="headerlink" title="ANR机制以及问题分析"></a>ANR机制以及问题分析</h4><p>目录</p>
<ol>
<li><p>概览</p>
</li>
<li><p>ANR机制</p>
</li>
<li><p>1 ANR的监测机制</p>
</li>
<li><p>1.1 Service处理超时</p>
</li>
<li><p>1.2 Broadcast处理超时</p>
</li>
<li><p>1.3 Input处理超时</p>
</li>
<li><p>1.4 小结</p>
</li>
<li><p>2 ANR的报告机制</p>
</li>
<li><p>2.1 CPU的使用情况</p>
</li>
<li><p>2.2 函数调用栈</p>
</li>
<li><p>问题分析方法</p>
</li>
<li><p>1 日志获取</p>
</li>
<li><p>2 问题定位</p>
</li>
<li><p>3 场景还原</p>
</li>
<li><p>3.1 第一个假设和验证</p>
</li>
<li><p>3.2 第二个假设和验证</p>
</li>
<li><p>总结<br>请尊重原创版权，转载注明出处。</p>
</li>
<li><p>概览<br>ANR(Application Not Responding)，应用程序无响应，简单一个定义，却涵盖了很多Android系统的设计思想。</p>
</li>
</ol>
<p>首先，ANR属于应用程序的范畴，这不同于SNR(System Not Respoding)，SNR反映的问题是系统进程(system_server)失去了响应能力，而ANR明确将问题圈定在应用程序。 SNR由Watchdog机制保证，具体可以查阅Watchdog机制以及问题分析; ANR由消息处理机制保证，Android在系统层实现了一套精密的机制来发现ANR，核心原理是消息调度和超时处理。</p>
<p>其次，ANR机制主体实现在系统层。所有与ANR相关的消息，都会经过系统进程(system_server)调度，然后派发到应用进程完成对消息的实际处理，同时，系统进程设计了不同的超时限制来跟踪消息的处理。 一旦应用程序处理消息不当，超时限制就起作用了，它收集一些系统状态，譬如CPU/IO使用情况、进程函数调用栈，并且报告用户有进程无响应了(ANR对话框)。</p>
<p>然后，ANR问题本质是一个性能问题。ANR机制实际上对应用程序主线程的限制，要求主线程在限定的时间内处理完一些最常见的操作(启动服务、处理广播、处理输入)， 如果处理超时，则认为主线程已经失去了响应其他操作的能力。主线程中的耗时操作，譬如密集CPU运算、大量IO、复杂界面布局等，都会降低应用程序的响应能力。</p>
<p>最后，部分ANR问题是很难分析的，有时候由于系统底层的一些影响，导致消息调度失败，出现问题的场景又难以复现。 这类ANR问题往往需要花费大量的时间去了解系统的一些行为，超出了ANR机制本身的范畴。</p>
<ol start="2">
<li>ANR机制<br>分析一些初级的ANR问题，只需要简单理解最终输出的日志即可，但对于一些由系统问题(譬如CPU负载过高、进程卡死)引发的ANR，就需要对整个ANR机制有所了解，才能定位出问题的原因。</li>
</ol>
<p>ANR机制可以分为两部分：</p>
<p>ANR的监测。Android对于不同的ANR类型(Broadcast, Service, InputEvent)都有一套监测机制。</p>
<p>ANR的报告。在监测到ANR以后，需要显示ANR对话框、输出日志(发生ANR时的进程函数调用栈、CPU使用情况等)。</p>
<p>整个ANR机制的代码也是横跨了Android的几个层：</p>
<p>App层：应用主线程的处理逻辑</p>
<p>Framework层： ANR机制的核心</p>
<p>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java<br>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java<br>frameworks/base/services/core/java/com/android/server/am/ActiveServices.java<br>frameworks/base/services/core/java/com/android/server/input/InputManagerService.java<br>frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java<br>frameworks/base/core/java/android/view/InputChannel<br>frameworks/base/services/core/java/com/android/internal/os/ProcessCpuTracker<br>Native层：输入事件派发机制。针对InputEvent类型的ANR</p>
<p>frameworks/base//services/core/jni/com_android_server_input_InputManagerService.cpp<br>frameworks/native/services/inputflinger/InputDispatcher.cpp<br>下面我们会深入源码，分析ANR的监测和报告过程。</p>
<p>2.1 ANR的监测机制<br>2.1.1 Service处理超时<br>Service运行在应用程序的主线程，如果Service的执行时间超过20秒，则会引发ANR。</p>
<p>当发生Service ANR时，一般可以先排查一下在Service的生命周期函数中(onCreate(), onStartCommand()等)有没有做耗时的操作，譬如复杂的运算、IO操作等。 如果应用程序的代码逻辑查不出问题，就需要深入检查当前系统的状态：CPU的使用情况、系统服务的状态等，判断当时发生ANR进程是否受到系统运行异常的影响。</p>
<p>如何检测Service超时呢？Android是通过设置定时消息实现的。定时消息是由AMS的消息队列处理的(system_server的ActivityManager线程)。 AMS有Service运行的上下文信息，所以在AMS中设置一套超时检测机制也是合情合理的。</p>
<p>Service ANR机制相对最为简单，主体实现在ActiveServices中。 当Service的生命周期开始时，bumpServiceExecutingLocked()会被调用，紧接着会调用scheduleServiceTimeoutLocked()：</p>
<p>void scheduleServiceTimeoutLocked(ProcessRecord proc) {<br>    …<br>    Message msg = mAm.mHandler.obtainMessage(<br>            ActivityManagerService.SERVICE_TIMEOUT_MSG);<br>    msg.obj = proc;<br>    // 通过AMS.MainHandler抛出一个定时消息<br>    mAm.mHandler.sendMessageAtTime(msg,<br>         proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));<br>}<br>上述方法通过AMS.MainHandler抛出一个定时消息SERVICE_TIMEOUT_MSG：</p>
<p>前台进程中执行Service，超时时间是SERVICE_TIMEOUT(20秒)<br>后台进程中执行Service，超时时间是SERVICE_BACKGROUND_TIMEOUT(200秒)<br>当Service的生命周期结束时，会调用serviceDoneExecutingLocked()方法，之前抛出的SERVICE_TIMEOUT_MSG消息在这个方法中会被清除。 如果在超时时间内，SERVICE_TIMEOUT_MSG没有被清除，那么，AMS.MainHandler就会响应这个消息:</p>
<p>case SERVICE_TIMEOUT_MSG: {<br>    // 判断是否在做dexopt操作， 该操作的比较耗时，允许再延长20秒<br>    if (mDidDexOpt) {<br>        mDidDexOpt = false;<br>        Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);<br>        nmsg.obj = msg.obj;<br>        mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);<br>        return;<br>    }<br>    mServices.serviceTimeout((ProcessRecord)msg.obj);<br>} break;<br>如果不是在做dexopt操作，ActiveServices.serviceTimeout()就会被调用：</p>
<p>void serviceTimeout(ProcessRecord proc) {<br>    …<br>    final long maxTime =  now -<br>              (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);<br>    …<br>    // 寻找运行超时的Service<br>    for (int i=proc.executingServices.size()-1; i&gt;=0; i–) {<br>        ServiceRecord sr = proc.executingServices.valueAt(i);<br>        if (sr.executingStart &lt; maxTime) {<br>            timeout = sr;<br>            break;<br>        }<br>       …<br>    }<br>    …<br>    // 判断执行Service超时的进程是否在最近运行进程列表，如果不在，则忽略这个ANR<br>    if (timeout != null &amp;&amp; mAm.mLruProcesses.contains(proc)) {<br>        anrMessage = “executing service “ + timeout.shortName;<br>    }<br>    …<br>    if (anrMessage != null) {<br>        mAm.appNotResponding(proc, null, null, false, anrMessage);<br>    }<br>}<br>上述方法会找到当前进程已经超时的Service，经过一些判定后，决定要报告ANR，最终调用AMS.appNotResponding()方法。 走到这一步，ANR机制已经完成了监测报告任务，剩下的任务就是ANR结果的输出，我们称之为ANR的报告机制。 ANR的报告机制是通过AMS.appNotResponding()完成的，Broadcast和InputEvent类型的ANR最终也都会调用这个方法，我们后文再详细展开。</p>
<p>至此，我们分析了Service的ANR机制：</p>
<p>通过定时消息跟踪Service的运行，当定时消息被响应时，说明Service还没有运行完成，这就意味着Service ANR。</p>
<p>2.1.2 Broadcast处理超时<br>应用程序可以注册广播接收器，实现BroadcastReceiver.onReceive()方法来完成对广播的处理。 通常，这个方法是在主线程执行的，Android限定它执行时间不能超过10秒，否则，就会引发ANR。</p>
<p>onReceive()也可以调度在其他线程执行，通过Context.registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)这个方法注册广播接收器， 可以指定一个处理的Handler，将onReceive()调度在非主线程执行。</p>
<p>这里先把问题抛出来了：</p>
<p>Android如何将广播投递给各个应用程序？<br>Android如何检测广播处理超时？<br>广播消息的调度<br>AMS维护了两个广播队列BroadcastQueue:</p>
<p>foreground queue，前台队列的超时时间是10秒<br>background queue，后台队列的超时时间是60秒<br>之所以有两个，就是因为要区分的不同超时时间。所有发送的广播都会进入到队列中等待调度，在发送广播时，可以通过Intent.FLAG_RECEIVER_FOREGROUND参数将广播投递到前台队列。 AMS线程会不断地从队列中取出广播消息派发到各个接收器(BroadcastReceiver)。当要派发广播时，AMS会调用BroadcastQueue.scheduleBroadcastsLocked()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleBroadcastsLocked() &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (mBroadcastsScheduled) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法中，往AMS线程的消息队列发送BROADCAST_INTENT_MSG消息，由此也可以看到真正派发广播的是AMS线程(system_server进程中的ActivityManager线程)。 由于上述方法可能被并发调用，所以通过mBroadcastsScheduled这个变量来标识BROADCAST_INTENT_MSG是不是已经被AMS线程接收了，当已经抛出的消息还未被接受时，不需要重新抛出。 该消息被接收后的处理逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">            ...</span><br><span class="line">            processNextBroadcast(true);</span><br><span class="line">        &#125; break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用BroadcastQueue.processNextBroadcast()方法，fromMsg参数为true表示这是一次来自BROADCAST_INTENT_MSG消息的派发请求。 BroadcastQueue.processNextBroadcast()是派发广播消息最为核心的函数，代码量自然也不小，我们分成几个部分来分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; processNextBroadcast部分1：处理非串行广播消息</span><br><span class="line">final void  processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 1. 设置mBroadcastsScheduled</span><br><span class="line">    if (fromMsg) &#123;</span><br><span class="line">        mBroadcastsScheduled &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2. 处理“并行广播消息”</span><br><span class="line">    while (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">        ...</span><br><span class="line">        final int N &#x3D; r.receivers.size();</span><br><span class="line">        for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">            Object target &#x3D; r.receivers.get(i);</span><br><span class="line">            deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false);</span><br><span class="line">        &#125;</span><br><span class="line">        addBroadcastToHistoryLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3. 处理阻塞的广播消息</span><br><span class="line">    if (mPendingBroadcast !&#x3D; null) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!isDead) &#123;</span><br><span class="line">            &#x2F;&#x2F; isDead表示当前广播消息的进程的存活状态</span><br><span class="line">            &#x2F;&#x2F; 如果还活着，则返回该函数，继续等待下次派发</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;未完待续</span><br></pre></td></tr></table></figure>
<p>第一个部分是处理非”串行广播消息“，有以下几个步骤：</p>
<p>设置mBroadcastsScheduled。该变量在前文说过，是对BROADCAST_INTENT_MSG进行控制。 如果是响应BROADCAST_INTENT_MSG的派发调用，则将mBroadcastsScheduled设为false， 表示本次BROADCAST_INTENT_MSG已经处理完毕，可以继续抛出下一次BROADCAST_INTENT_MSG消息了</p>
<p>处理“并行广播消息”。广播接受器有“动态”和“静态”之分，通过Context.registerReceiver()注册的广播接收器为“动态”的，通过AndroidManifest.xml注册的广播接收器为“静态”的。 广播消息有“并行”和“串行”之分，“并行广播消息”都会派发到“动态”接收器，“串行广播消息”则会根据实际情况派发到两种接收器。 我们先不去探究Android为什么这么设计，只关注这两种广播消息派发的区别。在BroadcastQueue维护着两个队列：</p>
<p>mParallelBroadcasts，“并行广播消息”都会进入到此队列中排队。“并行广播消息”可以一次性派发完毕，即在一个循环中将广播派发到所有的“动态”接收器</p>
<p>mOrderedBroadcasts，“串行广播消息”都会进入到此队列中排队。“串行广播消息”需要轮侯派发，当一个接收器处理完毕后，会再抛出BROADCAST_INTENT_MSG消息， 再次进入BroadcastQueue.processNextBroadcast()处理下一个</p>
<p>处理阻塞的广播消息。有时候会存在一个广播消息派发不出去的情况，这个广播消息会保存在mPendingBroadcast变量中。新一轮的派发启动时，会判断接收该消息的进程是否还活着， 如果接收进程还活着，那么就继续等待。否则，就放弃这个广播消息</p>
<p>接下来是最为复杂的一部分，处理“串行广播消息”，ANR监测机制只在这一类广播消息中才发挥作用，也就是说“并行广播消息”是不会发生ANR的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; processNextBroadcast部分2：从队列中取出“串行广播消息”</span><br><span class="line">    do &#123;</span><br><span class="line">        r &#x3D; mOrderedBroadcasts.get(0);</span><br><span class="line">        &#x2F;&#x2F; 1. 广播消息的第一个ANR监测机制</span><br><span class="line">        if (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123;</span><br><span class="line">            if ((numReceivers &gt; 0) &amp;&amp;</span><br><span class="line">                (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                broadcastTimeoutLocked(false); &#x2F;&#x2F; forcibly finish this broadcast</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2. 判断该广播消息是否处理完毕</span><br><span class="line">        if (r.receivers &#x3D;&#x3D; null || r.nextReceiver &gt;&#x3D; numReceivers ||</span><br><span class="line">            r.resultAbort || forceReceive) &#123;</span><br><span class="line">            ...</span><br><span class="line">            cancelBroadcastTimeoutLocked();</span><br><span class="line">            ...</span><br><span class="line">            mOrderedBroadcasts.remove(0);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; while (r &#x3D;&#x3D; null);</span><br></pre></td></tr></table></figure>

<p>这部分是一个do-while循环，每次都从mOrderedBroadcasts队列中取出第一条广播消息进行处理。第一个Broadcast ANR监测机制千呼万唤总算是出现了：</p>
<p>判定当前时间是否已经超过了r.dispatchTime + 2×mTimeoutPeriod×numReceivers:</p>
<p>dispatchTime表示这一系列广播消息开始派发的时间。“串行广播消息”是逐个接收器派发的，一个接收器处理完毕后，才开始处理下一个消息派发。 开始派发到第一个接收器的时间就是dispatchTime。dispatchTime需要开始等广播消息派发以后才会设定，也就是说，第一次进入processNextBroadcast()时， dispatchTime=0,并不会进入该条件判断</p>
<p>mTimeoutPeriod由当前BroadcastQueue的类型决定(forground为10秒，background为60秒)。这个时间在初始化BroadcastQueue的时候就设置好了， 本意是限定每一个Receiver处理广播的时间，这里利用它做了一个超时计算</p>
<p>假设一个广播消息有2个接受器，mTimeoutPeriod是10秒，当2×10×2=40秒后，该广播消息还未处理完毕，就调用broadcastTimeoutLocked()方法， 这个方法会判断当前是不是发生了ANR，我们后文再分析。</p>
<p>如果广播消息是否已经处理完毕，则从mOrderedBroadcasts中移除，重新循环，处理下一条;否则，就会跳出循环。</p>
<p>以上代码块完成的主要任务是从队列中取一条“串行广播消息”，接下来就准备派发了：</p>
<p>// processNextBroadcast部分3：串行广播消息的第二个ANR监测机制<br>    r.receiverTime = SystemClock.uptimeMillis();<br>    …<br>    if (! mPendingBroadcastTimeoutMessage) {<br>        long timeoutTime = r.receiverTime + mTimeoutPeriod;<br>        …<br>        setBroadcastTimeoutLocked(timeoutTime);<br>    }<br>//未完待续<br>取出“串行广播消息”后，一旦要开始派发，第二个ANR检测机制就出现了。mPendingBroadcastTimeoutMessage变量用于标识当前是否有阻塞的超时消息， 如果没有则调用BroadcastQueue.setBroadcastTimeoutLocked()：</p>
<p>final void setBroadcastTimeoutLocked(long timeoutTime) {<br>    if (! mPendingBroadcastTimeoutMessage) {<br>        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);<br>        mHandler.sendMessageAtTime(msg, timeoutTime);<br>        mPendingBroadcastTimeoutMessage = true;<br>    }<br>}<br>通过设置一个定时消息BROADCAST_TIMEOUT_MSG来跟踪当前广播消息的执行情况，这种超时监测机制跟Service ANR很类似，也是抛到AMS线程的消息队列。 如果所有的接收器都处理完毕了，则会调用cancelBroadcastTimeoutLocked()清除该消息;否则，该消息就会响应，并调用broadcastTimeoutLocked()， 这个方法在第一种ANR监测机制的时候调用过，第二种ANR监测机制也会调用，我们留到后文分析。</p>
<p>设置完定时消息后，就开始派发广播消息了，首先是“动态”接收器：</p>
<p>// processNextBroadcast部分4： 向“动态”接收器派发广播消息<br>    final Object nextReceiver = r.receivers.get(recIdx);<br>    // 动态接收器的类型都是BroadcastFilter<br>    if (nextReceiver instanceof BroadcastFilter) {<br>        BroadcastFilter filter = (BroadcastFilter)nextReceiver;<br>        deliverToRegisteredReceiverLocked(r, filter, r.ordered);<br>        …<br>        return;<br>    }<br>//未完待续<br>“动态”接收器的载体进程一般是处于运行状态的，所以向这种类型的接收器派发消息相对简单，调用BroadcastQueue.deliverToRegisteredReceiverLocked()完成接下来的工作。 但“静态”接收器是在AndroidManifest.xml中注册的，派发的时候，可能广播接收器的载体进程还没有启动，所以，这种场景会复杂很多。</p>
<p>// processNextBroadcast部分5： 向“静态”接收器派发广播消息<br>    // 静态接收器的类型都是 ResolveInfo<br>    ResolveInfo info = (ResolveInfo)nextReceiver;<br>    …<br>    // 1. 权限检查<br>    ComponentName component = new ComponentName(<br>                info.activityInfo.applicationInfo.packageName,<br>                info.activityInfo.name);<br>    int perm = mService.checkComponentPermission(info.activityInfo.permission,<br>                r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,<br>                info.activityInfo.exported);<br>    …<br>    // 2. 获取接收器所在的进程<br>    ProcessRecord app = mService.getProcessRecordLocked(targetProcess,<br>                info.activityInfo.applicationInfo.uid, false);<br>    // 3. 进程已经启动<br>    if (app != null &amp;&amp; app.thread != null) {<br>       …<br>       processCurBroadcastLocked(r, app);<br>       return;<br>    }<br>    // 4. 进程还未启动<br>    if ((r.curApp=mService.startProcessLocked(targetProcess,<br>                info.activityInfo.applicationInfo, true,<br>                r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,<br>                “broadcast”, r.curComponent,<br>                (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false))<br>                        == null) {<br>        …<br>        scheduleBroadcastsLocked();<br>        return;<br>    }<br>    // 5. 进程启动失败<br>    mPendingBroadcast = r;<br>    mPendingBroadcastRecvIndex = recIdx;<br>}<br>// processNextBroadcast完<br>“静态”接收器是ResolveInfo，需要通过PackageManager获取包信息，进行权限检查。权限检查的内容非常庞大，此处不表。</p>
<p>经过一系列复杂的权限检查后，终于可以向目标接收器派发了。通过AMS.getProcessRecordLocked()获取广播接收器的进程信息</p>
<p>如果app.thread ！= null，则进程已经启动，就可以调用BroadcastQueue.processCurBroadcastLocked()进行接下来的派发处理了</p>
<p>如果进程还没有启动，则需要通过AMS.startProcessLocked()来启动进程，当前消息并未派发，调用BroadcastQueue.scheduleBroadcastsLocked()进入下一次的调度</p>
<p>如果进程启动失败了，则当前消息记录成mPendingBroadcast，即阻塞的广播消息，等待下一次调度时处理</p>
<p>庞大的processNextBroadcast()终于完结了，它的功能就是对广播消息进行调度，该方法被设计得十分复杂而精巧，用于应对不同的广播消息和接收器的处理。</p>
<p>广播消息的跨进程传递<br>调度是完成了，接下来，我们就来分析被调度广播消息如何到达应用程序。上文的分析中，最终有两个方法将广播消息派发出去： BroadcastQueue.deliverToRegisteredReceiverLocked()和BroadcastQueue.processCurBroadcastLocked()。</p>
<p>我们先不展开这两个函数的逻辑，试想要将广播消息的从AMS线程所在的system_server进程传递到应用程序的进程，该怎么实现？ 自然需要用到跨进程调用，Android中最常规的手段就是Binder机制。没错，广播消息派发到应用进程就是这么玩的。</p>
<p>对于应用程序已经启动(app.thread != null)的情况，会通过IApplicationThread发起跨进程调用， 调用关系如下：</p>
<p>ActivityThread.ApplicationThread.scheduleReceiver()<br>└── ActivityThread.handleReceiver()<br>    └── BroadcastReceiver.onReceive()<br>对于应用程序还未启动的情况，会调用IIntentReceiver发起跨进程调用，应用进程的实现在LoadedApk.ReceiverDispatcher.IntentReceiver中， 调用关系如下：</p>
<p>LoadedApk.ReceiverDispatcher.IntentReceiver.performReceive()<br>└── LoadedApk.ReceiverDispatcher.performReceiver()<br>    └── LoadedApk.ReceiverDispatcher.Args.run()<br>        └── BroadcastReceiver.onReceive()<br>最终，都会调用到BroadcastReceiver.onReceive()，在应用进程执行接收广播消息的具体动作。 对于“串行广播消息”而言，执行完了以后，还需要通知system_server进程，才能继续将广播消息派发到下一个接收器，这又需要跨进程调用了。 应用进程在处理完广播消息后，即在BroadcastReceiver.onReceive()执行完毕后，会调用BroadcastReceiver.PendingResult.finish()， 接下来的调用关系如下：</p>
<p>BroadcastReceiver.PendingResult.finish()<br>└── BroadcastReceiver.PendingResult.sendFinished()<br>    └── IActivityManager.finishReceiver()<br>        └── ActivityManagerService.finishReceiver()<br>            └── BroadcastQueue.processNextBroadcat()<br>通过IActivityManager发起了一个从应用进程到system_server进程的调用，最终在AMS线程中，又走到了BroadcastQueue.processNextBroadcat(), 开始下一轮的调度。</p>
<p>broadcastTimeoutLocked()方法<br>前文说过，两种ANR机制最终都会调用BroadcastQueue.broadcastTimeoutLocked()方法， 第一种ANR监测生效时，会将fromMsg设置为false;第二种ANR监测生效时，会将fromMsg参数为True时，表示当前正在响应BROADCAST_TIMEOUT_MSG消息。</p>
<p>final void broadcastTimeoutLocked(boolean fromMsg) {<br>    // 1. 设置mPendingBroadcastTimeoutMessage<br>    if (fromMsg) {<br>        mPendingBroadcastTimeoutMessage = false;<br>    }<br>    …<br>    // 2. 判断第二种ANR机制是否超时<br>    BroadcastRecord r = mOrderedBroadcasts.get(0);<br>    if (fromMsg) {<br>        long timeoutTime = r.receiverTime + mTimeoutPeriod;<br>        if (timeoutTime &gt; now) {<br>            setBroadcastTimeoutLocked(timeoutTime);<br>            return;<br>        }<br>    }<br>    …<br>    // 3. 已经超时，则结束对当前接收器，开始新一轮调度<br>    finishReceiverLocked(r, r.resultCode, r.resultData,<br>                r.resultExtras, r.resultAbort, false);<br>    scheduleBroadcastsLocked();</p>
<pre><code>// 4. 抛出绘制ANR对话框的消息
if (anrMessage != null) {
    mHandler.post(new AppNotResponding(app, anrMessage));
}</code></pre><p>}<br>mPendingBroadcastTimeoutMessage标识是否存在未处理的BROADCAST_TIMEOUT_MSG消息， 将其设置成false，允许继续抛出BROADCAST_TIMEOUT_MSG消息</p>
<p>每次将广播派发到接收器，都会将r.receiverTime更新，如果判断当前还未超时，则又抛出一个BROADCAST_TIMEOUT_MSG消息。 正常情况下，所有接收器处理完毕后，才会清除BROADCAST_TIMEOUT_MSG;否则，每进行一次广播消息的调度，都会抛出BROADCAST_TIMEOUT_MSG消息</p>
<p>判断已经超时了，说明当前的广播接收器还未处理完毕，则结束掉当前的接收器，开始新一轮广播调度</p>
<p>最终，发出绘制ANR对话框的消息</p>
<p>至此，我们回答了前文提出的两个问题:</p>
<p><strong>AMS维护着广播队列BroadcastQueue，AMS线程不断从队列中取出消息进行调度，完成广播消息的派发。 在派发“串行广播消息”时，会抛出一个定时消息BROADCAST_TIMEOUT_MSG，在广播接收器处理完毕后，AMS会将定时消息清除。 如果BROADCAST_TIMEOUT_MSG得到了响应，就会判断是否广播消息处理超时，最终通知ANR的发生。</strong></p>
<p>2.1.3 Input处理超时<br>应用程序可以接收输入事件(按键、触屏、轨迹球等)，当5秒内没有处理完毕时，则会引发ANR。</p>
<p>如果Broadcast ANR一样，我们抛出Input ANR的几个问题：</p>
<p>输入事件经历了一些什么工序才能被派发到应用的界面？<br>如何检测到输入时间处理超时？<br>输入事件最开始由硬件设备(譬如按键或触摸屏幕)发起，Android有一套输入子系统来发现各种输入事件， 这些事件最终都会被InputDispatcher分发到各个需要接收事件的窗口。 那么，窗口如何告之InputDispatcher自己需要处理输入事件呢？Android通过InputChannel 连接InputDispatcher和窗口，InputChannel其实是封装后的Linux管道(Pipe)。 每一个窗口都会有一个独立的InputChannel，窗口需要将这个InputChannel注册到InputDispatcher中:</p>
<p>status_t InputDispatcher::registerInputChannel(const sp<InputChannel>&amp; inputChannel,<br>        const sp<InputWindowHandle>&amp; inputWindowHandle, bool monitor) {<br>    …<br>    sp<Connection> connection = new Connection(inputChannel, inputWindowHandle, monitor);<br>    int fd = inputChannel-&gt;getFd();<br>    mConnectionsByFd.add(fd, connection);<br>    …<br>    mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);<br>    …<br>    mLooper-&gt;wake();<br>    return OK;<br>}<br>对于InputDispatcher而言，每注册一个InputChannel都被视为一个Connection，通过文件描述符来区别。InputDispatcher是一个消息处理循环，当有新的Connection时，就需要唤醒消息循环队列进行处理。</p>
<p>输入事件的类型有很多，按键、轨迹球、触屏等，Android对这些事件进行了分类，处理这些事件的窗口也被赋予了一个类型(targetType)：Foucused或Touched， 如果当前输入事件是按键类型，则寻找Focused类型的窗口;如果当前输入事件类型是触摸类型，则寻找Touched类型的窗口。 InputDispatcher需要经过以下复杂的调用关系，才能把一个输入事件派发出去(调用关系以按键事件为例，触屏事件的调用关系类似)：</p>
<p>InputDispatcherThread::threadLoop()<br>└── InputDispatcher::dispatchOnce()<br>    └── InputDispatcher::dispatchOnceInnerLocked()<br>        └── InputDispatcher::dispatchKeyLocked()<br>            └── InputDispatcher::dispatchEventLocked()<br>                └── InputDispatcher::prepareDispatchCycleLocked()<br>                    └── InputDispatcher::enqueueDispatchEntriesLocked()<br>                        └── InputDispatcher::startDispatchCycleLocked()<br>                            └── InputPublisher::publishKeyEvent()<br>具体每个函数的实现逻辑此处不表。我们提炼出几个关键点：</p>
<p>InputDispatcherThread是一个线程，它处理一次消息的派发<br>输入事件作为一个消息，需要排队等待派发，每一个Connection都维护两个队列：<br>outboundQueue: 等待发送给窗口的事件。每一个新消息到来，都会先进入到此队列<br>waitQueue: 已经发送给窗口的事件<br>publishKeyEvent完成后，表示事件已经派发了，就将事件从outboundQueue挪到了waitQueue<br>事件经过这么一轮处理，就算是从InputDispatcher派发出去了，但事件是不是被窗口收到了，还需要等待接收方的“finished”通知。 在向InputDispatcher注册InputChannel的时候，同时会注册一个回调函数handleReceiveCallback():</p>
<p>int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) {<br>    …<br>    for (;;) {<br>        …<br>        status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled);<br>        if (status) {<br>            break;<br>        }<br>        d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled);<br>        …<br>    }<br>    …<br>    d-&gt;unregisterInputChannelLocked(connection-&gt;inputChannel, notify);<br>}<br>当收到的status为OK时，会调用finishDispatchCycleLocked()来完成一个消息的处理：</p>
<p>InputDispatcher::finishDispatchCycleLocked()<br>└── InputDispatcher::onDispatchCycleFinishedLocked()<br>    └── InputDispatcher::doDispatchCycleFinishedLockedInterruptible()<br>        └── InputDispatcher::startDispatchCycleLocked()<br>调用到doDispatchCycleFinishedLockedInterruptible()方法时，会将已经成功派发的消息从waitQueue中移除， 进一步调用会startDispatchCycleLocked开始派发新的事件。</p>
<p>至此，我们回答了第一个问题：</p>
<p>一个正常的输入事件会经过从outboundQueue挪到waitQueue的过程，表示消息已经派发出去;再经过从waitQueue中移除的过程，表示消息已经被窗口接收。 InputDispatcher作为中枢，不停地在递送着输入事件，当一个事件无法得到处理的时候，InputDispatcher不能就此死掉啊，否则系统也太容易崩溃了。 InputDispatcher的策略是放弃掉处理不过来的事件，并发出通知(这个通知机制就是ANR)，继续进行下一轮消息的处理。</p>
<p>理解输入事件分发模型，我们可以举一个生活中的例子：<br>每一个输入事件可以比做一个快递，InputDispatcher就像一个快递中转站，窗口就像是收件人，InputChannel就像是快递员。 所有快递都会经过中转站中处理，中转站需要知道每一个快递的收件人是谁，通过快递员将快递发送到具体的收件人。 这其中有很多场景导致快递不能及时送到：譬如联系不到收件人;快递很多，快递员会忙不过来;快递员受伤休假了等等… 这时候快递员就需要告知中转站：有快递无法及时送到了。中转站在收到快递员的通知后，一边继续派发其他快递，一边报告上级。</p>
<p>在了解输入事件分发模型之后，我们可以见识一下ANR机制了。在派发事件时，dispatchKeyLocked()和dispatchMotionLocked()， 需要找到当前的焦点窗口,焦点窗口才是最终接收事件的地方，找窗口的过程就会判断是否已经发生了ANR：</p>
<p>InputDispatcher::findFocusedWindowTargetsLocked()<br>InputDispatcher::findTouchedWindowTargetsLocked()<br>└── InputDispatcher::handleTargetsNotReadyLocked()<br>    └── InputDispatcher::onANRLocked()<br>        └── InputDispatcher::doNotifyANRLockedInterruptible()<br>            └── NativeInputManager::notifyANR()<br>首先，会调用findFocusedWindowTargetsLocked()或findTouchedWindowTargetsLocked()寻找接收输入事件的窗口。</p>
<p>在找到窗口以后，会调用checkWindowReadyForMoreInputLocked() 检查窗口是否有能力再接收新的输入事件，会有一系列的场景阻碍事件的继续派发：</p>
<p>场景1: 窗口处于paused状态，不能处理输入事件</p>
<p>“Waiting because the [targetType] window is paused.”</p>
<p>场景2: 窗口还未向InputDispatcher注册，无法将事件派发到窗口</p>
<p>“Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.”</p>
<p>场景3: 窗口和InputDispatcher的连接已经中断，即InputChannel不能正常工作</p>
<p>“Waiting because the [targetType] window’s input connection is [status]. The window may be in the process of being removed.”</p>
<p>场景4: InputChannel已经饱和，不能再处理新的事件</p>
<p>“Waiting because the [targetType] window’s input channel is full. Outbound queue length: %d. Wait queue length: %d.”</p>
<p>场景5: 对于按键类型(KeyEvent)的输入事件，需要等待上一个事件处理完毕</p>
<p>“Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: %d. Wait queue length: %d.”</p>
<p>场景6: 对于触摸类型(TouchEvent)的输入事件，可以立即派发到当前的窗口，因为TouchEvent都是发生在用户当前可见的窗口。但有一种情况， 如果当前应用由于队列有太多的输入事件等待派发，导致发生了ANR，那TouchEvent事件就需要排队等待派发。</p>
<p>“Waiting to send non-key event because the %s window has not finished processing certain input events that were delivered to it over %0.1fms ago. Wait queue length: %d. Wait queue head age: %0.1fms.”</p>
<p>然后，上述有任何一个场景发生了，则输入事件需要继续等待，紧接着就会调用handleTargetsNotReadyLocked()来判断是不是已经的等待超时了：</p>
<p>int32_t InputDispatcher::handleTargetsNotReadyLocked(nsecs_t currentTime,<br>        const EventEntry* entry,<br>        const sp<InputApplicationHandle>&amp; applicationHandle,<br>        const sp<InputWindowHandle>&amp; windowHandle,<br>        nsecs_t* nextWakeupTime, const char* reason) {<br>    …<br>    if (currentTime &gt;= mInputTargetWaitTimeoutTime) {<br>        onANRLocked(currentTime, applicationHandle, windowHandle,<br>            entry-&gt;eventTime, mInputTargetWaitStartTime, reason);<br>        <em>nextWakeupTime = LONG_LONG_MIN;<br>        return INPUT_EVENT_INJECTION_PENDING;<br>    }<br>    …<br>}<br>最后，如果当前事件派发已经超时，则说明已经检测到了ANR，调用onANRLocked()方法，然后将nextWakeupTime设置为最小值，马上开始下一轮调度。 在onANRLocked()方法中， 会保存ANR的一些状态信息，调用doNotifyANRLockedInterruptible()，进一步会调用到JNI层的 NativeInputManager::notifyANR()方法， 它的主要功能就是衔接Native层和Java层，直接调用Java层的InputManagerService.notifyANR()方法。<br>nsecs_t NativeInputManager::notifyANR(<br>    const sp<InputApplicationHandle>&amp; inputApplicationHandle,<br>    const sp<InputWindowHandle>&amp; inputWindowHandle,<br>    const String8&amp; reason) {<br>    …<br>    JNIEnv</em> env = jniEnv();</p>
<pre><code>// 将应用程序句柄、窗口句柄、ANR原因字符串，转化为Java层的对象
jobject inputApplicationHandleObj =
        getInputApplicationHandleObjLocalRef(env, inputApplicationHandle);
jobject inputWindowHandleObj =
        getInputWindowHandleObjLocalRef(env, inputWindowHandle);
jstring reasonObj = env-&gt;NewStringUTF(reason.string());

// 调用Java层的InputManagerService.notifyANR()方法
jlong newTimeout = env-&gt;CallLongMethod(mServiceObj,
            gServiceClassInfo.notifyANR, inputApplicationHandleObj, inputWindowHandleObj,
            reasonObj);
...
return newTimeout;</code></pre><p>}<br>至此，ANR的处理逻辑转交到了Java层。底层(Native)发现一旦有输入事件派发超时，就会通知上层(Java)，上层收到ANR通知后，决定是否终止当前输入事件的派发。</p>
<p>发生ANR时，Java层最开始的入口是InputManagerService.notifyANR()，它是直接被Native层调用的。我们先把ANR的Java层调用关系列出来：</p>
<p>InputManagerService.notifyANR()<br>└── InputMonitor.notifyANR()<br>    ├── IApplicationToken.keyDispatchingTimedOut()<br>    │   └── ActivityRecord.keyDispatchingTimedOut()<br>    │       └── AMS.inputDispatchingTimedOut()<br>    │           └── AMS.appNotResponding()<br>    │<br>    └── AMS.inputDispatchingTimedOut()<br>        └── AMS.appNotResponding()<br>InputManagerService.notifyANR()只是为Native层定义了一个接口，它直接调用InputMonitor.notifyANR()。 如果该方法的返回值等于0,则放弃本次输入事件;如果大于0,则表示需要继续等待的时间。<br>public long notifyANR(InputApplicationHandle inputApplicationHandle,<br>      InputWindowHandle inputWindowHandle, String reason) {<br>    …<br>    if (appWindowToken != null &amp;&amp; appWindowToken.appToken != null) {<br>        // appToken实际上就是当前的ActivityRecord。<br>        // 如果发生ANR的Activity还存在，则直接通过ActivityRecord通知事件派发超时<br>        boolean abort = appWindowToken.appToken.keyDispatchingTimedOut(reason);<br>        if (! abort) {<br>            return appWindowToken.inputDispatchingTimeoutNanos;<br>        }<br>    } else if (windowState != null) {<br>        // 如果发生ANR的Activity已经销毁了，则通过AMS通知事件派发超时<br>        long timeout = ActivityManagerNative.getDefault().inputDispatchingTimedOut(<br>                        windowState.mSession.mPid, aboveSystem, reason);<br>         if (timeout &gt;= 0) {<br>             return timeout;<br>         }<br>    }<br>    return 0; // abort dispatching<br>}<br>上述方法中有两种不同的调用方式，但最终都会交由AMS.inputDispatchingTimedOut()处理。AMS有重载的inputDispatchingTimedOut()方法，他们的参数不一样。 ActivityRecord调用时，可以传入的信息更多一点(当前发生ANR的界面是哪一个)。<br>@Override<br>public long inputDispatchingTimedOut(int pid, final boolean aboveSystem, String reason) {<br>    // 1. 根据进程号获取到ProcessRecord<br>    proc = mPidsSelfLocked.get(pid);<br>    …<br>    // 2. 获取超时时间<br>    // 测试环境下的超时时间是INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT(60秒)，<br>    // 正常环境下的超时时间是KEY_DISPATCHING_TIMEOUT(5秒)<br>    timeout = getInputDispatchingTimeoutLocked(proc);<br>    // 调用重载的函数，如果返回True，则表示需要中断当前的事件派发;<br>    if (!inputDispatchingTimedOut(proc, null, null, aboveSystem, reason)) {<br>        return -1;<br>    }<br>    // 3. 返回继续等待的时间，这个值会传递到Native层<br>    return timeout;<br>}</p>
<p>public boolean inputDispatchingTimedOut(final ProcessRecord proc,<br>        final ActivityRecord activity, final ActivityRecord parent,<br>        final boolean aboveSystem, String reason) {<br>    …<br>    // 1. 发生ANR进程正处于调试状态，不需要中断事件<br>    if (proc.debugging) {<br>        return false;<br>    }<br>    // 2. 当前正在做dexopt操作，这会比较耗时，不需要中断<br>    if (mDidDexOpt) {<br>        // Give more time since we were dexopting.<br>        mDidDexOpt = false;<br>        return false;<br>    }<br>    // 3. 发生ANR的进程是测试进程，需要中断，但不在UI界面显示ANR信息判断<br>    if (proc.instrumentationClass != null) {<br>        …<br>        finishInstrumentationLocked(proc, Activity.RESULT_CANCELED, info);<br>        return true;<br>    }</p>
<pre><code>// 4. 通知UI界面显示ANR信息
mHandler.post(new Runnable() {
    @Override
    public void run() {
        appNotResponding(proc, activity, parent, aboveSystem, annotation);
    }
});
...
return true;</code></pre><p>}<br>至此，我们回答了第二个问题：</p>
<p>在InputDispatcher派发输入事件时，会寻找接收事件的窗口，如果无法正常派发，则可能会导致当前需要派发的事件超时(默认是5秒)。 Native层发现超时了，会通知Java层，Java层经过一些处理后，会反馈给Native层，是继续等待还是丢弃当前派发的事件。</p>
<p>2.1.4 小结<br>ANR监测机制包含三种：</p>
<p>Service ANR，前台进程中Service生命周期不能超过20秒，后台进程中Service的生命周期不能超过200秒。 在启动Service时，抛出定时消息SERVICE_TIMEOUT_MSG或SERVICE_BACKGOURND_TIMEOUT_MSG，如果定时消息响应了，则说明发生了ANR</p>
<p>Broadcast ANR，前台的“串行广播消息”必须在10秒内处理完毕，后台的“串行广播消息”必须在60秒处理完毕， 每派发串行广播消息到一个接收器时，都会抛出一个定时消息BROADCAST_TIMEOUT_MSG，如果定时消息响应，则判断是否广播消息处理超时，超时就说明发生了ANR</p>
<p>Input ANR，输入事件必须在5秒内处理完毕。在派发一个输入事件时，会判断当前输入事件是否需要等待，如果需要等待，则判断是否等待已经超时，超时就说明发生了ANR</p>
<p>ANR监测机制实际上是对应用程序主线程的要求，要求主线成必须在限定的时间内，完成对几种操作的响应;否则，就可以认为应用程序主线程失去响应能力。</p>
<p>从ANR的三种监测机制中，我们看到不同超时机制的设计：</p>
<p>Service和Broadcast都是由AMS调度，利用Handler和Looper，设计了一个TIMEOUT消息交由AMS线程来处理，整个超时机制的实现都是在Java层； InputEvent由InputDispatcher调度，待处理的输入事件都会进入队列中等待，设计了一个等待超时的判断，超时机制的实现在Native层。</p>
<p>2.2 ANR的报告机制<br>无论哪种类型的ANR发生以后，最终都会调用 AMS.appNotResponding() 方法，所谓“殊途同归”。这个方法的职能就是向用户或开发者报告ANR发生了。 最终的表现形式是：弹出一个对话框，告诉用户当前某个程序无响应;输入一大堆与ANR相关的日志，便于开发者解决问题。</p>
<p>最终形式我们见过很多，但输出日志的原理是什么，未必所有人都了解，下面我们就来认识一下是如何输出ANR日志的。</p>
<p>final void appNotResponding(ProcessRecord app, ActivityRecord activity,<br>        ActivityRecord parent, boolean aboveSystem, final String annotation) {<br>    // app: 当前发生ANR的进程<br>    // activity: 发生ANR的界面<br>    // parent: 发生ANR的界面的上一级界面<br>    // aboveSystem:<br>    // annotation: 发生ANR的原因<br>    …<br>    // 1. 更新CPU使用信息。ANR的第一次CPU信息采样<br>    updateCpuStatsNow();<br>    …<br>    // 2. 填充firstPids和lastPids数组。从最近运行进程(Last Recently Used)中挑选：<br>    //    firstPids用于保存ANR进程及其父进程，system_server进程和persistent的进程(譬如Phone进程)<br>    //    lastPids用于保存除firstPids外的其他进程<br>    firstPids.add(app.pid);<br>    int parentPid = app.pid;<br>    if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid &gt; 0)<br>        parentPid = parent.app.pid;<br>    if (parentPid != app.pid) firstPids.add(parentPid);<br>    if (MY_PID != app.pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);</p>
<pre><code>for (int i = mLruProcesses.size() - 1; i &gt;= 0; i--) {
    ProcessRecord r = mLruProcesses.get(i);
    if (r != null &amp;&amp; r.thread != null) {
        int pid = r.pid;
        if (pid &gt; 0 &amp;&amp; pid != app.pid &amp;&amp; pid != parentPid &amp;&amp; pid != MY_PID) {
            if (r.persistent) {
                firstPids.add(pid);
            } else {
                lastPids.put(pid, Boolean.TRUE);
            }
        }
    }
}
...
// 3. 打印调用栈
File tracesFile = dumpStackTraces(true, firstPids, processCpuTracker, lastPids,
            NATIVE_STACKS_OF_INTEREST);
...
// 4. 更新CPU使用信息。ANR的第二次CPU使用信息采样
updateCpuStatsNow();
...
// 5. 显示ANR对话框
Message msg = Message.obtain();
HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
msg.what = SHOW_NOT_RESPONDING_MSG;
...
mHandler.sendMessage(msg);</code></pre><p>}<br>该方法的主体逻辑可以分成五个部分来看：</p>
<p>更新CPU的统计信息。这是发生ANR时，第一次CPU使用信息的采样，采样数据会保存在mProcessStats这个变量中</p>
<p>填充firstPids和lastPids数组。当前发生ANR的应用会首先被添加到firstPids中，这样打印函数栈的时候，当前进程总是在trace文件的最前面</p>
<p>打印函数调用栈(StackTrace)。具体实现由dumpStackTraces()函数完成</p>
<p>更新CPU的统计信息。这是发生ANR时，第二次CPU使用信息的采样，两次采样的数据分别对应ANR发生前后的CPU使用情况</p>
<p>显示ANR对话框。抛出SHOW_NOT_RESPONDING_MSG消息，AMS.MainHandler会处理这条消息，显示AppNotRespondingDialog</p>
<p>当然，除了主体逻辑，发生ANR时还会输出各种类别的日志：</p>
<p>event log，通过检索”am_anr”关键字，可以找到发生ANR的应用<br>main log，通过检索”ANR in “关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况<br>dropbox，通过检索”anr”类型，可以找到ANR的信息<br>traces, 发生ANR时，各进程的函数调用栈信息<br>我们分析ANR问题，往往是从main log中的CPU使用情况和traces中的函数调用栈开始。所以，更新CPU的使用信息updateCpuStatsNow()方法和打印函数栈dumpStackTraces()方法，是系统报告ANR问题关键所在。</p>
<p>2.2.1 CPU的使用情况<br>AMS.updateCpuStatsNow()方法的实现不在这里列出了，只需要知道更新CPU使用信息的间隔最小是5秒，即如果5秒内连续调用updateCpuStatsNow()方法，其实是没有更新CPU使用信息的。</p>
<p>CPU使用信息由ProcessCpuTracker这个类维护， 每次调用ProcessCpuTracker.update()方法，就会读取设备节点 /proc 下的文件，来更新CPU使用信息，具体有以下几个维度：</p>
<p>CPU的使用时间: 读取 /proc/stat</p>
<p>user： 用户进程的CPU使用时间<br>nice： 降低过优先级进程的CPU使用时间。Linux进程都有优先级，这个优先级可以进行动态调整，譬如进程初始优先级的值设为10,运行时降低为8,那么，修正值-2就定义为nice。 Android将user和nice这两个时间归类成user<br>sys： 内核进程的CPU使用时间<br>idle： CPU空闲的时间<br>wait： CPU等待IO的时间<br>hw irq： 硬件中断的时间。如果外设（譬如硬盘）出现故障，需要通过硬件终端通知CPU保存现场，发生上下文切换的时间就是CPU的硬件中断时间<br>sw irg： 软件中断的时间。同硬件中断一样，如果软件要求CPU中断，则上下文切换的时间就是CPU的软件中断时间<br>CPU负载: 读取 /proc/loadavg, 统计最近1分钟，5分钟，15分钟内，CPU的平均活动进程数。 CPU的负载可以比喻成超市收银员负载，如果有1个人正在买单，有2个人在排队，那么该收银员的负载就是3。 在收银员工作时，不断会有人买单完成，也不断会有人排队，可以在固定的时间间隔内(譬如，每隔5秒)统计一次负载，那么，就可以统计出一段时间内的平均负载。</p>
<p>页错误信息： 进程的CPU使用率最后输出的“faults: xxx minor/major”部分表示的是页错误次数，当次数为0时不显示。 major是指Major Page Fault(主要页错误，简称MPF)，内核在读取数据时会先后查找CPU的高速缓存和物理内存，如果找不到会发出一个MPF信息，请求将数据加载到内存。 minor是指Minor Page Fault(次要页错误，简称MnPF)，磁盘数据被加载到内存后，内核再次读取时，会发出一个MnPF信息。 一个文件第一次被读写时会有很多的MPF，被缓存到内存后再次访问MPF就会很少，MnPF反而变多，这是内核为减少效率低下的磁盘I/O操作采用的缓存技术的结果。</p>
<p>2.2.2 函数调用栈<br>AMS.dumpStackTraces()方法用于打印进程的函数调用栈，该方法的主体逻辑如下：</p>
<p>private static void dumpStackTraces(String tracesPath, ArrayList<Integer> firstPids,<br>            ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {<br>    …<br>    // 1. 对firstPids数组中的进程发送SIGNAL_QUIT。<br>    //    进程在收到SIGNAL_QUIT后，会打印函数调用栈<br>    int num = firstPids.size();<br>    for (int i = 0; i &lt; num; i++) {<br>        synchronized (observer) {<br>            Process.sendSignal(firstPids.get(i), Process.SIGNAL_QUIT);<br>            observer.wait(200);  // Wait for write-close, give up after 200msec<br>        }<br>    }<br>    …<br>    // 2. 打印Native进程的函数调用栈<br>    int[] pids = Process.getPidsForCommands(nativeProcs);<br>    if (pids != null) {<br>        for (int pid : pids) {<br>            Debug.dumpNativeBacktraceToFile(pid, tracesPath);<br>        }<br>    }<br>    …<br>    // 3. 更新CPU的使用情况<br>    processCpuTracker.init();<br>    System.gc();<br>    processCpuTracker.update();<br>    processCpuTracker.wait(500); // measure over 1/2 second.<br>    processCpuTracker.update();</p>
<pre><code>// 4. 对lastPids数组中的进程发送SIGNAL_QUIT
//    只有处于工作状态的lastPids进程，才会收到SIGNAL_QUIT，打印函数调用栈
final int N = processCpuTracker.countWorkingStats();
int numProcs = 0;
for (int i=0; i&lt;N &amp;&amp; numProcs&lt;5; i++) {
ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);
if (lastPids.indexOfKey(stats.pid) &gt;= 0) {
    numProcs++;
    Process.sendSignal(stats.pid, Process.SIGNAL_QUIT);
    observer.wait(200);  // Wait for write-close, give up after 200msec
}</code></pre><p>}<br>该方法有几个重要的逻辑(Native进程的函数调用栈此处不表)：</p>
<p>向进程发送SIGNAL_QUIT信号，进程在收到这个信号后，就会打印函数调用栈，默认输出到 /data/anr/traces.txt 文件中， 当然也可以配置 dalvik.vm.stack-trace-file 这个系统属性来指定输出函数调用栈的位置</p>
<p>traces文件中包含很多进程的函数调用栈，这是由firstPids和lastPids数组控制的，在最终的traces文件中，firstPids中的进程是先打印的， 而且当前发生ANR的进程又是排在firstPids的第一个，所以，当我们打开traces文件，第一个看到的就是当前发生ANR的应用进程</p>
<ol start="3">
<li>问题分析方法<br>分析ANR问题，有三大利器：Logcat，traces和StrictMode。 在StrictMode机制一文中，我们介绍过StrictMode的实现机制以及用途，本文中不讨论利用StrictMode来解决ANR问题，但各位读者需要有这个意识。 在Watchdog机制以及问题分析一文中，我们介绍过logcat和traces这两种日志的用途。 分析ANR问题同Watchdog问题一样，都需要经过日志获取、问题定位和场景还原三个步骤。</li>
</ol>
<p>3.1 日志获取<br>我们在上文中分析过，ANR报告机制的重要职能就是输出日志， 这些日志如何取到呢？请参见日志获取</p>
<p>3.2 问题定位<br>通过在event log中检索 am_anr 关键字，就可以找到发生ANR的进程，譬如以下日志：</p>
<p>10-16 00:48:27 820 907 I am_anr: [0,29533,com.android.systemui,1082670605,Broadcast of Intent { act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) }]<br>表示在 10-16 00:48:27 这个时刻，PID为 29533 进程发生了ANR，进程名是 com.android.systemui。</p>
<p>接下来可以在system log检索 ANR in 关键字，找到发生ANR前后的CPU使用情况：</p>
<p>10-16 00:50:10 820 907 E ActivityManager: ANR in com.android.systemui, time=130090695<br>10-16 00:50:10 820 907 E ActivityManager: Reason: Broadcast of Intent { act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) }<br>10-16 00:50:10 820 907 E ActivityManager: Load: 30.4 / 22.34 / 19.94<br>10-16 00:50:10 820 907 E ActivityManager: Android time :[2015-10-16 00:50:05.76] [130191,266]<br>10-16 00:50:10 820 907 E ActivityManager: CPU usage from 6753ms to -4ms ago:<br>10-16 00:50:10 820 907 E ActivityManager:   47% 320/netd: 3.1% user + 44% kernel / faults: 14886 minor 3 major<br>10-16 00:50:10 820 907 E ActivityManager:   15% 10007/com.sohu.sohuvideo: 2.8% user + 12% kernel / faults: 1144 minor<br>10-16 00:50:10 820 907 E ActivityManager:   13% 10654/hif_thread: 0% user + 13% kernel<br>10-16 00:50:10 820 907 E ActivityManager:   11% 175/mmcqd/0: 0% user + 11% kernel<br>10-16 00:50:10 820 907 E ActivityManager:   5.1% 12165/app_process: 1.6% user + 3.5% kernel / faults: 9703 minor 540 major<br>10-16 00:50:10 820 907 E ActivityManager:   3.3% 29533/com.android.systemui: 2.6% user + 0.7% kernel / faults: 8402 minor 343 major<br>10-16 00:50:10 820 907 E ActivityManager:   3.2% 820/system_server: 0.8% user + 2.3% kernel / faults: 5120 minor 523 major<br>10-16 00:50:10 820 907 E ActivityManager:   2.5% 11817/com.netease.pomelo.push.l.messageservice_V2: 0.7% user + 1.7% kernel / faults: 7728 minor 687 major<br>10-16 00:50:10 820 907 E ActivityManager:   1.6% 11887/com.android.email: 0.5% user + 1% kernel / faults: 6259 minor 587 major<br>10-16 00:50:10 820 907 E ActivityManager:   1.4% 11854/com.android.settings: 0.7% user + 0.7% kernel / faults: 5404 minor 471 major<br>10-16 00:50:10 820 907 E ActivityManager:   1.4% 11869/android.process.acore: 0.7% user + 0.7% kernel / faults: 6131 minor 561 major<br>10-16 00:50:10 820 907 E ActivityManager:   1.3% 11860/com.tencent.mobileqq: 0.1% user + 1.1% kernel / faults: 5542 minor 470 major<br>…<br>10-16 00:50:10 820 907 E ActivityManager:  +0% 12832/cat: 0% user + 0% kernel<br>10-16 00:50:10 820 907 E ActivityManager:  +0% 13211/zygote64: 0% user + 0% kernel<br>10-16 00:50:10 820 907 E ActivityManager: 87% TOTAL: 3% user + 18% kernel + 64% iowait + 0.5% softirq<br>这一段日志对于Android开发人员而言，实在太熟悉不过了，它包含的信息量巨大：</p>
<p>发生ANR的时间。event log中，ANR的时间是 00：48：27，因为AMS.appNotResponding()首先会打印event log，然后再打印system log， 所以，在system log中，找到ANR的时间是 00:50:10。可以从这个时间点之前的日志中，还原ANR出现时系统的运行状态</p>
<p>打印ANR日志的进程。ANR日志都是在system_server进程的AMS线程打印的，在event log和system log中，都能看到 820 和 907， 所以system_server的PID是 802，AMS线程的TID是 907。ANR的监测机制实现在AMS线程，分析一些受系统影响的ANR，需要知道system_server进程的运行状态</p>
<p>发生ANR的进程。ANR in关键字就表明了当前ANR的进程是com.android.system.ui，通过event log，知道进程的PID是 29533</p>
<p>发生ANR的原因。Reason关键字表明了当前发生ANR的原因是，处理TIME_TICK广播消息超时。 隐含的意思是TIME_TICK是一个串行广播消息，在 29533 的主线程中，执行BroadcastReceiver.onReceive()方法已经超过10秒</p>
<p>CPU负载。Load关键字表明了最近1分钟、5分钟、15分钟内的CPU负载分别是30.4、22.3、19.94。CPU最近1分钟的负载最具参考价值，因为ANR的超时限制基本都是1分钟以内， 这可以近似的理解为CPU最近1分钟平均有30.4个任务要处理，这个负载值是比较高的</p>
<p>CPU使用统计时间段。CPU usage from XX to XX ago关键字表明了这是在ANR发生之前一段时间内的CPU统计。 类似的还有CPU usage from XX to XX after关键字，表明是ANR发生之后一段时间内的CPU统计</p>
<p>各进程的CPU使用率。我们以com.android.systemui进程的CPU使用率为例，它包含以下信息：</p>
<p>总的CPU使用率: 3.3%，其中systemui进程在用户态的CPU使用率是2.6%，在内核态的使用率是0.7%</p>
<p>缺页次数fault：8402 minor表示高速缓存中的缺页次数，343 major表示内存的缺页次数。minor可以理解为进程在做内存访问，major可以理解为进程在做IO操作。 当前minor和major值都是比较高的，从侧面反映了发生ANR之前，systemui进程有有较多的内存访问操作，引发的IO次数也会较多</p>
<p>CPU使用率前面的 “+”。部分进程的CPU使用率前面有 “+” 号，譬如cat和zygote64，表示在上一次CPU统计的时间片段内，还没有这些进程，而这一次CPU统计的时间片段内，运行了这些进程。 类似的还有 “-” 号，表示两次CPU统计时间片段时，这些进程消亡了</p>
<p>CPU使用汇总。TOTAL关键字表明了CPU使用的汇总，87%是总的CPU使用率，其中有一项iowait表明CPU在等待IO的时间，占到64%，说明发生ANR以前，有大量的IO操作。app_process、 system_server, com.android.systemui这几个进程的major值都比较大，说明这些进程的IO操作较为频繁，从而拉升了整个iowait的时间</p>
<p>信息量是如此的庞大，以致于我们都要下结论了：CPU大量的时间都在等待IO，导致systemui进程分配不到CPU时间，从而主线程处理广播消息超时，发生了ANR。</p>
<p>对于一个严谨的开发人员而言，这种结论下得有点早，因为还有太多的疑问：</p>
<p>systemui进程也分到了一些CPU时间(3.3%)，难道BroadcastReceiver.onReceive()方法就一直无法执行吗？</p>
<p>为什么iowait的时间会这么多，而且多个进程的major值都很高？</p>
<p>接下来还是需要从其他日志中还原ANR出现的场景。</p>
<p>3.3 场景还原<br>3.3.1 第一个假设和验证<br>带着上文提出来的第一个疑问，我们先来做一个假设：如果systemui进程正在执行BroadcatReceiver.onReceive()方法，那么从traces.txt文件中，应该可以看到主线程的函数调用栈正在执行这个方法。</p>
<p>接下来，我们首先从traces文件中，找到发生ANR时(00:48:27)，sysemtui进程的函数调用栈信息。</p>
<p>—– pid 29533 at 2015-10-16 00:48:06 —–<br>Cmd line: com.android.systemui</p>
<p>DALVIK THREADS (53):<br>“main” prio=5 tid=1 Native<br>  | group=”main” sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000<br>  | sysTid=29533 nice=0 cgrp=bg_non_interactive sched=0/0 handle=0x7f894bbe58<br>  | state=S schedstat=( 288625433917 93454573244 903419 ) utm=20570 stm=8292 core=3 HZ=100<br>  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB<br>  | held mutexes=<br>  native: #00 pc 00060b0c  /system/lib64/libc.so (__epoll_pwait+8)<br>  native: #01 pc 0001bb54  /system/lib64/libc.so (epoll_pwait+32)<br>  native: #02 pc 0001b3d8  /system/lib64/libutils.so (android::Looper::pollInner(int)+144)<br>  native: #03 pc 0001b75c  /system/lib64/libutils.so (android::Looper::pollOnce(int, int<em>, int</em>, void<em>*)+76)<br>  native: #04 pc 000d7194  /system/lib64/libandroid_runtime.so (android::NativeMessageQueue::pollOnce(_JNIEnv</em>, int)+48)<br>  at android.os.MessageQueue.nativePollOnce(Native method)<br>  at android.os.MessageQueue.next(MessageQueue.java:148)<br>  at android.os.Looper.loop(Looper.java:151)<br>  at android.app.ActivityThread.main(ActivityThread.java:5718)<br>  at java.lang.reflect.Method.invoke!(Native method)<br>  at java.lang.reflect.Method.invoke(Method.java:372)<br>  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:975)<br>  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)</p>
<p>—– pid 29533 at 2015-10-16 00:48:29 —–<br>Cmd line: com.android.systemui</p>
<p>DALVIK THREADS (54):<br>“main” prio=5 tid=1 Blocked<br>  | group=”main” sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000<br>  | sysTid=29533 nice=0 cgrp=bg_non_interactive sched=0/0 handle=0x7f894bbe58<br>  | state=S schedstat=( 289080040422 93461978317 904874 ) utm=20599 stm=8309 core=0 HZ=100<br>  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB<br>  | held mutexes=<br>  at com.mediatek.anrappmanager.MessageLogger.println(SourceFile:77)</p>
<ul>
<li>waiting to lock &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger) held by thread 49<br>at android.os.Looper.loop(Looper.java:195)<br>at android.app.ActivityThread.main(ActivityThread.java:5718)<br>at java.lang.reflect.Method.invoke!(Native method)<br>at java.lang.reflect.Method.invoke(Method.java:372)<br>at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:975)<br>at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)<br>…<br>“Binder_5” prio=5 tid=49 Native<br>| group=”main” sCount=1 dsCount=0 obj=0x136760a0 self=0x7f7e453000<br>| sysTid=6945 nice=0 cgrp=default sched=0/0 handle=0x7f6e3ce000<br>| state=S schedstat=( 5505571091 4567508913 30743 ) utm=264 stm=286 core=4 HZ=100<br>| stack=0x7f6b83f000-0x7f6b841000 stackSize=1008KB<br>| held mutexes=<br>native: #00 pc 00019d14  /system/lib64/libc.so (syscall+28)<br>native: #01 pc 0005b5d8  /system/lib64/libaoc.so (???)<br>native: #02 pc 002c6f18  /system/lib64/libaoc.so (???)<br>native: #03 pc 00032c40  /system/lib64/libaoc.so (???)<br>at libcore.io.Posix.getpid(Native method)<br>at libcore.io.ForwardingOs.getpid(ForwardingOs.java:83)<br>at android.system.Os.getpid(Os.java:176)<br>at android.os.Process.myPid(Process.java:754)<br>at com.mediatek.anrappmanager.MessageLogger.dump(SourceFile:219)</li>
<li>locked &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger)<br>at com.mediatek.anrappmanager.ANRAppManager.dumpMessageHistory(SourceFile:65)<br>at android.app.ActivityThread$ApplicationThread.dumpMessageHistory(ActivityThread.java:1302)<br>at android.app.ApplicationThreadNative.onTransact(ApplicationThreadNative.java:682)<br>at android.os.Binder.execTransact(Binder.java:451)<br>最终，我们找到systemui进程ANR时刻(00:48:27)附近的两个函数调用栈:</li>
</ul>
<p>在ANR发生之前(00:48:06)，主线程的函数调用栈处于正常状态：消息队列中，循环中处理消息</p>
<p>在ANR发生之后2秒(00:48:29)，主线程处于Blocked状态，在等待一个被49号线程持有的锁。而49号线程是一个Binder线程，anrappmanager正在做dump操作。</p>
<p>笔者分析的日志是MTK平台产生的，所以从函数调用栈中看到com.mediatek.anrappmanager.MessageLogger这样的类，它是MTK在AOSP上的扩展，用于打印ANR日志。</p>
<p>至此，systemui进程发生ANR的直接原因我们已经找到了，systemui进程正在打印traces，存在较长时间的IO操作，导致主线程阻塞，从而无法处理TIME_TICK广播消息，所以发生了ANR。</p>
<p>要避免这种场景下的ANR，我们就需要打破主线程中Blocked的逻辑。其实本例是由于MTK在AOSP的android.os.Looper.loop()扩展了打印消息队列的功能，该功能存在设计缺陷，会导致锁等待的情况。</p>
<p>3.3.2 第二个假设和验证<br>我们进一步挖掘在systemui还没有发生ANR时，就在打印traces的原因。带着上文提出的第二个疑问，我们来做另一个假设： iowait较高，而且多个进程的major都很高，可能是由于当前正在调用AMS.dumpStackTraces()方法，很多进程都需要将自己的函数调用栈写到traces文件，所以IO就会较高。 如果当前正在调用AMS.dumpStackTraces()方法，那说明当时系统已经发生了异常，要么已经有ANR发生，要么有SNR发生</p>
<p>从event log中，我们检索到了另一个ANR：</p>
<p>10-16 00:47:58 820 907 I am_anr  : [0,10464,com.android.settings,1086864965,Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)]<br>在 00:47:58 这个时刻，com.android.settings进程发生了ANR，而且ANR的时间在systemui之前(00:48:27)。这一下，我们就找到佐证了，正是因为settings进程先发生了ANR，调用AMS.dumpStackTraces()， 从而很多进程都开始了打印traces的操作，所以系统的整个iowait比较高，大量进程的major值也比较高，systemui就在其列。在MTK逻辑的影响下，打印ANR日志会导致主线程阻塞，从而就连带引发了其他应用的ANR。</p>
<p>在system log中，我们检索到了settings进程ANR的CPU使用信息：</p>
<p>10-16 00:48:12 820 907 E ActivityManager: ANR in com.android.settings (com.android.settings/.SubSettings), time=130063718<br>10-16 00:48:12 820 907 E ActivityManager: Reason: Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)<br>10-16 00:48:12 820 907 E ActivityManager: Load: 21.37 / 19.25 / 18.84<br>10-16 00:48:12 820 907 E ActivityManager: Android time :[2015-10-16 00:48:12.24] [130077,742]<br>10-16 00:48:12 820 907 E ActivityManager: CPU usage from 0ms to 7676ms later:<br>10-16 00:48:12 820 907 E ActivityManager:   91% 820/system_server: 16% user + 75% kernel / faults: 13192 minor 167 major<br>10-16 00:48:12 820 907 E ActivityManager:   3.2% 175/mmcqd/0: 0% user + 3.2% kernel<br>10-16 00:48:12 820 907 E ActivityManager:   2.9% 29533/com.android.systemui: 2.3% user + 0.6% kernel / faults: 1352 minor 10 major<br>10-16 00:48:12 820 907 E ActivityManager:   2.2% 1736/com.android.phone: 0.9% user + 1.3% kernel / faults: 1225 minor 1 major<br>10-16 00:48:12 820 907 E ActivityManager:   2.2% 10464/com.android.settings: 0.7% user + 1.4% kernel / faults: 2801 minor 105 major<br>10-16 00:48:12 820 907 E ActivityManager:   0% 1785/com.meizu.experiencedatasync: 0% user + 0% kernel / faults: 3478 minor 2 major<br>10-16 00:48:12 820 907 E ActivityManager:   1.8% 11333/com.meizu.media.video: 1% user + 0.7% kernel / faults: 3843 minor 89 major<br>10-16 00:48:12 820 907 E ActivityManager:   1.5% 332/mobile_log_d: 0.5% user + 1% kernel / faults: 94 minor 1 major<br>10-16 00:48:12 820 907 E ActivityManager:   1% 11306/com.meizu.media.gallery: 0.7% user + 0.2% kernel / faults: 2204 minor 55 major<br>…<br>10-16 00:48:12 820 907 E ActivityManager:  +0% 11397/sh: 0% user + 0% kernel<br>10-16 00:48:12 820 907 E ActivityManager:  +0% 11398/app_process: 0% user + 0% kernel<br>10-16 00:48:12 820 907 E ActivityManager: 29% TOTAL: 5.1% user + 15% kernel + 9.5% iowait + 0% softirq<br>具体的涵义我们不再赘述了，只关注一下ANR的原因:</p>
<p>Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.<br>Outbound queue length: 0. Wait queue length: 1.)</p>
<p>之前对Input ANR机制的分析派上用长了，我们轻松知道这种ANR的原因是什么。 Wait queue length： 1表示之前的输入事件已经派发到Settings进程了，但Settings进程还没有处理完毕，新来的KeyEvent事件已经等待超过了5秒，所以ANR产生了。</p>
<p>接下来，又需要找到Settings的traces，分析Settings主线程处理输入事件超时的原因，我们点到为止。</p>
<ol start="4">
<li>总结<br>本文对Android ANR机制进行了深入的分析：</li>
</ol>
<p>ANR的监测机制，从Service，Broadcast，InputEvent三种不同的ANR监测机制的源码实现开始，分析了Android如何发现各类ANR。在启动服务、派发广播消息和输入事件时，植入超时检测，用于发现ANR</p>
<p>ANR的报告机制，分析Android如何输出ANR日志。当ANR被发现后，两个很重要的日志输出是：CPU使用情况和进程的函数调用栈，这两类日志是我们解决ANR问题的利器</p>
<p>ANR的解决方法，通过一个案例，对ANR日志进行了深入解读，梳理了分析ANR问题的思路和途径</p>
<p>最后，致各位读者，从日志出发解决ANR问题，理解ANR机制背后的实现原理，碰到再难的ANR问题也无需惊慌。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/30/Gradle%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/30/Gradle%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Gradle构建详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-30 14:15:41 / 修改时间：13:38:15" itemprop="dateCreated datePublished" datetime="2020-07-30T14:15:41+08:00">2020-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Gradle构建详解"><a href="#Gradle构建详解" class="headerlink" title="Gradle构建详解"></a>Gradle构建详解</h2><h3 id="Grdale-简介"><a href="#Grdale-简介" class="headerlink" title="Grdale 简介"></a>Grdale 简介</h3><h4 id="1-1-Gradle是什么"><a href="#1-1-Gradle是什么" class="headerlink" title="1.1 Gradle是什么?"></a>1.1 Gradle是什么?</h4><p>Gradle是一款专注于灵活性和性能的开源构建自动化工具。Gradle构建脚本使用Groovy或Kotlin DSL 编写。DSL 的全称是 Domain Specific Language，即领域特定语言，或者直接翻译成”特定领域的语言”，算了，再直接点，其实就是这个语言不通用，只能用于特定的某个领域，俗称“小语言”。因此 DSL 也是语言。Gradle 的组成可以细分为如下三个方面：</p>
<p>1）、groovy 核心语法：包括 groovy 基本语法、闭包、数据结构、面向对象等等。<br>2）、Android DSL（build scrpit block）：Android 插件在 Gradle 所特有的东西，我们可以在不同的 build scrpit block 中去做不同的事情。<br>3）、Gradle API：包含 Project、Task、Setting 等等。</p>
<h4 id="1-2-Gradle-构建生命周期"><a href="#1-2-Gradle-构建生命周期" class="headerlink" title="1.2 Gradle 构建生命周期"></a>1.2 Gradle 构建生命周期</h4><p>Gradle 的构建过程分为 三部分：初始化阶段、配置阶段和执行阶段。其构建流程如下图所示：</p>
<img src="/2020/07/30/Gradle%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/Gradle%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="[Gradle构建生命周期]">

<p><strong>1、初始化阶段</strong></p>
<p>初始化阶段会读取根工程中的<strong>setting.gradle</strong>中的include信息，确定有多少工程加入构建，然后，会为每一个项目（build.gradle 脚本文件）创建一个个与之对应的<strong>Project</strong>实例，最终形成一个项目的层次结构。<br>与初始化阶段相关的脚本文件是settings.gradle，而一个 settings.gradle 脚本对应一个 Settings 对象，我们最常用来声明项目的层次结构的 include 就是 Settings 对象下的一个方法，在 Gradle 初始化的时候会构造一个 Settings 实例对象，以执行各个 Project 的初始化配置。</p>
<p>在 settings.gradle 文件中，我们可以 在 Gradle 的构建过程中添加各个生命周期节点监听，其代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">include &#39;:app&#39;</span><br><span class="line">rootProject.name &#x3D; &quot;WanGradle&quot;</span><br><span class="line">gradle.addBuildListener(new BuildListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void buildStarted(Gradle gradle) &#123;</span><br><span class="line">        println &#39;开始构建&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void settingsEvaluated(Settings settings) &#123;</span><br><span class="line">        println &#39;settings 评估完成（settings.gradle 中代码执行完毕）&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void projectsLoaded(Gradle gradle) &#123;</span><br><span class="line">        println &#39;项目结构加载完成（初始化阶段结束）&#39;</span><br><span class="line">        println &#39;初始化结束，可访问根项目：&#39; + var1.gradle.rootProject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void projectsEvaluated(Gradle gradle) &#123;</span><br><span class="line">        println &#39;所有项目评估完成（配置阶段结束）&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildFinished(BuildResult result) &#123;</span><br><span class="line">        println &#39;构建结束 &#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此外，在 settings.gradle 文件中，我们可以指定其它 project 的位置，这样就可以将其它外部工程中的 moudle 导入到当前的工程之中了。示例代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (Boolean.parseBoolean(properties.get(&#39;switch_speech&#39;))) &#123;</span><br><span class="line">    include &quot;speech&quot;</span><br><span class="line">    project(&quot;:speech&quot;).projectDir &#x3D; new File(&quot;..&#x2F;OtherApp&#x2F;speech&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、配置阶段</strong></p>
<p>配置阶段的任务是 执行各项目下的 build.gradle 脚本，完成 Project 的配置，与此同时，会构造 Task 任务依赖关系图以便在执行阶段按照依赖关系执行 Task。而在配置阶段执行的代码通常来说都会包括以下三个部分的内容，如下所示：</p>
<ul>
<li>1)、build.gralde 中的各种语句。</li>
<li>2)、闭包。</li>
<li>3)、Task 中的配置段语句。</li>
</ul>
<p>需要注意的是，执行任何 Gradle 命令，在初始化阶段和配置阶段的代码都会被执行。</p>
<p><strong>3、执行阶段</strong></p>
<p>在配置阶段结束后，Gradle 会根据各个任务 Task 的依赖关系来创建一个有向无环图，我们可以通过 Gradle 对象的 getTaskGraph 方法来得到该有向无环图 =&gt; TaskExecutionGraph，并且，当有向无环图构建完成之后，所有 Task 执行之前，我们可以通过 whenReady(groovy.lang.Closure) 或者 addTaskExecutionGraphListener(TaskExecutionGraphListener) 来接收相应的通知，其代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gradle.getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void graphPopulated(TaskExecutionGraph graph) &#123;</span><br><span class="line">        println &#39;graphPopulated &#39; + graph</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后，Gradle 构建系统会通过调用 gradle &lt;任务名&gt; 来执行相应的各个任务。</p>
<h4 id="1-3-Hook-Gradle各个生命周期节点"><a href="#1-3-Hook-Gradle各个生命周期节点" class="headerlink" title="1.3 Hook Gradle各个生命周期节点"></a>1.3 Hook Gradle各个生命周期节点</h4><img src="/2020/07/30/Gradle%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/Hook_Gradle%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="[Hook_Gradle各个生命周期]">

<p>注意事项<br>1）、每一个 Hook 点对应的监听器一定要在回调的生命周期之前添加。<br>2）、如果注册了多个 project.afterEvaluate 回调，那么执行顺序将与注册顺序保持一致。</p>
<h4 id="1-4-实战【获取构建各个阶段、任务的耗时情况-】"><a href="#1-4-实战【获取构建各个阶段、任务的耗时情况-】" class="headerlink" title="1.4 实战【获取构建各个阶段、任务的耗时情况 】"></a>1.4 实战【获取构建各个阶段、任务的耗时情况 】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">long beginOfSetting &#x3D; System.currentTimeMillis()</span><br><span class="line">def beginOfConfig</span><br><span class="line">def configHasBegin &#x3D; false</span><br><span class="line">def beginOfProjectConfig &#x3D; new HashMap&lt;&gt;()</span><br><span class="line">def beginOfProjectExcute</span><br><span class="line"></span><br><span class="line">gradle.projectsLoaded &#123;</span><br><span class="line">    println &#39;初始化阶段，耗时：&#39; + (System.currentTimeMillis() -</span><br><span class="line">            beginOfSetting) + &#39;ms&#39;</span><br><span class="line">&#125;</span><br><span class="line">gradle.beforeProject &#123; project -&gt;</span><br><span class="line">    if (!configHasBegin) &#123;</span><br><span class="line">        configHasBegin &#x3D; true</span><br><span class="line">        beginOfConfig &#x3D; System.currentTimeMillis()</span><br><span class="line">    &#125;</span><br><span class="line">    beginOfProjectConfig.put(project, System.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line">gradle.afterProject &#123; project -&gt;</span><br><span class="line">    def begin &#x3D; beginOfProjectConfig.get(project)</span><br><span class="line">    println &#39;配置阶段，&#39; + project + &#39;耗时：&#39; +</span><br><span class="line">            (System.currentTimeMillis() - begin) + &#39;ms&#39;</span><br><span class="line">&#125;</span><br><span class="line">gradle.taskGraph.whenReady &#123;</span><br><span class="line">    println &#39;配置阶段，总共耗时：&#39; + (System.currentTimeMillis() -</span><br><span class="line">            beginOfConfig) + &#39;ms&#39;</span><br><span class="line">    beginOfProjectExcute &#x3D; System.currentTimeMillis()</span><br><span class="line">&#125;</span><br><span class="line">gradle.taskGraph.beforeTask &#123; task -&gt;</span><br><span class="line">    task.doFirst &#123;</span><br><span class="line">        task.ext.beginOfTask &#x3D; System.currentTimeMillis()</span><br><span class="line">    &#125;</span><br><span class="line">    task.doLast &#123;</span><br><span class="line">        println &#39;执行阶段，&#39; + task + &#39;耗时：&#39; +</span><br><span class="line">                (System.currentTimeMillis() - task.beginOfTask) + &#39;ms&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">gradle.buildFinished &#123;</span><br><span class="line">    println &#39;执行阶段，耗时：&#39; + (System.currentTimeMillis() -</span><br><span class="line">            beginOfProjectExcute) + &#39;ms&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>Project 是 Gradle 构建整个应用程序的入口。由前可知，每一个 build.gradle 都有一个与之对应的 Project 实例，而在 build.gradle 中，我们通常都会配置一系列的项目依赖，如下面这个依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.github.bumptech.glide:glide:4.8.0&#39;</span><br></pre></td></tr></table></figure>
<p>类似于 implementation、api 这种依赖关键字，在本质上它就是一个方法调用，在上面，我们使用 implementation() 方法传入了一个 map 参数，参数里面有三对 key-value，完整写法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation group: &#39;com.github.bumptech.glide&#39; name:&#39;glide&#39; version:&#39;4.8.0&#39;</span><br></pre></td></tr></table></figure>
<p>当我们使用 implementation、api 依赖对应的 aar 文件时，Gradle 会在 repository 仓库 里面找到与之对应的依赖文件，你的仓库中可能包含 jcenter、maven 等一系列仓库，而每一个仓库其实就是很多依赖文件的集合服务器, 而他们就是通过上述的 group、name、version 来进行归类存储的。</p>
<h4 id="2-1-Project-核心-API"><a href="#2-1-Project-核心-API" class="headerlink" title="2.1 Project 核心 API"></a>2.1 Project 核心 API</h4><p>每一个 Groovy 脚本都会被编译器编译成 Script 字节码，而每一个 build.gradle 脚本都会被编译器编译成 Project 字节码，所以我们在 build.gradle 中所写的一切逻辑都是在 Project 类内进行书写的。下面，我们将按照由易到难的套路来介绍 Project 的一系列重要的 API。</p>
<p>1、getAllprojects 表示 获取所有 project 的实例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def getProjects() &#123;</span><br><span class="line">    println &quot;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;</span><br><span class="line">    println &quot; Root Project Start &quot;</span><br><span class="line">    println &quot;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;</span><br><span class="line">    &#x2F;&#x2F; 1、getAllprojects 方法返回一个包含根 project 与其子 project 的 Set 集合</span><br><span class="line">    &#x2F;&#x2F; eachWithIndex 方法用于遍历集合、数组等可迭代的容器，</span><br><span class="line">    &#x2F;&#x2F; 并同时返回下标，不同于 each 方法仅返回 project</span><br><span class="line">    this.getAllprojects().eachWithIndex &#123; Project project, int index -&gt;</span><br><span class="line">        &#x2F;&#x2F; 2、下标为 0，表明当前遍历的是 rootProject</span><br><span class="line">        if (index &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            println &quot;Root Project is $project&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println &quot;child Project is $project&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、getSubprojects 表示获取当前工程下所有子工程的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def getSubProjects() &#123;</span><br><span class="line">    println &quot;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;</span><br><span class="line">    println &quot; Sub Project Start &quot;</span><br><span class="line">    println &quot;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;</span><br><span class="line">    &#x2F;&#x2F; getSubprojects 方法返回一个包含子 project 的 Set 集合</span><br><span class="line">    this.getSubprojects().each &#123; Project project -&gt;</span><br><span class="line">        println &quot;child Project is $project&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、getParent 表示 获取当前 project 的父类，需要注意的是，如果我们在根工程中使用它，获取的父类会为 null，因为根工程没有父类</p>
<p>4、如果我们想在根工程仅仅获取当前的 project 实例该怎么办呢？直接使用 getRootProject 即可在任意 build.gradle 文件获取当前根工程的 project 实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def getRootPro() &#123;</span><br><span class="line">    def rootProjectName &#x3D; this.getRootProject().name</span><br><span class="line">    println &quot;root project is $rootProjectName&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、project 表示的是 指定工程的实例，然后在闭包中对其进行操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project(&quot;app&quot;) &#123;</span><br><span class="line">    apply plugin: &#39;com.android.application&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、allprojects 表示 用于配置当前 project 及其旗下的每一个子 project</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;https:&#x2F;&#x2F;jitpack.io&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123; url &quot;https:&#x2F;&#x2F;plugins.gradle.org&#x2F;m2&#x2F;&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、subprojects 可以 统一配置当前 project 下的所有子 project</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line">    if (project.plugins.hasPlugin(&quot;com.android.library&quot;)) &#123;</span><br><span class="line">        apply from: &#39;..&#x2F;publishToMaven.gradle&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Project-属性"><a href="#2-2-Project-属性" class="headerlink" title="2.2 Project 属性"></a>2.2 Project 属性</h4><p>在 project 接口里，仅仅预先定义了 七个 属性，其源码如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 默认的工程构建文件名称</span><br><span class="line"> *&#x2F;</span><br><span class="line">String DEFAULT_BUILD_FILE &#x3D; &quot;build.gradle&quot;;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 区分开 project 名字与 task 名字的符号</span><br><span class="line"> *&#x2F;</span><br><span class="line">String PATH_SEPARATOR &#x3D; &quot;:&quot;;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认的构建目录名称</span><br><span class="line"> *&#x2F;</span><br><span class="line">String DEFAULT_BUILD_DIR_NAME &#x3D; &quot;build&quot;;</span><br><span class="line">String GRADLE_PROPERTIES &#x3D; &quot;gradle.properties&quot;;</span><br><span class="line">String SYSTEM_PROP_PREFIX &#x3D; &quot;systemProp&quot;;</span><br><span class="line">String DEFAULT_VERSION &#x3D; &quot;unspecified&quot;;</span><br><span class="line">String DEFAULT_STATUS &#x3D; &quot;release&quot;;</span><br></pre></td></tr></table></figure>
<p>幸运的是，Gradle 提供了 ext 关键字让我们有能力去定义自身所需要的扩展属性。有了它便可以对我们工程中的依赖进行全局配置</p>
<ul>
<li>ext拓展属性定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    android &#x3D; [</span><br><span class="line">        compileSdkVersion : 27,</span><br><span class="line">        buildToolsVersion : &quot;28.0.3&quot;</span><br><span class="line">    ]</span><br><span class="line">            </span><br><span class="line">    version &#x3D; [</span><br><span class="line">        supportLibraryVersion : &quot;28.0.0&quot;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    dependencies &#x3D; [</span><br><span class="line">        &quot;appcompat-v7&quot; : &quot;com.android.support:appcompat-v7:$&#123;version[&quot;supportLibraryVersion&quot;]&#125;&quot;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">            </span><br><span class="line">    annotationProcessor &#x3D; [</span><br><span class="line">        &quot;glide_compiler&quot; : &quot;com.github.bumptech.glide:compiler:$&#123;version[&quot;glideVersion&quot;]&#125;&quot;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">            </span><br><span class="line">    apiFileDependencies &#x3D; [</span><br><span class="line">        &quot;launchstarter&quot; : &quot;libs&#x2F;launchstarter-release-1.0.0.aar&quot;,</span><br><span class="line">        ...</span><br><span class="line">    ]</span><br><span class="line">            </span><br><span class="line">    debugImplementationDependencies &#x3D; [</span><br><span class="line">        &quot;MethodTraceMan&quot; : &quot;com.github.zhengcx:MethodTraceMan:1.0.7&quot;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    releaseImplementationDependencies &#x3D; [</span><br><span class="line">        &quot;MethodTraceMan&quot; : &quot;com.github.zhengcx:MethodTraceMan:1.0.5-noop&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>除了使用 ext 扩展属性定义额外的属性之外，我们也可以在 gradle.properties 下定义扩展属性</li>
</ul>
<h4 id="2-3-文件相关-API"><a href="#2-3-文件相关-API" class="headerlink" title="2.3 文件相关 API"></a>2.3 文件相关 API</h4><p>1）、路径获取 API<br>getRootDir()<br>getProjectDir()<br>getBuildDir()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println &quot;the root file path is:&quot; + getRootDir().absolutePath</span><br><span class="line">println &quot;this build file path is:&quot; + getBuildDir().absolutePath</span><br><span class="line">println &quot;this Project file path is:&quot; + getProjectDir().absolutePath</span><br></pre></td></tr></table></figure>

<p>2）、文件操作相关 API<br>文件定位<br>文件拷贝<br>文件树遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">def getContent(String path) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        def mFile &#x3D; file(path)</span><br><span class="line">        println mFile.text</span><br><span class="line">    &#125; catch (GradleException e) &#123;</span><br><span class="line">        println e.toString()</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def getContent(String path1, String path2) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        def mFiles &#x3D; files(path1, path2)</span><br><span class="line">        println mFiles[0].text + mFiles[1].text</span><br><span class="line">    &#125; catch (GradleException e) &#123;</span><br><span class="line">        println e.toString()</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task fileCopy() &#123;</span><br><span class="line">    delete &quot;build&quot;</span><br><span class="line">    copy &#123;</span><br><span class="line">        from file(&quot;build.gradle&quot;)</span><br><span class="line">        into getRootProject().getBuildDir().path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task fileList() &#123;</span><br><span class="line">    fileTree(&quot;build&#x2F;outputs&#x2F;apk&quot;) &#123; FileTree fileTree -&gt;</span><br><span class="line">        fileTree.visit &#123; FileTreeElement fileTreeElement -&gt;</span><br><span class="line">            println &quot;The file is $fileTreeElement.file.name&quot;</span><br><span class="line">            copy &#123;</span><br><span class="line">                from fileTreeElement.file</span><br><span class="line">                into getRootProject().getBuildDir().path + &quot;&#x2F;apkTree&#x2F;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-其它-API"><a href="#2-4-其它-API" class="headerlink" title="2.4 其它 API"></a>2.4 其它 API</h4><ul>
<li>依赖相关 API</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">implementation(rootProject.ext.dependencies.glide) &#123;</span><br><span class="line">    &#x2F;&#x2F; 排除依赖：一般用于解决资源、代码冲突相关的问题</span><br><span class="line">    exclude module: &#39;support-v4&#39; </span><br><span class="line">    &#x2F;&#x2F; 传递依赖：A &#x3D;&gt; B &#x3D;&gt; C ，B 中使用到了 C 中的依赖，</span><br><span class="line">    &#x2F;&#x2F; 且 A 依赖于 B，如果打开传递依赖，则 A 能使用到 B </span><br><span class="line">    &#x2F;&#x2F; 中所使用的 C 中的依赖，默认都是不打开，即 false</span><br><span class="line">    transitive false </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>外部命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">task apkMove() &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        &#x2F;&#x2F; 在 gradle 的执行阶段去执行</span><br><span class="line">        def sourcePath &#x3D; this.buildDir.path + &quot;&#x2F;outputs&#x2F;apk&#x2F;speed&#x2F;release&#x2F;&quot;</span><br><span class="line">        def destinationPath &#x3D; &quot;&#x2F;Users&#x2F;quchao&#x2F;Downloads&#x2F;&quot;</span><br><span class="line">        def command &#x3D; &quot;mv -f $sourcePath $destinationPath&quot;</span><br><span class="line">        exec &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                executable &quot;bash&quot;</span><br><span class="line">                args &quot;-c&quot;, command</span><br><span class="line">                println &quot;The command execute is success&quot;</span><br><span class="line">            &#125; catch (GradleException e) &#123;</span><br><span class="line">                println &quot;The command execute is failed&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><ol>
<li>Task定义</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task JsonChao&#123;</span><br><span class="line">    &#x2F;&#x2F; 执行在 gradle 生命周期的第二个阶段，即配置阶段。</span><br><span class="line">    println(&quot;hello~&quot;)</span><br><span class="line">    &#x2F;&#x2F; 3、给 task 附带一些 执行动作（Action），执行在</span><br><span class="line">    &#x2F;&#x2F; gradle 生命周期的第三个阶段，即执行阶段。</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println(&quot;start&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(&quot;end&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task Andorid(dependsOn:&quot;JsonChao&quot;) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(&quot;end?&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 doFirst 与 doLast 这两个 Action，它们的作用分别如下所示：</p>
<p>doFirst：表示 task 执行最开始的时候被调用的 Action。<br>doLast：表示 task 将执行完的时候被调用的 Action。<br>需要注意的是，doFirst 和 doLast 是可以被执行多次的。</p>
<h3 id="SourceSet"><a href="#SourceSet" class="headerlink" title="SourceSet"></a>SourceSet</h3><p>SourceSet 主要是 用来设置我们项目中源码或资源的位置的，目前它最常见的两个使用案例就是如下 两类：</p>
<ul>
<li>1）、修改 so 库存放位置。</li>
<li>2）、资源文件分包存放。</li>
</ul>
<p>1、修改 so 库存放位置<br>我们仅需在 app moudle 下的 android 闭包下配置如下代码即可修改 so 库存放位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            &#x2F;&#x2F; 修改 so 库存放位置</span><br><span class="line">            jniLibs.srcDirs &#x3D; [&quot;libs&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、资源文件分包存放<br>同样，在 app moudle 下的 android 闭包下配置如下代码即可将资源文件进行分包存放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            res.srcDirs &#x3D; [&quot;src&#x2F;main&#x2F;res&quot;,</span><br><span class="line">                           &quot;src&#x2F;main&#x2F;res-play&quot;,</span><br><span class="line">                           &quot;src&#x2F;main&#x2F;res-shop&quot;</span><br><span class="line">                            ... </span><br><span class="line">                           ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，我们也可以使用如下代码 将 sourceSets 在 android 闭包的外部进行定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.android.sourceSets &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义Gradle插件"><a href="#自定义Gradle插件" class="headerlink" title="自定义Gradle插件"></a>自定义Gradle插件</h3><p>在 Android 下的 gradle 插件共分为 两大类，如下所示：</p>
<ul>
<li>1、脚本插件：同普通的 gradle 脚本编写形式一样，通过 apply from: ‘JsonChao.gradle’ 引用。</li>
<li>2、对象插件：通过插件全路径类名或 id 引用，它主要有 三种编写形式，如下所示：<br>1）在当前构建脚本下直接编写。<br>2）在 buildSrc 目录下编写。<br>3）在完全独立的项目中编写。</li>
</ul>
<h4 id="5-1-脚本插件"><a href="#5-1-脚本插件" class="headerlink" title="5.1 脚本插件"></a>5.1 脚本插件</h4><p>同普通的 gradle 脚本编写形式一样，我们既可以写在 build.gradle 里面，也可以自己新建一个 gradle 脚本文件进行编写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class PluginDemo implements Plugin&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project target) &#123; </span><br><span class="line">        println &#39;Hello author!&#39;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: PluginDemo</span><br></pre></td></tr></table></figure>

<h4 id="5-2-运用-buildSrc-默认插件目录"><a href="#5-2-运用-buildSrc-默认插件目录" class="headerlink" title="5.2 运用 buildSrc 默认插件目录"></a>5.2 运用 buildSrc 默认插件目录</h4><p>buildSrc 是默认的插件目录，其次，在 buildSrc 目录下与独立工程的插件工程一样，也能够发布插件</p>
<img src="/2020/07/30/Gradle%E6%9E%84%E5%BB%BA%E8%AF%A6%E8%A7%A3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" class="" title="[自定义插件项目结构.png]">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [CustomGradlePlugin.groovy]</span><br><span class="line">class CustomGradlePlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        println &quot;Hello plugin...&quot; + project.name</span><br><span class="line">        &#x2F;&#x2F; 定义拓展属性releaseInfo</span><br><span class="line">        project.extensions.create(&quot;releaseInfo&quot;, ReleaseInfoExtension.class)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建新Task:releaseInfoTask</span><br><span class="line">        project.tasks.create(&quot;releaseInfoTask&quot;, ReleaseInfoTask.class)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 定义Transform</span><br><span class="line">        def appExtension &#x3D; project.extensions.findByType(AppExtension.class)</span><br><span class="line">        appExtension.registerTransform(new MyTransform());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ReleaseInfoTask.groovy]</span><br><span class="line">class ReleaseInfoTask extends DefaultTask &#123;</span><br><span class="line"></span><br><span class="line">    ReleaseInfoTask() &#123;</span><br><span class="line">        println &#39;init ReleaseInfoTask&#39;</span><br><span class="line">        &#x2F;&#x2F; 1、在构造器中配置了该 Task 对应的 Task group，即 Task 组，并为其添加上了对应的描述信息。</span><br><span class="line">        group &#x3D; &#39;version_manager&#39;</span><br><span class="line">        description &#x3D; &#39;release info update&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2、在 gradle 执行阶段执行</span><br><span class="line">    @TaskAction</span><br><span class="line">    void doAction() &#123;</span><br><span class="line">        println &quot;start do updateVersionInfo 1&quot;</span><br><span class="line">        updateVersionInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void updateVersionInfo() &#123;</span><br><span class="line">        println &quot;start do updateVersionInfo 2&quot;</span><br><span class="line">        &#x2F;&#x2F; 3、从 realeaseInfo Extension 属性中获取相应的版本信息</span><br><span class="line">        def versionCodeMsg &#x3D; project.extensions.releaseInfo.versionCode;</span><br><span class="line">        def versionNameMsg &#x3D; project.extensions.releaseInfo.versionName;</span><br><span class="line">        def versionInfoMsg &#x3D; project.extensions.releaseInfo.versionInfo;</span><br><span class="line">        def fileName &#x3D; project.extensions.releaseInfo.fileName;</span><br><span class="line">        def file &#x3D; project.file(fileName)</span><br><span class="line">        println file.absolutePath</span><br><span class="line">        &#x2F;&#x2F; 4、将实体对象写入到 xml 文件中</span><br><span class="line">        def sw &#x3D; new StringWriter()</span><br><span class="line">        def xmlBuilder &#x3D; new MarkupBuilder(sw)</span><br><span class="line">        if (file.text !&#x3D; null &amp;&amp; file.text.size() &lt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;没有内容</span><br><span class="line">            xmlBuilder.releases &#123;</span><br><span class="line">                release &#123;</span><br><span class="line">                    versionCode(versionCodeMsg)</span><br><span class="line">                    versionName(versionNameMsg)</span><br><span class="line">                    versionInfo(versionInfoMsg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;直接写入</span><br><span class="line">            file.withWriter &#123; writer -&gt; writer.append(sw.toString())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            println &quot;write finish&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;已有其它版本内容</span><br><span class="line">            xmlBuilder.release &#123;</span><br><span class="line">                versionCode(versionCodeMsg)</span><br><span class="line">                versionName(versionNameMsg)</span><br><span class="line">                versionInfo(versionInfoMsg)</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;插入到最后一行前面</span><br><span class="line">            def lines &#x3D; file.readLines()</span><br><span class="line">            def lengths &#x3D; lines.size() - 1</span><br><span class="line">            file.withWriter &#123; writer -&gt;</span><br><span class="line">                lines.eachWithIndex &#123; line, index -&gt;</span><br><span class="line">                    if (index !&#x3D; lengths) &#123;</span><br><span class="line">                        writer.append(line + &#39;\r\n&#39;)</span><br><span class="line">                    &#125; else if (index &#x3D;&#x3D; lengths) &#123;</span><br><span class="line">                        writer.append(&#39;\r\r\n&#39; + sw.toString() + &#39;\r\n&#39;)</span><br><span class="line">                        writer.append(lines.get(tlengths))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-Transform"><a href="#5-3-Transform" class="headerlink" title="5.3 Transform"></a>5.3 Transform</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">class MyTransform extends Transform &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 每一个 Transform 都有一个与之对应的 Transform task，</span><br><span class="line">     * 这里便是返回的 task name。它会出现在 app&#x2F;build&#x2F;intermediates&#x2F;transforms 目录下</span><br><span class="line">     *</span><br><span class="line">     * @return Transform Name</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return &quot;MyCustomTransform&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 需要处理的数据类型，目前 ContentType 有六种枚举类型，通常我们使用比较频繁的有前两种：</span><br><span class="line">     *      1、CONTENT_CLASS：表示需要处理 java 的 class 文件。</span><br><span class="line">     *      2、CONTENT_JARS：表示需要处理 java 的 class 与 资源文件。</span><br><span class="line">     *      3、CONTENT_RESOURCES：表示需要处理 java 的资源文件。</span><br><span class="line">     *      4、CONTENT_NATIVE_LIBS：表示需要处理 native 库的代码。</span><br><span class="line">     *      5、CONTENT_DEX：表示需要处理 DEX 文件。</span><br><span class="line">     *      6、CONTENT_DEX_WITH_RESOURCES：表示需要处理 DEX 与 java 的资源文件。</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        &#x2F;&#x2F; 用于确定我们需要对哪些类型的结果进行转换：如字节码、资源⽂件等等。</span><br><span class="line">        &#x2F;&#x2F; return TransformManager.RESOURCES</span><br><span class="line">        return TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 表示 Transform 要操作的内容范围，目前 Scope 有五种基本类型：</span><br><span class="line">     *      1、PROJECT                   只有项目内容</span><br><span class="line">     *      2、SUB_PROJECTS              只有子项目</span><br><span class="line">     *      3、EXTERNAL_LIBRARIES        只有外部库</span><br><span class="line">     *      4、TESTED_CODE               由当前变体（包括依赖项）所测试的代码</span><br><span class="line">     *      5、PROVIDED_ONLY             只提供本地或远程依赖项</span><br><span class="line">     *      SCOPE_FULL_PROJECT 是一个 Scope 集合，包含 Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES 这三项，即当前 Transform 的作用域包括当前项目、子项目以及外部的依赖库</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        &#x2F;&#x2F; 适用范围：通常是指定整个 project，也可以指定其它范围</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否支持增量更新</span><br><span class="line">        &#x2F;&#x2F; 如果返回 true，TransformInput 会包含一份修改的文件列表</span><br><span class="line">        &#x2F;&#x2F; 如果返回 false，会进行全量编译，删除上一次的输出内容</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 进行具体的转换过程</span><br><span class="line">     *</span><br><span class="line">     * @param transformInvocation</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line">        println &#39;--------------- MyTransform visit start --------------- &#39;</span><br><span class="line">        def startTime &#x3D; System.currentTimeMillis()</span><br><span class="line">        def inputs &#x3D; transformInvocation.inputs</span><br><span class="line">        def outputProvider &#x3D; transformInvocation.outputProvider</span><br><span class="line">        &#x2F;&#x2F; 删除之前的输出</span><br><span class="line">        if (outputProvider !&#x3D; null)</span><br><span class="line">            outputProvider.deleteAll()</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Transform 的 inputs 有两种类型，一种是目录，一种是 jar 包，要分开遍历</span><br><span class="line">        inputs.each &#123; TransformInput input -&gt;</span><br><span class="line">            &#x2F;&#x2F; 遍历 directoryInputs（本地 project 编译成的多个 class ⽂件存放的目录）</span><br><span class="line">            input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">                handleDirectory(directoryInput, outputProvider)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 遍历 jarInputs（各个依赖所编译成的 jar 文件）</span><br><span class="line">            input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">                handleJar(jarInput, outputProvider)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        def cost &#x3D; (System.currentTimeMillis() - startTime) &#x2F; 1000</span><br><span class="line">        println &#39;--------------- MyTransform visit end --------------- &#39;</span><br><span class="line">        println &quot;MyTransform cost ： $cost s&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void handleJar(JarInput jarInput, TransformOutputProvider outputProvider) &#123;</span><br><span class="line">        if (jarInput.file.getAbsolutePath().endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 截取文件路径的 md5 值重命名输出文件，避免出现同名而覆盖的情况出现</span><br><span class="line">            def jarName &#x3D; jarInput.name</span><br><span class="line">            def md5Name &#x3D; DigestUtils.md5Hex(jarInput.file.getAbsolutePath())</span><br><span class="line">            if (jarName.endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">                jarName &#x3D; jarName.substring(0, jarName.length() - 4)</span><br><span class="line">            &#125;</span><br><span class="line">            JarFile jarFile &#x3D; new JarFile(jarInput.file)</span><br><span class="line">            Enumeration enumeration &#x3D; jarFile.entries()</span><br><span class="line">            File tmpFile &#x3D; new File(jarInput.file.getParent() + File.separator + &quot;classes_temp.jar&quot;)</span><br><span class="line">            &#x2F;&#x2F; 避免上次的缓存被重复插入</span><br><span class="line">            if (tmpFile.exists()) &#123;</span><br><span class="line">                tmpFile.delete()</span><br><span class="line">            &#125;</span><br><span class="line">            JarOutputStream jarOutputStream &#x3D; new JarOutputStream(new FileOutputStream(tmpFile))</span><br><span class="line">            while (enumeration.hasMoreElements()) &#123;</span><br><span class="line">                JarEntry jarEntry &#x3D; (JarEntry) enumeration.nextElement()</span><br><span class="line">                String entryName &#x3D; jarEntry.getName()</span><br><span class="line">                ZipEntry zipEntry &#x3D; new ZipEntry(entryName)</span><br><span class="line">                InputStream inputStream &#x3D; jarFile.getInputStream(jarEntry)</span><br><span class="line">                if (checkClassFile(entryName)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 使用 ASM 对 class 文件进行操控</span><br><span class="line">                    println &#39;----------- deal with &quot;jar&quot; class file &lt;&#39; + entryName + &#39;&gt; -----------&#39;</span><br><span class="line">                    jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">                    ClassReader classReader &#x3D; new ClassReader(IOUtils.toByteArray(inputStream))</span><br><span class="line">                    ClassWriter classWriter &#x3D; new ClassWriter(classReader, org.objectweb.asm.ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                    ClassVisitor cv &#x3D; new MyCustomClassVisitor(classWriter)</span><br><span class="line">                    classReader.accept(cv, EXPAND_FRAMES)</span><br><span class="line">                    byte[] code &#x3D; classWriter.toByteArray()</span><br><span class="line">                    jarOutputStream.write(code)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">                    jarOutputStream.write(IOUtils.toByteArray(inputStream))</span><br><span class="line">                &#125;</span><br><span class="line">                jarOutputStream.closeEntry()</span><br><span class="line">            &#125;</span><br><span class="line">            jarOutputStream.close()</span><br><span class="line">            jarFile.close()</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 生成输出路径 dest：.&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;xxxTransform&#x2F;...</span><br><span class="line">            def dest &#x3D; outputProvider.getContentLocation(jarName + md5Name,</span><br><span class="line">                    jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line">            &#x2F;&#x2F; 将 input 的目录复制到 output 指定目录</span><br><span class="line">            FileUtils.copyFile(tmpFile, dest)</span><br><span class="line">            tmpFile.delete()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void handleDirectory(DirectoryInput directoryInput, TransformOutputProvider outputProvider) &#123;</span><br><span class="line">        &#x2F;&#x2F; 在增量模式下可以通过 directoryInput.changedFiles 方法获取修改的文件</span><br><span class="line">&#x2F;&#x2F;        directoryInput.changedFiles</span><br><span class="line">        if (directoryInput.file.size() &#x3D;&#x3D; 0)</span><br><span class="line">            return</span><br><span class="line">        if (directoryInput.file.isDirectory()) &#123;</span><br><span class="line">            &#x2F;**遍历以某一扩展名结尾的文件*&#x2F;</span><br><span class="line">            directoryInput.file.traverse(type: FileType.FILES, nameFilter: ~&#x2F;.*\.class&#x2F;) &#123;</span><br><span class="line">                File classFile -&gt;</span><br><span class="line">                    def name &#x3D; classFile.name</span><br><span class="line">                    if (checkClassFile(name)) &#123;</span><br><span class="line">                        println &#39;----------- deal with &quot;class&quot; file &lt;&#39; + name + &#39;&gt; -----------&#39;</span><br><span class="line">                        def classReader &#x3D; new ClassReader(classFile.bytes)</span><br><span class="line">                        def classWriter &#x3D; new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                        def classVisitor &#x3D; new MyCustomClassVisitor(classWriter)</span><br><span class="line">                        classReader.accept(classVisitor, EXPAND_FRAMES)</span><br><span class="line">                        byte[] codeBytes &#x3D; classWriter.toByteArray()</span><br><span class="line">                        FileOutputStream fileOutputStream &#x3D; new FileOutputStream(</span><br><span class="line">                                classFile.parentFile.absolutePath + File.separator + name</span><br><span class="line">                        )</span><br><span class="line">                        fileOutputStream.write(codeBytes)</span><br><span class="line">                        fileOutputStream.close()</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 获取 output 目录 dest：.&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;hencoderTransform&#x2F;</span><br><span class="line">        def destFile &#x3D; outputProvider.getContentLocation(</span><br><span class="line">                directoryInput.name,</span><br><span class="line">                directoryInput.contentTypes,</span><br><span class="line">                directoryInput.scopes,</span><br><span class="line">                Format.DIRECTORY</span><br><span class="line">        )</span><br><span class="line">        &#x2F;&#x2F; 将 input 的目录复制到 output 指定目录</span><br><span class="line">        FileUtils.copyDirectory(directoryInput.file, destFile)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 检查 class 文件是否需要处理</span><br><span class="line">     *</span><br><span class="line">     * @param fileName</span><br><span class="line">     * @return class 文件是否需要处理</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static boolean checkClassFile(String name) &#123;</span><br><span class="line">        &#x2F;&#x2F; 只处理需要的 class 文件</span><br><span class="line">        return (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.startsWith(&quot;R\$&quot;)</span><br><span class="line">                &amp;&amp; &quot;R.class&quot; !&#x3D; name &amp;&amp; &quot;BuildConfig.class&quot; !&#x3D; name</span><br><span class="line">                &amp;&amp; &quot;android&#x2F;support&#x2F;v4&#x2F;app&#x2F;FragmentActivity.class&quot; &#x3D;&#x3D; name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="发布-Gradle-插件"><a href="#发布-Gradle-插件" class="headerlink" title="发布 Gradle 插件"></a>发布 Gradle 插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;maven&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传到本地</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            &#x2F;&#x2F; 上传到当前项目根目录下的本地 repo 目录中</span><br><span class="line">            repository(url: uri(&#39;..&#x2F;repo&#39;))</span><br><span class="line"></span><br><span class="line">            pom.groupId &#x3D; &#39;com.json.chao.study&#39;</span><br><span class="line">            pom.artifactId &#x3D; &#39;custom-gradle-plugin&#39;</span><br><span class="line">            pom.version &#x3D; &#39;1.0.0&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 上传到远端</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    configuration &#x3D; configurations.archives</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: MAVEN_REPO_RELEASE_URL) &#123;</span><br><span class="line">                authentication(userName: &quot;JsonChao&quot;, password: &quot;123456&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pom.groupId &#x3D; &#39;com.json.chao.study&#39;</span><br><span class="line">            pom.artifactId &#x3D; &#39;custom-gradle-plugin&#39;</span><br><span class="line">            pom.version &#x3D; &#39;1.0.0&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5e924273f265da47f079379c#heading-24" target="_blank" rel="noopener">1. 深度探索 Gradle 自动化构建技术（一、Gradle 核心配置篇）</a><br><a href="https://juejin.im/post/5e97ac34f265da47aa3f6dca" target="_blank" rel="noopener">2. 深度探索 Gradle 自动化构建技术（二、Groovy 筑基篇）</a><br><a href="https://juejin.im/post/5e9c46c8518825737f1a7b4c#heading-57" target="_blank" rel="noopener">3. 深度探索 Gradle 自动化构建技术（三、Gradle 核心解密）</a><br><a href="https://juejin.im/post/5ea012f8e51d4546d4398a99" target="_blank" rel="noopener">4. 深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件）</a><br><a href="https://www.jianshu.com/p/0bac58cdff70" target="_blank" rel="noopener">5. 第四章 创建构建 Variant</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">微信小程序快速入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-29 13:08:35 / 修改时间：13:19:57" itemprop="dateCreated datePublished" datetime="2020-07-29T13:08:35+08:00">2020-07-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="微信小程序快速入门"><a href="#微信小程序快速入门" class="headerlink" title="微信小程序快速入门"></a>微信小程序快速入门</h2><h3 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">参考官方文档</a></p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>项目目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── app.js</span><br><span class="line">├── app.json</span><br><span class="line">├── app.wxss</span><br><span class="line">├── pages</span><br><span class="line">│   │── index</span><br><span class="line">│   │   ├── index.wxml</span><br><span class="line">│   │   ├── index.js</span><br><span class="line">│   │   ├── index.json</span><br><span class="line">│   │   └── index.wxss</span><br><span class="line">│   └── logs</span><br><span class="line">│       ├── logs.wxml</span><br><span class="line">│       └── logs.js</span><br><span class="line">└── utils</span><br></pre></td></tr></table></figure>

<ul>
<li>app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</li>
<li>app.json 是对整个小程序的<strong>全局配置</strong>。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</li>
<li>app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</li>
<li>index.wxml 是页面的结构文件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/24/Handler%20native%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/24/Handler%20native%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Handler native底层机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-24 19:29:50 / 修改时间：19:29:51" itemprop="dateCreated datePublished" datetime="2020-07-24T19:29:50+08:00">2020-07-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>AngelDevil<br>博客园首页新随笔联系订阅管理<br>随笔 - 40  文章 - 0  评论 - 206<br>Android消息处理机制(Handler、Looper、MessageQueue与Message)<br>Android是消息驱动的，实现消息驱动有几个要素：</p>
<p>消息的表示：Message<br>消息队列：MessageQueue<br>消息循环，用于循环取出消息进行处理：Looper<br>消息处理，消息循环从消息队列中取出消息后要对消息进行处理：Handler<br>平时我们最常使用的就是Message与Handler了，如果使用过HandlerThread或者自己实现类似HandlerThread的东西可能还会接触到Looper，而MessageQueue是Looper内部使用的，对于标准的SDK，我们是无法实例化并使用的（构造函数是包可见性）。</p>
<p>我们平时接触到的Looper、Message、Handler都是用JAVA实现的，Android做为基于Linux的系统，底层用C、C++实现的，而且还有NDK的存在，消息驱动的模型怎么可能只存在于JAVA层，实际上，在Native层存在与Java层对应的类如Looper、MessageQueue等。</p>
<p> 初始化消息队列<br>首先来看一下如果一个线程想实现消息循环应该怎么做，以HandlerThread为例：</p>
<p>复制代码<br>public void run() {<br>    mTid = Process.myTid();<br>    Looper.prepare();<br>    synchronized (this) {<br>        mLooper = Looper.myLooper();<br>        notifyAll();<br>    }<br>    Process.setThreadPriority(mPriority);<br>    onLooperPrepared();<br>    Looper.loop();<br>    mTid = -1;<br>}<br>复制代码<br>主要是红色标明的两句，首先调用prepare初始化MessageQueue与Looper，然后调用loop进入消息循环。先看一下Looper.prepare。</p>
<p>复制代码<br>public static void prepare() {<br>    prepare(true);<br>}</p>
<p>private static void prepare(boolean quitAllowed) {<br>    if (sThreadLocal.get() != null) {<br>        throw new RuntimeException(“Only one Looper may be created per thread”);<br>    }<br>    sThreadLocal.set(new Looper(quitAllowed));<br>}<br>复制代码<br>重载函数，quitAllowed默认为true，从名字可以看出来就是消息循环是否可以退出，默认是可退出的，Main线程（UI线程）初始化消息循环时会调用prepareMainLooper，传进去的是false。使用了ThreadLocal，每个线程可以初始化一个Looper。</p>
<p>再来看一下Looper在初始化时都做了什么：</p>
<p>复制代码<br>private Looper(boolean quitAllowed) {<br>    mQueue = new MessageQueue(quitAllowed);<br>    mRun = true;<br>    mThread = Thread.currentThread();<br>}</p>
<p>MessageQueue(boolean quitAllowed) {<br>    mQuitAllowed = quitAllowed;<br>    nativeInit();<br>}<br>复制代码<br>在Looper初始化时，新建了一个MessageQueue的对象保存了在成员mQueue中。MessageQueue的构造函数是包可见性，所以我们是无法直接使用的，在MessageQueue初始化的时候调用了nativeInit，这是一个Native方法：</p>
<p>复制代码<br>static void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) {<br>    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();<br>    if (!nativeMessageQueue) {<br>        jniThrowRuntimeException(env, “Unable to allocate native queue”);<br>        return;<br>    }</p>
<pre><code>nativeMessageQueue-&gt;incStrong(env);
android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);</code></pre><p>}</p>
<p>static void android_os_MessageQueue_setNativeMessageQueue(JNIEnv* env, jobject messageQueueObj,<br>        NativeMessageQueue* nativeMessageQueue) {<br>    env-&gt;SetIntField(messageQueueObj, gMessageQueueClassInfo.mPtr,<br>             reinterpret_cast<jint>(nativeMessageQueue));<br>}<br>复制代码<br>在nativeInit中，new了一个Native层的MessageQueue的对象，并将其地址保存在了Java层MessageQueue的成员mPtr中，Android中有好多这样的实现，一个类在Java层与Native层都有实现，通过JNI的GetFieldID与SetIntField把Native层的类的实例地址保存到Java层类的实例的mPtr成员中，比如Parcel。</p>
<p>再看NativeMessageQueue的实现：</p>
<p>复制代码<br>NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) {<br>    mLooper = Looper::getForThread();<br>    if (mLooper == NULL) {<br>        mLooper = new Looper(false);<br>        Looper::setForThread(mLooper);<br>    }<br>}<br>复制代码<br>在NativeMessageQueue的构造函数中获得了一个Native层的Looper对象，Native层的Looper也使用了线程本地存储，注意new Looper时传入了参数false。</p>
<p>复制代码<br>Looper::Looper(bool allowNonCallbacks) :<br>        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),<br>        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {<br>    int wakeFds[2];<br>    int result = pipe(wakeFds);<br>    LOG_ALWAYS_FATAL_IF(result != 0, “Could not create wake pipe.  errno=%d”, errno);</p>
<pre><code>mWakeReadPipeFd = wakeFds[0];
mWakeWritePipeFd = wakeFds[1];

result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake read pipe non-blocking.  errno=%d&quot;,
        errno);

result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake write pipe non-blocking.  errno=%d&quot;,
        errno);

// Allocate the epoll instance and register the wake pipe.
mEpollFd = epoll_create(EPOLL_SIZE_HINT);
LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);

struct epoll_event eventItem;
memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
eventItem.events = EPOLLIN;
eventItem.data.fd = mWakeReadPipeFd;
result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);
LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;,
        errno);</code></pre><p>}<br>复制代码<br>Native层的Looper使用了epoll。初始化了一个管道，用mWakeWritePipeFd与mWakeReadPipeFd分别保存了管道的写端与读端，并监听了读端的EPOLLIN事件。注意下初始化列表的值，mAllowNonCallbacks的值为false。</p>
<p>mAllowNonCallback是做什么的？使用epoll仅为了监听mWakeReadPipeFd的事件？其实Native Looper不仅可以监听这一个描述符，Looper还提供了addFd方法：</p>
<p>int addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data);<br>int addFd(int fd, int ident, int events, const sp<LooperCallback>&amp; callback, void* data);<br>fd表示要监听的描述符。ident表示要监听的事件的标识，值必须&gt;=0或者为ALOOPER_POLL_CALLBACK(-2)，event表示要监听的事件，callback是事件发生时的回调函数，mAllowNonCallbacks的作用就在于此，当mAllowNonCallbacks为true时允许callback为NULL，在pollOnce中ident作为结果返回，否则不允许callback为空，当callback不为NULL时，ident的值会被忽略。还是直接看代码方便理解：</p>
<p>复制代码<br>int Looper::addFd(int fd, int ident, int events, const sp<LooperCallback>&amp; callback, void* data) {<br>#if DEBUG_CALLBACKS<br>    ALOGD(“%p ~ addFd - fd=%d, ident=%d, events=0x%x, callback=%p, data=%p”, this, fd, ident,<br>            events, callback.get(), data);<br>#endif<br>    if (!callback.get()) {<br>        if (! mAllowNonCallbacks) {<br>            ALOGE(“Invalid attempt to set NULL callback but not allowed for this looper.”);<br>            return -1;<br>        }<br>        if (ident &lt; 0) {<br>            ALOGE(“Invalid attempt to set NULL callback with ident &lt; 0.”);<br>            return -1;<br>        }<br>    } else {<br>        ident = ALOOPER_POLL_CALLBACK;<br>    }</p>
<pre><code>int epollEvents = 0;
if (events &amp; ALOOPER_EVENT_INPUT) epollEvents |= EPOLLIN;
if (events &amp; ALOOPER_EVENT_OUTPUT) epollEvents |= EPOLLOUT;

{ // acquire lock
    AutoMutex _l(mLock);

    Request request;
    request.fd = fd;
    request.ident = ident;
    request.callback = callback;
    request.data = data;

    struct epoll_event eventItem;
    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
    eventItem.events = epollEvents;
    eventItem.data.fd = fd;

    ssize_t requestIndex = mRequests.indexOfKey(fd);
    if (requestIndex &lt; 0) {
        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);
        if (epollResult &lt; 0) {
            ALOGE(&quot;Error adding epoll events for fd %d, errno=%d&quot;, fd, errno);
            return -1;
        }
        mRequests.add(fd, request);
    } else {
        int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);
        if (epollResult &lt; 0) {
            ALOGE(&quot;Error modifying epoll events for fd %d, errno=%d&quot;, fd, errno);
            return -1;
        }
        mRequests.replaceValueAt(requestIndex, request);
    }
} // release lock
return 1;</code></pre><p>}<br>复制代码<br>如果callback为空会检查mAllowNonCallbacks看是否允许callback为空，如果允许callback为空还会检测ident是否&gt;=0。如果callback不为空会把ident的值赋值为ALOOPER_POLL_CALLBACK，不管传进来的是什么值。</p>
<p>接下来把传进来的参数值封装到一个Request结构体中，并以描述符为键保存到一个KeyedVector mRequests中，然后通过epoll_ctl添加或替换（如果这个描述符之前有调用addFD添加监听）对这个描述符事件的监听。</p>
<p>类图：</p>
<p>　　</p>
<p>发送消息<br>通过Looper.prepare初始化好消息队列后就可以调用Looper.loop进入消息循环了，然后我们就可以向消息队列发送消息，消息循环就会取出消息进行处理，在看消息处理之前，先看一下消息是怎么被添加到消息队列的。</p>
<p>在Java层，Message类表示一个消息对象，要发送消息首先就要先获得一个消息对象，Message类的构造函数是public的，但是不建议直接new Message，Message内部保存了一个缓存的消息池，我们可以用obtain从缓存池获得一个消息，Message使用完后系统会调用recycle回收，如果自己new很多Message，每次使用完后系统放入缓存池，会占用很多内存的，如下所示：</p>
<p>复制代码<br>    public static Message obtain() {<br>        synchronized (sPoolSync) {<br>            if (sPool != null) {<br>                Message m = sPool;<br>                sPool = m.next;<br>                m.next = null;<br>                sPoolSize–;<br>                return m;<br>            }<br>        }<br>        return new Message();<br>    }</p>
<pre><code>public void recycle() {
    clearForRecycle();

    synchronized (sPoolSync) {
        if (sPoolSize &lt; MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}</code></pre><p>复制代码<br>Message内部通过next成员实现了一个链表，这样sPool就了为了一个Messages的缓存链表。</p>
<p>消息对象获取到了怎么发送呢，大家都知道是通过Handler的post、sendMessage等方法，其实这些方法最终都是调用的同一个方法sendMessageAtTime:</p>
<p>复制代码<br>    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {<br>        MessageQueue queue = mQueue;<br>        if (queue == null) {<br>            RuntimeException e = new RuntimeException(<br>                    this + “ sendMessageAtTime() called with no mQueue”);<br>            Log.w(“Looper”, e.getMessage(), e);<br>            return false;<br>        }<br>        return enqueueMessage(queue, msg, uptimeMillis);<br>    }<br>复制代码<br>sendMessageAtTime获取到消息队列然后调用enqueueMessage方法，消息队列mQueue是从与Handler关联的Looper获得的。</p>
<p>复制代码<br>    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {<br>        msg.target = this;<br>        if (mAsynchronous) {<br>            msg.setAsynchronous(true);<br>        }<br>        return queue.enqueueMessage(msg, uptimeMillis);<br>    }<br>复制代码<br>enqueueMessage将message的target设置为当前的handler，然后调用MessageQueue的enqueueMessage，在调用queue.enqueueMessage之前判断了mAsynchronous，从名字看是异步消息的意思，要明白Asynchronous的作用，需要先了解一个概念Barrier。</p>
<p>Barrier与Asynchronous Message<br>Barrier是什么意思呢，从名字看是一个拦截器，在这个拦截器后面的消息都暂时无法执行，直到这个拦截器被移除了，MessageQueue有一个函数叫enqueueSyncBarier可以添加一个Barrier。</p>
<p>复制代码<br>    int enqueueSyncBarrier(long when) {<br>        // Enqueue a new sync barrier token.<br>        // We don’t need to wake the queue because the purpose of a barrier is to stall it.<br>        synchronized (this) {<br>            final int token = mNextBarrierToken++;<br>            final Message msg = Message.obtain();<br>            msg.arg1 = token;</p>
<pre><code>        Message prev = null;
        Message p = mMessages;
        if (when != 0) {
            while (p != null &amp;&amp; p.when &lt;= when) {
                prev = p;
                p = p.next;
            }
        }
        if (prev != null) { // invariant: p == prev.next
            msg.next = p;
            prev.next = msg;
        } else {
            msg.next = p;
            mMessages = msg;
        }
        return token;
    }
}</code></pre><p>复制代码<br>在enqueueSyncBarrier中，obtain了一个Message，并设置msg.arg1=token，token仅是一个每次调用enqueueSyncBarrier时自增的int值，目的是每次调用enqueueSyncBarrier时返回唯一的一个token，这个Message同样需要设置执行时间，然后插入到消息队列，特殊的是这个Message没有设置target，即msg.target为null。</p>
<p>进入消息循环后会不停地从MessageQueue中取消息执行，调用的是MessageQueue的next函数，其中有这么一段：</p>
<p>复制代码<br>Message msg = mMessages;<br>if (msg != null &amp;&amp; msg.target == null) {<br>    // Stalled by a barrier.  Find the next asynchronous message in the queue.<br>    do {<br>        prevMsg = msg;<br>        msg = msg.next;<br>    } while (msg != null &amp;&amp; !msg.isAsynchronous());<br>}<br>复制代码<br>如果队列头部的消息的target为null就表示它是个Barrier，因为只有两种方法往mMessages中添加消息，一种是enqueueMessage，另一种是enqueueBarrier，而enqueueMessage中如果mst.target为null是直接抛异常的，后面会看到。</p>
<p>所谓的异步消息其实就是这样的，我们可以通过enqueueBarrier往消息队列中插入一个Barrier，那么队列中执行时间在这个Barrier以后的同步消息都会被这个Barrier拦截住无法执行，直到我们调用removeBarrier移除了这个Barrier，而异步消息则没有影响，消息默认就是同步消息，除非我们调用了Message的setAsynchronous，这个方法是隐藏的。只有在初始化Handler时通过参数指定往这个Handler发送的消息都是异步的，这样在Handler的enqueueMessage中就会调用Message的setAsynchronous设置消息是异步的，从上面Handler.enqueueMessage的代码中可以看到。</p>
<p> 所谓异步消息，其实只有一个作用，就是在设置Barrier时仍可以不受Barrier的影响被正常处理，如果没有设置Barrier，异步消息就与同步消息没有区别，可以通过removeSyncBarrier移除Barrier：</p>
<p>复制代码<br>void removeSyncBarrier(int token) {<br>    // Remove a sync barrier token from the queue.<br>    // If the queue is no longer stalled by a barrier then wake it.<br>    final boolean needWake;<br>    synchronized (this) {<br>        Message prev = null;<br>        Message p = mMessages;<br>        while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) {<br>            prev = p;<br>            p = p.next;<br>        }<br>        if (p == null) {<br>            throw new IllegalStateException(“The specified message queue synchronization “<br>                    + “ barrier token has not been posted or has already been removed.”);<br>        }<br>        if (prev != null) {<br>            prev.next = p.next;<br>            needWake = false;<br>        } else {<br>            mMessages = p.next;<br>            needWake = mMessages == null || mMessages.target != null;<br>        }<br>        p.recycle();<br>    }<br>    if (needWake) {<br>        nativeWake(mPtr);<br>    }<br>}<br>复制代码<br>参数token就是enqueueSyncBarrier的返回值，如果没有调用指定的token不存在是会抛异常的。</p>
<p>enqueueMessage<br>接下来看一下是怎么MessageQueue的enqueueMessage。</p>
<p>复制代码<br>    final boolean enqueueMessage(Message msg, long when) {<br>        if (msg.isInUse()) {<br>            throw new AndroidRuntimeException(msg + “ This message is already in use.”);<br>        }<br>        if (msg.target == null) {<br>            throw new AndroidRuntimeException(“Message must have a target.”);<br>        }</p>
<pre><code>    boolean needWake;
    synchronized (this) {
        if (mQuiting) {
            RuntimeException e = new RuntimeException(
                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);
            Log.w(&quot;MessageQueue&quot;, e.getMessage(), e);
            return false;
        }

        msg.when = when;
        Message p = mMessages;
        if (p == null || when == 0 || when &lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }
    }
    if (needWake) {
        nativeWake(mPtr);
    }
    return true;
}</code></pre><p>复制代码<br>注意上面代码红色的部分，当msg.target为null时是直接抛异常的。</p>
<p>在enqueueMessage中首先判断，如果当前的消息队列为空，或者新添加的消息的执行时间when是0，或者新添加的消息的执行时间比消息队列头的消息的执行时间还早，就把消息添加到消息队列头（消息队列按时间排序），否则就要找到合适的位置将当前消息添加到消息队列。</p>
<p>Native发送消息<br>消息模型不只是Java层用的，Native层也可以用，前面也看到了消息队列初始化时也同时初始化了Native层的Looper与NativeMessageQueue，所以Native层应该也是可以发送消息的。与Java层不同的是，Native层是通过Looper发消息的，同样所有的发送方法最终是调用sendMessageAtTime：</p>
<p>复制代码<br>void Looper::sendMessageAtTime(nsecs_t uptime, const sp<MessageHandler>&amp; handler,<br>        const Message&amp; message) {<br>#if DEBUG_CALLBACKS<br>    ALOGD(“%p ~ sendMessageAtTime - uptime=%lld, handler=%p, what=%d”,<br>            this, uptime, handler.get(), message.what);<br>#endif</p>
<pre><code>size_t i = 0;
{ // acquire lock
    AutoMutex _l(mLock);

    size_t messageCount = mMessageEnvelopes.size();
    while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) {
        i += 1;
    }

    MessageEnvelope messageEnvelope(uptime, handler, message);
    mMessageEnvelopes.insertAt(messageEnvelope, i, 1);

    // Optimization: If the Looper is currently sending a message, then we can skip
    // the call to wake() because the next thing the Looper will do after processing
    // messages is to decide when the next wakeup time should be.  In fact, it does
    // not even matter whether this code is running on the Looper thread.
    if (mSendingMessage) {
        return;
    }
} // release lock

// Wake the poll loop only when we enqueue a new message at the head.
if (i == 0) {
    wake();
}</code></pre><p>}<br>复制代码<br> Native Message只有一个int型的what字段用来区分不同的消息，sendMessageAtTime指定了Message，Message要执行的时间when，与处理这个消息的Handler：MessageHandler，然后用MessageEnvelope封装了time, MessageHandler与Message，Native层发的消息都保存到了mMessageEnvelopes中，mMessageEnvelopes是一个Vector<MessageEnvelope>。Native层消息同样是按时间排序，与Java层的消息分别保存在两个队列里。</p>
<p>消息循环<br>消息队列初始化好了，也知道怎么发消息了，下面就是怎么处理消息了，看Handler.loop函数：</p>
<p>复制代码<br>    public static void loop() {<br>        final Looper me = myLooper();<br>        if (me == null) {<br>            throw new RuntimeException(“No Looper; Looper.prepare() wasn’t called on this thread.”);<br>        }<br>        final MessageQueue queue = me.mQueue;</p>
<pre><code>    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn&apos;t corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                    + Long.toHexString(ident) + &quot; to 0x&quot;
                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                    + msg.target.getClass().getName() + &quot; &quot;
                    + msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycle();
    }
}</code></pre><p>复制代码<br>loop每次从MessageQueue取出一个Message，调用msg.target.dispatchMessage(msg)，target就是发送message时跟message关联的handler，这样就调用到了熟悉的dispatchMessage，Message被处理后会被recycle。当queue.next返回null时会退出消息循环，接下来就看一下MessageQueue.next是怎么取出消息的，又会在什么时候返回null。</p>
<p>复制代码<br>final Message next() {<br>        int pendingIdleHandlerCount = -1; // -1 only during first iteration<br>        int nextPollTimeoutMillis = 0;</p>
<pre><code>    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }
        nativePollOnce(mPtr, nextPollTimeoutMillis);

        synchronized (this) {
            if (mQuiting) {
                return null;
            }

            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // If first time idle, then get the number of idlers to run.
            // Idle handles only run if the queue is empty or if the first message
            // in the queue (possibly a barrier) is due to be handled in the future.
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(&quot;MessageQueue&quot;, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}</code></pre><p>复制代码<br>MessageQueue.next首先会调用nativePollOnce，然后如果mQuiting为true就返回null，Looper就会退出消息循环。</p>
<p>接下来取消息队列头部的消息，如果头部消息是Barrier（target==null）就往后遍历找到第一个异步消息，接下来检测获取到的消息（消息队列头部的消息或者第一个异步消息），如果为null表示没有消息要执行，设置nextPollTimeoutMillis = -1；否则检测这个消息要执行的时间，如果到执行时间了就将这个消息markInUse并从消息队列移除，然后从next返回到loop；否则设置nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE)，即距离最近要执行的消息还需要多久，无论是当前消息队列没有消息可以执行（设置了Barrier并且没有异步消息或消息队列为空）还是队列头部的消息未到执行时间，都会执行后面的代码，看有没有设置IdleHandler，如果有就运行IdleHandler，当IdleHandler被执行之后会设置nextPollTimeoutMillis ＝ 0。</p>
<p>首先看一下nativePollOnce，native方法，调用JNI，最后调到了Native Looper::pollOnce，并从Java层传进去了nextPollTimeMillis，即Java层的消息队列中执行时间最近的消息还要多久到执行时间。</p>
<p>复制代码<br>int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void<em>* outData) {<br>    int result = 0;<br>    for (;;) {<br>        while (mResponseIndex &lt; mResponses.size()) {<br>            const Response&amp; response = mResponses.itemAt(mResponseIndex++);<br>            int ident = response.request.ident;<br>            if (ident &gt;= 0) {<br>                int fd = response.request.fd;<br>                int events = response.events;<br>                void</em> data = response.request.data;<br>#if DEBUG_POLL_AND_WAKE<br>                ALOGD(“%p ~ pollOnce - returning signalled identifier %d: “<br>                        “fd=%d, events=0x%x, data=%p”,<br>                        this, ident, fd, events, data);<br>#endif<br>                if (outFd != NULL) *outFd = fd;<br>                if (outEvents != NULL) *outEvents = events;<br>                if (outData != NULL) *outData = data;<br>                return ident;<br>            }<br>        }</p>
<pre><code>if (result != 0) {</code></pre><p>#if DEBUG_POLL_AND_WAKE<br>            ALOGD(“%p ~ pollOnce - returning result %d”, this, result);<br>#endif<br>            if (outFd != NULL) *outFd = 0;<br>            if (outEvents != NULL) *outEvents = 0;<br>            if (outData != NULL) *outData = NULL;<br>            return result;<br>        }</p>
<pre><code>    result = pollInner(timeoutMillis);
}</code></pre><p>}<br>复制代码<br>先不看开始的一大串代码，先看一下pollInner：</p>
<p>复制代码<br>int Looper::pollInner(int timeoutMillis) {<br>#if DEBUG_POLL_AND_WAKE<br>    ALOGD(“%p ~ pollOnce - waiting: timeoutMillis=%d”, this, timeoutMillis);<br>#endif</p>
<pre><code>// Adjust the timeout based on when the next message is due.
if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
    nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
    int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
    if (messageTimeoutMillis &gt;= 0
            &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
        timeoutMillis = messageTimeoutMillis;
    }</code></pre><p>#if DEBUG_POLL_AND_WAKE<br>        ALOGD(“%p ~ pollOnce - next message in %lldns, adjusted timeout: timeoutMillis=%d”,<br>                this, mNextMessageUptime - now, timeoutMillis);<br>#endif<br>    }</p>
<pre><code>// Poll.
int result = ALOOPER_POLL_WAKE;
mResponses.clear();
mResponseIndex = 0;

struct epoll_event eventItems[EPOLL_MAX_EVENTS];
int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

// Acquire lock.
mLock.lock();

// Check for poll error.
if (eventCount &lt; 0) {
    if (errno == EINTR) {
        goto Done;
    }
    ALOGW(&quot;Poll failed with an unexpected error, errno=%d&quot;, errno);
    result = ALOOPER_POLL_ERROR;
    goto Done;
}

// Check for poll timeout.
if (eventCount == 0) {</code></pre><p>#if DEBUG_POLL_AND_WAKE<br>        ALOGD(“%p ~ pollOnce - timeout”, this);<br>#endif<br>        result = ALOOPER_POLL_TIMEOUT;<br>        goto Done;<br>    }</p>
<pre><code>// Handle all events.</code></pre><p>#if DEBUG_POLL_AND_WAKE<br>    ALOGD(“%p ~ pollOnce - handling events from %d fds”, this, eventCount);<br>#endif</p>
<pre><code>for (int i = 0; i &lt; eventCount; i++) {
    int fd = eventItems[i].data.fd;
    uint32_t epollEvents = eventItems[i].events;
    if (fd == mWakeReadPipeFd) {
        if (epollEvents &amp; EPOLLIN) {
            awoken();
        } else {
            ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake read pipe.&quot;, epollEvents);
        }
    } else {
        ssize_t requestIndex = mRequests.indexOfKey(fd);
        if (requestIndex &gt;= 0) {
            int events = 0;
            if (epollEvents &amp; EPOLLIN) events |= ALOOPER_EVENT_INPUT;
            if (epollEvents &amp; EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
            if (epollEvents &amp; EPOLLERR) events |= ALOOPER_EVENT_ERROR;
            if (epollEvents &amp; EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
            pushResponse(events, mRequests.valueAt(requestIndex));
        } else {
            ALOGW(&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;
                    &quot;no longer registered.&quot;, epollEvents, fd);
        }
    }
}</code></pre><p>Done: ;</p>
<pre><code>// Invoke pending message callbacks.
mNextMessageUptime = LLONG_MAX;
while (mMessageEnvelopes.size() != 0) {
    nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
    const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0);
    if (messageEnvelope.uptime &lt;= now) {
        // Remove the envelope from the list.
        // We keep a strong reference to the handler until the call to handleMessage
        // finishes.  Then we drop it so that the handler can be deleted *before*
        // we reacquire our lock.
        { // obtain handler
            sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;
            Message message = messageEnvelope.message;
            mMessageEnvelopes.removeAt(0);
            mSendingMessage = true;
            mLock.unlock();</code></pre><p>#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS<br>                ALOGD(“%p ~ pollOnce - sending message: handler=%p, what=%d”,<br>                        this, handler.get(), message.what);<br>#endif<br>                handler-&gt;handleMessage(message);<br>            } // release handler</p>
<pre><code>        mLock.lock();
        mSendingMessage = false;
        result = ALOOPER_POLL_CALLBACK;
    } else {
        // The last message left at the head of the queue determines the next wakeup time.
        mNextMessageUptime = messageEnvelope.uptime;
        break;
    }
}

// Release lock.
mLock.unlock();

// Invoke all response callbacks.
for (size_t i = 0; i &lt; mResponses.size(); i++) {
    Response&amp; response = mResponses.editItemAt(i);
    if (response.request.ident == ALOOPER_POLL_CALLBACK) {
        int fd = response.request.fd;
        int events = response.events;
        void* data = response.request.data;</code></pre><p>#if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS<br>            ALOGD(“%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p”,<br>                    this, response.request.callback.get(), fd, events, data);<br>#endif<br>            int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);<br>            if (callbackResult == 0) {<br>                removeFd(fd);<br>            }<br>            // Clear the callback reference in the response structure promptly because we<br>            // will not clear the response vector itself until the next poll.<br>            response.request.callback.clear();<br>            result = ALOOPER_POLL_CALLBACK;<br>        }<br>    }<br>    return result;<br>}<br>复制代码<br>Java层的消息都保存在了Java层MessageQueue的成员mMessages中，Native层的消息都保存在了Native Looper的mMessageEnvelopes中，这就可以说有两个消息队列，而且都是按时间排列的。timeOutMillis表示Java层下个要执行的消息还要多久执行，mNextMessageUpdate表示Native层下个要执行的消息还要多久执行，如果timeOutMillis为0，epoll_wait不设置TimeOut直接返回；如果为-1说明Java层无消息直接用Native的time out；否则pollInner取这两个中的最小值作为timeOut调用epoll_wait。当epoll_wait返回时就可能有以下几种情况：</p>
<p>出错返回。</p>
<p>Time Out</p>
<p>正常返回，描述符上有事件产生。</p>
<p>如果是前两种情况直接goto DONE。</p>
<p>否则就说明FD上有事件发生了，如果是mWakeReadPipeFd的EPOLLIN事件就调用awoken，如果不是mWakeReadPipeFd，那就是通过addFD添加的fd，在addFD中将要监听的fd及其events，callback,data封装成了Request对象，并以fd为键保存到了KeyedVector mRequests中，所以在这里就以fd为键获得在addFD时关联的Request，并连同events通过pushResonse加入mResonse队列（Vector），Resonse仅是对events与Request的封装。如果是epoll_wait出错或timeout，就没有描述符上有事件，就不用执行这一段代码，所以直接goto DONE了。</p>
<p>复制代码<br>void Looper::pushResponse(int events, const Request&amp; request) {<br>    Response response;<br>    response.events = events;<br>    response.request = request;<br>    mResponses.push(response);<br>}<br>复制代码<br>接下来进入DONE部分，从mMessageEnvelopes取出头部的Native消息，如果到达了执行时间就调用它内部保存的MessageeHandler的handleMessage处理并从Native 消息队列移除，设置result为ALOOPER_POLL_CALLBACK，否则计算mNextMessageUptime表示Native消息队列下一次消息要执行的时间。如果未到头部消息的执行时间有可能是Java层消息队列消息的执行时间小于Native层消息队列头部消息的执行时间，到达了Java层消息的执行时间epoll_wait TimeOut返回了，或都通过addFd添加的描述符上有事件发生导致epoll_wait返回，或者epoll_wait是出错返回。Native消息是没有Barrier与Asynchronous的。</p>
<p>最后，遍历mResponses（前面刚通过pushResponse存进去的），如果response.request.ident == ALOOPER_POLL_CALLBACK，就调用注册的callback的handleEvent(fd, events, data)进行处理，然后从mResonses队列中移除，这次遍历完之后，mResponses中保留来来的就都是ident&gt;=0并且callback为NULL的了。在NativeMessageQueue初始化Looper时传入了mAllowNonCallbacks为false，所以这次处理完后mResponses一定为空。</p>
<p>接下来返回到pollOnce。pollOnce是一个for循环，pollInner中处理了所有response.request.ident==ALOOPER_POLL_CALLBACK的Response，在第二次进入for循环后如果mResponses不为空就可以找到ident&gt;0的Response，将其ident作为返回值返回由调用pollOnce的函数自己处理，在这里我们是在NativeMessageQueue中调用的Loope的pollOnce，没对返回值进行处理，而且mAllowNonCallbacks为false也就不可能进入这个循环。pollInner返回值不可能是0，或者说只可能是负数，所以pollOnce中的for循环只会执行两次，在第二次就返回了。</p>
<p>Native Looper可以单独使用，也有一个prepare函数，这时mAllowNonCallbakcs值可能为true，pollOnce中对mResponses的处理就有意义了。</p>
<p> wake与awoken<br>在Native Looper的构造函数中，通过pipe打开了一个管道，并用mWakeReadPipeFd与mWakeWritePipeFd分别保存了管道的读端与写端，然后用epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd,&amp; eventItem)监听了读端的EPOLLIN事件，在pollInner中通过epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis)读取事件，那是在什么时候往mWakeWritePipeFd写，又是在什么时候读的mWakeReadPipeFd呢？</p>
<p>在Looper.cpp中我们可以发现如下两个函数：</p>
<p>复制代码<br>void Looper::wake() {<br>#if DEBUG_POLL_AND_WAKE<br>    ALOGD(“%p ~ wake”, this);<br>#endif</p>
<pre><code>ssize_t nWrite;
do {
    nWrite = write(mWakeWritePipeFd, &quot;W&quot;, 1);
} while (nWrite == -1 &amp;&amp; errno == EINTR);

if (nWrite != 1) {
    if (errno != EAGAIN) {
        ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);
    }
}</code></pre><p>}</p>
<p>void Looper::awoken() {<br>#if DEBUG_POLL_AND_WAKE<br>    ALOGD(“%p ~ awoken”, this);<br>#endif</p>
<pre><code>char buffer[16];
ssize_t nRead;
do {
    nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
} while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer));</code></pre><p>}<br>复制代码<br>wake函数向mWakeWritePipeFd写入了一个“W”字符，awoken从mWakeReadPipeFd读，往mWakeWritePipeFd写数据只是为了在pollInner中的epoll_wait可以监听到事件返回。在pollInner也可以看到如果是mWakeReadPipeFd的EPOLLIN事件只是调用了awoken消耗掉了写入的字符就往后处理了。</p>
<p>那什么时候调用wake呢？这个只要找到调用的地方分析一下就行了，先看Looper.cpp，在sendMessageAtTime即发送Native Message的时候，根据发送的Message的执行时间查找mMessageEnvelopes计算应该插入的位置，如果是在头部插入，就调用wake唤醒epoll_wait，因为在进入pollInner时根据Java层消息队列头部消息的执行时间与Native层消息队列头部消息的执行时间计算出了一个timeout，如果这个新消息是在头部插入，说明执行时间至少在上述两个消息中的一个之前，所以应该唤醒epoll_wait，epoll_wait返回后，检查Native消息队列，看头部消息即刚插入的消息是否到执行时间了，到了就执行，否则就可能需要设置新的timeout。同样在Java层的MessageQueue中，有一个函数nativeWake也同样可以通过JNI调用wake，调用nativeWake的时机与在Native调用wake的时机类似，在消息队列头部插入消息，还有一种情况就是，消息队列头部是一个Barrier，而且插入的消息是第一个异步消息。</p>
<p>复制代码<br>if (p == null || when == 0 || when &lt; p.when) {<br>    // New head, wake up the event queue if blocked.<br>    msg.next = p;<br>    mMessages = msg;<br>    needWake = mBlocked;<br>} else {<br>    // Inserted within the middle of the queue.  Usually we don’t have to wake<br>    // up the event queue unless there is a barrier at the head of the queue<br>    // and the message is the earliest asynchronous message in the queue.<br>    needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();//如果头部是Barrier并且新消息是异步消息则“有可能”需要唤醒<br>    Message prev;<br>    for (;;) {<br>        prev = p;<br>        p = p.next;<br>        if (p == null || when &lt; p.when) {<br>            break;<br>        }<br>        if (needWake &amp;&amp; p.isAsynchronous()) { // 消息队列中有异步消息并且执行时间在新消息之前，所以不需要唤醒。<br>            needWake = false;<br>        }<br>    }<br>    msg.next = p; // invariant: p == prev.next<br>    prev.next = msg;<br>}<br>复制代码<br>在头部插入消息不一定调用nativeWake，因为之前可能正在执行IdleHandler，如果执行了IdleHandler，就在IdleHandler执行后把nextPollTimeoutMillis设置为0，下次进入for循环就用0调用nativePollOnce，不需要wake，只有在没有消息可以执行（消息队列为空或没到执行时间）并且没有设置IdleHandler时mBlocked才会为true。</p>
<p>如果Java层的消息队列被Barrier Block住了并且当前插入的是一个异步消息有可能需要唤醒Looper，因为异步消息可以在Barrier下执行，但是这个异步消息一定要是执行时间最早的异步消息。</p>
<p>退出Looper也需要wake，removeSyncBarrier时也可能需要。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/20/Flutter%20%E7%AA%A5%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/20/Flutter%20%E7%AA%A5%E6%8E%A2/" class="post-title-link" itemprop="url">Flutter 窥探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-20 10:48:06" itemprop="dateCreated datePublished" datetime="2020-07-20T10:48:06+08:00">2020-07-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Flutter-窥探"><a href="#Flutter-窥探" class="headerlink" title="Flutter 窥探"></a>Flutter 窥探</h2><p>全文是对<a href="https://flutterchina.club/docs/" target="_blank" rel="noopener">Flutter文档</a>的简单总结版。</p>
<p>Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。</p>
<ul>
<li>跨平台自绘引擎:Flutter既不使用WebView，也不使用操作系统的原生控件。Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API</li>
<li>高性能:首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><ol>
<li>flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#windows" target="_blank" rel="noopener">点击下载</a></li>
</ol>
</li>
<li><ol start="2">
<li>安装Android Studio,打开File-&gt;Settings-&gt;Plugins 选择Flutter 、Dart插件并安装重启Android Studio</li>
</ol>
</li>
<li><ol start="3">
<li>创建Flutter工程，择选Flutter SDK路径</li>
</ol>
</li>
</ul>
<p>常见问题：</p>
<ol>
<li><p>Flutter“不能热加载(hot reload),热重载按钮灰色且无法点击?<br>运行：flutter doctor 检查配置项是否成功</p>
</li>
<li><p>app体积为何比较大?<br>其实flutter 在release时App体积和native的大小差不多，而debug时体积通常会大。debug版本体积较大是为了Hot reload和快速编译。release版时，flutter又会采用AOT策略，提高App运行效率，release版只打包必需的资源，因而体积又会减少。</p>
</li>
<li><p>如果Android Studio的File=&gt;New无法创建Flutter项目，建议使用以下的命令行创建一个Flutter项目</p>
<blockquote>
<p>flutter create HelloWorld</p>
</blockquote>
</li>
</ol>
<h3 id="第一个Flutter-App"><a href="#第一个Flutter-App" class="headerlink" title="第一个Flutter App"></a>第一个Flutter App</h3><img src="/2020/07/20/Flutter%20%E7%AA%A5%E6%8E%A2/Flutter%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" class="" title="[Flutter项目结构]">

<ul>
<li><strong>app</strong>目录下面是原生应用的配置，如包名、应用名称等</li>
<li><strong>pubspec.yaml</strong>文件类似于gradle用于App的库的引入，常见的有dio、flutter_webview_plugin、video_player</li>
</ul>
<p>Flutter 有两种状态控件：StatelessWidget、StatefulWidget</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [lib&#x2F;main.dart]</span><br><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单行函数特殊写法</span><br><span class="line">void main() &#x3D;&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在Flutter中一切皆Widget</span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">        title: &#39;Flutte&#39;,</span><br><span class="line">        theme: ThemeData(</span><br><span class="line">            primarySwatch: Colors.blue,</span><br><span class="line">            visualDensity: VisualDensity.adaptivePlatformDensity,</span><br><span class="line">        ),</span><br><span class="line">        home: MainPage(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flutter基础组件"><a href="#Flutter基础组件" class="headerlink" title="Flutter基础组件"></a>Flutter基础组件</h3><h4 id="1-基础控件"><a href="#1-基础控件" class="headerlink" title="1. 基础控件"></a>1. 基础控件</h4><p><strong>Text文本控件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    &quot;Hello World&quot;,</span><br><span class="line">    textAlign: TextAlign.center, &#x2F;&#x2F; 对齐方向</span><br><span class="line">    overflow: TextOverflow.ellipsis, &#x2F;&#x2F; 截断...</span><br><span class="line">    maxLines: 2, &#x2F;&#x2F; 最大2行</span><br><span class="line">    style: TextStyle(</span><br><span class="line">        fontSize: 20, &#x2F;&#x2F; 字体大小</span><br><span class="line">        color: Colors.green, &#x2F;&#x2F; 字体颜色</span><br><span class="line">        backgroundColor: Colors.red, &#x2F;&#x2F; 背景颜色</span><br><span class="line">        fontStyle: FontStyle.italic, &#x2F;&#x2F; 斜体</span><br><span class="line">        fontWeight: FontWeight.bold, &#x2F;&#x2F; 加粗</span><br><span class="line">        letterSpacing: 0, &#x2F;&#x2F; 字母间距</span><br><span class="line">        wordSpacing: 5, &#x2F;&#x2F; 字符间距</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const Text.rich(</span><br><span class="line">  TextSpan(</span><br><span class="line">    text: &#39;Hello&#39;,</span><br><span class="line">    children: &lt;TextSpan&gt;[</span><br><span class="line">      TextSpan(text: &#39; beautiful &#39;, style: TextStyle(fontStyle: FontStyle.italic)),</span><br><span class="line">      TextSpan(text: &#39;world&#39;, style: TextStyle(fontWeight: FontWeight.bold)),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>Image图片控件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          header(context),</span><br><span class="line">          header(context),</span><br><span class="line">          header(context),</span><br><span class="line">          header(context),</span><br><span class="line">          header(context),</span><br><span class="line">        ],</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<h4 id="2-事件集合"><a href="#2-事件集合" class="headerlink" title="2. 事件集合"></a>2. 事件集合</h4><h4 id="3-导航跳转"><a href="#3-导航跳转" class="headerlink" title="3. 导航跳转"></a>3. 导航跳转</h4><h4 id="4-文件网络"><a href="#4-文件网络" class="headerlink" title="4. 文件网络"></a>4. 文件网络</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/19/MMKV%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/MMKV%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">MMKV 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-19 16:41:24" itemprop="dateCreated datePublished" datetime="2020-07-19T16:41:24+08:00">2020-07-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MMKV——基于-mmap-的高性能通用-key-value-组件"><a href="#MMKV——基于-mmap-的高性能通用-key-value-组件" class="headerlink" title="MMKV——基于 mmap 的高性能通用 key-value 组件"></a>MMKV——基于 mmap 的高性能通用 key-value 组件</h3><p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。近期也已移植到 Android / macOS / Win32 / POSIX 平台，一并开源。</p>
<h5 id="MMKV-源起"><a href="#MMKV-源起" class="headerlink" title="MMKV 源起"></a>MMKV 源起</h5><p>在微信客户端的日常运营中，时不时就会爆发特殊文字引起系统的 crash，<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286826&idx=1&sn=35601cb1156617aa235b7fd4b085bfc4" target="_blank" rel="noopener">参考文章</a>，文章里面设计的技术方案是在关键代码前后进行计数器的加减，通过检查计数器的异常，来发现引起闪退的异常文字。在会话列表、会话界面等有大量 cell 的地方，希望新加的计时器不会影响滑动性能；另外这些计数器还要永久存储下来——因为闪退随时可能发生。这就需要一个性能非常高的通用 key-value 存储组件，我们考察了 SharedPreferences、NSUserDefaults、SQLite 等常见组件，发现都没能满足如此苛刻的性能要求。考虑到这个防 crash 方案最主要的诉求还是实时写入，而 mmap 内存映射文件刚好满足这种需求，我们尝试通过它来实现一套 key-value 组件。</p>
<h5 id="MMKV-原理"><a href="#MMKV-原理" class="headerlink" title="MMKV 原理"></a>MMKV 原理</h5><ul>
<li><strong>内存准备</strong><br>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。</li>
<li><strong>数据组织</strong><br>数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</li>
<li><strong>写入优化</strong><br>考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力。我们考虑将增量 kv 对象序列化后，append 到内存末尾。</li>
<li><strong>空间增长</strong><br>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。我们需要在性能和空间上做个折中。</li>
</ul>
<p>更详细的设计原理参考 <a href="https://github.com/Tencent/MMKV/wiki/design" target="_blank" rel="noopener">MMKV 原理</a>。</p>
<h3 id="Android-指南"><a href="#Android-指南" class="headerlink" title="Android 指南"></a>Android 指南</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'com.tencent:mmkv-static:1.2.1'</span></span><br><span class="line">    <span class="comment">// replace "1.2.1" with any available version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多安装指引参考 <a href="https://github.com/Tencent/MMKV/wiki/android_setup_cn" target="_blank" rel="noopener">Android Setup</a>。</p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>MMKV 的使用非常简单，所有变更立马生效，无需调用 <code>sync</code>、<code>apply</code>。<br>在 App 启动时初始化 MMKV，设定 MMKV 的根目录（files/mmkv/），例如在 <code>Application</code> 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    String rootDir = MMKV.initialize(<span class="keyword">this</span>);</span><br><span class="line">    System.out.println(<span class="string">"mmkv root: "</span> + rootDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MMKV 提供一个全局的实例，可以直接使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MMKV kv = MMKV.defaultMMKV();</span><br><span class="line">kv.encode(<span class="string">"bool"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">boolean</span> bValue = kv.decodeBool(<span class="string">"bool"</span>);</span><br><span class="line"></span><br><span class="line">kv.encode(<span class="string">"int"</span>, Integer.MIN_VALUE);</span><br><span class="line"><span class="keyword">int</span> iValue = kv.decodeInt(<span class="string">"int"</span>);</span><br><span class="line"></span><br><span class="line">kv.encode(<span class="string">"string"</span>, <span class="string">"Hello from mmkv"</span>);</span><br><span class="line">String str = kv.decodeString(<span class="string">"string"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><h4 id="MMKV-初始化"><a href="#MMKV-初始化" class="headerlink" title="MMKV 初始化"></a>MMKV 初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [MMKV.java]</span><br><span class="line">public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 应用初始化</span><br><span class="line">    public static String initialize(Context context) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置根目录(不可修改)</span><br><span class="line">        String root &#x3D; context.getFilesDir().getAbsolutePath() + &quot;&#x2F;mmkv&quot;;</span><br><span class="line">        &#x2F;&#x2F; 日志级别(debug、info、warning、error、none)</span><br><span class="line">        MMKVLogLevel logLevel &#x3D; BuildConfig.DEBUG ? MMKVLogLevel.LevelDebug : MMKVLogLevel.LevelInfo;</span><br><span class="line">        return initialize(root, null, logLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String initialize(String rootDir, LibLoader loader, MMKVLogLevel logLevel) &#123;</span><br><span class="line">        if (loader !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 设置loader,通过loader加载库</span><br><span class="line">            if (BuildConfig.FLAVOR.equals(&quot;SharedCpp&quot;)) &#123;</span><br><span class="line">                loader.loadLibrary(&quot;c++_shared&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            loader.loadLibrary(&quot;mmkv&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 不设置loader，通过System加载库</span><br><span class="line">            if (BuildConfig.FLAVOR.equals(&quot;SharedCpp&quot;)) &#123;</span><br><span class="line">                System.loadLibrary(&quot;c++_shared&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.loadLibrary(&quot;mmkv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 设置root目录</span><br><span class="line">        MMKV.rootDir &#x3D; rootDir;</span><br><span class="line">        jniInitialize(MMKV.rootDir, logLevel2Int(logLevel));</span><br><span class="line">        return rootDir;</span><br><span class="line">    &#125;    </span><br><span class="line">    private static native void jniInitialize(String rootDir, int level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [native-bridge.cpp]</span><br><span class="line">MMKV_JNI void jniInitialize(JNIEnv *env, jobject obj, jstring rootDir, jint logLevel) &#123;</span><br><span class="line">    if (!rootDir) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    const char *kstr &#x3D; env-&gt;GetStringUTFChars(rootDir, nullptr);</span><br><span class="line">    if (kstr) &#123;</span><br><span class="line">        MMKV::initializeMMKV(kstr, (MMKVLogLevel) logLevel);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(rootDir, kstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [MMKV.cpp]</span><br><span class="line">ThreadOnceToken_t once_control &#x3D; ThreadOnceUninitialized;</span><br><span class="line">void MMKV::initializeMMKV(const MMKVPath_t &amp;rootDir, MMKVLogLevel logLevel) &#123;</span><br><span class="line">    g_currentLogLevel &#x3D; logLevel;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Linux Threads使用互斥锁和条件变量保证由pthread_once()指定的函数执行且仅执行一次，而once_control表示是否执行过。</span><br><span class="line">    ThreadLock::ThreadOnce(&amp;once_control, initialize);</span><br><span class="line"></span><br><span class="line">    g_rootDir &#x3D; rootDir;</span><br><span class="line">    &#x2F;&#x2F; mkpath：上层目录不存在也没关系，自动一起创建。目录已经存在时会返回true。</span><br><span class="line">    &#x2F;&#x2F; mkdir：上层目录不存在时，创建会失败。比如创建“c:\\test\test”，如果test不存在，那test也创建不了。目录已经存在时会返回false。</span><br><span class="line">    mkPath(g_rootDir);</span><br><span class="line"></span><br><span class="line">    MMKVInfo(&quot;root dir: &quot; MMKV_PATH_FORMAT, g_rootDir.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取MMKV对象"><a href="#获取MMKV对象" class="headerlink" title="获取MMKV对象"></a>获取MMKV对象</h4><p>C语言底层创建MMKV对象，并将该对象地址保存到nativeHandle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [MMKV.java]</span><br><span class="line">public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123;</span><br><span class="line">    static public final int SINGLE_PROCESS_MODE &#x3D; 0x1;</span><br><span class="line">    private long nativeHandle;</span><br><span class="line">    </span><br><span class="line">    private MMKV(long handle) &#123;</span><br><span class="line">        nativeHandle &#x3D; handle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static MMKV defaultMMKV() &#123;</span><br><span class="line">        if (rootDir &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;You should Call MMKV.initialize() first.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 底层创建MMKV对象，并返回该对象地址</span><br><span class="line">        long handle &#x3D; getDefaultMMKV(SINGLE_PROCESS_MODE, null);</span><br><span class="line">        &#x2F;&#x2F; 将底层MMKV地址保存到nativeHandle</span><br><span class="line">        return new MMKV(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    private native static long getDefaultMMKV(int mode, String cryptKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [native-bridge.cpp]</span><br><span class="line">MMKV_JNI jlong getDefaultMMKV(JNIEnv *env, jobject obj, jint mode, jstring cryptKey) &#123;</span><br><span class="line">    MMKV *kv &#x3D; nullptr;</span><br><span class="line">    if (cryptKey) &#123;</span><br><span class="line">        string crypt &#x3D; jstring2string(env, cryptKey);</span><br><span class="line">        if (crypt.length() &gt; 0) &#123;</span><br><span class="line">            kv &#x3D; MMKV::defaultMMKV((MMKVMode) mode, &amp;crypt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!kv) &#123;</span><br><span class="line">        kv &#x3D; MMKV::defaultMMKV((MMKVMode) mode, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回地址</span><br><span class="line">    return (jlong) kv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [MMKV.cpp]</span><br><span class="line">&#x2F;&#x2F; 获取一个 unordered_map, 类似于 Java 中的 HashMap</span><br><span class="line">unordered_map&lt;std::string, MMKV *&gt; *g_instanceDic;</span><br><span class="line"></span><br><span class="line">MMKV *MMKV::defaultMMKV(MMKVMode mode, string *cryptKey) &#123;</span><br><span class="line">#ifndef MMKV_ANDROID</span><br><span class="line">    return mmkvWithID(DEFAULT_MMAP_ID, mode, cryptKey);</span><br><span class="line">#else</span><br><span class="line">    return mmkvWithID(DEFAULT_MMAP_ID, DEFAULT_MMAP_SIZE, mode, cryptKey);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifndef MMKV_ANDROID</span><br><span class="line">MMKV *MMKV::mmkvWithID(const string &amp;mmapID, MMKVMode mode, string *cryptKey, MMKVPath_t *rootPath) &#123;</span><br><span class="line"></span><br><span class="line">    if (mmapID.empty()) &#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPED_LOCK(g_instanceLock);</span><br><span class="line">    &#x2F;&#x2F; 通过 mmapID 和 rootPath, 组成最终的 mmap 文件路径的 key</span><br><span class="line">    auto mmapKey &#x3D; mmapedKVKey(mmapID, rootPath);</span><br><span class="line">    auto itr &#x3D; g_instanceDic-&gt;find(mmapKey);</span><br><span class="line">    if (itr !&#x3D; g_instanceDic-&gt;end()) &#123;</span><br><span class="line">        MMKV *kv &#x3D; itr-&gt;second;</span><br><span class="line">        return kv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (rootPath) &#123;</span><br><span class="line">        MMKVPath_t specialPath &#x3D; (*rootPath) + MMKV_PATH_SLASH + SPECIAL_CHARACTER_DIRECTORY_NAME;</span><br><span class="line">        if (!isFileExist(specialPath)) &#123;</span><br><span class="line">            mkPath(specialPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建MMKV对象</span><br><span class="line">    auto kv &#x3D; new MMKV(mmapID, mode, cryptKey, rootPath);</span><br><span class="line">    kv-&gt;m_mmapKey &#x3D; mmapKey;</span><br><span class="line">    (*g_instanceDic)[mmapKey] &#x3D; kv;</span><br><span class="line">    return kv;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取文件名</span><br><span class="line">string mmapedKVKey(const string &amp;mmapID, MMKVPath_t *rootPath) &#123;</span><br><span class="line">    if (rootPath &amp;&amp; g_rootDir !&#x3D; (*rootPath)) &#123;</span><br><span class="line">        return md5(*rootPath + MMKV_PATH_SLASH + string2MMKVPath_t(mmapID));</span><br><span class="line">    &#125;</span><br><span class="line">    return mmapID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifndef MMKV_ANDROID</span><br><span class="line">MMKV::MMKV(const std::string &amp;mmapID, MMKVMode mode, string *cryptKey, MMKVPath_t *rootPath)</span><br><span class="line">    : m_mmapID(mmapID) &#x2F;&#x2F; 文件名</span><br><span class="line">    , m_path(mappedKVPathWithID(m_mmapID, mode, rootPath)) &#x2F;&#x2F; 存放路径</span><br><span class="line">    , m_crcPath(crcPathWithID(m_mmapID, mode, rootPath)) &#x2F;&#x2F; 校验文件存放路径</span><br><span class="line">    , m_dic(nullptr) &#x2F;&#x2F; </span><br><span class="line">    , m_dicCrypt(nullptr)</span><br><span class="line">    , m_file(new MemoryFile(m_path))</span><br><span class="line">    , m_metaFile(new MemoryFile(m_crcPath))</span><br><span class="line">    , m_metaInfo(new MMKVMetaInfo())</span><br><span class="line">    , m_crypter(nullptr)</span><br><span class="line">    , m_lock(new ThreadLock())</span><br><span class="line">    , m_fileLock(new FileLock(m_metaFile-&gt;getFd()))</span><br><span class="line">    , m_sharedProcessLock(new InterProcessLock(m_fileLock, SharedLockType))</span><br><span class="line">    , m_exclusiveProcessLock(new InterProcessLock(m_fileLock, ExclusiveLockType))</span><br><span class="line">    , m_isInterProcess((mode &amp; MMKV_MULTI_PROCESS) !&#x3D; 0) &#123;</span><br><span class="line">    m_actualSize &#x3D; 0;</span><br><span class="line">    m_output &#x3D; nullptr;</span><br><span class="line"></span><br><span class="line">#    ifndef MMKV_DISABLE_CRYPT</span><br><span class="line">    if (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; 0) &#123;</span><br><span class="line">        m_dicCrypt &#x3D; new MMKVMapCrypt();</span><br><span class="line">        m_crypter &#x3D; new AESCrypt(cryptKey-&gt;data(), cryptKey-&gt;length());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        m_dic &#x3D; new MMKVMap();</span><br><span class="line">    &#125;</span><br><span class="line">#    else</span><br><span class="line">    m_dic &#x3D; new MMKVMap();</span><br><span class="line">#    endif</span><br><span class="line"></span><br><span class="line">    m_needLoadFromFile &#x3D; true;</span><br><span class="line">    m_hasFullWriteback &#x3D; false;</span><br><span class="line"></span><br><span class="line">    m_crcDigest &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    m_lock-&gt;initialize();</span><br><span class="line">    m_sharedProcessLock-&gt;m_enable &#x3D; m_isInterProcess;</span><br><span class="line">    m_exclusiveProcessLock-&gt;m_enable &#x3D; m_isInterProcess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; sensitive zone</span><br><span class="line">    &#123;</span><br><span class="line">        SCOPED_LOCK(m_sharedProcessLock);</span><br><span class="line">        &#x2F;&#x2F; 根据 m_mmapID 来加载文件中的数据</span><br><span class="line">        loadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [MMKV_IO.cpp]</span><br><span class="line">void MMKV::loadFromFile() &#123;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    if (m_metaFile-&gt;isFileValid()) &#123;</span><br><span class="line">        m_metaInfo-&gt;read(m_metaFile-&gt;getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!m_file-&gt;isFileValid()) &#123;</span><br><span class="line">        m_file-&gt;reloadFromFile();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!m_file-&gt;isFileValid()) &#123;</span><br><span class="line">        MMKVError(&quot;file [%s] not valid&quot;, m_path.c_str());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bool loadFromFile &#x3D; false, needFullWriteback &#x3D; false;</span><br><span class="line">        checkDataValid(loadFromFile, needFullWriteback);</span><br><span class="line">        auto ptr &#x3D; (uint8_t *) m_file-&gt;getMemory();</span><br><span class="line">        if (loadFromFile &amp;&amp; m_actualSize &gt; 0) &#123;</span><br><span class="line">            MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);</span><br><span class="line">            if (m_crypter) &#123;</span><br><span class="line">                clearDictionary(m_dicCrypt);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                clearDictionary(m_dic);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (needFullWriteback) &#123;</span><br><span class="line">                MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                MiniPBCoder::decodeMap(*m_dic, inputBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_needLoadFromFile &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [MemoryFile.cpp]</span><br><span class="line">MemoryFile::MemoryFile(const MMKVPath_t &amp;path) : m_name(path), m_fd(-1), m_ptr(nullptr), m_size(0) &#123;</span><br><span class="line">    reloadFromFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MemoryFile::reloadFromFile() &#123;</span><br><span class="line">    m_fd &#x3D; open(m_name.c_str(), O_RDWR | O_CREAT | O_CLOEXEC, S_IRWXU);</span><br><span class="line">    mmkv::getFileSize(m_fd, m_size);</span><br><span class="line">    &#x2F;&#x2F; round up to (n * pagesize)</span><br><span class="line">    if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE !&#x3D; 0)) &#123;</span><br><span class="line">        size_t roundSize &#x3D; ((m_size &#x2F; DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE;</span><br><span class="line">        &#x2F;&#x2F; 修正文件大小, 最小为 4kb</span><br><span class="line">        truncate(roundSize);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        auto ret &#x3D; mmap();</span><br><span class="line">        if (!ret) &#123;</span><br><span class="line">            doCleanMemoryCache(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MemoryFile::mmap() &#123;</span><br><span class="line">    m_ptr &#x3D; (char *) ::mmap(m_ptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0);</span><br><span class="line">    if (m_ptr &#x3D;&#x3D; MAP_FAILED) &#123;</span><br><span class="line">        m_ptr &#x3D; nullptr;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MemoryFile::doCleanMemoryCache(bool forceClean) &#123;</span><br><span class="line">    if (m_ptr &amp;&amp; m_ptr !&#x3D; MAP_FAILED) &#123;</span><br><span class="line">        if (munmap(m_ptr, m_size) !&#x3D; 0) &#123;</span><br><span class="line">            MMKVError(&quot;fail to munmap [%s], %s&quot;, m_name.c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_ptr &#x3D; nullptr;</span><br><span class="line"></span><br><span class="line">    if (m_fd &gt;&#x3D; 0) &#123;</span><br><span class="line">        if (::close(m_fd) !&#x3D; 0) &#123;</span><br><span class="line">            MMKVError(&quot;fail to close [%s], %s&quot;, m_name.c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_fd &#x3D; -1;</span><br><span class="line">    m_size &#x3D; 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MMKV-encode、decode方法"><a href="#MMKV-encode、decode方法" class="headerlink" title="MMKV encode、decode方法"></a>MMKV encode、decode方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [MMKV.java]</span><br><span class="line">public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123;</span><br><span class="line">    public boolean encode(String key, String value) &#123;</span><br><span class="line">        return encodeString(nativeHandle, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private native boolean encodeString(long handle, String key, String value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [native-bridge.cpp]</span><br><span class="line">MMKV_JNI jboolean encodeString(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue) &#123;</span><br><span class="line">    MMKV *kv &#x3D; reinterpret_cast&lt;MMKV *&gt;(handle);</span><br><span class="line">    if (kv &amp;&amp; oKey) &#123;</span><br><span class="line">        string key &#x3D; jstring2string(env, oKey);</span><br><span class="line">        if (oValue) &#123;</span><br><span class="line">            string value &#x3D; jstring2string(env, oValue);</span><br><span class="line">            return (jboolean) kv-&gt;set(value, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            kv-&gt;removeValueForKey(key);</span><br><span class="line">            return (jboolean) true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (jboolean) false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [MMKV.cpp]</span><br><span class="line">bool MMKV::set(const string &amp;value, MMKVKey_t key) &#123;</span><br><span class="line">    if (isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将数据编码成 ProtocolBuffer</span><br><span class="line">    return setDataForKey(MMBuffer((void *) value.data(), value.length(), MMBufferNoCopy), key, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [MMKV_IO.cpp]</span><br><span class="line">bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, MMKVKey_t key, bool isDataHolder) &#123;</span><br><span class="line">    if ((!isDataHolder &amp;&amp; data.length() &#x3D;&#x3D; 0) || isKeyEmpty(key)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    SCOPED_LOCK(m_lock);</span><br><span class="line">    SCOPED_LOCK(m_exclusiveProcessLock);</span><br><span class="line">    &#x2F;&#x2F; 检查文件有效性</span><br><span class="line">    checkLoadData();</span><br><span class="line">    ...</span><br><span class="line">    auto itr &#x3D; m_dic-&gt;find(key);</span><br><span class="line">    if (itr !&#x3D; m_dic-&gt;end()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将该对象添加到内存里</span><br><span class="line">        auto ret &#x3D; appendDataWithKey(data, itr-&gt;second, isDataHolder);</span><br><span class="line">        if (!ret.first) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        itr-&gt;second &#x3D; std::move(ret.second);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        auto ret &#x3D; appendDataWithKey(data, key, isDataHolder);</span><br><span class="line">        if (!ret.first) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        m_dic-&gt;emplace(key, std::move(ret.second));</span><br><span class="line">    &#125;</span><br><span class="line">    m_hasFullWriteback &#x3D; false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MMBuffer MMKV::getDataForKey(MMKVKey_t key) &#123;</span><br><span class="line">    checkLoadData();</span><br><span class="line">    ...</span><br><span class="line">    auto itr &#x3D; m_dic-&gt;find(key);</span><br><span class="line">    if (itr !&#x3D; m_dic-&gt;end()) &#123;</span><br><span class="line">        auto basePtr &#x3D; (uint8_t *) (m_file-&gt;getMemory()) + Fixed32Size;</span><br><span class="line">        return itr-&gt;second.toMMBuffer(basePtr);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 没找到就返回一个新的MMBuffer</span><br><span class="line">    MMBuffer nan;</span><br><span class="line">    return nan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.jianshu.com/p/13b889028326" target="_blank" rel="noopener">Android 存储优化 —— MMKV 集成与原理</a><br><a href="https://blog.csdn.net/z_ryan/article/details/79604192" target="_blank" rel="noopener">剖析linux下的零拷贝技术（zero-copy）</a><br><a href="https://zhuanlan.zhihu.com/p/103508247" target="_blank" rel="noopener"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/18/Linux%20MMAP%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/18/Linux%20MMAP%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Linux MMAP机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-18 21:41:56" itemprop="dateCreated datePublished" datetime="2020-07-18T21:41:56+08:00">2020-07-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Linux-MMAP机制"><a href="#Linux-MMAP机制" class="headerlink" title="Linux MMAP机制"></a>Linux MMAP机制</h4><h4 id="传统文件IO"><a href="#传统文件IO" class="headerlink" title="传统文件IO"></a>传统文件IO</h4><p>虚拟内存被操作系统划分成两块：用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>
<p><img src="%E4%BC%A0%E7%BB%9FIO.png" alt="传统IO.png"></p>
<p>1、调用write，告诉内核需要写入数据的开始地址与长度<br>2、内核将数据拷贝到内核缓存<br>3、由操作系统调用，将数据拷贝到磁盘，完成写入</p>
<p>可见，将数据写入文件需要将<strong>数据拷贝两次（用户空间到内核空间、内核空间到磁盘文件）</strong>，再写入到文件中，如果数据量过大，也会有很大的性能损耗。</p>
<h4 id="MMAP（memory-mapping）"><a href="#MMAP（memory-mapping）" class="headerlink" title="MMAP（memory mapping）"></a>MMAP（memory mapping）</h4><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。</p>
<p><img src="mmap.png" alt="mmap"></p>
<p>对文件进行映射，会在进程的虚拟内存分配地址空间，创建映射关系。实现这样的映射关系后，就可以采用指针的方式读写操作这一段内存，而系统会自动回写到对应的文件磁盘上。</p>
<h5 id="MMAP优势"><a href="#MMAP优势" class="headerlink" title="MMAP优势"></a>MMAP优势</h5><ul>
<li>MMAP对文件的读写操作只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据的拷贝次数，提高了文件读写效率。</li>
<li>MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件，不需要开启线程，操作MMAP的速度和操作内存的速度一样快；</li>
<li>MMAP提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统如内存不足、进程退出等时候负责将内存回写到文件，不必担心 crash 导致数据丢失。</li>
</ul>
<p>代码示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::string file &quot;&quot;;</span><br><span class="line">int32_t m_size &#x3D; getpagesize()</span><br><span class="line">int m_fd &#x3D; open(file.c_str(), O_RWDR|)</span><br><span class="line"></span><br><span class="line">mmap(0, m_size, PORT_READ|PROR_WRITE, MAP_SHARED)</span><br></pre></td></tr></table></figure>

<p>视频:<a href="https://www.bilibili.com/video/BV1Sf4y117Q6?from=search&seid=6722485054973252272" target="_blank" rel="noopener">Linux MMAP机制</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
