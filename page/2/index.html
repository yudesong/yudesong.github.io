<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/23/startActivityForResult%E5%92%8CsetResult%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/startActivityForResult%E5%92%8CsetResult%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">startActivityForResult和setResult详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-23 19:24:13 / 修改时间：19:24:44" itemprop="dateCreated datePublished" datetime="2021-02-23T19:24:13+08:00">2021-02-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>startActivityForResult与startActivity的不同之处在于：</p>
<ul>
<li>startActivity( )<br>仅仅是跳转到目标页面，若是想跳回当前页面，则必须再使用一次startActivity( )。</li>
<li>startActivityForResult( )<br>可以一次性完成这项任务，当程序执行到这段代码的时候，假若从T1Activity跳转到下一个Text2Activity，而当这个Text2Activity调用了finish()方法以后，程序会自动跳转回T1Activity，并调用前一个T1Activity中的onActivityResult( )方法。</li>
</ul>
<p>相关函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(Intent intent, Int requestCode)</span><br><span class="line">setResut(int resultCode, Intent intent)</span><br><span class="line">onActivityResult(int requestCode, int resultCode, Intent intent)</span><br></pre></td></tr></table></figure>

<p>简单例子介绍:</p>
<p>1.跳转的时候不是采用startActivity(intent) 这个方法，而是startActivityForResult(intent, 0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Intent intent&#x3D;new Intent();</span><br><span class="line">intent.setClass(A.this, B.class);</span><br><span class="line">Bundle bundle&#x3D;new Bundle();</span><br><span class="line">String str1&#x3D;&quot;aaaaaa&quot;;</span><br><span class="line">bundle.putString(&quot;str1&quot;, str1);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivityForResult(intent, 0);</span><br></pre></td></tr></table></figure>

<p>2.重写onActivityResult方法，用来接收B回传的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    switch (resultCode) &#123; &#x2F;&#x2F;resultCode为回传的标记，我在B中回传的是RESULT_OK</span><br><span class="line">       case RESULT_OK:</span><br><span class="line">            Bundle b&#x3D;data.getExtras(); &#x2F;&#x2F;data为B中回传的Intent</span><br><span class="line">            String str&#x3D;b.getString(&quot;str1&quot;);&#x2F;&#x2F;str即为回传的值</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在B中回传数据时采用setResult方法，并且之后要调用finish方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setResult(RESULT_OK, intent); &#x2F;&#x2F;intent为A传来的带有Bundle的intent，当然也可以自己定义新的Bundle</span><br><span class="line">finish();&#x2F;&#x2F;此处一定要调用finish()方法</span><br></pre></td></tr></table></figure>

<p>Android activity的setResult()在什么时候调用(重点也是难点)</p>
<p>如果在startActivityForResult起来的Activity里面设置setResult,结果并不会马上返回给parent的Activity,只有当前Activity被finish,结果才会被发送给parent的onActivityResult去处理!</p>
<p>如果一个activity要返回数据到启动它的那个activity，可以调用setResult()方法。那什么时候去调用setResult()方法返回数据呢？<br>看一下源码就明白了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final void setResult(int resultCode, Intent data) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mResultCode &#x3D; resultCode;</span><br><span class="line">        mResultData &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void finish() &#123;</span><br><span class="line">    if (mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">        int resultCode;</span><br><span class="line">        Intent resultData;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            resultCode &#x3D; mResultCode;</span><br><span class="line">            resultData &#x3D; mResultData;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Config.LOGV) Log.v(TAG, &quot;Finishing self: token&#x3D;&quot; + mToken);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (ActivityManagerNative.getDefault()</span><br><span class="line">                .finishActivity(mToken, resultCode, resultData)) &#123;</span><br><span class="line">                mFinished &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; Empty</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mParent.finishFromChild(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以看出activity返回result是在被finish的时候，也就是说调用setResult()方法必须在finish()之前。<br>那么如果在如下方法中调用setResult()也有可能不会返回成功： onPause()， onStop()， onDestroy(),<br>因为这些方法调用不一定是在finish之前的，当然在onCreate()就调用setResult肯定是在finish之前的</p>
<p>按BACK键从一个Activity退出来的，一按BACK，android就会自动调用Activity的finish()方法，然后设置resultCode为RESULT_CANCELED，也就不会返回任何数据了 .<br>解决方法就是在Activity里面捕获按BACK的事件，捕获到之后先setResult，然后自己来调用finish,就搞定了……把BACK事件直接自己给吞了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBackPressed() &#123;</span><br><span class="line">    Log.i(TAG, &quot;onBackPressed&quot;);</span><br><span class="line">    setResult(Const.LIVE_OK);</span><br><span class="line">    super.onBackPressed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然还可以在onCreate()就调用setResult，不过我觉得这种方法没有重写onBackPressed()方法好.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/23/RemoteViews%20%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/RemoteViews%20%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">RemoteViews 详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-23 16:38:38 / 修改时间：17:34:18" itemprop="dateCreated datePublished" datetime="2021-02-23T16:38:38+08:00">2021-02-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RemoteViews-简介"><a href="#RemoteViews-简介" class="headerlink" title="RemoteViews 简介"></a>RemoteViews 简介</h2><h3 id="一、什么是RemoteViews"><a href="#一、什么是RemoteViews" class="headerlink" title="一、什么是RemoteViews"></a>一、什么是RemoteViews</h3><p>RemoteViews翻译过来就是远程视图.顾名思义,RemoteViews不是当前进程的View,是属于SystemServer进程.应用程序与RemoteViews之间依赖Binder实现了进程间通信.</p>
<h3 id="二、RemoteViews的用法"><a href="#二、RemoteViews的用法" class="headerlink" title="二、RemoteViews的用法"></a>二、RemoteViews的用法</h3><p>RemoteViews使用最多的场合是<strong>通知栏和桌面小插件</strong>. 以通知栏为例,讲解下它的用法.</p>
<p>1、新建一个Notification</p>
<p>在3.0之后官方推荐使用建造者模式创建Notification.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Notification mNotification &#x3D; new Notification.Builder(this)</span><br><span class="line">        .setContentTitle(&quot;这是标题 &quot;)    </span><br><span class="line">        .setContentText(&quot;这是内容&quot;)        </span><br><span class="line">        .setSmallIcon(R.drawable.ic_launcher)                </span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>Notification有很多属性,这里列举一些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- setContentTitle       设置标题</span><br><span class="line">- setContentText        设置内容</span><br><span class="line">- setLargeIcon          设置通知栏大图标</span><br><span class="line">- setSmallIcon          设置通知栏小图标</span><br><span class="line">- setContent            设置RemoteViews</span><br><span class="line">- setContentIntent      当通知条目被点击，就执行这个被设置的Intent.</span><br><span class="line">- setDeleteIntent       当用户点击&quot;Clear All Notifications&quot;按钮区删除所有的通知的时候，这个被设置的Intent被执行</span><br><span class="line">- setLights             设置闪光灯</span><br><span class="line">- setSound              设置声音</span><br><span class="line">- setPriority           设置优先级</span><br></pre></td></tr></table></figure>

<p>2、设置Notification的RemoteViews</p>
<p>如果要给通知栏使用自定义布局就要使用RemoteViews了,传入包名和相应的布局.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RemoteViews mRemoteViews&#x3D;new RemoteViews(&quot;com.example.remoteviewdemo&quot;, R.layout.remoteview_layout);</span><br></pre></td></tr></table></figure>
<p>然后通过setContent()传入RemoteViews 对象即可.</p>
<p>这里顺便讲一下PendingIntent,PendingIntent是”延迟意图”的意思,就是当满足某一条件时出触发这个Intent.通过PendingIntent的getActivity、getBroadcast、getService等分别构建一个打开对应组件的延迟Intent.<br>传入四个参数，context、intent、requestCode(自定义)、flag.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent&#x3D;new Intent(MainActivity.this,MainActivity.class);</span><br><span class="line">PendingIntent mPendingIntent&#x3D;PendingIntent.getActivity(MainActivity.this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br></pre></td></tr></table></figure>

<p>PendingIntent有4种flag.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- FLAG_ONE_SHOT                只执行一次</span><br><span class="line">- FLAG_NO_CREATE               若描述的Intent不存在则返回NULL值</span><br><span class="line">- FLAG_CANCEL_CURRENT          如果描述的PendingIntent已经存在，则在产生新的Intent之前会先取消掉当前的</span><br><span class="line">- FLAG_UPDATE_CURRENT          总是执行,这个flag用的最多</span><br></pre></td></tr></table></figure>

<p>3、获取通知管理者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager manager &#x3D; (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br></pre></td></tr></table></figure>

<p>4、弹出通知</p>
<p>调用notify方法,传入一个id(自定义)和通知实例即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager.notify(1, mNotification);</span><br></pre></td></tr></table></figure>

<p>5、改变RemoteViews的布局</p>
<p>RemoteViews并不能直接获得控件实例,然后对控件进行操作.它提供了<br>setTextViewText(viewId, text)、setImageViewResource(viewId, srcId)等方法进行操作,传入控件id和相应的修改内容.<br>列举一下常用的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- setTextViewText(viewId, text)                     设置文本</span><br><span class="line">- setTextColor(viewId, color)                       设置文本颜色</span><br><span class="line">- setTextViewTextSize(viewId, units, size)          设置文本大小 </span><br><span class="line">- setImageViewBitmap(viewId, bitmap)                设置图片</span><br><span class="line">- setImageViewResource(viewId, srcId)               根据图片资源设置图片</span><br><span class="line">- setViewPadding(viewId, left, top, right, bottom)  设置Padding间距</span><br><span class="line">- setOnClickPendingIntent(viewId, pendingIntent)    设置点击事件</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>案例</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PendingIntent pi &#x3D; PendingIntent.getActivity(MainActivity.this, 0x001,</span><br><span class="line">        new Intent(MainActivity.this, TargetActivity.class), PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">RemoteViews remoteView &#x3D; new RemoteViews(getPackageName(), R.layout.remoteview_main);</span><br><span class="line">remoteView.setTextViewText(R.id.remoteview_main_title, &quot;Title&quot;);</span><br><span class="line">remoteView.setTextViewText(R.id.remoteview_main_content, &quot;ContentContentContent&quot;);</span><br><span class="line">remoteView.setImageViewResource(R.id.remoteview_main_icon, R.mipmap.ic_launcher_round);</span><br><span class="line">remoteView.setOnClickPendingIntent(R.id.remoteview_main_view, pi);</span><br><span class="line">Notification.Builder nb &#x3D; new Notification.Builder(MainActivity.this)</span><br><span class="line">        .setSmallIcon(R.mipmap.ic_launcher) &#x2F;&#x2F; 小图标</span><br><span class="line">        .setCustomContentView(remoteView) &#x2F;&#x2F; 设置自定义的RemoteView，需要API最低为24</span><br><span class="line">        .setWhen(System.currentTimeMillis()) &#x2F;&#x2F; 设置通知发送的时间戳</span><br><span class="line">        .setAutoCancel(true) &#x2F;&#x2F; 点击通知后通知在通知栏上消失</span><br><span class="line">        .setDefaults(Notification.DEFAULT_ALL); &#x2F;&#x2F; 设置默认的提示音、振动方式、灯光等</span><br><span class="line">((NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE)).notify(1, nb.build()); &#x2F;&#x2F; build()方法需要的最低API为16</span><br></pre></td></tr></table></figure>

<h3 id="三、RemoteViews的改变原理"><a href="#三、RemoteViews的改变原理" class="headerlink" title="三、RemoteViews的改变原理"></a>三、RemoteViews的改变原理</h3><p>1.setTextViewText方法代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteViews implements Parcelable, Filter &#123;</span><br><span class="line">    private final class ReflectionAction extends Action &#123;</span><br><span class="line">        ReflectionAction(int viewId, String methodName, int type, Object value) &#123;</span><br><span class="line">            this.viewId &#x3D; viewId;</span><br><span class="line">            this.methodName &#x3D; methodName;</span><br><span class="line">            this.type &#x3D; type;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setTextViewText(int viewId, CharSequence text) &#123;</span><br><span class="line">        setCharSequence(viewId, &quot;setText&quot;, text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setCharSequence(int viewId, String methodName, CharSequence value) &#123;</span><br><span class="line">        addAction(new ReflectionAction(viewId, methodName, ReflectionAction.CHAR_SEQUENCE, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addAction(Action a) &#123;</span><br><span class="line">        if (mActions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mActions &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        mActions.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void reapply(Context context, View v) &#123;</span><br><span class="line">        reapply(context, v, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void reapply(Context context, View v, OnClickHandler handler) &#123;</span><br><span class="line">        RemoteViews rvToApply &#x3D; getRemoteViewsToApply(context);</span><br><span class="line">        rvToApply.performApply(v, (ViewGroup) v.getParent(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void performApply(View v, ViewGroup parent, OnClickHandler handler) &#123;</span><br><span class="line">        if (mActions !&#x3D; null) &#123;</span><br><span class="line">            handler &#x3D; handler &#x3D;&#x3D; null ? DEFAULT_ON_CLICK_HANDLER : handler;</span><br><span class="line">            final int count &#x3D; mActions.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">                Action a &#x3D; mActions.get(i);</span><br><span class="line">                a.apply(v, parent, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public View apply(Context context, ViewGroup parent, OnClickHandler handler) &#123;</span><br><span class="line">        RemoteViews rvToApply &#x3D; getRemoteViewsToApply(context);</span><br><span class="line">        View result &#x3D; inflateView(context, rvToApply, parent);</span><br><span class="line">        rvToApply.performApply(result, parent, handler);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>manager.notify(1, mNotification)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class NotificationManager &#123;</span><br><span class="line">    public void notify(int id, Notification notification) &#123;</span><br><span class="line">        notify(null, id, notification);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void notify(String tag, int id, Notification notification) &#123;</span><br><span class="line">        notifyAsUser(tag, id, notification, mContext.getUser());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void notifyAsUser(String tag, int id, Notification notification, UserHandle user) &#123;</span><br><span class="line">        INotificationManager service &#x3D; getService();</span><br><span class="line">        String pkg &#x3D; mContext.getPackageName();</span><br><span class="line">        try &#123;</span><br><span class="line">            service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id,</span><br><span class="line">                    fixNotification(notification), user.getIdentifier());</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static public INotificationManager getService() &#123;</span><br><span class="line">        if (sService !&#x3D; null) &#123;</span><br><span class="line">            return sService;</span><br><span class="line">        &#125;</span><br><span class="line">        IBinder b &#x3D; ServiceManager.getService(&quot;notification&quot;);</span><br><span class="line">        sService &#x3D; INotificationManager.Stub.asInterface(b);</span><br><span class="line">        return sService;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[NotificationManagerService.java]</span><br><span class="line">public class NotificationManagerService extends SystemService &#123;</span><br><span class="line">    void enqueueNotificationInternal(...) &#123;</span><br><span class="line">        final StatusBarNotification n &#x3D; new StatusBarNotification(</span><br><span class="line">                pkg, opPkg, id, tag, notificationUid, callingPid, notification,</span><br><span class="line">                user, null, System.currentTimeMillis());</span><br><span class="line">        ...        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/itgungnir/p/6923949.html" target="_blank" rel="noopener">【Android - 进阶】之RemoteViews简介</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/23/SurfaceFlinger%20%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/SurfaceFlinger%20%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">SurfaceFlinger详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-23 10:55:52 / 修改时间：15:45:03" itemprop="dateCreated datePublished" datetime="2021-02-23T10:55:52+08:00">2021-02-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SurfaceFlinger-启动过程"><a href="#SurfaceFlinger-启动过程" class="headerlink" title="SurfaceFlinger 启动过程"></a>SurfaceFlinger 启动过程</h2><p>SurfaceFlinger 进程是由 init 进程创建的，运行在独立的 SurfaceFlinger 进程中。init 进程读取 init.rc 文件启动 SurfaceFlinger。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service surfaceflinger &#x2F;system&#x2F;bin&#x2F;surfaceflinger</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br></pre></td></tr></table></figure>

<p>SurfaceFlinger 的创建会执行 main_surfaceflinger.cpp 里面的main方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main(int, char**) &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置 surfaceflinger 进程的 binder 线程池数最多为4，然后启动 binder 线程池</span><br><span class="line">    ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4);</span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 SurfaceFlinger 对象，将 surfaceflinger 进程设置为高优先级及使用前台调度策略</span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger &#x3D; new SurfaceFlinger();</span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(0, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发布 surface flinger，注册到 ServiceManager</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 启动DisplayService</span><br><span class="line">    startDisplayService();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 运行在当前线程</span><br><span class="line">    flinger-&gt;run();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceFlinger 的实例化会执行到：onFirstRef()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::onFirstRef() &#123;</span><br><span class="line">    mEventQueue.init(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123;</span><br><span class="line">    mFlinger &#x3D; flinger;</span><br><span class="line">    mLooper &#x3D; new Looper(true);</span><br><span class="line">    mHandler &#x3D; new Handler(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后会执行到 SurfaceFlinger::init()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化 EGL，作为默认的显示</span><br><span class="line">    mEGLDisplay &#x3D; eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化硬件 composer 对象</span><br><span class="line">    mHwc &#x3D; new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取 RenderEngine 引擎</span><br><span class="line">    mRenderEngine &#x3D; RenderEngine::create(mEGLDisplay, mHwc-&gt;getVisualID());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;检索创建的 EGL 上下文</span><br><span class="line">    mEGLContext &#x3D; mRenderEngine-&gt;getEGLContext();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化非虚拟显示屏</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        DisplayDevice::DisplayType type((DisplayDevice::DisplayType)i);</span><br><span class="line">        &#x2F;&#x2F;建立已连接的显示设备</span><br><span class="line">        if (mHwc-&gt;isConnected(i) || type&#x3D;&#x3D;DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">            bool isSecure &#x3D; true;</span><br><span class="line">            createBuiltinDisplayLocked(type);</span><br><span class="line">            wp&lt;IBinder&gt; token &#x3D; mBuiltinDisplays[i];</span><br><span class="line"></span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">            sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">            &#x2F;&#x2F;创建 BufferQueue 的生产者和消费者</span><br><span class="line">            BufferQueue::createBufferQueue(&amp;producer, &amp;consumer,</span><br><span class="line">                    new GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">            sp&lt;FramebufferSurface&gt; fbs &#x3D; new FramebufferSurface(*mHwc, i, consumer);</span><br><span class="line">            int32_t hwcId &#x3D; allocateHwcDisplayId(type);</span><br><span class="line">            &#x2F;&#x2F;创建显示设备</span><br><span class="line">            sp&lt;DisplayDevice&gt; hw &#x3D; new DisplayDevice(this,</span><br><span class="line">                    type, hwcId, mHwc-&gt;getFormat(hwcId), isSecure, token,</span><br><span class="line">                    fbs, producer,</span><br><span class="line">                    mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">            if (i &gt; DisplayDevice::DISPLAY_PRIMARY) &#123;</span><br><span class="line">                hw-&gt;setPowerMode(HWC_POWER_MODE_NORMAL);</span><br><span class="line">            &#125;</span><br><span class="line">            mDisplays.add(token, hw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当应用和 sf 的 vsync 偏移量一致时，则只创建一个 EventThread 线程</span><br><span class="line">    if (vsyncPhaseOffsetNs !&#x3D; sfVsyncPhaseOffsetNs) &#123;</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;app&quot;);</span><br><span class="line">        mEventThread &#x3D; new EventThread(vsyncSrc);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, true, &quot;sf&quot;);</span><br><span class="line">        mSFEventThread &#x3D; new EventThread(sfVsyncSrc);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;创建 DispSyncSource 对象</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc &#x3D; new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;sf-app&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建线程 EventThread</span><br><span class="line">        mEventThread &#x3D; new EventThread(vsyncSrc);</span><br><span class="line">        &#x2F;&#x2F;设置 EventThread</span><br><span class="line">        mEventQueue.setEventThread(mEventThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建 EventControl</span><br><span class="line">    mEventControlThread &#x3D; new EventControlThread(this);</span><br><span class="line">    mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当不存在 HWComposer 时，则设置软件 vsync</span><br><span class="line">    if (mHwc-&gt;initCheck() !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        mPrimaryDispSync.setPeriod(16666667);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化绘图状态</span><br><span class="line">    mDrawingState &#x3D; mCurrentState;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化显示设备</span><br><span class="line">    initializeDisplays();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;启动开机动画</span><br><span class="line">    startBootAnim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要功能是：</p>
<ol>
<li>初始化 EGL</li>
<li>创建 HWComposer</li>
<li>初始化非虚拟显示屏</li>
<li>启动 EventThread 线程</li>
<li>启动开机动画</li>
</ol>
<h3 id="创建-HWComposer："><a href="#创建-HWComposer：" class="headerlink" title="创建 HWComposer："></a>创建 HWComposer：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler):mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false) &#123;</span><br><span class="line">    ...</span><br><span class="line">    bool needVSyncThread &#x3D; true;</span><br><span class="line">    int fberr &#x3D; loadFbHalModule(); &#x2F;&#x2F;加载 framebuffer 的 HAL 层模块</span><br><span class="line">    loadHwcModule(); &#x2F;&#x2F;加载 HWComposer 模块</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标记已分配的 display ID</span><br><span class="line">    for (size_t i&#x3D;0 ; i&lt;NUM_BUILTIN_DISPLAYS ; i++) &#123;</span><br><span class="line">        mAllocatedDisplayIDs.markBit(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mHwc) &#123;</span><br><span class="line">        if (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            mCBContext-&gt;hwc &#x3D; this;</span><br><span class="line">            mCBContext-&gt;procs.invalidate &#x3D; &amp;hook_invalidate;</span><br><span class="line">            &#x2F;&#x2F;VSYNC 信号的回调方法</span><br><span class="line">            mCBContext-&gt;procs.vsync &#x3D; &amp;hook_vsync;</span><br><span class="line">            if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                mCBContext-&gt;procs.hotplug &#x3D; &amp;hook_hotplug;</span><br><span class="line">            else</span><br><span class="line">                mCBContext-&gt;procs.hotplug &#x3D; NULL;</span><br><span class="line">            memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero));</span><br><span class="line">            &#x2F;&#x2F;注册回调函数</span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;进入此处，说明已成功打开硬件 composer 设备，则不再需要 vsync 线程</span><br><span class="line">        needVSyncThread &#x3D; false;</span><br><span class="line">        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    if (needVSyncThread) &#123;</span><br><span class="line">        &#x2F;&#x2F;不支持硬件的 VSYNC，则会创建线程来模拟定时 VSYNC 信号</span><br><span class="line">        mVSyncThread &#x3D; new VSyncThread(*this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HWComposer代表着硬件显示设备，注册了VSYNC信号的回调。VSYNC信号本身是由显示驱动产生的，在不支持硬件的VSYNC，则会创建“VSyncThread”线程来模拟定时 VSYNC 信号。</p>
<p>当硬件产生VSYNC信号时，则会发送消息，handler 收到消息进行处理。当 SurfaceFlinger 进程收到 VSync 信号后经层层调用，最终调用到该对象的 handleMessageRefresh() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    preComposition();&#x2F;&#x2F;处理显示设备与 layers 的改变，更新光标</span><br><span class="line">    rebuildLayerStacks();&#x2F;&#x2F;重建所有可见 Layer 列表，根据Z轴排序</span><br><span class="line">    setUpHWComposer();&#x2F;&#x2F;更新 HWComposer 图层</span><br><span class="line">    doDebugFlashRegions(); </span><br><span class="line">    doComposition();&#x2F;&#x2F;生成 OpenGL 纹理图像</span><br><span class="line">    postComposition();&#x2F;&#x2F;将图像传递到物理屏幕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Surface-创建过程"><a href="#Surface-创建过程" class="headerlink" title="Surface 创建过程"></a>Surface 创建过程</h2><h3 id="1-WMS-addWindow"><a href="#1-WMS-addWindow" class="headerlink" title="1. WMS.addWindow"></a>1. WMS.addWindow</h3><p>Surface 创建的过程就是 Activity 显示的过程，在 ActivityThread.handleResumeActivity() 中调用了 Activity.makeVisible()，我们接着看下 Activity 是怎么显示出来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;[Activity.java]</span><br><span class="line">void makeVisible() &#123;</span><br><span class="line">    if (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm &#x3D; getWindowManager();&#x2F;&#x2F;此处 getWindowManager 获取的是 WindowManagerImpl 对象</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[WindowManagerImpl.java]</span><br><span class="line">public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[WindowManagerGlobal.java]</span><br><span class="line">public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123;</span><br><span class="line">    ...</span><br><span class="line">    final WindowManager.LayoutParams wparams &#x3D; (WindowManager.LayoutParams) params;</span><br><span class="line">    &#x2F;&#x2F;创建 ViewRootImpl</span><br><span class="line">    ViewRootImpl root &#x3D; new ViewRootImpl(view.getContext(), display);</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    &#x2F;&#x2F;设置 View</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[ViewRootImpl.java]</span><br><span class="line">public final class ViewRootImpl implements ViewParent,</span><br><span class="line">        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 创建 Surface，此时 Surface 创建完什么都没有</span><br><span class="line">    final Surface mSurface &#x3D; new Surface();</span><br><span class="line">    ...</span><br><span class="line">    public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        &#x2F;&#x2F;获取 IWindowSession 的代理类</span><br><span class="line">        mWindowSession &#x3D; WindowManagerGlobal.getWindowSession();</span><br><span class="line">        mDisplay &#x3D; display;</span><br><span class="line">        mThread &#x3D; Thread.currentThread(); &#x2F;&#x2F;主线程</span><br><span class="line">        mWindow &#x3D; new W(this);</span><br><span class="line">        mChoreographer &#x3D; Choreographer.getInstance();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            requestLayout();</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F;通过 Binder调用，进入 system 进程的 Session</span><br><span class="line">            res &#x3D; mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                  getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                  mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                  mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final class Session extends IWindowSession.Stub implements IBinder.DeathRecipient &#123;</span><br><span class="line">        public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123;</span><br><span class="line">            &#x2F;&#x2F;调用 WMS.addWindow</span><br><span class="line">            return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">                    outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[WindowManagerService.java]</span><br><span class="line">public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123;</span><br><span class="line">    ...</span><br><span class="line">    WindowToken token &#x3D; mTokenMap.get(attrs.token);</span><br><span class="line">    &#x2F;&#x2F;创建 WindowState</span><br><span class="line">    WindowState win &#x3D; new WindowState(this, session, client, token,</span><br><span class="line">                attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;调整 WindowManager 的 LayoutParams 参数</span><br><span class="line">    mPolicy.adjustWindowParamsLw(win.mAttrs);</span><br><span class="line">    res &#x3D; mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">    addWindowToListInOrderLocked(win, true);</span><br><span class="line">    &#x2F;&#x2F; 设置 input</span><br><span class="line">    mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br><span class="line">    &#x2F;&#x2F;详见下面分析</span><br><span class="line">    win.attach();</span><br><span class="line">    mWindowMap.put(client.asBinder(), win);</span><br><span class="line">    </span><br><span class="line">    if (win.canReceiveKeys()) &#123;</span><br><span class="line">        &#x2F;&#x2F;当该窗口能接收按键事件，则更新聚焦窗口</span><br><span class="line">        focusChanged &#x3D; updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                false &#x2F;*updateInputWindows*&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line">    assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[WindowState.java]</span><br><span class="line">void attach() &#123;</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[Session.java]</span><br><span class="line">void windowAddedLocked(String packageName) &#123;</span><br><span class="line">    if (mSurfaceSession &#x3D;&#x3D; null) &#123;</span><br><span class="line">        mSurfaceSession &#x3D; new SurfaceSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[SurfaceSession.java]</span><br><span class="line">private long mNativeClient; &#x2F;&#x2F; SurfaceComposerClient*</span><br><span class="line"></span><br><span class="line">public SurfaceSession() &#123;</span><br><span class="line">    mNativeClient &#x3D; nativeCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_view_SurfaceSession.cpp</span><br><span class="line">static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    SurfaceComposerClient* client &#x3D; new SurfaceComposerClient();</span><br><span class="line">    client-&gt;incStrong((void*)nativeCreate);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 SurfaceSession 构造方法中通过 nativeCreate 方法返回了一个 SurfaceComposerClient 指针，它表示一个跟 SurfaceFlinger 的连接。</p>
<p>当其第一次被使用时会调用如下函数：创建了一个实现 ISurfaceComposerClient 接口的 Client 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn &#x3D; (rootProducer !&#x3D; nullptr) ? sf-&gt;createScopedConnection(rootProducer) : sf-&gt;createConnection();</span><br><span class="line">    if (conn !&#x3D; 0) &#123;</span><br><span class="line">        mClient &#x3D; conn;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection() &#123;</span><br><span class="line">    return initClient(new Client(this)); &#x2F;&#x2F; initClient方法只是调用initCheck检查了一下</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下上面 WMS 中的相关操作：WMS 创建了一个 WindowState 对象表示客户端的一个 Window, 接着调用 WindowState.attach 方法创建了一个 SurfaceSession 对象，SurfaceSession 表示一个跟 SurfaceFlinger 的连接，它创建了一个 SurfaceComposerClient 对象，然后 SurfaceComposerClient 又创建了一个 Client 对象。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    relayoutWindow(params, viewVisibility, insetsPending)</span><br><span class="line">    &#x2F;&#x2F; measure, layout, draw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int relayoutWindow(...) throws RemoteException &#123;</span><br><span class="line">    &#x2F;&#x2F; 注意最后一个参数 mSurface 便是之前创建的 Surface 对象</span><br><span class="line">    &#x2F;&#x2F; 会调用 WMS.relayoutWindow 方法</span><br><span class="line">    mWindowSession.relayout(mWindow, ..., mSurface);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; WMS</span><br><span class="line">public int relayoutWindow(Session session, ..., Surface outSurface) &#123;</span><br><span class="line">    result &#x3D; createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int createSurfaceControl(Surface outSurface, int result, WindowState win, WindowStateAnimator winAnimator) &#123;</span><br><span class="line">    WindowSurfaceController surfaceController &#x3D; winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line">    if (surfaceController !&#x3D; null) &#123;</span><br><span class="line">        surfaceController.getSurfaceControl(outSurface);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getSurface(Surface outSurface) &#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Surface.java</span><br><span class="line">public void copyFrom(SurfaceControl other) &#123;</span><br><span class="line">    &#x2F;&#x2F; 即上面返回的 native SurfaceControl 指针</span><br><span class="line">    long surfaceControlPtr &#x3D; other.mNativeObject;</span><br><span class="line">    long newNativeObject &#x3D; nativeGetFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mNativeObject !&#x3D; 0) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setNativeObjectLocked(long ptr) &#123;</span><br><span class="line">    if (mNativeObject !&#x3D; ptr) &#123;</span><br><span class="line">        mNativeObject &#x3D; ptr;</span><br><span class="line">        if (mHwuiContext !&#x3D; null) &#123;</span><br><span class="line">            mHwuiContext.updateSurface();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_view_Surface.cpp</span><br><span class="line">static jlong nativeGetFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;</span><br><span class="line">    &#x2F;&#x2F; ctrl 是前面创建的 SurfaceControl 对象</span><br><span class="line">    sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">    sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line">    if (surface !&#x3D; NULL) &#123;</span><br><span class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() const</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    if (mSurfaceData &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return generateSurfaceLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    return mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() const</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; mGraphicBufferProducer 是上面创建的 gbp 对象</span><br><span class="line">    mSurfaceData &#x3D; new Surface(mGraphicBufferProducer, false);</span><br><span class="line">    return mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[WindowSurfaceController.java]</span><br><span class="line">class WindowSurfaceController &#123;</span><br><span class="line">    public WindowSurfaceController(...) &#123;</span><br><span class="line">        final SurfaceControl.Builder b &#x3D; win.makeSurface()</span><br><span class="line">                .setParent(win.getSurfaceControl())</span><br><span class="line">                .setName(name)</span><br><span class="line">                .setBufferSize(w, h)</span><br><span class="line">                .setFormat(format)</span><br><span class="line">                .setFlags(flags)</span><br><span class="line">                .setMetadata(METADATA_WINDOW_TYPE, windowType)</span><br><span class="line">                .setMetadata(METADATA_OWNER_UID, ownerUid);</span><br><span class="line">        mSurfaceControl &#x3D; b.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private SurfaceControl(...) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回 native SurfaceControl 指针</span><br><span class="line">    mNativeObject &#x3D; nativeCreate(session, name, w, h, format, flags, parent !&#x3D; null ? parent.mNativeObject : 0, windowType, ownerUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_view_SurfaceControl.cpp</span><br><span class="line">static jlong nativeCreate(...) &#123;</span><br><span class="line">    &#x2F;&#x2F; client 即上面创建的 SurfaceComposerClient 对象</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;</span><br><span class="line">    client-&gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);</span><br><span class="line">    return reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t SurfaceComposerClient::createSurfaceChecked(..., sp&lt;SurfaceControl&gt;* outSurface, ...) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    err &#x3D; mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, windowType, ownerUid, &amp;handle, &amp;gbp);</span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        *outSurface &#x3D; new SurfaceControl(this, handle, gbp, true &#x2F;* owned *&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t Client::createSurface(...) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    flinger-&gt;createLayer(name, client, w, h, format, flags, windowType, ownerUid, handle, gbp, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/07/JSBridge%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/07/JSBridge%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">JsBridge 源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-07 15:21:38 / 修改时间：16:48:49" itemprop="dateCreated datePublished" datetime="2021-02-07T15:21:38+08:00">2021-02-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、JsBridge-简介"><a href="#一、JsBridge-简介" class="headerlink" title="一、JsBridge 简介"></a>一、JsBridge 简介</h2><h3 id="1-1-集成"><a href="#1-1-集成" class="headerlink" title="1.1 集成"></a>1.1 集成</h3><p>JsBridge <a href="https://github.com/lzyzsd/JsBridge" target="_blank" rel="noopener">源码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123; url &quot;https:&#x2F;&#x2F;jitpack.io&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;com.github.lzyzsd:jsbridge:1.0.4&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webView.registerHandler(&quot;submitFromWeb&quot;, new BridgeHandler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handler(String data, CallBackFunction function) &#123;</span><br><span class="line">        Log.i(TAG, &quot;handler &#x3D; submitFromWeb, data from web &#x3D; &quot; + data);</span><br><span class="line">        function.onCallBack(&quot;submitFromWeb exe, response data from Java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">WebViewJavascriptBridge.callHandler(</span><br><span class="line">    &#39;submitFromWeb&#39;</span><br><span class="line">    , &#123;&#39;param&#39;: str1&#125;</span><br><span class="line">    , function(responseData) &#123;</span><br><span class="line">        document.getElementById(&quot;show&quot;).innerHTML &#x3D; &quot;send get responseData from java, data &#x3D; &quot; + responseData</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">webView.callHandler(&quot;functionInJs&quot;, new Gson().toJson(user), new CallBackFunction() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCallBack(String data) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="二、JsBridge-源码"><a href="#二、JsBridge-源码" class="headerlink" title="二、JsBridge 源码"></a>二、JsBridge 源码</h2><h3 id="2-1-BridgeWebView-源码"><a href="#2-1-BridgeWebView-源码" class="headerlink" title="2.1 BridgeWebView 源码"></a>2.1 BridgeWebView 源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class BridgeWebView extends WebView implements WebViewJavascriptBridge &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存向WebView注册的方法，以及回调</span><br><span class="line">    Map&lt;String, BridgeHandler&gt; messageHandlers &#x3D; new HashMap&lt;String, BridgeHandler&gt;();</span><br><span class="line">    Map&lt;String, CallBackFunction&gt; responseCallbacks &#x3D; new HashMap&lt;String, CallBackFunction&gt;();</span><br><span class="line">	</span><br><span class="line">    public BridgeWebView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">		super(context, attrs);</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    private void init() &#123;</span><br><span class="line">		this.setVerticalScrollBarEnabled(false);</span><br><span class="line">		this.setHorizontalScrollBarEnabled(false);</span><br><span class="line">		this.getSettings().setJavaScriptEnabled(true);</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            WebView.setWebContentsDebuggingEnabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">		this.setWebViewClient(generateBridgeWebViewClient());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    protected BridgeWebViewClient generateBridgeWebViewClient() &#123;</span><br><span class="line">        return new BridgeWebViewClient(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 注册方法</span><br><span class="line">	public void registerHandler(String handlerName, BridgeHandler handler) &#123;</span><br><span class="line">		if (handler !&#x3D; null) &#123;</span><br><span class="line">			messageHandlers.put(handlerName, handler);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 执行</span><br><span class="line">	public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123;</span><br><span class="line">        doSend(handlerName, data, callBack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void doSend(String handlerName, String data, CallBackFunction responseCallback) &#123;</span><br><span class="line">		Message m &#x3D; new Message();</span><br><span class="line">		if (!TextUtils.isEmpty(data)) &#123;</span><br><span class="line">			m.setData(data);</span><br><span class="line">		&#125;</span><br><span class="line">		if (responseCallback !&#x3D; null) &#123;</span><br><span class="line">			String callbackStr &#x3D; String.format(&quot;javascript:WebViewJavascriptBridge._handleMessageFromNative(&#39;%s&#39;);&quot;, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));</span><br><span class="line">			responseCallbacks.put(callbackStr, responseCallback);</span><br><span class="line">			m.setCallbackId(callbackStr);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!TextUtils.isEmpty(handlerName)) &#123;</span><br><span class="line">			m.setHandlerName(handlerName);</span><br><span class="line">		&#125;</span><br><span class="line">		queueMessage(m);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void queueMessage(Message m) &#123;</span><br><span class="line">		if (startupMessage !&#x3D; null) &#123;</span><br><span class="line">			startupMessage.add(m);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			dispatchMessage(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	void dispatchMessage(Message m) &#123;</span><br><span class="line">        String messageJson &#x3D; m.toJson();</span><br><span class="line">        messageJson &#x3D; messageJson.replaceAll(&quot;(\\\\)([^utrn])&quot;, &quot;\\\\\\\\$1$2&quot;);</span><br><span class="line">        messageJson &#x3D; messageJson.replaceAll(&quot;(?&lt;&#x3D;[^\\\\])(\&quot;)&quot;, &quot;\\\\\&quot;&quot;);</span><br><span class="line">        String javascriptCommand &#x3D; String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);</span><br><span class="line">        if (Thread.currentThread() &#x3D;&#x3D; Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">            this.loadUrl(javascriptCommand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理页面返回数据</span><br><span class="line">	void handlerReturnData(String url) &#123;</span><br><span class="line">		String functionName &#x3D; BridgeUtil.getFunctionFromReturnUrl(url);</span><br><span class="line">		CallBackFunction f &#x3D; responseCallbacks.get(functionName);</span><br><span class="line">		String data &#x3D; BridgeUtil.getDataFromReturnUrl(url);</span><br><span class="line">		if (f !&#x3D; null) &#123;</span><br><span class="line">			f.onCallBack(data);</span><br><span class="line">			responseCallbacks.remove(functionName);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-BridgeWebViewClient源码"><a href="#2-2-BridgeWebViewClient源码" class="headerlink" title="2.2 BridgeWebViewClient源码"></a>2.2 BridgeWebViewClient源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class BridgeWebViewClient extends WebViewClient &#123;</span><br><span class="line">    private BridgeWebView webView;</span><br><span class="line"></span><br><span class="line">    public BridgeWebViewClient(BridgeWebView webView) &#123;</span><br><span class="line">        this.webView &#x3D; webView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            url &#x3D; URLDecoder.decode(url, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果是返回数据</span><br><span class="line">            webView.handlerReturnData(url);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; </span><br><span class="line">            &#x2F;&#x2F; 刷新消息列队</span><br><span class="line">            webView.flushMessageQueue();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">        super.onPageFinished(view, url);</span><br><span class="line">        if (BridgeWebView.toLoadJs !&#x3D; null) &#123;</span><br><span class="line">            BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);</span><br><span class="line">        &#125;</span><br><span class="line">        if (webView.getStartupMessage() !&#x3D; null) &#123;</span><br><span class="line">            for (Message m : webView.getStartupMessage()) &#123;</span><br><span class="line">                webView.dispatchMessage(m);</span><br><span class="line">            &#125;</span><br><span class="line">            webView.setStartupMessage(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/04/xCrash-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/xCrash-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">xCrash 源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-04 17:12:34" itemprop="dateCreated datePublished" datetime="2021-02-04T17:12:34+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、-xCrash介绍"><a href="#一、-xCrash介绍" class="headerlink" title="一、 xCrash介绍"></a>一、 xCrash介绍</h2><p>xCrash 能为安卓 app 提供捕获 java 崩溃，native 崩溃和 ANR 的能力。不需要 root 权限或任何系统权限。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>支持 Android 4.1 - 11（API level 16 - 30）。</li>
<li>支持 armeabi-v7a，arm64-v8a，x86 和 x86_64。</li>
<li>捕获 java 崩溃，native 崩溃和 ANR。</li>
<li>获取详细的进程、线程、内存、FD、网络统计信息。</li>
<li>通过正则表达式设置需要获取哪些线程的信息。</li>
<li>不需要 root 权限或任何系统权限。</li>
</ul>
<h2 id="二、xCrash集成"><a href="#二、xCrash集成" class="headerlink" title="二、xCrash集成"></a>二、xCrash集成</h2><ol>
<li><p>在app目录下面的build.gradle添加依赖库支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;, &#39;x86&#39;, &#39;x86_64&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;    </span><br><span class="line">    implementation &#39;com.iqiyi.xcrash:xcrash-android-lib:3.0.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>xCrash初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在Application的onCreate方法里进行初始化</span><br><span class="line">xcrash.XCrash.init(this);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="三、xCrash-源码"><a href="#三、xCrash-源码" class="headerlink" title="三、xCrash 源码"></a>三、xCrash 源码</h2><h3 id="1-xcrash-XCrash-init-this"><a href="#1-xcrash-XCrash-init-this" class="headerlink" title="1. xcrash.XCrash.init(this)"></a>1. xcrash.XCrash.init(this)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class XCrash &#123;</span><br><span class="line">    </span><br><span class="line">    public static int init(Context ctx) &#123;</span><br><span class="line">        return init(ctx, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized int init(Context ctx, InitParameters params) &#123;</span><br><span class="line">        &#x2F;&#x2F; 参数初始化</span><br><span class="line">        ......</span><br><span class="line">        &#x2F;&#x2F; [重要] Java层Crash监控</span><br><span class="line">        JavaCrashHandler.getInstance().initialize(...);</span><br><span class="line">        &#x2F;&#x2F; [重要] 应用ANR监控</span><br><span class="line">        AnrHandler.getInstance().initialize(...);</span><br><span class="line">        &#x2F;&#x2F; [重要] Native层Crash监控</span><br><span class="line">        NativeHandler.getInstance().initialize(...);</span><br><span class="line">        &#x2F;&#x2F; 读写文件辅助类</span><br><span class="line">        FileManager.getInstance().maintain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-JavaCrashHandler"><a href="#2-JavaCrashHandler" class="headerlink" title="2. JavaCrashHandler"></a>2. JavaCrashHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class JavaCrashHandler implements UncaughtExceptionHandler &#123;</span><br><span class="line">    private UncaughtExceptionHandler defaultHandler &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    void initialize(...) &#123;</span><br><span class="line">        this.defaultHandler &#x3D; Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread thread, Throwable throwable) &#123;</span><br><span class="line">        if (defaultHandler !&#x3D; null) &#123;</span><br><span class="line">            Thread.setDefaultUncaughtExceptionHandler(defaultHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        handleException(thread, throwable);</span><br><span class="line">        if (this.rethrow) &#123;</span><br><span class="line">            if (defaultHandler !&#x3D; null) &#123;</span><br><span class="line">                defaultHandler.uncaughtException(thread, throwable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ActivityMonitor.getInstance().finishAllActivities();</span><br><span class="line">            Process.killProcess(this.pid);</span><br><span class="line">            System.exit(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void handleException(Thread thread, Throwable throwable) &#123;</span><br><span class="line">        StringWriter sw &#x3D; new StringWriter();</span><br><span class="line">        PrintWriter pw &#x3D; new PrintWriter(sw);</span><br><span class="line">        throwable.printStackTrace(pw);</span><br><span class="line">        String stacktrace &#x3D; sw.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-AnrHandler"><a href="#3-AnrHandler" class="headerlink" title="3. AnrHandler"></a>3. AnrHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class AnrHandler &#123;</span><br><span class="line">    private FileObserver fileObserver &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    void initialize(...) &#123;</span><br><span class="line">        &#x2F;&#x2F; [重要] &lt; Android 5.0 以下可以访问&#x2F;data&#x2F;anr目录</span><br><span class="line">        fileObserver &#x3D; new FileObserver(&quot;&#x2F;data&#x2F;anr&#x2F;&quot;, FileObserver.CLOSE_WRITE) &#123;</span><br><span class="line">            public void onEvent(int event, String path) &#123;</span><br><span class="line">                if (path !&#x3D; null) &#123;</span><br><span class="line">                    String filepath &#x3D; &quot;&#x2F;data&#x2F;anr&#x2F;&quot; + path;</span><br><span class="line">                    if (filepath.contains(&quot;trace&quot;)) &#123;</span><br><span class="line">                        handleAnr(filepath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        fileObserver.startWatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [重要] Android 5.0以上实际上是捕获了SIGQUIT信号，这个是Android App发生ANR时由ActivityMangerService向App发送的信号。</span><br><span class="line">int xcc_signal_trace_register(void (*handler)(int, siginfo_t *, void *))</span><br><span class="line">&#123;</span><br><span class="line">    int              r;</span><br><span class="line">    sigset_t         set;</span><br><span class="line">    struct sigaction act;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;un-block the SIGQUIT mask for current thread, hope this is the main thread</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGQUIT);</span><br><span class="line">    if(0 !&#x3D; (r &#x3D; pthread_sigmask(SIG_UNBLOCK, &amp;set, &amp;xcc_signal_trace_oldset))) return r;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;register new signal handler for SIGQUIT</span><br><span class="line">    memset(&amp;act, 0, sizeof(act));</span><br><span class="line">    sigfillset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_sigaction &#x3D; handler;</span><br><span class="line">    act.sa_flags &#x3D; SA_RESTART | SA_SIGINFO;</span><br><span class="line">    if(0 !&#x3D; sigaction(SIGQUIT, &amp;act, &amp;xcc_signal_trace_oldact))</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_sigmask(SIG_SETMASK, &amp;xcc_signal_trace_oldset, NULL);</span><br><span class="line">        return XCC_ERRNO_SYS;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-NativeHandler"><a href="#4-NativeHandler" class="headerlink" title="4. NativeHandler"></a>4. NativeHandler</h3><p>Native层崩溃捕获建议提前参考：<a href="https://www.cnblogs.com/mingfeng002/p/9118253.html" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class NativeHandler &#123;</span><br><span class="line">    int initialize(...) &#123;</span><br><span class="line">        System.loadLibrary(&quot;xcrash&quot;);</span><br><span class="line">        int r &#x3D; nativeInit(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 映射 xc_jni_init函数</span><br><span class="line">    private static native int nativeInit(...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 映射 xc_jni_notify_java_crashed函数</span><br><span class="line">    private static native void nativeNotifyJavaCrashed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static jint xc_jni_init(JNIEnv *env, jobject thiz,) &#123;</span><br><span class="line">    xc_crash_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int xc_crash_init(JNIEnv *env,...) &#123;</span><br><span class="line">    xcc_signal_crash_register(xc_crash_signal_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void xc_crash_signal_handler(int sig, siginfo_t *si, void *uc) &#123;</span><br><span class="line">    pid_t dumper_pid &#x3D; xc_crash_fork(xc_crash_exec_dumper);</span><br><span class="line">    if(-1 &#x3D;&#x3D; dumper_pid) &#123;</span><br><span class="line">        xcc_util_write_format_safe(xc_crash_log_fd, XC_CRASH_ERR_TITLE&quot;fork failed, errno&#x3D;%d\n\n&quot;, errno);</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;parent process ...</span><br><span class="line">    int wait_r &#x3D; XCC_UTIL_TEMP_FAILURE_RETRY(waitpid(dumper_pid, &amp;status, __WALL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static xcc_signal_crash_info_t xcc_signal_crash_info[] &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">    &#123;.signum &#x3D; SIGABRT&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGBUS&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGFPE&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGILL&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGSEGV&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGTRAP&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGSYS&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGSTKFLT&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int xcc_signal_crash_register(void (*handler)(int, siginfo_t *, void *))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 设置额外栈空间，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文</span><br><span class="line">    stack_t ss;</span><br><span class="line">    if(NULL &#x3D;&#x3D; (ss.ss_sp &#x3D; calloc(1, XCC_SIGNAL_CRASH_STACK_SIZE))) return XCC_ERRNO_NOMEM;</span><br><span class="line">    ss.ss_size  &#x3D; XCC_SIGNAL_CRASH_STACK_SIZE;</span><br><span class="line">    ss.ss_flags &#x3D; 0;</span><br><span class="line">    if(0 !&#x3D; sigaltstack(&amp;ss, NULL)) return XCC_ERRNO_SYS;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置信号处理函数</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    memset(&amp;act, 0, sizeof(act));</span><br><span class="line">    sigfillset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_sigaction &#x3D; handler;</span><br><span class="line">    act.sa_flags &#x3D; SA_RESTART | SA_SIGINFO | SA_ONSTACK;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 注册信号量</span><br><span class="line">    size_t i;</span><br><span class="line">    for(i &#x3D; 0; i &lt; sizeof(xcc_signal_crash_info) &#x2F; sizeof(xcc_signal_crash_info[0]); i++)</span><br><span class="line">        if(0 !&#x3D; sigaction(xcc_signal_crash_info[i].signum, &amp;act, &amp;(xcc_signal_crash_info[i].oldact)))</span><br><span class="line">            return XCC_ERRNO_SYS;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/04/BlockCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/BlockCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">BlockCanary 源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 14:34:48 / 修改时间：16:55:53" itemprop="dateCreated datePublished" datetime="2021-02-04T14:34:48+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、-BlockCanary介绍"><a href="#一、-BlockCanary介绍" class="headerlink" title="一、 BlockCanary介绍"></a>一、 BlockCanary介绍</h2><p>BlockCanary是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。</p>
<h2 id="二、BlockCanary集成"><a href="#二、BlockCanary集成" class="headerlink" title="二、BlockCanary集成"></a>二、BlockCanary集成</h2><ol>
<li><p>在app目录下面的build.gradle添加依赖库支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;    </span><br><span class="line">    debugImplementation &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;</span><br><span class="line">    releaseImplementation &#39;com.github.markzhai:blockcanary-no-op:1.5.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BlockCanary初始化以及自定义监控下上文配置(可选)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在Application的onCreate方法里进行初始化</span><br><span class="line">BlockCanary.install(this, new AppBlockCanaryContext()).start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义监控下上文</span><br><span class="line">public class AppBlockCanaryContext extends BlockCanaryContext &#123;</span><br><span class="line">    public int provideMonitorDuration() &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean displayNotification() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String providePath() &#123;</span><br><span class="line">        return &quot;&#x2F;blockcanary&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; provideWhiteList() &#123;</span><br><span class="line">        LinkedList&lt;String&gt; whiteList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        whiteList.add(&quot;org.chromium&quot;);</span><br><span class="line">        return whiteList;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="三、BlockCanary-源码"><a href="#三、BlockCanary-源码" class="headerlink" title="三、BlockCanary 源码"></a>三、BlockCanary 源码</h2><h3 id="1-BlockCanary-install-this-new-AppBlockCanaryContext-start"><a href="#1-BlockCanary-install-this-new-AppBlockCanaryContext-start" class="headerlink" title="1. BlockCanary#install(this, new AppBlockCanaryContext()).start();"></a>1. BlockCanary#install(this, new AppBlockCanaryContext()).start();</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final class BlockCanary &#123;</span><br><span class="line">    public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化BlockCanaryContext里面的sApplicationContext、sInstance</span><br><span class="line">        BlockCanaryContext.init(context, blockCanaryContext);</span><br><span class="line">        &#x2F;&#x2F; 设置DisplayActivity是否可用，根据自定义displayNotification()判断</span><br><span class="line">        setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification());</span><br><span class="line">        &#x2F;&#x2F; 初始化BlockCanary对象</span><br><span class="line">        return get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 源码里面没有volatile关键字???</span><br><span class="line">    private static volatile BlockCanary sInstance;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 双重校验锁</span><br><span class="line">    public static BlockCanary get() &#123;</span><br><span class="line">        if (sInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (BlockCanary.class) &#123;</span><br><span class="line">                if (sInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    sInstance &#x3D; new BlockCanary();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private BlockCanary() &#123;</span><br><span class="line">        BlockCanaryInternals.setContext(BlockCanaryContext.get());</span><br><span class="line">        mBlockCanaryCore &#x3D; BlockCanaryInternals.getInstance();</span><br><span class="line">        &#x2F;&#x2F; 1. 添加用户自定义Block拦截器</span><br><span class="line">        mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get());</span><br><span class="line">        if (!BlockCanaryContext.get().displayNotification()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2. 添加DisplayService拦截器,当发生卡顿的时候，用于显示给用户</span><br><span class="line">        mBlockCanaryCore.addBlockInterceptor(new DisplayService());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean mMonitorStarted &#x3D; false;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        if (!mMonitorStarted) &#123;</span><br><span class="line">            mMonitorStarted &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; [**重要**]设置Looper自定义Printer</span><br><span class="line">            Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-BlockCanaryInternals"><a href="#2-BlockCanaryInternals" class="headerlink" title="2. BlockCanaryInternals"></a>2. BlockCanaryInternals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public final class BlockCanaryInternals &#123;</span><br><span class="line">    LooperMonitor monitor;</span><br><span class="line">    &#x2F;&#x2F; 卡顿拦截器集合</span><br><span class="line">    private List&lt;BlockInterceptor&gt; mInterceptorChain &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public BlockCanaryInternals() &#123;</span><br><span class="line">        &#x2F;&#x2F; 收集Looper主线程的堆栈信息，具体方法mCurrentThread.getStackTrace()</span><br><span class="line">        stackSampler &#x3D; new StackSampler(</span><br><span class="line">                Looper.getMainLooper().getThread(),</span><br><span class="line">                sContext.provideDumpInterval());</span><br><span class="line">        &#x2F;&#x2F; 收集&#x2F;proc&#x2F;&#123;pid&#125;&#x2F;stat</span><br><span class="line">        cpuSampler &#x3D; new CpuSampler(sContext.provideDumpInterval());</span><br><span class="line"></span><br><span class="line">        setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onBlockEvent(long realTimeStart, long realTimeEnd,</span><br><span class="line">                                     long threadTimeStart, long threadTimeEnd) &#123;</span><br><span class="line">                &#x2F;&#x2F; 搜集卡顿线程堆栈信息</span><br><span class="line">                ArrayList&lt;String&gt; threadStackEntries &#x3D; stackSampler</span><br><span class="line">                        .getThreadStackEntries(realTimeStart, realTimeEnd);</span><br><span class="line">                if (!threadStackEntries.isEmpty()) &#123;</span><br><span class="line">                    BlockInfo blockInfo &#x3D; BlockInfo.newInstance()</span><br><span class="line">                            .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd)</span><br><span class="line">                            .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd))</span><br><span class="line">                            .setRecentCpuRate(cpuSampler.getCpuRateInfo())</span><br><span class="line">                            .setThreadStackEntries(threadStackEntries)</span><br><span class="line">                            .flushString();</span><br><span class="line">                    LogWriter.save(blockInfo.toString());</span><br><span class="line">                    &#x2F;&#x2F; 循环遍历拦截器链</span><br><span class="line">                    if (mInterceptorChain.size() !&#x3D; 0) &#123;</span><br><span class="line">                        for (BlockInterceptor interceptor : mInterceptorChain) &#123;</span><br><span class="line">                            interceptor.onBlock(getContext().provideContext(), blockInfo);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging()));</span><br><span class="line">        LogWriter.cleanObsolete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-LooperMonitor-检测卡顿"><a href="#3-LooperMonitor-检测卡顿" class="headerlink" title="3. LooperMonitor 检测卡顿"></a>3. LooperMonitor 检测卡顿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class LooperMonitor implements Printer &#123;</span><br><span class="line">    private static final int DEFAULT_BLOCK_THRESHOLD_MILLIS &#x3D; 3000;</span><br><span class="line">    &#x2F;&#x2F; 默认卡顿检测时间间隔3s</span><br><span class="line">    private long mBlockThresholdMillis &#x3D; DEFAULT_BLOCK_THRESHOLD_MILLIS;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void println(String x) &#123;</span><br><span class="line">        if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!mPrintingStarted) &#123;</span><br><span class="line">            mStartTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">            mStartThreadTimestamp &#x3D; SystemClock.currentThreadTimeMillis();</span><br><span class="line">            mPrintingStarted &#x3D; true;</span><br><span class="line">            startDump(); &#x2F;&#x2F; 收集主线程的堆栈信息</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            mPrintingStarted &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F; 判断主线程处理消息是否超时</span><br><span class="line">            if (isBlock(endTime)) &#123;</span><br><span class="line">                notifyBlockEvent(endTime);</span><br><span class="line">            &#125;</span><br><span class="line">            stopDump();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断主线程Looper处理一个消息时间间隔是否超过3s</span><br><span class="line">    private boolean isBlock(long endTime) &#123;</span><br><span class="line">        return endTime - mStartTimestamp &gt; mBlockThresholdMillis;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-卡顿原理解密"><a href="#4-卡顿原理解密" class="headerlink" title="4. 卡顿原理解密"></a>4. 卡顿原理解密</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final class Looper &#123;</span><br><span class="line">    private Printer mLogging;</span><br><span class="line"></span><br><span class="line">    public void setMessageLogging(@Nullable Printer printer) &#123;</span><br><span class="line">        mLogging &#x3D; printer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void loop() &#123;</span><br><span class="line">        final MessageQueue queue &#x3D; me.mQueue;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block</span><br><span class="line"></span><br><span class="line">            final Printer logging &#x3D; me.mLogging;</span><br><span class="line">            if (logging !&#x3D; null) &#123;</span><br><span class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 在dispatchMessage的前后都有打印日志信息</span><br><span class="line">            &#x2F;&#x2F; 判断日志打印间隔就可以知道是否存在卡顿</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            if (logging !&#x3D; null) &#123;</span><br><span class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/23/Smail%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/Smail%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Smail简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 14:56:12 / 修改时间：15:10:09" itemprop="dateCreated datePublished" datetime="2020-11-23T14:56:12+08:00">2020-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Smail简介"><a href="#Smail简介" class="headerlink" title="Smail简介"></a>Smail简介</h2><h3 id="Smali简介"><a href="#Smali简介" class="headerlink" title="Smali简介"></a>Smali简介</h3><p>Dalvik虚拟机和Jvm一样，也有自己的一套指令集，类似汇编语言, smali文件就是Dalvik的寄存器语言.</p>
<h3 id="Smali文件结构解"><a href="#Smali文件结构解" class="headerlink" title="Smali文件结构解"></a>Smali文件结构解</h3><p>smali文件是由Dalvik指令组成的，它有自己的一套规则，它的指令都是以“.”开头，常用的指令如下：</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.class</td>
<td align="left">包名+类名</td>
</tr>
<tr>
<td align="left">.super</td>
<td align="left">父类类名</td>
</tr>
<tr>
<td align="left">.source</td>
<td align="left">源文件名称</td>
</tr>
<tr>
<td align="left">.implements</td>
<td align="left">接口实现</td>
</tr>
<tr>
<td align="left">.field</td>
<td align="left">定义字段</td>
</tr>
<tr>
<td align="left">.method/.end method</td>
<td align="left">方法的开始与结束</td>
</tr>
<tr>
<td align="left">.locals</td>
<td align="left">方法内使用的v开口的寄存器个数</td>
</tr>
<tr>
<td align="left">.prologue</td>
<td align="left">表示方法中代码的开始处</td>
</tr>
<tr>
<td align="left">.line</td>
<td align="left">对应java中的行数</td>
</tr>
<tr>
<td align="left">.param</td>
<td align="left">指定了方法的参数</td>
</tr>
<tr>
<td align="left">.paramter</td>
<td align="left">和.paramter含义相同</td>
</tr>
<tr>
<td align="left">.param</td>
<td align="left">指定了方法的参数</td>
</tr>
<tr>
<td align="left">.annotation/.end annotation</td>
<td align="left">注解的开始和结束</td>
</tr>
</tbody></table>
<p>现在来看下smali文件的结构：</p>
<h4 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件"></a>1.头文件</h4><p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &lt;访问权限修饰符&gt; [非权限修饰符] &lt;类名&gt;</span><br><span class="line">.super &lt;父类名&gt;</span><br><span class="line">.source &lt;源文件名称&gt;</span><br></pre></td></tr></table></figure>

<p>访问权限修饰符即所谓的public,protected,private，而非权限修饰符则指的是final,abstract,static，两者都可以为空。<br>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class public final Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;PreferencesFactory;</span><br><span class="line">.super Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">.source &quot;PreferencesFactory.java&quot;</span><br></pre></td></tr></table></figure>

<p>如果原java代码有经过混淆，那一般.class里面的类名和.source的源文件名会不一样，以下是经过混淆的(类名正常是xxx/PreferencesFactory，混淆以后变成xxx/d)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class public final Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;d;</span><br><span class="line">.super Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">.source &quot;PreferencesFactor</span><br></pre></td></tr></table></figure>

<h4 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2.接口实现"></a>2.接口实现</h4><p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#interfaces</span><br><span class="line">.implements &lt;接口名称&gt;</span><br></pre></td></tr></table></figure>

<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># interfaces</span><br><span class="line">.implements Landroid&#x2F;view&#x2F;View$OnClickListener;</span><br></pre></td></tr></table></figure>

<p>其中# interfaces为注释</p>
<h4 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h4><p>如果一个类中使用了注解，就会出现.annotation，格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#annotations</span><br><span class="line">.annotation [注解的属性] &lt;注解类名&gt;</span><br><span class="line">    [注解字段&#x3D;值]</span><br><span class="line">    ...</span><br><span class="line">.end annotation</span><br></pre></td></tr></table></figure>

<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># annotations</span><br><span class="line">.annotation build Landroid&#x2F;annotation&#x2F;TargetApi;</span><br><span class="line">    value &#x3D; 0xb</span><br><span class="line">.end annotation</span><br></pre></td></tr></table></figure>
<p>其中# annotations为注释</p>
<h4 id="4-变量定义"><a href="#4-变量定义" class="headerlink" title="4.变量定义"></a>4.变量定义</h4><p>使用.field描述字段的定义，分为静态变量和普通变量两种：</p>
<p>静态变量<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#static fields</span><br><span class="line">.field &lt;访问权限&gt; static [修饰词] &lt;字段名&gt;:&lt;变量类型&gt;</span><br></pre></td></tr></table></figure>
<p>使用# static fields注释，并加了static修饰符，</p>
<p>举例说明：<br>smali:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># static fields</span><br><span class="line">.field public static mStr:Ljava&#x2F;lang&#x2F;String;</span><br></pre></td></tr></table></figure>
<p>java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String mStr;</span><br></pre></td></tr></table></figure>
<p>普通变量<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#instance fields</span><br><span class="line">.field &lt;访问权限修饰符&gt; [非权限修饰符] &lt;变量名&gt;:&lt;变量类型&gt;</span><br></pre></td></tr></table></figure>
<p>使用# instance fields注释，</p>
<p>举例说明：<br>smali:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.field private bool:Z</span><br></pre></td></tr></table></figure>
<p>java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private boolean bool;</span><br></pre></td></tr></table></figure>

<h4 id="5-方法描述"><a href="#5-方法描述" class="headerlink" title="5.方法描述"></a>5.方法描述</h4><p>smali中的方法以.method/.end method进行描述，有分两种方法，一种是直接方法，一种是虚方法，<br>什么事直接方法和虚方法呢？直接方法就是不能被覆写的方法，包括用static，private修饰的方法，虚方法表示可以被覆写的方法，包括public，protected修饰的方法。<br>两者在smali中的注释分别是直接方法(#direct methods)，虚方法(#virtual methods),一般直接方法在smali文件的前半部分，虚方法在后半部分。<br>方法的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#direct methods&#x2F;#virtual methods</span><br><span class="line">.method &lt;访问权限修饰符&gt; [非访问权限修饰符] &lt;方法原型&gt;</span><br><span class="line">      &lt;.locals&gt;</span><br><span class="line">      [.parameter]</span><br><span class="line">      [.prologue]</span><br><span class="line">      [.line]</span><br><span class="line">      &lt;代码逻辑&gt;</span><br><span class="line">.end</span><br></pre></td></tr></table></figure>
<p>其中.parameter,.prologue,.line是可选的。<br>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods</span><br><span class="line">.method public final onClick(Landroid&#x2F;view&#x2F;View;)V</span><br><span class="line">    .locals 1</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 71</span><br><span class="line">    iget-object v0, p0, Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;a;-&gt;a:Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;FTPServerPreferences;</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0&#125;, Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;FTPServerPreferences;-&gt;a(Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;FTPServerPreferences;)V</span><br><span class="line"></span><br><span class="line">    .line 72</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>注意几个特殊的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.method xxx constructor &lt;clinit&gt;()V  &#x2F;&#x2F;类中final变量的初始化</span><br><span class="line">.method xxx constructor &lt;init&gt;()V   &#x2F;&#x2F;类中的构造行数</span><br><span class="line">.method static synthetic methodName(xxxx)V &#x2F;&#x2F;加synthetic修饰符的方法，synthetic是合成的意思，即这个方法在原java代码里面是没有的，是在java编译成Dalvik字节码的时候合成的，后续会详细分析这类方法</span><br></pre></td></tr></table></figure>
<p>方法中具体的语法在文章的后半部分详细说明。</p>
<h4 id="smali数据类型"><a href="#smali数据类型" class="headerlink" title="smali数据类型"></a>smali数据类型</h4><p>Dalvik字节码和Java一样，都只有两种数据类型：基本类型和引用类型，8中基本数据类型，对象和数组是引用类型，Dalvik字节码和Jvm中对数据类型的描述是一致的，对于基本类型和无返回类型用一个大写字母表示，对象类型用一个大写字母L加对象的全限定名表示，如Ljava/lang/String表示字符串对象类型，一维数组用一个”[“加数据类型或对象类型表示.</p>
<p>java数据类型和Dalvik字节码的数据类型一一对应，对应关系如下表：</p>
<table>
<thead>
<tr>
<th>java类型</th>
<th>smali描述符</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>L</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>void</td>
<td>V</td>
</tr>
<tr>
<td>对象类型</td>
<td>L</td>
</tr>
<tr>
<td>数组类型</td>
<td>[</td>
</tr>
<tr>
<td>基本数据类型</td>
<td>Z,B,S,C,I,L,F,D为基本数据类型，从上表可以看出，Dalvik字节码基本类型的描述符基本上是java基本类型的首字母，除了boolean对应为Z外</td>
</tr>
</tbody></table>
<ul>
<li><p>对象类型<br>L加上类或者接口的全称表示对象类型，即Lpackage/objectName，如String类型描述符为Ljava/lang/String，包com.biyou下面的test类的类型描述符为Lcom/biyou/test</p>
</li>
<li><p>数组类型<br>基本类型的数组为”[“加上基本类型描述符来表示，一维数组前面是一个”[“,多一个维度前面多加一个”[“,比如int类型，一维是:[I,二维是:[[I,依次类推。<br>对象类型的数组为”[“加上对象类型表示符来表示，如String类型表示为:[Ljava/lang/String。</p>
</li>
</ul>
<h3 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h3><p>smali的语法跟汇编语言有点类似，但没有汇编那么复杂，可以很轻松的看懂，推荐使用source insight来看。</p>
<p>变量的描述<br>格式为：</p>
<p>对象类型描述符-&gt;变量名:类型描述符;<br>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lcom&#x2F;biyou&#x2F;test;-&gt;count:I  &#x2F;&#x2F;基本类型</span><br><span class="line">Lcom&#x2F;biyou&#x2F;test;-&gt;str:Ljava&#x2F;lang&#x2F;String  &#x2F;&#x2F;对象类型</span><br></pre></td></tr></table></figure>
<p>Dalvik对变量的描述都会指明变量定义的和变量的类型，如例子中的count变量的描述，说明它定义在com.biyou.test类，是int类型的变量</p>
<p>方法的描述<br>格式为:</p>
<p>对象类型描述符-&gt;方法名(参数类型描述符)返回值类型描述符;</p>
<p>下面我们通过几个例子来说明,以java.lang.String为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java方法:public char charAt(int index)&#123;...&#125;</span><br><span class="line">Davilk描述:Ljava&#x2F;lang&#x2F;String;-&gt;charAt(I)C</span><br><span class="line"></span><br><span class="line">java方法:public void getChars(int srcBegin,int srcEnd,char dst[],int dstBegin)&#123;...&#125;</span><br><span class="line">Davilk描述:Ljava&#x2F;lang&#x2F;String;-&gt;getChars(II[CI)V</span><br><span class="line"></span><br><span class="line">java方法:public boolean equals(Object anObject)&#123;...&#125;</span><br><span class="line">Davilk描述:Ljava&#x2F;lang&#x2F;String;-&gt;equals(Ljava&#x2F;lang&#x2F;Object)Z</span><br></pre></td></tr></table></figure>

<h3 id="Dalvik指令集"><a href="#Dalvik指令集" class="headerlink" title="Dalvik指令集"></a>Dalvik指令集</h3><p>掌握以上的字段和方法的描述,只能说我们懂了如何描述一个字段和方法,而关于方法中具体的逻辑则需要了解Dalvik中的指令集.因为Dalvik是基于寄存器的架构的,因此指令集和JVM中的指令集区别较大,反而更类似x86的中的汇编指令。</p>
<p>1.空操作指令<br>空操作指令的助记符为nop，它的值为00，通常nop指令被用来作对齐代码之用，无实际操作。</p>
<p>2.数据定义指令<br>数据定义指令用于定义代码中使用的常量,字符串，类等数据,基础字节码是const</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>const/4 vA,#+B</td>
<td>将数值符号扩展为32后赋值给寄存器vA</td>
</tr>
<tr>
<td>const/16 vAA, #+BBBB</td>
<td>将数据符号扩展为32位后赋给寄存器vAA</td>
</tr>
<tr>
<td>const vAA, #+BBBBBBBB</td>
<td>将数值赋给寄存器vAA</td>
</tr>
<tr>
<td>const/high16 vAA, #+BBBB0000</td>
<td>将数值右边零扩展为32位后赋给寄存器vAA</td>
</tr>
<tr>
<td>const-wide/16 vAA,#+BBBB</td>
<td>将数值符号扩展为64位后赋值个寄存器对vAA</td>
</tr>
<tr>
<td>const-wide/32 vAA,#+BBBB</td>
<td>将数值符号扩展为64位后赋值个寄存器对vAA</td>
</tr>
<tr>
<td>const-wide vAA, #+BBBBBBBBBBBBBBBB</td>
<td>将数值赋给寄存器对vAA</td>
</tr>
<tr>
<td>const-wide/high16 vAA, #+BBBB000000000000</td>
<td>将数值右边零扩展为64位后赋给寄存器对vAA</td>
</tr>
<tr>
<td>const-string vAA,string@BBBB</td>
<td>通过字符串索引高走字符串赋值给寄存器vAA</td>
</tr>
<tr>
<td>const-string/jumbo vAA, string@BBBBBBBB</td>
<td>通过字符串索引（较大）构造一个字符串并赋给寄存器vAA</td>
</tr>
<tr>
<td>const-class vAA,type@BBBB</td>
<td>通过类型索引获取一个类的引用赋值给寄存器vAA</td>
</tr>
<tr>
<td>const-class/jumbo vAAAA, type@BBBBBBBB</td>
<td>通过给定的类型索引获取一个类引用并赋给寄存器vAAAA。这条指令占用两个字节，值为0xooff(Android4.0中新增的指令)</td>
</tr>
</tbody></table>
<p>3.锁指令<br>锁指令多用在多线程程序中对同一对象的操作。Dalvik指令集中有两条锁指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitor-enter vAA：为指定的对象获取锁。</span><br><span class="line">monitor-exit vAA：释放指定的对象的锁。</span><br></pre></td></tr></table></figure>

<p>如java的com.biyou.test类需要需要加锁：<br>java为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized (test.class)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>smali为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const-class v0, Lcom&#x2F;biyou&#x2F;test;</span><br><span class="line">monitor-enter v0</span><br><span class="line">...</span><br><span class="line">monitor-exit v0</span><br></pre></td></tr></table></figure>

<p>4.变量操作指令<br>字段操作指令表示对对象字段进行设值和取值操作,就像是你在代码中长些的set和get方法.基本指令是iput-type,iget-type,sput-type,sget-type.type表示数据类型.</p>
<p>普通字段读写操作<br>前缀是i的iput-type和iget-type指令用于字段的读写操作.</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>iget-object vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id对象的引用值给vBB寄存器</td>
</tr>
<tr>
<td>iget-boolean vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>iget-wide vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>iget vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>iput-object vAA,vBB,filed_id</td>
<td>把vAA寄存器指向的对象的引用赋值给vBB寄存器中的filed_id对象</td>
</tr>
<tr>
<td>iput-boolean vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的boolean类型</td>
</tr>
<tr>
<td>iput-wide vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的wide类型</td>
</tr>
<tr>
<td>iput vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的int类型</td>
</tr>
</tbody></table>
<p>静态字段读写操作<br>前缀是s的sput-type和sget-type指令用于静态字段的读写操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sget-object vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id对象的引用值给vBB寄存器</td>
</tr>
<tr>
<td>sget-boolean vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>sget-wide vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>sget vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>sput-object vAA,vBB,filed_id</td>
<td>把vAA寄存器指向的对象的引用赋值给vBB寄存器中的filed_id对象</td>
</tr>
<tr>
<td>sput-boolean vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的boolean类型</td>
</tr>
<tr>
<td>sput-wide vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的wide类型</td>
</tr>
<tr>
<td>sput vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的int类型</td>
</tr>
</tbody></table>
<p>5.跳转指令<br>跳转指令用于从当前地址跳转到指定的偏移处。Dalvik指令集中有三种跳转指令：无条件跳转（goto），分支跳转（switch）与条件跳转（if）。</p>
<p>goto +AA：无条件跳转到指定偏移处，偏移量AA不能为0。</p>
<p>goto/16 +AAAA：无条件跳转到指定偏移处，偏量AAAA不能为0。</p>
<p>goto/32 +AAAAAAAA：无条件跳转到指定偏移处。</p>
<p>packed-switch vAA, +BBBBBBBB：分支跳转指令。vAA寄存器为switch分支中需要判断的值，BBBBBBBB指向一个packed-switch-payload格式的偏移表，表中的值是有规律递增的。</p>
<p>sparse-switch vAA, +BBBBBBBB：分支跳转指令。vAA寄存器为switch分支中需要判断的值，BBBBBBBB指向一个sparse-switch-payload格式的偏移表，表中的值是无规律的偏移量。</p>
<p>if-test vA, vB, +CCCC：条件跳转指令。比较vA寄存器与vB寄存器的值，如果比较结果满足就跳转到CCCC指定的偏移处。偏移量CCCC不能为0。if-test类型的指令有以下几条：</p>
<p>if-eq：如果vA等于vB则跳转。Java语法表示为“if(vA == vB)”</p>
<p>if-ne：如果vA不等于vB则跳转。Java语法表示为“if(vA != vB)”</p>
<p>if-lt：如果vA小于vB则跳转。Java语法表示为“if(vA &lt; vB)”</p>
<p>if-ge：如果vA大于等于vB则跳转。Java语法表示为“if(vA &gt;= vB)”</p>
<p>if-gt：如果vA大于vB则跳转。Java语法表示为“if(vA &gt; vB)”</p>
<p>if-le：如果vA小于等于vB则跳转。Java语法表示为“if(vA &lt;= vB)”</p>
<p>if-testz vAA, +BBBB：条件跳转指令。拿vAA寄存器与0比较，如果比较结果满足或值为0时就跳转到BBBB指定的偏移处。偏移量BBBB不能为0。if-testz类型的指令有以下几条：</p>
<p>if-eqz：如果vAA为0则跳转。Java语法表示为“if(vAA == 0)”</p>
<p>if-nez：如果vAA不为0则跳转。Java语法表示为“if(vAA != 0)”</p>
<p>if-ltz：如果vAA小于0则跳转。Java语法表示为“if(vAA &lt; 0)”</p>
<p>if-gez：如果vAA大于等于0则跳转。Java语法表示为“if(vAA &gt;= 0)”</p>
<p>if-gtz：如果vAA大于0则跳转。Java语法表示为“if(vAA &gt; 0)”</p>
<p>if-lez：如果vAA小于等于0则跳转。Java语法表示为“if(vAA &lt;= 0)”</p>
<p>6.比较指令<br>比较指令用于对两个寄存器的值（浮点型或长整型）进行比较。它的格式为“cmpkind vAA, vBB, vCC”，其中vBB寄存器与vCC寄存器是需要比较的两个寄存器或寄存器对，比较的结果放到vAA寄存器。Dalvik指令集中共有5条比较指令：</p>
<p>cmpl-float vAA,vBB,vCC：比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1</p>
<p>cmpg-float vAA,vBB,vCC：比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，则结果为1，相等则结果为0，小于的话结果为-1</p>
<p>cmpl-double vAA,vBB,vCC：比较两个双精度浮点数。如果vBB寄存器对大于vCC寄存器对，则结果为-1，相等则结果为0，小于则结果为1</p>
<p>cmpg-double vAA,vBB,vCC：比较两个双精度浮点数。如果vBB寄存器对大于vCC寄存器对，则结果为1，相等则结果为0，小于的话，则结果为-1</p>
<p>cmp-long vAA,vBB,vCC：比较两个长整型数。如果vBB寄存器大于vCC寄存器，则结果为1，相等则结果为0，小则结果为-1</p>
<p>7.数据转换指令<br>数据转换指令用于将一种类型的数值转换成另一种类型。它的格式为“unop vA, vB”，vB寄存器或vB寄存器对存放需要转换的数据，转换后的结果保存在vA寄存器或vA寄存器对中。</p>
<p>•“neg-int”：对整型数求补。</p>
<p>•“not-int”：对整型数求反。</p>
<p>•“neg-long”：对长整型数求补。</p>
<p>•“not-long”：对长整型数求反。</p>
<p>•“neg-float”：对单精度浮点型数求补。</p>
<p>•“neg-double”：对双精度浮点型数求补。</p>
<p>•“int-to-long”：将整型数转换为长整型。</p>
<p>•“int-to-float”：将整型数转换为单精度浮点型数。</p>
<p>•“int-to-dobule”：将整型数转换为双精度浮点数。</p>
<p>•“long-to-int”：将长整型数转换为整型。</p>
<p>•“long-to-float”：将长整型数转换为单精度浮点型。</p>
<p>•“long-to-double”：将长整型数转换为双精度浮点型。</p>
<p>•“float-to-int”：将单精度浮点数转换为整型。</p>
<p>•“float-to-long”：将单精度浮点数转换为长整型数。</p>
<p>•“float-to-double”：将单精度浮点数转换为双精度浮点型数。</p>
<p>•“double-to-int”：将双精度浮点数转换为整型。</p>
<p>•“double-to-long”：将双精度浮点数转换为长整型。</p>
<p>•“double-to-float”：将双精度浮点数转换为单精度浮点型。</p>
<p>•“int-to-byte”：将整型转换为字节型。</p>
<p>•“int-to-char”：将整型转换为字符型。</p>
<p>•“int-to-short”：将整型转换为短整型。</p>
<p>8.数据运行指令<br>数据运算指令包括算术运算指令与逻辑运算指令。算术运算指令主要进行数值间如加，减，乘，除，模，移位等运算。逻辑运算指令主要进行数值间与，或，非，抑或等运算。数据运算指令有如下四类（数据运算时可能是在寄存器或寄存器对间进行，下面的指令作用讲解时使用寄存器来描述）：</p>
<p>•“binop vAA, vBB, vCC”：将vBB寄存器与vCC寄存器进行运算，结果保存到vAA寄存器。</p>
<p>•“binop/2addr vA, vB”：将vA寄存器与vB寄存器进行运算，结果保存到vA寄存器。</p>
<p>•“binop/lit16 vA, vB, #+CCCC”：将vB寄存器与常量 CCCC进行运算，结果保存到vA寄存器。</p>
<p>•“binop/lit8 vAA, vBB, #+CC”：将vBB寄存器与常量CC进行运算，结果保存到vAA寄存器。</p>
<p>后面3类指令比第1类指令分别多出了2addr，lit16，lit8等指令后缀。四类指令中基础字节码相同的指令执行的运算操作是类似的，第1类指令中，根据数据的类型不同会在基础字节码后面加上数据类型后缀，如 -int 或 -long 分别表示操作的数据类型为整型与长整型。第1类指令可归类如下：</p>
<p>•“add-type”：vBB寄存器与vCC寄存器值进行加法运算（vBB + vCC）</p>
<p>•”sub-type”：vBB寄存器与vCC寄存器值进行减法运算（vBB - vCC）</p>
<p>•”mul-type”：vBB寄存器与vCC寄存器值进行乘法运算（vBB * vCC）</p>
<p>•”div-type”：vBB寄存器与vCC寄存器值进行除法运算（vBB / vCC）</p>
<p>•”rem-type”：vBB寄存器与vCC寄存器值进行模运算（vBB % vCC）</p>
<p>•”and-type”：vBB寄存器与vCC寄存器值进行与运算（vBB &amp; vCC）</p>
<p>•”or-type”：vBB寄存器与vCC寄存器值进行或运算（vBB | vCC）</p>
<p>•”xor-type”：vBB寄存器与vCC寄存器值进行异或运算（vBB ^ vCC）</p>
<p>•”shl-type”：vBB寄存器值（有符号数）左移vCC位（vBB &lt;&lt; vCC ）</p>
<p>•”shr-type”：vBB寄存器值（有符号）右移vCC位（vBB &gt;&gt; vCC）</p>
<p>•”ushr-type”：vBB寄存器值（无符号数）右移vCC位（vBB &gt;&gt;&gt; vCC）</p>
<p>其中基础字节码后面的-type可以是-int，-long， -float，-double。后面3类指令与之类似。</p>
<p>9.方法调用指令<br>方法调用指令负责调用类实例的方法。它的基础指令为 invoke，方法调用指令有“invoke-kind {vC, vD, vE, vF, vG},meth@BBBB”与“invoke-kind/range {vCCCC .. vNNNN},meth@BBBB”两类，两类指令在作用上并无不同，只是后者在设置参数寄存器时使用了range来指定寄存器的范围。根据方法类型的不同，共有如下五条方法调用指令：<br>•invoke-virtual或 invoke-virtual/range调用实例的虚方法。<br>•invoke-super或”invoke-super/range调用实例的父类方法。<br>•invoke-direct或“invoke-direct/range调用实例的直接方法。<br>•invoke-static或invoke-static/range调用实例的静态方法。<br>•invoke-interface或invoke-interface/range调用实例的接口方法。</p>
<p>在Android4.0系统中，Dalvik指令集中增加了“invoke-kind/jumbo {vCCCC .. vNNNN},meth@BBBBBBBB”这类指令，它与上面介绍的两类指令作用相同，只是在指令中增加了jumbo字节码后缀，且寄存器值与指令的索引取值范围更大。</p>
<p>方法调用指令的返回值必须使用move-result*指令来获取。如下面两条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Landroid&#x2F;os&#x2F;Parcel;-&gt;obtain() Landroid&#x2F;os&#x2F;Parcel;</span><br><span class="line">move-result-object v0</span><br></pre></td></tr></table></figure>

<p>10.异常处理指令<br>  Dalvik指令集中有一条指令用来抛出异常。</p>
<p>•throw vAA：抛出vAA寄存器中指定类型的异常。</p>
<p>11.实例操作指令<br>与实例相关的操作包括实例的类型转换，检查及新建等：</p>
<p>•check-cast vAA, type@BBBB：将vAA寄存器中的对象引用转换成指定的类型，如果失败会抛出ClassCastException异常。如果类型B指定的是基本类型，对于非基本类型的A来说，运行时始终会失败。</p>
<p>•instance-of vA, vB, type@CCCC：判断vB寄存器中的对象引用是否可以转换成指定的类型，如果可以vA寄存器赋值为1，否则vA寄存器赋值为0。</p>
<p>•new-instance vAA, type@BBBB：构造一个指定类型对象的新实例，并将对象引用赋值给vAA寄存器，类型符type指定的类型不能是数组类。</p>
<p>•check-cast/jumbo vAAAA, type@BBBBBBBB：指令功能与“check-cast vAA, type@BBBB”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•instance-of/jumbo vAAAA, vBBBB, type@CCCCCCCC：指令功能与“instance-of vA, vB, type@CCCC”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•new-instance/jumbo vAAAA, type@BBBBBBBB：指令功能与“new-instance vAA, type@BBBB”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>12.返回指令<br>  返回指令指的是函数结尾时运行的最后一条指令。它的基础字节码为teturn，共有以下四条返回指令：</p>
<p>•return-void：表示函数从一个void方法返回。<br>•return vAA：表示函数返回一个32位非对象类型的值，返回值寄存器为8位的寄存器vAA。<br>•return-wide vAA：表示函数返回一个64位非对象类型的值，返回值为8位的寄存器对vAA。<br>•return-object vAA：表示函数返回一个对象类型的值。返回值为8位的寄存器vAA。</p>
<p>13.数据操作指令<br>数据操作指令为move。move指令的原型为“move destination,source”，move指令根据字节码的大小与类型不同，后面会跟上不同的后缀。</p>
<p>•move vA, vB：将vB寄存器的值赋给vA寄存器，A源寄存器与目的寄存器都为4位。<br>•move/from16 vAA, vBBBB：将vBBBB寄存器的值赋给vAA寄存器，源寄存器为16位，目的寄存器为8位。<br>•move/16 vAAAA, vBBBB：将vBBBB寄存器的值赋给vAAAA寄存器，源寄存器与目的寄存器都为16位。<br>•move-wide vA, vB：为4位的寄存器对赋值。源寄存器与目的寄存器都为4位。<br>•move-wide/from16 vAA, vBBBB 与“move-wide/16 vAAAA, vBBBB”实现与“move-wide”相同。<br>•move-object vA, vB：为对象赋值。源寄存器与目的寄存器都为4位。<br>•move-object/from16 vAA, vBBBB：为对象赋值。源寄存器为16位，目的寄存器为8位。<br>•move-object/16 vAA, vBBBB：为对象赋值。源寄存器与目的寄存器都为16位。<br>•move-result vAA：将上一个invoke类型指令操作的单字非对象结果赋给vAA寄存器。<br>•move-result-wide vAA：将上一个invoke类型指令操作的双字非对象结果赋给vAA寄存器。<br>•move-result-object vAA：将上一个invoke类型指令操作的对象结果赋给vAA寄存器。<br>•move-exception vAA：保存一个运行时发生的异常到vAA寄存器，这条指令必须是异常发生时的异常处理器的一条指令。否则的话，指令无效。</p>
<p>14.对象操作指令<br>与对象实例相关的操作,比如对象创建,对象检查等.</p>
<p>15.数组操作指令<br>数组操作包括获取数组长度，新建数组，数组赋值，数组元素取值与赋值等操作。</p>
<p>•array-length vA, vB：获取给定vB寄存器中数组的长度并将值赋给vA寄存器，数组长度指的是数组的条目个数。</p>
<p>•new-array vA, vB, type@CCCC：构造指定类型（type@CCCC）与大小（vB）的数组，并将值赋给vA寄存器。</p>
<p>•filled-new-array {vC, vD, vE, vF, vG},type@BBBB：构造指定类型（type@BBBB）与大小（vA）的数组并填充数组内容。vA寄存器是隐含使用的，除了指定数组的大小外还指定了参数的个数，vC~vG是使用到的参数寄存序列。</p>
<p>•filled-new-array/range {vCCCC ..vNNNN}, type@BBBB：指令功能与“filled-new-array {vC, vD, vE, vF, vG},type@BBBB”相同，只是参数寄存器使用range字节码后缀指定了取值范围 ，vC是第一个参数寄存器，N = A +C -1。</p>
<p>•fill-array-data vAA, +BBBBBBBB：用指定的数据来填充数组，vAA寄存器为数组引用，引用必须为基础类型的数组，在指令后面会紧跟一个数据表。</p>
<p>•new-array/jumbo vAAAA, vBBBB,type@CCCCCCCC：指令功能与“new-</p>
<p>array vA,vB,type@CCCC”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•filled-new-array/jumbo {vCCCC ..vNNNN},type@BBBBBBBB：指令功能与“filled-new-array/range {vCCCC ..vNNNN},type@BBBB”相同，只是索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•arrayop vAA, vBB, vCC：对vBB寄存器指定的数组元素进入取值与赋值。vCC寄存器指定数组元素索引，vAA寄存器用来存放读取的或需要设置的数组元素的值。读取元素使用aget类指令，元素赋值使用aput类指定，根据数组中存储的类型指令后面会紧跟不同的指令后缀，指令列表有 aget, aget-wide, aget-object, aget-boolean, aget-byte,aget-char, aget-short, aput, aput-wide, aput-object, aput-boolean, aput-byte, aput-char, aput-short。</p>
<h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://blog.csdn.net/lixpjita39/article/details/75193833" target="_blank" rel="noopener">Android逆向世界之一:smali文件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/20/Utils%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/Utils%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Utils框架解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-20 10:04:17" itemprop="dateCreated datePublished" datetime="2020-10-20T10:04:17+08:00">2020-10-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Utils框架解析"><a href="#Utils框架解析" class="headerlink" title="Utils框架解析"></a>Utils框架解析</h2><h3 id="View-注入"><a href="#View-注入" class="headerlink" title="View 注入"></a>View 注入</h3><ol>
<li>Class&lt;?&gt; thisCls = activity.getClass() 获取Class对象</li>
<li>thisCls.getAnnotation(ContentView.class) 获取注解对象</li>
<li>activity.setContentView(viewId)</li>
<li>Field[] fields = thisCls.getDeclaredFields(); 遍历activity的所有fields字段获取ViewInject注解对象</li>
<li></li>
</ol>
<h2 id="仿小红书ViewPage滑动指示器"><a href="#仿小红书ViewPage滑动指示器" class="headerlink" title="仿小红书ViewPage滑动指示器"></a>仿小红书ViewPage滑动指示器</h2><ol>
<li><p>布局文件<br> &lt;RelativeLayout</p>
<pre><code>android:layout_width=&quot;66dp&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_gravity=&quot;bottom|right&quot;
android:layout_marginEnd=&quot;20dp&quot;
android:layout_marginBottom=&quot;10dp&quot;&gt;

&lt;com.vid007.videobuddy.xlui.widget.SlidingIndicator
    android:id=&quot;@+id/sliding_indicator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre> </RelativeLayout>
</li>
<li><p>自定义指示器SlidingIndicator<br>public class SlidingIndicator extends HorizontalScrollView {<br> private int mNumber = 1;<br> private int mLastCursorPosition = 0;<br> private Context mContext;<br> private LinearLayout mLinearLayout;<br> private FrameLayout mFrameLayout;<br> private int ivWidth = 40;<br> private int ivHeight = 20;<br> private int mDotNormalBackgroundResource = R.drawable.commonui_white_oval;<br> private int mDotSelectedBackgroundResource = R.drawable.web_find_video_guide_title_icon;</p>
<p> public SlidingIndicator(Context context) {</p>
<pre><code>this(context, null);</code></pre><p> }</p>
<p> public SlidingIndicator(Context context, AttributeSet attrs) {</p>
<pre><code>this(context, attrs, 0);</code></pre><p> }</p>
<p> public SlidingIndicator(Context context, AttributeSet attrs, int defStyleAttr) {</p>
<pre><code>super(context, attrs, defStyleAttr);
mContext = context;</code></pre><p> }</p>
<p> public void setNumber(int number) {</p>
<pre><code>if (number &gt; 0) {
    mNumber = number;
}</code></pre><p> }</p>
<p> public void setIvWidth(int width) {</p>
<pre><code>if (width &gt; 0 &amp;&amp; width &lt;= 100) {
    this.ivWidth = width;
}</code></pre><p> }</p>
<p> public void setIvHeight(int height) {</p>
<pre><code>if (height &gt; 0 &amp;&amp; height &lt;= 100) {
    this.ivHeight = height;
}</code></pre><p> }</p>
<p> public void slidingIndicatorShow() {</p>
<pre><code>init(mContext, ivWidth, ivHeight);</code></pre><p> }</p>
<p> public void setDotBg(@DrawableRes int drawableId) {</p>
<pre><code>mDotNormalBackgroundResource = drawableId;</code></pre><p> }</p>
<p> public void setIvSlidingBg(@DrawableRes int drawableId) {</p>
<pre><code>mDotSelectedBackgroundResource = drawableId;</code></pre><p> }</p>
<p> private void init(Context context, int width, int height) {</p>
<pre><code>mFrameLayout = new FrameLayout(context);
mFrameLayout.setLayoutParams(new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
mLinearLayout = new LinearLayout(context);
mLinearLayout.setOrientation(LinearLayout.HORIZONTAL);
mLinearLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));

for (int i = 0; i &lt; mNumber; i++) {
    ImageView imageView = new ImageView(context);
    imageView.setBackgroundResource(mDotNormalBackgroundResource);
    MarginLayoutParams vm = null;
    if (i == 4 &amp;&amp; mNumber &gt;= 5) {
        vm = new MarginLayoutParams(15, 15);
        vm.setMargins(height / 2, 3, height / 2, 0);
    } else {
        vm = new MarginLayoutParams(width / 2, height);
        vm.setMargins(height / 2, 0, height / 2, 0);
    }
    imageView.setLayoutParams(vm);
    mLinearLayout.addView(imageView);
}
mFrameLayout.addView(mLinearLayout);
addView(mFrameLayout);</code></pre><p> }</p>
<p> public void setDotSelected(int position) {</p>
<pre><code>for (int i = 0; i &lt; mNumber; i++) {
    ImageView imageView = (ImageView) mLinearLayout.getChildAt(i);
    if (position == i) {
        imageView.setBackgroundResource(mDotSelectedBackgroundResource);
    } else {
        imageView.setBackgroundResource(mDotNormalBackgroundResource);
    }
    imageView.setAlpha(0.8f);
}
setItemScrollAnimation(position);</code></pre><p> }</p>
<p> public void setItemScrollAnimation(int position) {</p>
<pre><code>if (mNumber &lt;= 5) return;
if (position &lt; 3) return;
if (position == mNumber - 1) return;
if (position == (mLastCursorPosition + 1)) {
    smoothScrollBy(40, 0);
    tryChangeItemToSmall(position);
} else if (position == (mLastCursorPosition - 1)) {
    smoothScrollBy(-40, 0);
    tryChangeItemToSmall(position);
}
mLastCursorPosition = position;</code></pre><p> }</p>
<p> public void tryChangeItemToSmall(int position) {</p>
<pre><code>for (int i = 0; i &lt; mNumber; i++) {
    ImageView imageView = (ImageView) mLinearLayout.getChildAt(i);
    LinearLayout.LayoutParams vm = new LinearLayout.LayoutParams(ivWidth / 2, ivHeight);
    vm.setMargins(ivHeight / 2, 0, ivHeight / 2, 0);
    imageView.setLayoutParams(vm);
}

if (position == 3) {
    return;
}
ImageView imageView2 = (ImageView) mLinearLayout.getChildAt(position - 3);
LinearLayout.LayoutParams vm2 = new LinearLayout.LayoutParams(15, 15);
vm2.setMargins(ivHeight / 2, 3, ivHeight / 2, 0);
imageView2.setLayoutParams(vm2);

if (position == mNumber - 2) {
    return;
}
ImageView imageView3 = (ImageView) mLinearLayout.getChildAt(position + 1);
LinearLayout.LayoutParams vm3 = new LinearLayout.LayoutParams(15, 15);
vm3.setMargins(ivHeight / 2, 3, ivHeight / 2, 0);
imageView3.setLayoutParams(vm3);</code></pre><p> }<br>}</p>
</li>
<li><p>对接</p>
<pre><code>mSlidingIndicator = findViewById(R.id.sliding_indicator);
mSlidingIndicator.setOnTouchListener(new View.OnTouchListener(){
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return true;
    }
});</code></pre></li>
</ol>
<p>mSlidingIndicator.setDotSelected(position);<br>        mSlidingIndicator.setNumber(bannerSize);<br>        mSlidingIndicator.slidingIndicatorShow();<br>        mSlidingIndicator.setDotSelected(0);    </p>
<ol start="4">
<li>完整备份<br>package com.vid007.videobuddy.xlui.widget;</li>
</ol>
<p>import android.content.Context;<br>import android.os.Handler;<br>import android.os.Looper;<br>import android.os.Message;<br>import android.util.AttributeSet;<br>import android.util.SparseArray;<br>import android.view.LayoutInflater;<br>import android.view.MotionEvent;<br>import android.view.View;<br>import android.view.ViewGroup;<br>import android.widget.FrameLayout;<br>import android.widget.HorizontalScrollView;<br>import android.widget.ImageView;<br>import android.widget.LinearLayout;</p>
<p>import androidx.annotation.CallSuper;<br>import androidx.annotation.NonNull;<br>import androidx.viewpager.widget.PagerAdapter;<br>import androidx.viewpager.widget.ViewPager;</p>
<p>import com.vid007.videobuddy.R;<br>import com.xl.basic.coreutils.android.DimensionUtil;<br>import com.xl.basic.coreutils.android.HandlerTimer;<br>import com.xl.basic.coreutils.log.XLLog;<br>import com.xl.basic.xlui.widget.AspectRatioViewPager;</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>/**</p>
<ul>
<li><p>轮播图控件</p>
</li>
<li><p></li>
<li><p>Created by lixianpeng on 2019/1/23.</p>
</li>
<li><p>Copyright (c) 2019 Xunlei. All rights reserved.</p>
</li>
<li></li>
<li><p>@author lixianpeng</p>
</li>
<li><p>@since 2019/1/23</p>
</li>
<li><p>/<br>public class SliderView extends FrameLayout {<br>  public static final String TAG = SliderView.class.getSimpleName();</p>
<p>  private static final int WHAT_CHANGE_BAR_MESSAGE = 1201;<br>  protected SlidingIndicator mSlidingIndicator;<br>  protected LinearLayout mDotLinearLayout;<br>  protected AspectRatioViewPager mViewPager;<br>  protected SliderAdapter&lt;?&gt; mAdapter;</p>
<p>  protected int mDotSize;<br>  protected int mDotSpace; //dot间距<br>  protected int mBannerVisible;<br>  protected int mCurrentPosition;<br>  protected OnItemShowListener mOnItemShowListener;<br>  protected OnItemClickListener mOnItemClickListener;</p>
<p>  private int mDotNormalBackgroundResource;<br>  private int mDotSelectedBackgroundResource;<br>  private int mPeriod = 1000 * 20;<br>  private boolean mIsVisibleToUser = true;<br>  private boolean mIsUserScrolling = false;</p>
<p>  private Handler.Callback mMsgCallback = new Handler.Callback() {</p>
<pre><code>@Override
public boolean handleMessage(Message msg) {
    switch (msg.what) {
        case WHAT_CHANGE_BAR_MESSAGE: {
            XLLog.d(TAG, &quot;handleMessage&quot;);
            if (!mIsUserScrolling) {
                XLLog.d(TAG, &quot;handleMessage scrollToNextPosition&quot;);
                scrollToNextPosition();
            }
        }
        break;
    }
    return false;
}</code></pre><p>  };<br>  private Handler mHandler = new Handler(Looper.getMainLooper(), mMsgCallback);<br>  private HandlerTimer mHandlerTimer = new HandlerTimer(mHandler) {</p>
<pre><code>@Override
public void onTimer() {
    if (mBannerVisible == View.VISIBLE &amp;&amp; mIsVisibleToUser) {
        XLLog.d(TAG, &quot;mTimer schedule visible&quot;);
        mHandler.sendMessage(mHandler.obtainMessage(WHAT_CHANGE_BAR_MESSAGE));
    }
    XLLog.d(TAG, &quot;mTimer schedule&quot;);
}</code></pre><p>  };</p>
<p>  public SliderView(Context context, AttributeSet attrs, int defStyleAttr) {</p>
<pre><code>super(context, attrs, defStyleAttr);
init(context);</code></pre><p>  }</p>
<p>  public SliderView(Context context, AttributeSet attrs) {</p>
<pre><code>super(context, attrs);
init(context);</code></pre><p>  }</p>
<p>  public SliderView(Context context) {</p>
<pre><code>super(context);
init(context);</code></pre><p>  }</p>
<p>  protected int getRealPosition(int position) {</p>
<pre><code>if (mDotLinearLayout != null) {
    int count = mDotLinearLayout.getChildCount();
    if (count &gt; 0) {
        return position % count;
    }
}
return 0;</code></pre><p>  }</p>
<p>  // if: Banner &gt; 5<br>  protected int getDotViewRealPosition(int position) {</p>
<pre><code>if (mDotLinearLayout != null) {
    int count = mRealBannerDotViewSize;
    if (count &gt; 0) {
        return position % count;
    }
}
return 0;</code></pre><p>  }</p>
<p>  public void setOnItemShowListener(OnItemShowListener listener) {</p>
<pre><code>mOnItemShowListener = listener;</code></pre><p>  }</p>
<p>  public void setOnItemClickListener(OnItemClickListener listener) {</p>
<pre><code>mOnItemClickListener = listener;</code></pre><p>  }</p>
<p>  @CallSuper<br>  protected void init(Context context) {</p>
<pre><code>LayoutInflater.from(context).inflate(R.layout.layout_silder_view, this);

mDotSize = DimensionUtil.dip2px(6);
mDotSpace = DimensionUtil.dip2px(3);
mDotNormalBackgroundResource = R.drawable.commonui_white_oval;
mDotSelectedBackgroundResource = R.drawable.web_find_video_guide_title_icon;

mViewPager = findViewById(R.id.banner_viewpager);
mSlidingIndicator = findViewById(R.id.sliding_indicator);
mSlidingIndicator.setOnTouchListener(new View.OnTouchListener(){
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return true;
    }
});
//mDotLinearLayout = findViewById(R.id.banner_dot_lin);
mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

    }

    @Override
    public void onPageSelected(int position) {
        mSlidingIndicator.setDotSelected(position);
        //setDotSelected(position);
        reportSliderItemViewShow();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        if (state == ViewPager.SCROLL_STATE_IDLE) {
            mIsUserScrolling = false;
        } else {
            mIsUserScrolling = true;
        }
    }
});
mViewPager.setOffscreenPageLimit(2);
mViewPager.setPageMargin(DimensionUtil.dip2px(8));</code></pre><p>  }</p>
<p>  public void shouldStartTimer() {</p>
<pre><code>if (mAdapter != null) {
    if (mAdapter.getRealSize() &gt; 1) {
        startTimer();
    } else {
        cancelTimer();
    }
}</code></pre><p>  }</p>
<p>  public void setAdapter(SliderAdapter&lt;?&gt; adapter) {</p>
<pre><code>mAdapter = adapter;
mViewPager.setAdapter(mAdapter);</code></pre><p>  }</p>
<p>  @CallSuper<br>  public void destroy() {</p>
<pre><code>if (mAdapter != null) {
    mAdapter.setData(null);
}
mHandler.removeCallbacks(null);</code></pre><p>  }</p>
<p>  protected void reportSliderItemViewShow() {</p>
<pre><code>if (mOnItemShowListener != null &amp;&amp; mAdapter != null &amp;&amp; mBannerVisible == View.VISIBLE) {
    mOnItemShowListener.onSliderItemShow(mCurrentPosition % mAdapter.getData().size());
}</code></pre><p>  }</p>
<p>  protected void setDotSelected(int position) {</p>
<pre><code>mCurrentPosition = position;
int count = mDotLinearLayout.getChildCount();
if (count &gt; 0) {
    int realPosition = getDotViewRealPosition(position);
    // 如果超过5个最后一个也是点点点
    if (realPosition &gt;= 4) realPosition = 4;
    for (int i = 0; i &lt; count; i++) {
        ImageView imageView = (ImageView) mDotLinearLayout.getChildAt(i);
        if (realPosition == i) {
            imageView.setBackgroundResource(mDotSelectedBackgroundResource);
        } else {
            imageView.setBackgroundResource(mDotNormalBackgroundResource);
        }
        imageView.setAlpha(0.8f);
    }
}</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li><p>滑动到下一个位置</p>
</li>
<li><p>/<br>protected void scrollToNextPosition() {<br>  if (mViewPager != null &amp;&amp; mAdapter != null) {</p>
<pre><code>int position = mViewPager.getCurrentItem();
position++;
if (position + 1 &gt;= mAdapter.getCount()) {
    position = mAdapter.getMiddlePosition(getRealPosition(position));
    XLLog.e(TAG, &quot;handleMessage out reposition&quot;);
}
XLLog.d(TAG, &quot;scrollToNextPosition &quot;);
mViewPager.setCurrentItem(position);</code></pre><p>  }<br>}</p>
<p>protected void cancelTimer() {<br>  if (mHandlerTimer != null) {</p>
<pre><code>mHandlerTimer.stop();
XLLog.d(TAG, &quot;cancelTimer &quot;);</code></pre><p>  }<br>}</p>
<p>@Override<br>protected void onAttachedToWindow() {<br>  super.onAttachedToWindow();<br>  XLLog.d(TAG, “onAttachedToWindow”);<br>  if (mAdapter != null &amp;&amp; mAdapter.getRealSize() &gt; 1) {</p>
<pre><code>startTimer();
XLLog.d(TAG, &quot;onAttachedToWindow startTimer&quot;);</code></pre><p>  }<br>}</p>
<p>@Override<br>protected void onVisibilityChanged(@NonNull View changedView, int visibility) {<br>  super.onVisibilityChanged(changedView, visibility);<br>  mBannerVisible = visibility;<br>  XLLog.d(TAG, “onVisibilityChanged “ + visibility);<br>  setTimerAccordingToVisible();<br>}</p>
<p>@Override<br>protected void onDetachedFromWindow() {<br>  super.onDetachedFromWindow();<br>  cancelTimer();<br>  mHandler.removeCallbacksAndMessages(null);<br>  XLLog.d(TAG, “onDetachedFromWindow”);<br>}</p>
<p>protected void startTimer() {<br>  mHandlerTimer.start(mPeriod, true);<br>  XLLog.d(TAG, “startTimer “);<br>}</p>
<p>private int mRealBannerDotViewSize = 0;</p>
<p>protected void addBannerDotView(int bannerSize) {<br>  mSlidingIndicator.setNumber(bannerSize);<br>  mSlidingIndicator.slidingIndicatorShow();<br>  mSlidingIndicator.setDotSelected(0);<br>//        mRealBannerDotViewSize = bannerSize;<br>//        if (bannerSize &lt;= 5) {<br>//            for (int i = 0; i &lt; bannerSize; i++) {<br>//                addDotView();<br>//            }<br>//        } else {<br>//            for (int i = 0; i &lt; bannerSize - 1; i++) {<br>//                addDotView();<br>//            }<br>//            addSmallDotView();<br>//        }<br>}</p>
<p>protected void addDotView() {<br>  LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(mDotSize, mDotSize);<br>  params.leftMargin = mDotSpace;<br>  params.rightMargin = mDotSpace;<br>  ImageView imageView = new ImageView(getContext());<br>  imageView.setScaleType(ImageView.ScaleType.FIT_XY);<br>  mDotLinearLayout.addView(imageView, params);<br>}</p>
<p>protected void addSmallDotView() {<br>  int dotSize = DimensionUtil.dip2px(4);<br>  int dotSpace = DimensionUtil.dip2px(3);<br>  int topMargin = DimensionUtil.dip2px(1);<br>  LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(dotSize, dotSize);<br>  params.leftMargin = dotSpace;<br>  params.rightMargin = dotSpace;<br>  params.topMargin = topMargin;<br>  ImageView imageView = new ImageView(getContext());<br>  imageView.setScaleType(ImageView.ScaleType.FIT_XY);<br>  mDotLinearLayout.addView(imageView, params);<br>}</p>
<p>private void setTimerAccordingToVisible() {<br>  if (mBannerVisible == View.VISIBLE &amp;&amp; mIsVisibleToUser) {</p>
<pre><code>shouldStartTimer();</code></pre><p>  } else {</p>
<pre><code>cancelTimer();</code></pre><p>  }<br>}</p>
<p>public void setUserVisibleHint(boolean isVisibleToUser) {<br>  mIsVisibleToUser = isVisibleToUser;<br>  setTimerAccordingToVisible();<br>}</p>
<p>public interface OnItemShowListener {<br>  void onSliderItemShow(int position);<br>}</p>
<p>public interface OnItemClickListener {<br>  void onItemClick(int position);<br>}</p>
<p>public abstract class SliderAdapter<DATA> extends PagerAdapter {<br>  private final int COUNT = 10 * 10000;<br>  private ArrayList<DATA> mData = new ArrayList&lt;&gt;();<br>  private SparseArray<View> mRecoverItemArray = new SparseArray&lt;&gt;();<br>  private static final int MAX_RECOVER_SIZE = 7;</p>
<p>  public ArrayList<DATA> getData() {</p>
<pre><code>return mData;</code></pre><p>  }</p>
<p>  public int getRealSize() {</p>
<pre><code>if (mData != null) {
    return mData.size();
}
return 0;</code></pre><p>  }</p>
<p>  public void clearData() {</p>
<pre><code>mData.clear();
mRecoverItemArray.clear();
notifyDataSetChanged();</code></pre><p>  }</p>
<p>  public void setData(List<DATA> data) {</p>
<pre><code>mData.clear();
if (data != null) {
    mData.addAll(data);
}
notifyDataSetChanged();</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li><p>中间位置的第relativePosition项</p>
</li>
<li></li>
<li><p>@return 中间位置的第relativePosition项</p>
</li>
<li><p>/<br>public int getMiddlePosition(int relativePosition) {<br>  if (mData.size() &gt; 0) {</p>
<pre><code>return COUNT / 2 - COUNT / 2 % mData.size() + relativePosition;</code></pre><p>  }<br>  return 0;<br>}</p>
<p>@Override<br>public int getCount() {<br>  if (mData.size() == 1) {</p>
<pre><code>return 1;</code></pre><p>  }<br>  return mData.size() &gt; 0 ? COUNT : 0;<br>}</p>
<p>@Override<br>public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {<br>  return view == object;<br>}</p>
<p>@NonNull<br>@Override<br>public final Object instantiateItem(@NonNull ViewGroup container, int position) {<br>  View itemView = mRecoverItemArray.get(position % MAX_RECOVER_SIZE);<br>  if (itemView == null) {</p>
<pre><code>itemView = onCreateSliderItemView(container, position);</code></pre><p>  } else {</p>
<pre><code>mRecoverItemArray.remove(position % MAX_RECOVER_SIZE);</code></pre><p>  }<br>  container.addView(itemView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);<br>  onSliderItemViewInstantiated(itemView, position);<br>  XLLog.d(TAG, “SliderAdapter instantiateItem position=” + position + “,itemView=” + itemView);<br>  return itemView;<br>}</p>
<p>@Override<br>public final void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {<br>  View itemView = (View) object;<br>  container.removeView(itemView);<br>  if (itemView instanceof ImageView) {</p>
<pre><code>((ImageView) itemView).setImageDrawable(null);</code></pre><p>  }<br>  XLLog.d(TAG, “SliderAdapter destroyItem position=” + position + “,itemView=” + itemView);<br>  mRecoverItemArray.put(position % MAX_RECOVER_SIZE, itemView);<br>  onSliderItemViewDestroyed(itemView);<br>}</p>
<p>@Override<br>public int getItemPosition(@NonNull Object object) {<br>  return POSITION_NONE;<br>}</p>
<p>@NonNull<br>abstract public View onCreateSliderItemView(@NonNull ViewGroup container, int position);</p>
<p>abstract public void onSliderItemViewInstantiated(@NonNull View itemView, int position);</p>
<p>public void onSliderItemViewDestroyed(@NonNull View itemView) {<br>}<br>}<br>}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/21/%E8%87%AA%E5%AE%9A%E4%B9%89Native%20Crash%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/%E8%87%AA%E5%AE%9A%E4%B9%89Native%20Crash%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/" class="post-title-link" itemprop="url">自定义Native Crash异常捕获</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-21 10:43:49 / 修改时间：10:43:34" itemprop="dateCreated datePublished" datetime="2020-08-21T10:43:49+08:00">2020-08-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Native-Crash-异常捕获"><a href="#Native-Crash-异常捕获" class="headerlink" title="Native Crash 异常捕获"></a>Native Crash 异常捕获</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>在Android平台，native crash一直是crash里的大头。native crash具有上下文不全、出错信息模糊、难以捕捉等特点，比java crash更难修复。所以一个合格的异常捕获组件也要能达到以下目的：</p>
<h3 id="二、信号机制"><a href="#二、信号机制" class="headerlink" title="二、信号机制"></a>二、信号机制</h3><p>1.程序奔溃<br>在Unix-like系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。<br>异常发生时，CPU通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。<br>linux把这些中断处理，统一为信号量，可以注册信号量向量进行处理。<br>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。</p>
<p>2.信号机制<br>函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换。</p>
<p>(1) 信号的接收<br>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<p>(2) 信号的检测<br>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<p>进程从内核态返回到用户态前进行信号检测<br>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测<br>当发现有新信号时，便会进入下一步，信号的处理。</p>
<p>(3) 信号的处理<br>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<p>(4) 常见信号量类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#define SIGHUP 1  &#x2F;&#x2F; 终端连接结束时发出(不管正常或非正常)</span><br><span class="line">#define SIGINT 2  &#x2F;&#x2F; 程序终止(例如Ctrl-C)</span><br><span class="line">#define SIGQUIT 3 &#x2F;&#x2F; 程序退出(Ctrl-\)</span><br><span class="line">#define SIGILL 4 &#x2F;&#x2F; 执行了非法指令，或者试图执行数据段，堆栈溢出</span><br><span class="line">#define SIGTRAP 5 &#x2F;&#x2F; 断点时产生，由debugger使用</span><br><span class="line">#define SIGABRT 6 &#x2F;&#x2F; 调用abort函数生成的信号，表示程序异常</span><br><span class="line">#define SIGIOT 6 &#x2F;&#x2F; 同上，更全，IO异常也会发出</span><br><span class="line">#define SIGBUS 7 &#x2F;&#x2F; 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数</span><br><span class="line">#define SIGFPE 8 &#x2F;&#x2F; 计算错误，比如除0、溢出</span><br><span class="line">#define SIGKILL 9 &#x2F;&#x2F; 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略</span><br><span class="line">#define SIGUSR1 10 &#x2F;&#x2F; 未使用，保留</span><br><span class="line">#define SIGSEGV 11 &#x2F;&#x2F; 非法内存操作，与SIGBUS不同，他是对合法地址的非法访问，比如访问没有读权限的内存，向没有写权限的地址写数据</span><br><span class="line">#define SIGUSR2 12 &#x2F;&#x2F; 未使用，保留</span><br><span class="line">#define SIGPIPE 13 &#x2F;&#x2F; 管道破裂，通常在进程间通信产生</span><br><span class="line">#define SIGALRM 14 &#x2F;&#x2F; 定时信号,</span><br><span class="line">#define SIGTERM 15 &#x2F;&#x2F; 结束程序，类似温和的SIGKILL，可被阻塞和处理。通常程序如果终止不了，才会尝试SIGKILL</span><br><span class="line">#define SIGSTKFLT 16  &#x2F;&#x2F; 协处理器堆栈错误</span><br><span class="line">#define SIGCHLD 17 &#x2F;&#x2F; 子进程结束时, 父进程会收到这个信号。</span><br><span class="line">#define SIGCONT 18 &#x2F;&#x2F; 让一个停止的进程继续执行</span><br><span class="line">#define SIGSTOP 19 &#x2F;&#x2F; 停止进程,本信号不能被阻塞,处理或忽略</span><br><span class="line">#define SIGTSTP 20 &#x2F;&#x2F; 停止进程,但该信号可以被处理和忽略</span><br><span class="line">#define SIGTTIN 21 &#x2F;&#x2F; 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号</span><br><span class="line">#define SIGTTOU 22 &#x2F;&#x2F; 类似于SIGTTIN, 但在写终端时收到</span><br><span class="line">#define SIGURG 23 &#x2F;&#x2F; 有紧急数据或out-of-band数据到达socket时产生</span><br><span class="line">#define SIGXCPU 24 &#x2F;&#x2F; 超过CPU时间资源限制时发出</span><br><span class="line">#define SIGXFSZ 25 &#x2F;&#x2F; 当进程企图扩大文件以至于超过文件大小资源限制</span><br><span class="line">#define SIGVTALRM 26 &#x2F;&#x2F; 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.</span><br><span class="line">#define SIGPROF 27 &#x2F;&#x2F; 类似于SIGALRM&#x2F;SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间</span><br><span class="line">#define SIGWINCH 28 &#x2F;&#x2F; 窗口大小改变时发出</span><br><span class="line">#define SIGIO 29 &#x2F;&#x2F; 文件描述符准备就绪, 可以开始进行输入&#x2F;输出操作</span><br><span class="line">#define SIGPOLL SIGIO &#x2F;&#x2F; 同上，别称</span><br><span class="line">#define SIGPWR 30 &#x2F;&#x2F; 电源异常</span><br><span class="line">#define SIGSYS 31 &#x2F;&#x2F; 非法的系统调用</span><br></pre></td></tr></table></figure>

<p>通常我们在做 crash 收集的时候，主要关注这几个信号量：</p>
<blockquote>
<p>const int signal_array[] = {SIGILL, SIGABRT, SIGBUS, SIGFPE, SIGSEGV, SIGSTKFLT, SIGSYS};</p>
</blockquote>
<h3 id="三、捕捉native-crash"><a href="#三、捕捉native-crash" class="headerlink" title="三、捕捉native crash"></a>三、捕捉native crash</h3><p>** 1. 注册信号处理函数**</p>
<p>第一步就是要用信号处理函数捕获到native crash(SIGSEGV, SIGBUS等)。在posix系统，可以用sigaction()：</p>
<blockquote>
<p>#include &lt;signal.h&gt;<br>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));<br>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。<br>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。<br>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册信号处理函数</span><br><span class="line">void signal_handle(int code, siginfo_t *si, void *context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    struct sigaction old_signal_handlers[SIGNALS_LEN];</span><br><span class="line">    </span><br><span class="line">    struct sigaction handler;  </span><br><span class="line">    memset(&amp;handler, 0, sizeof(handler));  </span><br><span class="line">    sigemptyset(&amp;handler.sa_mask);  </span><br><span class="line">    handler.sa_sigaction &#x3D; signal_handle;  </span><br><span class="line">    handler.sa_flags &#x3D; SA_SIGINFO;  </span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; SIGNALS_LEN; ++i) &#123;</span><br><span class="line">        sigaction(signal_array[i], &amp;handler, &amp; old_signal_handlers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 2. 设置额外栈空间**</p>
<blockquote>
<p>#include &lt;signal.h&gt;<br>int sigaltstack(const stack_t *ss, stack_t *oss);<br>SIGSEGV很有可能是栈溢出引起的，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文。而且当栈满了（太多次递归，栈上太多对象），系统会在同一个已经满了的栈上调用SIGSEGV的信号处理函数，又再一次引起同样的信号。</p>
</blockquote>
<p>我们应该开辟一块新的空间作为运行信号处理函数的栈。可以使用sigaltstack在任意线程注册一个可选的栈，保留一下在紧急情况下使用的空间。（系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">    stack_t stack;  </span><br><span class="line">    memset(&amp;stack, 0, sizeof(stack));  </span><br><span class="line">    &#x2F;* Reserver the system default stack size. We don&#39;t need that much by the way. *&#x2F;  </span><br><span class="line">    stack.ss_size &#x3D; SIGSTKSZ;  </span><br><span class="line">    stack.ss_sp &#x3D; malloc(stack.ss_size);  </span><br><span class="line">    stack.ss_flags &#x3D; 0;  </span><br><span class="line">    &#x2F;* Install alternate stack size. Be sure the memory region is valid until you revert it. *&#x2F;  </span><br><span class="line">    if (stack.ss_sp !&#x3D; NULL &amp;&amp; sigaltstack(&amp;stack, NULL) &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">      ...  </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 3. 兼容其他signal处理**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void signal_handle(int code, siginfo_t *si, void *context) &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* Call previous handler. *&#x2F;  </span><br><span class="line">    old_handler.sa_sigaction(code, si, sc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些信号可能在之前已经被安装过信号处理函数，而sigaction一个信号量只能注册一个处理函数，这意味着我们的处理函数会覆盖其他人的处理信号<br>保存旧的处理函数，在处理完我们的信号处理函数后，在重新运行老的处理函数就能完成兼容。</p>
<h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><p>1.防止死锁或者死循环<br>首先我们要了解async-signal-safe和可重入函数概念：</p>
<p>A signal handler function must be very careful, since processing elsewhere may be interrupted at some arbitrary point in the execution of the program.<br>POSIX has the concept of “safe function”. If a signal interrupts the execution of an unsafe function, and handler either calls an unsafe function or handler terminates via a call to longjmp() or siglongjmp() and the program subsequently calls an unsafe function, then the behavior of the program is undefined.</p>
<p>回想下在“信号机制”一节中的图示，进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令（类似发生硬件中断）。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。如果进程正在执行malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号而插入执行该信号处理程序，其中又调用malloc，这时会发生什么？这可能会对进程造成破坏，因为malloc通常为它所分配的存储区维护一个链表，而插入执行信号处理程序时，进程可能正在更改此链表。（参考《UNIX环境高级编程》）</p>
<p>Single UNIX Specification说明了在信号处理程序中保证调用安全的函数。这些函数是可重入的并被称为是异步信号安全（async-signal-safe）。除了可重入以外，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送。下面是这些异步信号安全函数：</p>
<p>但即使我们自己在信号处理程序中不使用不可重入的函数，也无法保证保存的旧的信号处理程序中不会有非异步信号安全的函数。所以要使用alarm保证信号处理程序不会陷入死锁或者死循环的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void signal_handler(const int code, siginfo_t *const si,</span><br><span class="line">                                    void *const sc) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure we do not deadlock. Default of ALRM is to die.</span><br><span class="line">    * (signal() and alarm() are signal-safe) *&#x2F;</span><br><span class="line">    signal(code, SIG_DFL);</span><br><span class="line">    signal(SIGALRM, SIG_DFL);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure we do not deadlock. Default of ALRM is to die.</span><br><span class="line">      * (signal() and alarm() are signal-safe) *&#x2F;</span><br><span class="line">    (void) alarm(8);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 2. 在哪里打印堆栈**</p>
<p><strong>(1) 子进程</strong></p>
<p>考虑到信号处理程序中的诸多限制，一般会clone一个新的进程，在其中完成解析堆栈等任务。</p>
<p>下面是Google Breakpad的流程图，在新的进程中DoDump，使用ptrace解析crash进程的堆栈，同时信号处理程序等待子进程完成任务后，再调用旧的信号处理函数。父子进程使用管道通信。</p>
<p>(2) 子线程<br>在我的实验中，在子进程或者信号处理函数中，经常无法回调给java层。于是我选择了在初始化的时候就建立了子线程并一直等待，等到捕捉到crash信号时，唤醒这条线程dump出crash堆栈，并把crash堆栈回调给java。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static void nativeInit(JNIEnv* env, jclass javaClass, jstring packageNameStr, jstring tombstoneFilePathStr, jobject obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">    initCondition();</span><br><span class="line"></span><br><span class="line">    pthread_t thd;</span><br><span class="line">    int ret &#x3D; pthread_create(&amp;thd, NULL, DumpThreadEntry, NULL);</span><br><span class="line">    if(ret) &#123;</span><br><span class="line">        qmlog(&quot;%s&quot;, &quot;pthread_create error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* DumpThreadEntry(void *argv) &#123;</span><br><span class="line">    JNIEnv* env &#x3D; NULL;</span><br><span class="line">     if((*g_jvm)-&gt;AttachCurrentThread(g_jvm, &amp;env, NULL) !&#x3D; JNI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;AttachCurrentThread() failed&quot;);</span><br><span class="line">        estatus &#x3D; 0;</span><br><span class="line">        return &amp;estatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F;等待信号处理函数唤醒</span><br><span class="line">        waitForSignal();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;回调native异常堆栈给java层</span><br><span class="line">        throw_exception(env);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;告诉信号处理函数已经处理完了</span><br><span class="line">        notifyThrowException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if((*g_jvm)-&gt;DetachCurrentThread(g_jvm) !&#x3D; JNI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;DetachCurrentThread() failed&quot;);</span><br><span class="line">        estatus &#x3D; 0;</span><br><span class="line">        return &amp;estatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &amp;estatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、收集native-crash原因"><a href="#六、收集native-crash原因" class="headerlink" title="六、收集native crash原因"></a>六、收集native crash原因</h3><p>信号处理函数的入参中有丰富的错误信息，下面我们来一一分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*信号处理函数*&#x2F;</span><br><span class="line">void (*sa_sigaction)(const int code, siginfo_t *const si, void * const sc) </span><br><span class="line"></span><br><span class="line">siginfo_t &#123;</span><br><span class="line">   int      si_signo;     &#x2F;* Signal number 信号量 *&#x2F;</span><br><span class="line">   int      si_errno;     &#x2F;* An errno value *&#x2F;</span><br><span class="line">   int      si_code;      &#x2F;* Signal code 错误码 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 1. code**</p>
<p>发生native crash之后，logcat中会打出如下一句信息：</p>
<blockquote>
<p>signal 11 (SIGSEGV), code 0 (SI_USER), fault addr 0x0</p>
</blockquote>
<p>根据code去查表，其实就可以知道发生native crash的大致原因：</p>
<p>代码的一部分如下，其实就是根据不同的code，输出不同信息，这些都是固定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">case SIGFPE:</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">    case FPE_INTDIV:</span><br><span class="line">      return &quot;Integer divide by zero&quot;;</span><br><span class="line">    case FPE_INTOVF:</span><br><span class="line">      return &quot;Integer overflow&quot;;</span><br><span class="line">    case FPE_FLTDIV:</span><br><span class="line">      return &quot;Floating-point divide by zero&quot;;</span><br><span class="line">    case FPE_FLTOVF:</span><br><span class="line">      return &quot;Floating-point overflow&quot;;</span><br><span class="line">    case FPE_FLTUND:</span><br><span class="line">      return &quot;Floating-point underflow&quot;;</span><br><span class="line">    case FPE_FLTRES:</span><br><span class="line">      return &quot;Floating-point inexact result&quot;;</span><br><span class="line">    case FPE_FLTINV:</span><br><span class="line">      return &quot;Invalid floating-point operation&quot;;</span><br><span class="line">    case FPE_FLTSUB:</span><br><span class="line">      return &quot;Subscript out of range&quot;;</span><br><span class="line">    default:</span><br><span class="line">      return &quot;Floating-point&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  case SIGSEGV:</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">    case SEGV_MAPERR:</span><br><span class="line">      return &quot;Address not mapped to object&quot;;</span><br><span class="line">    case SEGV_ACCERR:</span><br><span class="line">      return &quot;Invalid permissions for mapped object&quot;;</span><br><span class="line">    default:</span><br><span class="line">      return &quot;Segmentation violation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<p>** 2. pc值**</p>
<p>信号处理函数中的第三个入参sc是uc_mcontext的结构体，是cpu相关的上下文，包括当前线程的寄存器信息和奔溃时的pc值。能够知道崩溃时的pc，就能知道崩溃时执行的是那条指令。</p>
<p>不过这个结构体的定义是平台相关，不同平台、不同cpu架构中的定义都不一样：</p>
<p>x86-64架构：uc_mcontext.gregs[REG_RIP]<br>arm架构：uc_mcontext.arm_pc</p>
<p>** 3. 共享库名字和相对偏移地址**<br>(1) dladdr()<br>pc值是程序加载到内存中的绝对地址，我们需要拿到奔溃代码相对于共享库的相对偏移地址，才能使用addr2line分析出是哪一行代码。通过dladdr()可以获得共享库加载到内存的起始地址，和pc值相减就可以获得相对偏移地址，并且可以获得共享库的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dl_info info;  </span><br><span class="line">if (dladdr(addr, &amp;info) !&#x3D; 0 &amp;&amp; info.dli_fname !&#x3D; NULL) &#123;  </span><br><span class="line">  void * const nearest &#x3D; info.dli_saddr;  </span><br><span class="line">  &#x2F;&#x2F;相对偏移地址</span><br><span class="line">  const uintptr_t addr_relative &#x3D;  </span><br><span class="line">    ((uintptr_t) addr - (uintptr_t) info.dli_fbase);  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为有追求的我们，肯定不满足于仅仅通过一个函数就获得答案。我们尝试下如何手工分析出相对地址。首先要了解下进程的地址空间布局。</p>
<p>(2) Linux下进程的地址空间布局</p>
<p>任何一个程序通常都包括代码段和数据段，这些代码和数据本身都是静态的。程序要想运行，首先要由操作系统负责为其创建进程，并在进程的虚拟地址空间中为其代码段和数据段建立映射。光有代码段和数据段是不够的，进程在运行过程中还要有其动态环境，其中最重要的就是堆栈。</p>
<p>上图中Random stack offset和Random mmap offset等随机值意在防止恶意程序。Linux通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱布局，以免恶意程序通过计算访问栈、库函数等地址。</p>
<p>栈(stack)，作为进程的临时数据区,增长方向是从高地址到低地址。</p>
<p>(3) /proc/self/maps：检查各个模块加载在内存的地址范围<br>在Linux系统中，/proc/self/maps保存了各个程序段在内存中的加载地址范围，grep出共享库的名字，就可以知道共享库的加载基值是多少。</p>
<p>得到相对偏移地址之后，使用readelf查看共享库的符号表，就可以知道是哪个函数crash了。</p>
<h3 id="七、获取堆栈"><a href="#七、获取堆栈" class="headerlink" title="七、获取堆栈"></a>七、获取堆栈</h3><p>1.原理<br>在前一步，我们获取了奔溃时的pc值和各个寄存器的内容，通过SP和FP所限定的stack frame，就可以得到母函数的SP和FP，从而得到母函数的stack frame（PC，LR，SP，FP会在函数调用的第一时间压栈），以此追溯，即可得到所有函数的调用顺序。</p>
<p>2.实现<br>在4.1.1以上，5.0以下：使用安卓系统自带的libcorkscrew.so<br>5.0以上：安卓系统中没有了libcorkscrew.so，使用自己编译的libunwind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USE_UNWIND</span><br><span class="line">    &#x2F;* Frame buffer initial position. *&#x2F;</span><br><span class="line">    t-&gt;frames_size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Skip us and the caller. *&#x2F;</span><br><span class="line">   t-&gt;f rames_skip &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 使用libcorkscrew解堆栈 *&#x2F;</span><br><span class="line">#ifdef USE_CORKSCREW</span><br><span class="line">    t-&gt;frames_size &#x3D; backtrace_signal(si, sc, t-&gt;frames, 0, BACKTRACE_FRAMES_MAX);</span><br><span class="line">#else</span><br><span class="line">    &#x2F;* Unwind frames (equivalent to backtrace()) *&#x2F;</span><br><span class="line">    _Unwind_Backtrace(coffeecatch_unwind_callback, t);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;* 如果无法加载libcorkscrew，则使用自己编译的libunwind解堆栈 *&#x2F;</span><br><span class="line">#ifdef USE_LIBUNWIND</span><br><span class="line">    if (t-&gt;frames_size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        size_t i;</span><br><span class="line">        t-&gt;frames_size &#x3D; unwind_signal(si, sc, t-&gt;uframes, 0,BACKTRACE_FRAMES_MAX);</span><br><span class="line">        for(i &#x3D; 0 ; i &lt; t-&gt;frames_size ; i++) &#123;</span><br><span class="line">            t-&gt;frames[i].absolute_pc &#x3D; (uintptr_t) t-&gt;uframes[i];</span><br><span class="line">            t-&gt;frames[i].stack_top &#x3D; 0;</span><br><span class="line">            t-&gt;frames[i].stack_size &#x3D; 0;</span><br><span class="line">            __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;absolute_pc:%x&quot;, t-&gt;frames[i].absolute_pc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>libunwind是一个独立的开源库，高版本的安卓源码中也使用了libunwind作为解堆栈的工具，并针对安卓做了一些适配。下面是使用libunwind解堆栈的主循环，每次循环解一层堆栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE int</span><br><span class="line">slow_backtrace (void **buffer, int size, unw_context_t *uc)</span><br><span class="line">&#123;</span><br><span class="line">  unw_cursor_t cursor;</span><br><span class="line">  unw_word_t ip;</span><br><span class="line">  int n &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  if (unlikely (unw_init_local (&amp;cursor, uc) &lt; 0))</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  while (unw_step (&amp;cursor) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (n &gt;&#x3D; size)</span><br><span class="line">          return n;</span><br><span class="line"></span><br><span class="line">      if (unw_get_reg (&amp;cursor, UNW_REG_IP, &amp;ip) &lt; 0)</span><br><span class="line">          return n;</span><br><span class="line">      buffer[n++] &#x3D; (void *) (uintptr_t) ip;</span><br><span class="line">    &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>八、获取函数符号<br>(1) libcorkscrew<br>可以通过libcorkscrew中的get_backtrace_symbols函数获得函数符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* Describes the symbols associated with a backtrace frame.</span><br><span class="line">*&#x2F;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    uintptr_t relative_pc;</span><br><span class="line">    uintptr_t relative_symbol_addr;</span><br><span class="line">    char* map_name;</span><br><span class="line">    char* symbol_name;</span><br><span class="line">    char* demangled_name;</span><br><span class="line">&#125; backtrace_symbol_t;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* Gets the symbols for each frame of a backtrace.</span><br><span class="line">* The symbols array must be big enough to hold one symbol record per frame.</span><br><span class="line">* The symbols must later be freed using free_backtrace_symbols.</span><br><span class="line">*&#x2F;</span><br><span class="line">void get_backtrace_symbols(const backtrace_frame_t* backtrace, size_t frames,</span><br><span class="line">        backtrace_symbol_t* backtrace_symbols);</span><br></pre></td></tr></table></figure>

<p>** (2) dladdr**<br>更通用的方法是通过dladdr获得函数名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int dladdr(void *addr, Dl_info *info);</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">   const char *dli_fname;  &#x2F;* Pathname of shared object that</span><br><span class="line">                              contains address *&#x2F;</span><br><span class="line">   void       *dli_fbase;  &#x2F;* Base address at which shared</span><br><span class="line">                              object is loaded *&#x2F;</span><br><span class="line">   const char *dli_sname;  &#x2F;* Name of symbol whose definition</span><br><span class="line">                              overlaps addr *&#x2F;</span><br><span class="line">   void       *dli_saddr;  &#x2F;* Exact address of symbol named</span><br><span class="line">                              in dli_sname *&#x2F;</span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure>
<p>传入每一层堆栈的相对偏移地址，就可以从dli_fname中获得函数名字。</p>
<p>九、获得java堆栈<br>如何获得native crash所对应的java层堆栈，这个问题曾经困扰了我一段时间。这里有一个前提：我们认为crash线程就是捕获到信号的线程，虽然这在SIGABRT下不一定可靠。有了这个认知，接下来就好办了。在信号处理函数中获得当前线程的名字，然后把crash线程的名字传给java层，在java里dump出这个线程的堆栈，就是crash所对应的java层堆栈了。</p>
<p>在c中获得线程名字：</p>
<p>char* getThreadName(pid_t tid) {<br>    if (tid &lt;= 1) {<br>        return NULL;<br>    }<br>    char* path = (char <em>) calloc(1, 80);<br>    char</em> line = (char *) calloc(1, THREAD_NAME_LENGTH);</p>
<pre><code>snprintf(path, PATH_MAX, &quot;proc/%d/comm&quot;, tid);
FILE* commFile = NULL;
if (commFile = fopen(path, &quot;r&quot;)) {
    fgets(line, THREAD_NAME_LENGTH, commFile);
    fclose(commFile);
}
free(path);
if (line) {
    int length = strlen(line);
    if (line[length - 1] == &apos;\n&apos;) {
        line[length - 1] = &apos;\0&apos;;
    }
}
return line;</code></pre><p>}<br>然后传给java层：</p>
<pre><code>/**
 * 根据线程名获得线程对象，native层会调用该方法，不能混淆
 * @param threadName
 * @return
 */
@Keep
public static Thread getThreadByName(String threadName) {
    if (TextUtils.isEmpty(threadName)) {
        return null;
    }

    Set&lt;Thread&gt; threadSet = Thread.getAllStackTraces().keySet();
    Thread[] threadArray = threadSet.toArray(new Thread[threadSet.size()]);

    Thread theThread = null;
    for(Thread thread : threadArray) {
        if (thread.getName().equals(threadName)) {
            theThread =  thread;
        }
    }

    Log.d(TAG, &quot;threadName: &quot; + threadName + &quot;, thread: &quot; + theThread);
    return theThread;
}</code></pre><p>十、 结果展示<br>经过诸多探索，终于得到了完美的堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Error: signal 11 (Address not mapped to object) at address 0x0</span><br><span class="line">  at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line">Caused by: java.lang.Error: signal 11 (Address not mapped to object) at address 0x0</span><br><span class="line">  at &#x2F;data&#x2F;app-lib&#x2F;com.tencent.moai.crashcatcher.demo-1&#x2F;libQMCrashGenerator.so.0xd8e(dangerousFunction:0x5:0)</span><br><span class="line">  at &#x2F;data&#x2F;app-lib&#x2F;com.tencent.moai.crashcatcher.demo-1&#x2F;libQMCrashGenerator.so.0xd95(wrapDangerousFunction:0x2:0)</span><br><span class="line">  at &#x2F;data&#x2F;app-lib&#x2F;com.tencent.moai.crashcatcher.demo-1&#x2F;libQMCrashGenerator.so.0xd9d(nativeInvalidAddressCrash:0x2:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x1ee8c(dvmPlatformInvoke:0x70:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x503b7(dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*):0x1ee:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x28268(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2f738(dvmMterpStd(Thread*):0x44:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2cda8(dvmInterpret(Thread*, Method const*, JValue*):0xb8:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x648e3(dvmInvokeMethod(Object*, Method const*, ArrayObject*, ArrayObject*, ClassObject*, bool):0x1aa:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x6cff9(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x28268(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2f738(dvmMterpStd(Thread*):0x44:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2cda8(dvmInterpret(Thread*, Method const*, JValue*):0xb8:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x643d9(dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list):0x14c:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x4bca1(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so.0x50ac3(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so.0x518e7(android::AndroidRuntime::start(char const*, char const*):0x206:0)</span><br><span class="line">  at &#x2F;system&#x2F;bin&#x2F;app_process.0xf33(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libc.so.0xf584(__libc_init:0x64:0)</span><br><span class="line">  at &#x2F;system&#x2F;bin&#x2F;app_process.0x107c(Native Method)</span><br><span class="line">Caused by: java.lang.Error: java stack</span><br><span class="line">  at com.tencent.crashcatcher.CrashCatcher.nativeInvalidAddressCrash(Native Method)</span><br><span class="line">  at com.tencent.crashcatcher.CrashCatcher.invalidAddressCrash(CrashCatcher.java:33)</span><br><span class="line">  at com.tencent.moai.crashcatcher.demo.MainActivity$4.onClick(MainActivity.java:56)</span><br><span class="line">  at android.view.View.performClick(View.java:4488)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:18860)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:808)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:222)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5484)</span><br><span class="line">  at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:515)</span><br><span class="line">  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:860)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:676)</span><br><span class="line">  at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure>

<p>在native层构造了一个Error传给java，所以在java层可以很轻松地根据堆栈进行业务上的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface CrashHandleListener &#123;</span><br><span class="line">    @Keep</span><br><span class="line">    void onCrash(int id, Error e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外初始化时就建立等待回调线程的方式，提供了稳定的给java层的回调。在回调中我们打印了app的状态信息，包括activity的堆栈、app是否在前台等，以及打印crash前的logcat日志和把应用日志flush进文件。针对某些具体的native crash还做了业务上的处理，例如遇到热补丁框架相关的crash时就回滚补丁。</p>
<p>在用户环境中的很多native crash单靠堆栈是解决不了的，logcat是非常重要的补充。好几例webview crash都是通过发生crash时的logcat定位的。比如我们曾经遇到过的一个的webview crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#00 pc 00039874  &#x2F;system&#x2F;lib&#x2F;libc.so (tgkill+12)</span><br><span class="line">#01 pc 00013b5d  &#x2F;system&#x2F;lib&#x2F;libc.so (pthread_kill+52)</span><br><span class="line">#02 pc 0001477b  &#x2F;system&#x2F;lib&#x2F;libc.so (raise+10)</span><br><span class="line">#03 pc 00010ff5  &#x2F;system&#x2F;lib&#x2F;libc.so (__libc_android_abort+36)</span><br><span class="line">#04 pc 0000f554  &#x2F;system&#x2F;lib&#x2F;libc.so (abort+4)</span><br><span class="line">#05 pc 00239885  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#06 pc 00219da3  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#07 pc 00206459  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#08 pc 001fb6c7  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#09 pc 001edc97  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#10 pc 001ec5ad  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#11 pc 001ec617  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#12 pc 001ec5e5  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#13 pc 001ec5bf  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#14 pc 0022c941  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#15 pc 0022c92b  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#16 pc 0022e6a1  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#17 pc 0022ebcd  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#18 pc 0022ee1d  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#19 pc 0022c511  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#20 pc 00013347  &#x2F;system&#x2F;lib&#x2F;libc.so (_ZL15__pthread_startPv+30)</span><br><span class="line">#21 pc 0001135f  &#x2F;system&#x2F;lib&#x2F;libc.so (__start_thread+6)</span><br></pre></td></tr></table></figure>
<p>单凭堆栈根本看不出来是什么问题，但是在logcat中却看到这样一个warning log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">05-21 15:09:28.423 W&#x2F;System.err(16811): java.lang.NullPointerException: Attempt to get length of null array</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at java.io.ByteArrayInputStream.&lt;init&gt;(ByteArrayInputStream.java:60)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.fetcher.HttpImageFetcher.fetchFromNetwork(HttpImageFetcher.java:86)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.fetcher.BaseFetcher.fetch(BaseFetcher.java:24)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.delaystream.DelayInputStream.read(DelayInputStream.java:36)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.delaystream.DelayHttpInputStream.read(DelayHttpInputStream.java:12)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at java.io.InputStream.read(InputStream.java:181)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at org.chromium.android_webview.InputStreamUtil.read(InputStreamUtil.java:54)</span><br><span class="line">查代码发现是我们在WebViewClient的shouldInterceptRequest接口中的业务代码发生了NullPointerException， 传进去WebView内部变成了natvie crash，问题解决。</span><br></pre></td></tr></table></figure>





<p>=============================================================</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *head_cpu &#x3D; nullptr;</span><br><span class="line">asprintf(&amp;head_cpu, &quot;r0 %08lx  r1 %08lx  r2 %08lx  r3 %08lx\n&quot;</span><br><span class="line">                 &quot;r4 %08lx  r5 %08lx  r6 %08lx  r7 %08lx\n&quot;</span><br><span class="line">                 &quot;r8 %08lx  r9 %08lx  sl %08lx  fp %08lx\n&quot;</span><br><span class="line">                 &quot;ip %08lx  sp %08lx  lr %08lx  pc %08lx  cpsr %08lx\n&quot;,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r0, t-&gt;uc_mcontext.arm_r1, t-&gt;uc_mcontext.arm_r2,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r3, t-&gt;uc_mcontext.arm_r4, t-&gt;uc_mcontext.arm_r5,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r6, t-&gt;uc_mcontext.arm_r7, t-&gt;uc_mcontext.arm_r8,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r9, t-&gt;uc_mcontext.arm_r10, t-&gt;uc_mcontext.arm_fp,</span><br><span class="line">         t-&gt;uc_mcontext.arm_ip, t-&gt;uc_mcontext.arm_sp, t-&gt;uc_mcontext.arm_lr,</span><br><span class="line">         t-&gt;uc_mcontext.arm_pc, t-&gt;uc_mcontext.arm_cpsr);</span><br></pre></td></tr></table></figure>
<p>不过uc_mcontext结构体的定义是平台相关的，比如我们熟知的arm、x86这种都不是同一个结构体定义，上面的代码只列出了arm架构的寄存器信息，要兼容其他架构的 cpu 在处理的时候，就得要寄出宏编译大法，不同的架构使用不同的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t pc_from_ucontext(const ucontext_t *uc) &#123;</span><br><span class="line">#if (defined(__arm__))</span><br><span class="line">    return uc-&gt;uc_mcontext.arm_pc;</span><br><span class="line">#elif defined(__aarch64__)</span><br><span class="line">    return uc-&gt;uc_mcontext.pc;</span><br><span class="line">#elif (defined(__x86_64__))</span><br><span class="line">    return uc-&gt;uc_mcontext.gregs[REG_RIP];</span><br><span class="line">#elif (defined(__i386))</span><br><span class="line">  return uc-&gt;uc_mcontext.gregs[REG_EIP];</span><br><span class="line">#elif (defined (__ppc__)) || (defined (__powerpc__))</span><br><span class="line">  return uc-&gt;uc_mcontext.regs-&gt;nip;</span><br><span class="line">#elif (defined(__hppa__))</span><br><span class="line">  return uc-&gt;uc_mcontext.sc_iaoq[0] &amp; ~0x3UL;</span><br><span class="line">#elif (defined(__sparc__) &amp;&amp; defined (__arch64__))</span><br><span class="line">  return uc-&gt;uc_mcontext.mc_gregs[MC_PC];</span><br><span class="line">#elif (defined(__sparc__) &amp;&amp; !defined (__arch64__))</span><br><span class="line">  return uc-&gt;uc_mcontext.gregs[REG_PC];</span><br><span class="line">#else</span><br><span class="line">#error &quot;Architecture is unknown, please report me!&quot;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pc值转内存地址<br>pc值是程序加载到内存中的绝对地址，绝对地址不能直接使用，因为每次程序运行创建的内存肯定都不是固定区域的内存，所以绝对地址肯定每次运行都不一致。我们需要拿到崩溃代码相对于当前库的相对偏移地址，这样才能使用 addr2line 分析出是哪一行代码。通过dladdr()可以获得共享库加载到内存的起始地址，和pc值相减就可以获得相对偏移地址，并且可以获得共享库的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dl_info info;  </span><br><span class="line">if (dladdr(addr, &amp;info) &amp;&amp; info.dli_fname) &#123;  </span><br><span class="line">  void * const nearest &#x3D; info.dli_saddr;  </span><br><span class="line">  uintptr_t addr_relative &#x3D; addr - info.dli_fbase;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 Crash 发生时的函数调用栈<br>获取函数调用栈是最麻烦的，至今没有一个好用的，全都要做一些大改动。常见的做法有四种：</p>
<p>第一种：直接使用系统的&lt;unwind.h&gt;库，可以获取到出错文件与函数名。只不过需要自己解析函数符号，同时经常会捕获到系统错误，需要手动过滤。<br>第二种：在4.1.1以上，5.0以下，使用系统自带的libcorkscrew.so，5.0开始，系统中没有了libcorkscrew.so，可以自己编译系统源码中的libunwind。libunwind是一个开源库，事实上高版本的安卓源码中就使用了他的优化版替换libcorkscrew。<br>第三种：使用开源库coffeecatch，但是这种方案也不能百分之百兼容所有机型。<br>第四种：使用 Google 的breakpad，这是所有 C/C++堆栈获取的权威方案，基本上业界都是基于这个库来做的。只不过这个库是全平台的 android、iOS、Windows、Linux、MacOS 全都有，所以非常大，在使用的时候得把无关的平台剥离掉减小体积。<br>下</p>
<p>面以第一种为例讲一下实现：<br>核心方法是使用&lt;unwind.h&gt;库提供的一个方法_Unwind_Backtrace()这个函数可以传入一个函数指针作为回调，指针指向的函数有一个重要的参数是_Unwind_Context类型的结构体指针。<br>可以使用_Unwind_GetIP()函数将当前函数调用栈中每个函数的绝对内存地址（也就是上文中提到的 pc 值），写入到_Unwind_Context结构体中，最终返回的是当前调用栈的全部函数地址了，_Unwind_Word实际上就是一个unsigned int。<br>而capture_backtrace()返回的就是当前我们获取到调用栈中内容的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * callback used when using &lt;unwind.h&gt; to get the trace for the current context</span><br><span class="line"> *&#x2F;</span><br><span class="line">_Unwind_Reason_Code unwind_callback(struct _Unwind_Context *context, void *arg) &#123;</span><br><span class="line">    backtrace_state_t *state &#x3D; (backtrace_state_t *) arg;</span><br><span class="line">    _Unwind_Word pc &#x3D; _Unwind_GetIP(context);</span><br><span class="line">    if (pc) &#123;</span><br><span class="line">        if (state-&gt;current &#x3D;&#x3D; state-&gt;end) &#123;</span><br><span class="line">            return _URC_END_OF_STACK;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *state-&gt;current++ &#x3D; (void *) pc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _URC_NO_REASON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * uses built in &lt;unwind.h&gt; to get the trace for the current context</span><br><span class="line"> *&#x2F;</span><br><span class="line">size_t capture_backtrace(void **buffer, size_t max) &#123;</span><br><span class="line">    backtrace_state_t state &#x3D; &#123;buffer, buffer + max&#125;;</span><br><span class="line">    _Unwind_Backtrace(unwind_callback, &amp;state);</span><br><span class="line">    return state.current - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当所有的函数的绝对内存地址(pc 值)都获取到了，就可以用上文讲的办法将 pc 值转换为相对偏移量，获取到真正的函数信息和相对内存地址了。</p>
<p>void *buffer[max_line];<br>int frames_size = capture_backtrace(buffer, max_line);<br>for (int i = 0; i &lt; frames_size; i++) {<br>    Dnfo; l_info i<br>    const void *addr = buffer[i];<br>    if (dladdr(addr, &amp;info) &amp;&amp; info.dli_fname) {<br>      void * const nearest = info.dli_saddr;<br>      uintptr_t addr_relative = addr - info.dli_fbase;<br>}<br>Dl_info是一个结构体，内部封装了函数所在文件、函数名、当前库的基地址等信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    const char *dli_fname;  &#x2F;* Pathname of shared object that</span><br><span class="line">                               contains address *&#x2F;</span><br><span class="line">    void       *dli_fbase;  &#x2F;* Address at which shared object</span><br><span class="line">                               is loaded *&#x2F;</span><br><span class="line">    const char *dli_sname;  &#x2F;* Name of nearest symbol with address</span><br><span class="line">                               lower than addr *&#x2F;</span><br><span class="line">    void       *dli_saddr;  &#x2F;* Exact address of symbol named</span><br><span class="line">                               in dli_sname *&#x2F;</span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure>
<p>有了这个对象，我们就能获取到全部想要的信息了。虽然获取到全部想要的信息，但&lt;unwind.h&gt;有个麻烦的就是不想要的信息也给你了，所以需要手动过滤掉各种系统错误，最终得到的数据，就可以上报到自己的服务器了。</p>
<p>数据回传到服务器<br>数据回传有两种方式，一种是直接将信息写入文件，下次启动的时候直接由 Java 上报；另一种就是回调 Java 代码，让 Java 去处理。用 Java 处理的好处是 Java 层可以继续在当前上下文上加上 Java 层的各种状态信息，写入到同一个文件中，使得开发在解决 bug 的时候能更方便。<br>这里就简单将数据写入文件了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void save(const char *name, char *content) &#123;</span><br><span class="line">    FILE *file &#x3D; fopen(name, &quot;w+&quot;);</span><br><span class="line">    fputs(content, file);</span><br><span class="line">    fflush(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    &#x2F;&#x2F;可以在写入文件以后，再通知 Java 层，直接将文件名传给 Java 层更简单。  </span><br><span class="line">    report();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你按照本文讲的，应该是可以创建一个可以工作的 Native Crash 收集库了，但是还有很多细节上的问题，比如数据的丢失问题，写文件的时候使用w+可能造成上次存储的文件丢失；如果当前函数发生了无限递归造成堆栈溢出，在统计的时候需要考虑到这种情况而新开堆栈否则本来就满了的堆栈又在当前堆栈处理溢出信号，处理肯定是会失败的；再比方说多进程多线程在 C 上的各种问题，真的是很复杂。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/27834417" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a><br><a href="https://blog.csdn.net/JMW1407/article/details/107737137" target="_blank" rel="noopener">什么是信号（signal）？信号的处理机制？利用信号进行简单的进程通信过程设计（c++）?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/14/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/14/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">LeetCode初级算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-14 10:19:30 / 修改时间：10:20:14" itemprop="dateCreated datePublished" datetime="2020-08-14T10:19:30+08:00">2020-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LeetCode-初级算法"><a href="#LeetCode-初级算法" class="headerlink" title="LeetCode 初级算法"></a>LeetCode 初级算法</h2><ol>
<li>删除排序数组中的重复项</li>
</ol>
<p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/" target="_blank" rel="noopener"></a></p>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
