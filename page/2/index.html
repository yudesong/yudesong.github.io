<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">JVM常见参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 23:56:34" itemprop="dateCreated datePublished" datetime="2020-06-05T23:56:34+08:00">2020-06-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>先从一道笔试题开始</strong></p>
<blockquote>
<p>对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3<br>,其最小内存值和Survivor区总大小分别是多少？</p>
</blockquote>
<p>如果对JVM参数不了解，基本就可以歇歇了。本题主要考察的就是Java堆内存的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xmx  最大堆大小</span><br><span class="line">-Xms  初始堆大小</span><br><span class="line">-Xmn  年轻代大小</span><br><span class="line">-XX:NewRatio  年轻代（年轻代包括：Eden和两个Surivor）与年老代（年老代不包括持久代）的比值</span><br><span class="line">-XX:SurvivorRatio  年轻代中Eden区与Survivor区的大小比值</span><br><span class="line">年轻代5120m， Eden：Survivor&#x3D;3，Survivor区大小&#x3D;1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</span><br><span class="line">-Xms初始堆大小即最小内存值为10240m</span><br><span class="line">新生代大部分要回收，采用Copying算法，快！</span><br><span class="line">老年代 大部分不需要回收，采用Mark-Compact算法</span><br></pre></td></tr></table></figure>

<img src="/2020/06/05/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0/Java-Memory-Model.png" class="" title="[Java-Memory-Model]">

<p><strong>永久区分配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize    设置永久区的初始空间</span><br><span class="line">-XX:MaxPermSize 设置永久区的最大空间</span><br></pre></td></tr></table></figure>

<p><strong>栈的分配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 设置栈空间的大小,通常只有几百K</span><br></pre></td></tr></table></figure>

<p><strong>GC参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails  打印GC详细日志</span><br><span class="line">-Xloggc:log&#x2F;gc.log   指定GClog的位置</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/loveer/p/11522493.html" target="_blank" rel="noopener">JVM参数配置</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8812%EF%BC%89ReentrantLock%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8812%EF%BC%89ReentrantLock%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（12）ReentrantLock原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 11:02:41" itemprop="dateCreated datePublished" datetime="2020-06-05T11:02:41+08:00">2020-06-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/ReentrantLock/" itemprop="url" rel="index"><span itemprop="name">ReentrantLock</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="ReentrantLock-简介"><a href="#ReentrantLock-简介" class="headerlink" title="ReentrantLock 简介"></a>ReentrantLock 简介</h5><p>ReentrantLock是一个继承Lock接口并且是基于CAS操作来实现的Java锁，ReentrantLock还支持公平锁和非公平锁两种方式。 </p>
<img src="/2020/06/05/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8812%EF%BC%89ReentrantLock%E5%8E%9F%E7%90%86/32fe52d9f90b34b6082b3ce032d373c5.png" class="" title="[啃碎并发（12）ReentrantLock原理]">

<h5 id="一般的用法"><a href="#一般的用法" class="headerlink" title="一般的用法"></a>一般的用法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock mLock &#x3D; new ReentrantLock();</span><br><span class="line">mLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">	&#x2F;&#x2F; 业务逻辑</span><br><span class="line">&#125; finaly &#123;</span><br><span class="line">	mLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>0. Condition 接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line">	void await() throws InterruptedException;</span><br><span class="line">	void awaitUninterruptibly();</span><br><span class="line">	void signal(); &#x2F;&#x2F; 唤醒单个线程</span><br><span class="line">	void signalAll(); &#x2F;&#x2F;唤醒多有线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. Lock 接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">	void lock(); &#x2F;&#x2F; 如果没获取到锁则阻塞</span><br><span class="line">	void lockInterruptibly() throws InterruptedException; </span><br><span class="line">	boolean tryLock(); &#x2F;&#x2F; 如果获取到锁立即返回true，否则立即返回false</span><br><span class="line">	void unlock();</span><br><span class="line">	Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-ReentrantLock源码"><a href="#2-ReentrantLock源码" class="headerlink" title="2. ReentrantLock源码"></a>2. ReentrantLock源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F; 初始化默认为非公平锁</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync &#x3D; new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync &#x3D; (fair ? new FairSync() : new NonfairSync());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.nonfairTryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -5179523762034025860L;</span><br><span class="line">        </span><br><span class="line">        abstract void lock();</span><br><span class="line">        </span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            &#x2F;&#x2F; 如果锁的state为0, 则尝试CAS操作将state修改为1</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设置state&#x3D;1成功，将当前线程设置为OwnerThread</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 可重入，将state的值加1</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 释放锁将state减1，并且将OwnnerThread置null</span><br><span class="line">        protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c &#x3D; getState() - releases;</span><br><span class="line">            if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free &#x3D; false;</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                free &#x3D; true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean isHeldExclusively() &#123;</span><br><span class="line">            return getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ConditionObject newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Thread getOwner() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 0 ? null : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getHoldCount() &#123;</span><br><span class="line">            return isHeldExclusively() ? getState() : 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isLocked() &#123;</span><br><span class="line">            return getState() !&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 非公平锁</span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            &#x2F;&#x2F; 第一次尝试CAS获取锁</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                &#x2F;&#x2F; 如果获取锁成功，则将Owner线程设置为当前线程</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 公平锁</span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 和非公平锁相比，这里多了一个判断：是否有线程在等待</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AbstractQueuedSynchronizer.acquire(int arg)</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非公平锁</strong>在lock()的时候，首先会进行一次CAS枪锁操作成功就获取锁，否则再去判断state是否为0，为0的话再次枪锁，否则进入阻塞队列。<br><strong>公平锁</strong>在lock()的时候多了一步判断<strong>阻塞队列中是否有线程在等待</strong>，没有的话就去CAS获取锁，否则进入阻塞队列。</p>
<blockquote>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
</blockquote>
<h5 id="3-AbstractQueuedSynchronizer原理"><a href="#3-AbstractQueuedSynchronizer原理" class="headerlink" title="3. AbstractQueuedSynchronizer原理"></a>3. AbstractQueuedSynchronizer原理</h5><p>AbstractQueuedSynchronizer(抽象同步队列)简称AQS主要依赖一个int成员变量来表示<strong>同步状态state</strong>，以及一个<strong>CLH等待队列</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123;</span><br><span class="line">    private static final sun.misc.Unsafe U &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">    static final class Node &#123;</span><br><span class="line">        static final Node SHARED &#x3D; new Node(); &#x2F;&#x2F; 共享</span><br><span class="line">        static final Node EXCLUSIVE &#x3D; null;    &#x2F;&#x2F; 独占</span><br><span class="line">        volatile Node prev;  &#x2F;&#x2F; 前驱节点</span><br><span class="line">        volatile Node next;  &#x2F;&#x2F; 后继节点</span><br><span class="line">        volatile Thread thread; &#x2F;&#x2F; 当前节点对应的Thread线程</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; volatile 标识锁的状态(0 、 大于 0) </span><br><span class="line">    private volatile int state;</span><br><span class="line">    private transient volatile Node head; &#x2F;&#x2F; CLH头节点</span><br><span class="line">    private transient volatile Node tail; &#x2F;&#x2F; CLH尾节点</span><br><span class="line">    </span><br><span class="line">    protected final int getState() &#123; </span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通常用于当前正持有锁的线程对state变量进行修改，不存在竞争，是线程安全的，所以此处没必要用CAS保证原子性，修改的性能更重要。</span><br><span class="line">    protected final void setState(int newState) &#123;</span><br><span class="line">        state &#x3D; newState;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 通常用于在获取到锁之前，尝试加锁时，对state进行修改，这种场景下，由于当前线程不是锁持有者，</span><br><span class="line">    &#x2F;&#x2F; 所以对state的修改是线程不安全的，也就是说可能存在多个线程都尝试修改state,</span><br><span class="line">    &#x2F;&#x2F; 所以需要保证对state修改的原子性操作，即使用了unsafe类的本地CAS方法；</span><br><span class="line">    protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        return U.compareAndSwapInt(this, STATE, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化CLH队列head</span><br><span class="line">    private final void initializeSyncQueue() &#123;</span><br><span class="line">        Node h;</span><br><span class="line">        if (U.compareAndSwapObject(this, HEAD, null, (h &#x3D; new Node())))</span><br><span class="line">            tail &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 尝试CAS获取锁，如果没获取到则将当前线程添加到等待队列</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 添加Node到CLH队列</span><br><span class="line">    private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node &#x3D; new Node(mode);</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node oldTail &#x3D; tail;</span><br><span class="line">            if (oldTail !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 设置node节点的前驱节点为队列尾节点</span><br><span class="line">                U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">                &#x2F;&#x2F; 设置CLH的的tail为node节点</span><br><span class="line">                if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 设tail的后继为node节点</span><br><span class="line">                    oldTail.next &#x3D; node;</span><br><span class="line">                    return node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                initializeSyncQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Node enq(Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node oldTail &#x3D; tail;</span><br><span class="line">            if (oldTail !&#x3D; null) &#123;</span><br><span class="line">                U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">                if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                    oldTail.next &#x3D; node;</span><br><span class="line">                    return oldTail;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                initializeSyncQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 自旋</span><br><span class="line">    final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted &#x3D; false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取node的前驱节点, 当前驱节点为head的时候，尝试CAS获取锁，成功则将自己设置为head节点</span><br><span class="line">                final Node p &#x3D; node.predecessor();</span><br><span class="line">                if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next &#x3D; null;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 获取不到锁，会在此处进入线程等待状态</span><br><span class="line">                &#x2F;&#x2F; 后续被唤醒的话，也是从这里出来，然后继续for循环</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">            throw t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 在 acquire 失败后检查并更新node的status，如果需要阻塞线程就返回true</span><br><span class="line">    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws &#x3D; pred.waitStatus;</span><br><span class="line">        &#x2F;&#x2F; 前驱节点是正在等待状态</span><br><span class="line">        if (ws &#x3D;&#x3D; Node.SIGNAL) return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 前驱取消了资源获取，那么当前节点就要遍历前面节点，找到最近一个正在等待的节点</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next &#x3D; node;&#x2F;&#x2F; 此处 pred.waitStatus &lt; 0，亦即pred 还在等待尝试获取资源</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; 前驱正在等待，则设置其状态为SIGNAL，让他获取资源后通知本节点，</span><br><span class="line">            pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">            &#x2F;&#x2F; 但是本节点不能马上阻塞，因为设置不一定能成功,需要下次再次检查</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断CLH队列是否有等待的线程</span><br><span class="line">    public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        Node s;</span><br><span class="line">        return h !&#x3D; t &amp;&amp;</span><br><span class="line">            ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 释放锁，state减1，唤醒head的下一个节点或者从尾向前寻找一个等待状态正常的node节点并唤醒他</span><br><span class="line">    public final boolean release(int arg) &#123;</span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h &#x3D; head;</span><br><span class="line">            if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">        int c &#x3D; getState() - releases;</span><br><span class="line">        if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">            &#x2F;&#x2F; 当前运行的线程和锁住的线程不是同一个，抛出监控状态异常错误</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        boolean free &#x3D; false;</span><br><span class="line">        if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果为0，则意味着这时可以释放锁了</span><br><span class="line">            free &#x3D; true;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            &#x2F;&#x2F; 设置当前的占据锁的线程为null，给其他线程一个机会</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        &#x2F;&#x2F; 存在重入的机会，所以不一定就是释放该锁</span><br><span class="line">        return free;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        int ws &#x3D; node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)&#x2F;&#x2F; 可能需要释放通知信号，把状态置零，允许失败</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        Node s &#x3D; node.next;&#x2F;&#x2F; 找到后继节点</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;&#x2F;&#x2F; 如果后继节点为空或者已经取消</span><br><span class="line">            s &#x3D; null;&#x2F;&#x2F; 确保该节点的释放</span><br><span class="line">            for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            &#x2F;&#x2F; 从队尾开始找到需要通知的最近的后继节点</span><br><span class="line">                if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                    s &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 如果需唤醒的后继节点存在则唤醒之</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 以下为父类 AbstractOwnableSynchronizer 定义</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread &#x3D; thread; &#125;</span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【解读】<br>lock() -&gt; acquire(1) -&gt; tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</p>
<h5 id="3-LinkedBlockingQueue-类"><a href="#3-LinkedBlockingQueue-类" class="headerlink" title="3. LinkedBlockingQueue 类"></a>3. LinkedBlockingQueue 类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">        implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">	private final AtomicInteger count &#x3D; new AtomicInteger();</span><br><span class="line">    transient Node&lt;E&gt; head;</span><br><span class="line">    private transient Node&lt;E&gt; last;</span><br><span class="line">    private final ReentrantLock takeLock &#x3D; new ReentrantLock();</span><br><span class="line">    private final Condition notEmpty &#x3D; takeLock.newCondition();</span><br><span class="line">    private final ReentrantLock putLock &#x3D; new ReentrantLock();</span><br><span class="line">    private final Condition notFull &#x3D; putLock.newCondition();	</span><br><span class="line">	</span><br><span class="line">	public LinkedBlockingQueue() &#123;</span><br><span class="line">        this(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">        if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException();</span><br><span class="line">        this.capacity &#x3D; capacity;</span><br><span class="line">        last &#x3D; head &#x3D; new Node&lt;E&gt;(null);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    private static final long serialVersionUID &#x3D; -6903933977591709194L;</span><br><span class="line">	    static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item &#x3D; x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;【****重点****】</span><br><span class="line">	public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        if (e &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">        int c &#x3D; -1;</span><br><span class="line">        Node&lt;E&gt; node &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line">        final ReentrantLock putLock &#x3D; this.putLock;</span><br><span class="line">        final AtomicInteger count &#x3D; this.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count.get() &#x3D;&#x3D; capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c &#x3D; count.getAndIncrement();</span><br><span class="line">            if (c + 1 &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c &#x3D;&#x3D; 0)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	private void enqueue(Node&lt;E&gt; node) &#123;</span><br><span class="line">        last &#x3D; last.next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;【****重点****】</span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        E x;</span><br><span class="line">        int c &#x3D; -1;</span><br><span class="line">        final AtomicInteger count &#x3D; this.count;</span><br><span class="line">        final ReentrantLock takeLock &#x3D; this.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count.get() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x &#x3D; dequeue();</span><br><span class="line">            c &#x3D; count.getAndDecrement();</span><br><span class="line">            if (c &gt; 1)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        if (c &#x3D;&#x3D; capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    private E dequeue() &#123;</span><br><span class="line">        Node&lt;E&gt; h &#x3D; head;</span><br><span class="line">        Node&lt;E&gt; first &#x3D; h.next;</span><br><span class="line">        h.next &#x3D; h; &#x2F;&#x2F; help GC</span><br><span class="line">        head &#x3D; first;</span><br><span class="line">        E x &#x3D; first.item;</span><br><span class="line">        first.item &#x3D; null;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Semaphore/CountDownLatch (共享锁)</li>
</ol>
<p>3.1 Semaphore </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line">try &#123;</span><br><span class="line">    semaphore.acquire();</span><br><span class="line">	&#x2F;&#x2F; 业务逻辑</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125; finaly (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3、问题总结<br>上面的case只是各种线程执行方式的一种，实际场景中包含了各种各样的运行方式，每个线程执行的时间也长短不一，现在讨论几个常见的问题<br>3.1、为什么在unparkSuccessor操作中从尾节点开始扫描<br>这个问题需要回头观察CLH队列是如何创建的，来到addWaiter方法<br>Node pred = tail;<br>if (pred != null) {<br>    node.prev = pred;<br>    if (compareAndSetTail(pred, node)) {<br>        // 通过CAS 操作后node节点为tail<br>        // 并且早就设置了node.prev = pred<br>        // 1、也就是前置的链表已经绑定完毕，后置的链表还未绑定<br>        pred.next = node;<br>        return node;<br>    }<br>}</p>
<p>在代码块1处执行完成之后，还未执行绑定后置链表操作，如果出现唤醒操作，从头部开始遍历存在一定几率使得无法获取到当前最新的节点（因为后置链表还未绑定，无法通过.next获取到下一个节点信息），而从尾部开始扫描则不会导致该问题<br>很巧妙的利用尾部扫描避免了可能的并发问题<br>3.2、公平锁中的hasQueuedPredecessors操作为什么从tail开始<br>public final boolean hasQueuedPredecessors() {<br>    Node t = tail; // Read fields in reverse initialization order<br>    Node h = head;<br>    // 先读取tail节点，再读取head节点<br>    Node s;<br>    return h != t &amp;&amp;<br>        ((s = h.next) == null || s.thread != Thread.currentThread());<br>}</p>
<p>在思考这个问题之前，需要时刻认为CLH队列一直都在动态的变化中，head和tail随时会发生变化<br>在构建CLH链表时，是先设置head，然后设置tail，那么如果有null的情况只有head!=null &amp;&amp; tail==null<br>一旦在这个时刻添加尾节点成功，head.next 的值其实已经变化了，但是如果先获取head可能存在null的情况，所以先获取tail再获取head<br>3.3、当前运行的线程在哪里<br>不存放在CLH队列中，样例图中也并未展示出来，其一直处于运行中，主要CLH队列的head节点线程为null<br>3.4、节点的waitStatus和AQS的state的区别<br>两者表示的含义完全不一样，节点的waitStatus是表示节点状态，简洁的表达线程的状态，当其值大于0就认为该节点线程放弃竞争锁<br>AQS中的state表示该锁被占据的次数，某一时刻只能被一个线程一次或者多次占据，其他线程只能被挂起等待</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Android%20Bitmap%20%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/Android%20Bitmap%20%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Android Bitmap 详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-04 14:35:15" itemprop="dateCreated datePublished" datetime="2020-06-04T14:35:15+08:00">2020-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">性能优化</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Bitmap/" itemprop="url" rel="index"><span itemprop="name">Bitmap</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-Bitmap"><a href="#0-Bitmap" class="headerlink" title="0. Bitmap"></a>0. Bitmap</h4><p>Bitmap位图包括<strong>像素以及长、宽、颜色等描述信息</strong>。长宽和像素位数是用来描述图片的，可以通过这些信息计算出图片的像素占用内存的大小。</p>
<p>Android中创建Bitmap对象的方法主要是依赖<strong>BitmapFactory</strong></p>
<ul>
<li>public static Bitmap decodeFile(String pathName, Options opts)</li>
<li>public static Bitmap decodeFile(String pathName)</li>
<li>public static Bitmap decodeStream(InputStream is)</li>
<li>public static Bitmap decodeFileDescriptor(FileDescriptor fd)</li>
<li>public static Bitmap decodeResource(Resources res, int id)</li>
</ul>
<p>里面重载了很多带有<strong>Options opts</strong>参数的函数</p>
<h5 id="0-1-Config属性"><a href="#0-1-Config属性" class="headerlink" title="0.1. Config属性"></a>0.1. Config属性</h5><p>表示图片像素类型，包括ALPHA_8、RGB_565、ARGB_4444、ARGB_8888 A：透明度；RGB分别是Red、Green、Blue，三种原色</p>
<ul>
<li>ARGB_8888：四个通道都是8位，每个像素占用4个字节，图片质量是最高的，但是占用的内存也是最大的；</li>
<li>ARGB_4444：四个通道都是4位，每个像素占用2个字节，图片的失真比较严重；</li>
<li>RGB_565：没有A通道，每个像素占用2个字节，图片失真小，但是没有透明度；</li>
<li>ALPHA_8：只有A通道，每个像素占用1个字节大大小，只有透明度，没有颜色值。</li>
</ul>
<p>使用场景总结：ARGB_4444失真严重，基本不用；ALPHA_8使用场景特殊，比如设置遮盖效果等；不需要设置透明度，RGB_565是个不错的选择；既要设置透明度，对图片质量要求又高，就用ARGB_8888。</p>
<h5 id="0-2-CompressFormat"><a href="#0-2-CompressFormat" class="headerlink" title="0.2. CompressFormat"></a>0.2. CompressFormat</h5><p>图片的压缩格式总共有三种：Bitmap.CompressFormat.JPEG、Bitmap.CompressFormat.PNG、Bitmap.CompressFormat.WEBP</p>
<ul>
<li>JPEG：一种有损压缩（JPEG2000既可以有损也可以无损），”.jpg”或者”.jpeg”; 优点：采用了直接色，有丰富的色彩，适合存储照片和生动图像效果；缺点：有损，不适合用来存储logo、线框类图。</li>
<li>PNG: 一种无损压缩，”.png”; 优点：支持透明、无损，主要用于小图标，透明背景等；缺点：若色彩复杂，则图片生成后文件很大；</li>
<li>WEBP:以WebP算法进行压缩；Google开发的新的图片格式，同时支持无损和有损压缩，使用直接色。无损压缩，相同质量的webp比PNG小大约26%；有损压缩，相同质量的webp比JPEG小25%-34% 支持动图，基本取代gif</li>
</ul>
<h4 id="1-BitmapFactory-Options"><a href="#1-BitmapFactory-Options" class="headerlink" title="1. BitmapFactory.Options"></a>1. BitmapFactory.Options</h4><p><strong>BitmapFactory.Options 定义</strong></p>
<p>Options是BitmapFactory 的静态内部类，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class BitmapFactory &#123;</span><br><span class="line">    private static final int DECODE_BUFFER_SIZE &#x3D; 16 * 1024;</span><br><span class="line">    public static class Options &#123;</span><br><span class="line">		public Bitmap inBitmap;</span><br><span class="line">		public boolean inMutable;</span><br><span class="line">		public boolean inJustDecodeBounds;</span><br><span class="line">		public int inSampleSize;</span><br><span class="line">		&#x2F;&#x2F; 设置彩色模式</span><br><span class="line">		public Bitmap.Config inPreferredConfig &#x3D; Bitmap.Config.ARGB_8888;</span><br><span class="line">		public ColorSpace inPreferredColorSpace &#x3D; null;</span><br><span class="line">		public int outWidth;</span><br><span class="line">		public int outHeight;</span><br><span class="line">		&#x2F;&#x2F; 获取图像的Mime类型</span><br><span class="line">		public String outMimeType;</span><br><span class="line">		public int inDensity;</span><br><span class="line">		public int inTargetDensity;</span><br><span class="line">		public int inScreenDensity;</span><br><span class="line">		public boolean inScaled;</span><br><span class="line">		&#x2F;&#x2F; 设置缓存区,如果不设置默认为16M</span><br><span class="line">		public byte[] inTempStorage</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BitmapFactory.Options options = new BitmapFactory.Options();</p>
</blockquote>
<p><strong>Options 常用的参数含义</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认值为false，如果设置成true，那么在解码的时候就不会返回bitmap，即bitmap &#x3D; null。</span><br><span class="line">options.inJustDecodeBounds &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以复用之前用过的bitmap</span><br><span class="line">options.inBitmap &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是该bitmap缓存是否可变，如果设置为true，将可被inBitmap复用</span><br><span class="line">options.inMutable &#x3D; true;</span><br><span class="line"></span><br><span class="line">DisplayMetrics dm &#x3D; getResources().getDisplayMetrics();</span><br><span class="line">&#x2F;&#x2F;表示这个bitmap的像素密度，当inDensity为0时，系统默认赋值为屏幕当前像素密度</span><br><span class="line">options.inDensity &#x3D; dm.densityDpi;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示要被画出来时的目标像素密度，当inTargetDensity为0时，系统默认赋值为屏幕当前像素密度</span><br><span class="line">options.inTargetDensity &#x3D; options.inDensity;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示实际设备的像素密度</span><br><span class="line">options.inScreenDensity &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个参数可以改变bitmap分辨率大小，inSampleSize &gt;&#x3D; 1。</span><br><span class="line">&#x2F;&#x2F;当inSampleSize &lt; 1时，inSampleSize就默认是1。</span><br><span class="line">&#x2F;&#x2F;假如：图片的宽和高分别是width、height，那么图片解码生成的bitmap的宽度是：width &#x2F; inSampleSize，高度是：height &#x2F; inSampleSize</span><br><span class="line">&#x2F;&#x2F;inSampleSize影响bitmap的分辨率，从而影响bitmap占用内存的大小。</span><br><span class="line">options.inSampleSize &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置这个Bitmap是否可以被缩放，默认值是true，表示可以被缩放。</span><br><span class="line">options.inScaled &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>这里重点讲解一下<strong>inBitmap参数</strong></p>
<p>这个参数用来实现Bitmap内存的复用，但复用存在一些限制，具体体现在：<strong>在Android 4.4之前只能重用相同大小的Bitmap的内存，而Android 4.4及以后版本则只要后来的Bitmap比之前的小即可。</strong>使用inBitmap参数前，每创建一个Bitmap对象都会分配一块内存供其使用，而使用了inBitmap参数后，多个Bitmap可以复用一块内存，这样可以提高性能。<br>关于这个复用Bitmap内存的详细方法以及注意事项Android Developer网站已给出了详细的说明（Managing Bitmap Memory）。这里简单的贴出部分示例代码了解下它的大致用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static void addInBitmapOptions(BitmapFactory.Options options, ImageCache cache) &#123; </span><br><span class="line">  &#x2F;&#x2F; inBitmap only works with mutable bitmaps, so force the decoder to </span><br><span class="line">  &#x2F;&#x2F; return mutable bitmaps. </span><br><span class="line">  options.inMutable &#x3D; true; </span><br><span class="line">  if (cache !&#x3D; null) &#123; </span><br><span class="line">    &#x2F;&#x2F; Try to find a bitmap to use for inBitmap. </span><br><span class="line">    Bitmap inBitmap &#x3D; cache.getBitmapFromReusableSet(options); </span><br><span class="line">    if (inBitmap !&#x3D; null) &#123; </span><br><span class="line">      &#x2F;&#x2F; If a suitable bitmap has been found, </span><br><span class="line">      &#x2F;&#x2F; set it as the value of inBitmap. </span><br><span class="line">      options.inBitmap &#x3D; inBitmap; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static boolean canUseForInBitmap( Bitmap candidate, </span><br><span class="line">    BitmapFactory.Options targetOptions) &#123; </span><br><span class="line">  if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123; </span><br><span class="line">    &#x2F;&#x2F; From Android 4.4 (KitKat) onward we can re-use </span><br><span class="line">    &#x2F;&#x2F; if the byte size of the new bitmap is smaller than </span><br><span class="line">    &#x2F;&#x2F; the reusable bitmap candidate </span><br><span class="line">    &#x2F;&#x2F; allocation byte count. </span><br><span class="line">    int width &#x3D; targetOptions.outWidth &#x2F; targetOptions.inSampleSize; </span><br><span class="line">    int height &#x3D; targetOptions.outHeight &#x2F; targetOptions.inSampleSize; </span><br><span class="line">    int byteCount &#x3D; width * height * getBytesPerPixel(candidate.getConfig()); </span><br><span class="line">    return byteCount &lt;&#x3D; candidate.getAllocationByteCount(); </span><br><span class="line">  &#125; </span><br><span class="line">  &#x2F;&#x2F; On earlier versions, </span><br><span class="line">  &#x2F;&#x2F; the dimensions must match exactly and the inSampleSize must be 1 </span><br><span class="line">  return candidate.getWidth() &#x3D;&#x3D; targetOptions.outWidth </span><br><span class="line">      &amp;&amp; candidate.getHeight() &#x3D;&#x3D; targetOptions.outHeight </span><br><span class="line">      &amp;&amp; targetOptions.inSampleSize &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图片加载之前先计算图片大小</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap &#x3D; BitmapFactory.decodeFile(FileDirUtil.getInstance().getExternalStorageDirectory() + File.separator + &quot;temp.jpg&quot;);</span><br></pre></td></tr></table></figure>

<p>我们看一下上面的代码，那是解码一张本地图片，解码之后bitmap将占用内存空间，如果bitmap太大导致app性能降低，甚至导致OOM发生，为了防止这种现象，我们可以先计算本地图片的分辨率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">Bitmap bitmap &#x3D; BitmapFactory.decodeFile(FileDirUtil.getInstance().getExternalStorageDirectory() + File.separator + &quot;temp.jpg&quot;, options );</span><br><span class="line">int imageHeight &#x3D; options.outHeight;</span><br><span class="line">Log.d(TAG, &quot;图片的高度：&quot;+imageHeight);</span><br><span class="line">int imageWidth &#x3D; options.outWidth;</span><br><span class="line">Log.d(TAG, &quot;图片的宽度：&quot;+imageWidth);</span><br></pre></td></tr></table></figure>

<p>当inJustDecodeBounds设置true时，本地图片解码之后bitmap为null，只计算图片的宽度和高度。拿到图片宽度和高度之后可以根据我们自己的策略是否放大或缩小图片分辨率。</p>
<p><strong>像素密度分析</strong><br>BitmapFactory.Options中与像素密度有关的主要有三个参数：<strong>inDensity、inTargetDensity、inScreenDensity</strong>，配合inScaled参数可以控制图像缩放。</p>
<p>我们先看一下源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static void setDensityFromOptions(Bitmap outputBitmap, Options opts) &#123;</span><br><span class="line">    if (outputBitmap &#x3D;&#x3D; null || opts &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">    final int density &#x3D; opts.inDensity;</span><br><span class="line">    if (density !&#x3D; 0) &#123;</span><br><span class="line">        outputBitmap.setDensity(density);</span><br><span class="line">        final int targetDensity &#x3D; opts.inTargetDensity;</span><br><span class="line">        if (targetDensity &#x3D;&#x3D; 0 || density &#x3D;&#x3D; targetDensity || density &#x3D;&#x3D; opts.inScreenDensity) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] np &#x3D; outputBitmap.getNinePatchChunk();</span><br><span class="line">        final boolean isNinePatch &#x3D; np !&#x3D; null &amp;&amp; NinePatch.isNinePatchChunk(np);</span><br><span class="line">        if (opts.inScaled || isNinePatch) &#123;</span><br><span class="line">			&#x2F;&#x2F; 如果图片可以伸缩或者是9Patch，则设置图片的像素密度为targetDensity</span><br><span class="line">            outputBitmap.setDensity(targetDensity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (opts.inBitmap !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; bitmap复用过, 重新设置density值为屏幕默认像素密度</span><br><span class="line">		&#x2F;&#x2F; 相当于DisplayMetrics dm &#x3D; getResources().getDisplayMetrics(); </span><br><span class="line">		&#x2F;&#x2F; 获取屏幕像素密度：dm.densityDpi</span><br><span class="line">        outputBitmap.setDensity(Bitmap.getDefaultDensity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inDensity、inTargetDensity、inScreenDensity、inScaled配合使用可以对图片进行缩放，缩放的比例是targetDensity / density</p>
<h5 id="采样压缩示例"><a href="#采样压缩示例" class="headerlink" title="采样压缩示例"></a>采样压缩示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options &#x3D; new BitmapFactory.Options();  </span><br><span class="line">&#x2F;&#x2F;inJustDecodeBounds为true，不返回bitmap，只返回这个bitmap的尺寸  </span><br><span class="line">options.inJustDecodeBounds &#x3D; true; </span><br><span class="line">BitmapFactory.decodeResource(getResources(), images[position], options);  </span><br><span class="line">&#x2F;&#x2F;利用返回的原图片的宽高，我们就可以计算出缩放比inSampleSize（只能是2的整数次幂）</span><br><span class="line">options.inSampleSize &#x3D; caluelateInSampleSize(options, reqWidth, reqHeight);&#x2F;&#x2F;使用RGB_565减少图片大小  </span><br><span class="line">options.inPreferredConfig &#x3D; Bitmap.Config.RGB_565;  </span><br><span class="line">&#x2F;&#x2F;释放内存，共享引用（21版本后失效）  </span><br><span class="line">options.inPurgeable &#x3D; true;  </span><br><span class="line">options.inInputShareable &#x3D; true;  </span><br><span class="line">             </span><br><span class="line">&#x2F;&#x2F;inJustDecodeBounds为false，返回bitmap  </span><br><span class="line">options.inJustDecodeBounds &#x3D; false;  </span><br><span class="line">Bitmap bitmap &#x3D; BitmapFactory.decodeResource(getResources(), images[position], options);  </span><br><span class="line"></span><br><span class="line">private int calculateSampleSize(BitmapFactory.Options options,int reqWidth,int reqHeight)&#123;</span><br><span class="line">	int width &#x3D; options.outWidth;</span><br><span class="line">    int height &#x3D;options.outHeight;int inSampleSize &#x3D; 1;</span><br><span class="line">    int halfWidth &#x3D; width &#x2F; 2;</span><br><span class="line">    int halfHeight &#x3D; height &#x2F; 2;</span><br><span class="line">    while((halfWidth &#x2F; inSampleSize) &gt;&#x3D; reqWidth &amp;&amp; (halfHeight &#x2F; inSampleSize) &gt;&#x3D; reqHeight)&#123;</span><br><span class="line">        inSampleSize *&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用BitmapRegionDecoder区域加载器加载大图"><a href="#利用BitmapRegionDecoder区域加载器加载大图" class="headerlink" title="利用BitmapRegionDecoder区域加载器加载大图"></a>利用BitmapRegionDecoder区域加载器加载大图</h4><p>最主要的就是BitmapRegionDecode.newInstance(…)获取一个对象，然后通过这个对象去调用decodeRegion（…）得到bitmap，最后就可以显示在屏幕上了。考虑到用户可以触摸移动图像，我们用手势控制器GestureDetector来控制图片显示的区域。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/View%20%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/View%20%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/" class="post-title-link" itemprop="url">View 绘制与动画</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-04 10:53:39 / 修改时间：13:19:53" itemprop="dateCreated datePublished" datetime="2020-06-04T10:53:39+08:00">2020-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="View绘制onMeasure重载"><a href="#View绘制onMeasure重载" class="headerlink" title="View绘制onMeasure重载"></a>View绘制onMeasure重载</h4><p><strong>锁定宽高比Layout</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private float mRatio &#x3D; 16f &#x2F; 9;</span><br><span class="line">private boolean mIsWidthFollowsHeight;&#x2F;&#x2F;是否是宽度跟随高度变化，默认false，即默认高度跟随宽度变化</span><br><span class="line"></span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    if (mIsWidthFollowsHeight) &#123;</span><br><span class="line">        int height &#x3D; MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        int width &#x3D; (int) (height * mRatio + 0.5f);</span><br><span class="line">        super.onMeasure(MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY), heightMeasureSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int width &#x3D; MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int height &#x3D; (int) (width &#x2F; mRatio + 0.5f);</span><br><span class="line">        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RecyclerView 横向滑动冲突</strong></p>
<p>通过ACTION_DOWN的点击位置，以及ACTION_MOVE计算是否是横向滑动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent e) &#123;</span><br><span class="line">        ViewParent parent &#x3D; getParent();</span><br><span class="line">        if (parent &#x3D;&#x3D; null || !mIsInterceptTouchEvent) &#123;</span><br><span class="line">            if (parent !&#x3D; null) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(false);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onInterceptTouchEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line">        switch (e.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mDownX &#x3D; (int) e.getX();</span><br><span class="line">                mDownY &#x3D; (int) e.getY();</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(true);</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                float x &#x3D; e.getX();</span><br><span class="line">                float y &#x3D; e.getY();</span><br><span class="line">                float deltaX &#x3D; Math.abs(x - mDownX);</span><br><span class="line">                float deltaY &#x3D; Math.abs(y - mDownY);</span><br><span class="line">                if (deltaX &lt; mTouchSlop &amp;&amp; deltaY &lt; mTouchSlop) &#123;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(true);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    boolean isHorizontal &#x3D; deltaX &gt; deltaY * 2;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(isHorizontal);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通用下滑关闭RelativeLayout</strong></p>
<ol>
<li>解决事件拦截</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mDownX &#x3D; (int) ev.getRawX();</span><br><span class="line">            mDownY &#x3D; mTempY &#x3D; (int) ev.getRawY();</span><br><span class="line">            return false;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            int moveX &#x3D; (int) ev.getRawX();</span><br><span class="line">            int moveY &#x3D; (int) ev.getRawY();</span><br><span class="line">            &#x2F;&#x2F; 可以调整最小滑动识别距离</span><br><span class="line">            if (Math.abs(moveY - mDownY) &gt; mTouchSlop &amp;&amp; Math.abs(moveX - mDownX) &gt; mTouchSlop &#x2F; 10) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/Java%20wait%E3%80%81notify%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/Java%20wait%E3%80%81notify%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Java wait、notify实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 20:44:23" itemprop="dateCreated datePublished" datetime="2020-06-03T20:44:23+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java中的wait/notify/notifyAll可用来实现线程间通信，是Object类的方法，这三个方法都是native方法，是平台相关的，常用来实现生产者/消费者模式。先来我们来看下相关定义：</p>
<ul>
<li>wait() :调用该方法的线程进入WATTING状态，只有等待另外线程的通知或中断才会返回，调用wait()方法后，会释放对象的锁。</li>
<li>wait(long):超时等待最多long毫秒，如果没有通知就超时返回。</li>
<li>notify() : 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁。</li>
<li>notifyAll()：通知所有等待在该对象上的线程。</li>
</ul>
<h4 id="2个线程交替打印123456789"><a href="#2个线程交替打印123456789" class="headerlink" title="2个线程交替打印123456789"></a>2个线程交替打印123456789</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyDemo &#123;</span><br><span class="line">    private Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    private volatile int i &#x3D; 1;</span><br><span class="line">    </span><br><span class="line">    class Thread1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for (; i &lt; 10; ) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot; -&gt; &quot; + (i++));</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;打印完毕&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void test() &#123;</span><br><span class="line">        Thread1 t1 &#x3D; new Thread1();</span><br><span class="line">        t1.setName(&quot;线程A&quot;);</span><br><span class="line">        Thread1 t2 &#x3D; new Thread1();</span><br><span class="line">        t2.setName(&quot;线程B&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3个线程交替打印ABCABCABCABC"><a href="#3个线程交替打印ABCABCABCABC" class="headerlink" title="3个线程交替打印ABCABCABCABC"></a>3个线程交替打印ABCABCABCABC</h4><p>提示：采用3个lock对象锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="采用ArrayList-wait-notifyAll-实现生产者和消费者"><a href="#采用ArrayList-wait-notifyAll-实现生产者和消费者" class="headerlink" title="采用ArrayList + wait() + notifyAll() 实现生产者和消费者"></a>采用ArrayList + wait() + notifyAll() 实现生产者和消费者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">public class ConsumerDemo &#123;</span><br><span class="line">    private static CountDownLatch countDownLatch &#x3D; new CountDownLatch(4);</span><br><span class="line"></span><br><span class="line">    static class Buffer &#123;</span><br><span class="line">        private final int SIZE &#x3D; 5;</span><br><span class="line">        private ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        public synchronized int get() &#123;</span><br><span class="line">            while (list.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;消费者线程：&quot; + Thread.currentThread().getName()</span><br><span class="line">                            + &quot;进入阻塞状态，&quot; + &quot;当前缓冲区大小：&quot; + list.size());</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Integer data &#x3D; list.remove(0);</span><br><span class="line">            System.out.println(&quot;消费者线程：&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot;正在消费value &#x3D; &quot; + data);</span><br><span class="line">            notifyAll();</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public synchronized void put(Integer val) &#123;</span><br><span class="line">            while (list.size() &#x3D;&#x3D; SIZE) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;生产者线程：&quot; + Thread.currentThread().getName()</span><br><span class="line">                            + &quot;进入阻塞状态，&quot; + &quot;当前缓冲区大小：&quot; + list.size());</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(val);</span><br><span class="line">            System.out.println(&quot;生产者线程：&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot;正在生产数据value &#x3D; &quot; + val);</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Consumer implements Runnable &#123;</span><br><span class="line">        Buffer buffer;</span><br><span class="line"></span><br><span class="line">        public Consumer(Buffer buffer) &#123;</span><br><span class="line">            this.buffer &#x3D; buffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">                buffer.get();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Producer implements Runnable &#123;</span><br><span class="line">        Buffer buffer;</span><br><span class="line"></span><br><span class="line">        Producer(Buffer buffer) &#123;</span><br><span class="line">            this.buffer &#x3D; buffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">                buffer.put(i);</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Buffer buffer &#x3D; new Buffer();</span><br><span class="line">        Thread producer &#x3D; new Thread(new Producer(buffer), &quot;生产者&quot;);</span><br><span class="line">        Thread producer2 &#x3D; new Thread(new Producer(buffer), &quot;生产者2&quot;);</span><br><span class="line">        Thread consumer &#x3D; new Thread(new Consumer(buffer), &quot;消费者&quot;);</span><br><span class="line">        Thread consumer2 &#x3D; new Thread(new Consumer(buffer), &quot;消费者2&quot;);</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;程序运行结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue-实现"><a href="#LinkedBlockingQueue-实现" class="headerlink" title="LinkedBlockingQueue 实现"></a>LinkedBlockingQueue 实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer extends Thread &#123;</span><br><span class="line">    private Storage storage;</span><br><span class="line">    public Consumer(Storage storage) &#123;</span><br><span class="line">        this.storage &#x3D; storage;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Storage.Goods goods &#x3D; storage.goods.take();</span><br><span class="line">                System.out.printf(String.valueOf(storage.goods.size())+&quot;\\n&quot;);</span><br><span class="line">                Thread.sleep(300);</span><br><span class="line">                System.out.println(&quot;消费&quot; + &quot; &quot; + goods.getName());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Producer extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private Storage storage;</span><br><span class="line">    private int i &#x3D; 0;</span><br><span class="line">    public Producer(Storage storage) &#123;</span><br><span class="line">        this.storage &#x3D; storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                storage.goods.put(new Storage.Goods(&quot;苹果&quot;+ i));</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Storage &#123;</span><br><span class="line"></span><br><span class="line">    public static int MAX_COUNT &#x3D; 5;    &#x2F;&#x2F;容量为5</span><br><span class="line"></span><br><span class="line">    public BlockingQueue&lt;Goods&gt; goods &#x3D; new LinkedBlockingQueue&lt;Goods&gt;(MAX_COUNT);</span><br><span class="line">    public Storage() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Goods &#123;</span><br><span class="line">        int id;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Goods(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    public static Object obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        Storage storage &#x3D; new Storage();</span><br><span class="line">        Consumer consumer1 &#x3D; new Consumer(storage);</span><br><span class="line">        Consumer consumer2 &#x3D; new Consumer(storage);</span><br><span class="line">        Producer producer &#x3D; new Producer(storage);</span><br><span class="line"></span><br><span class="line">        service.submit(consumer1);</span><br><span class="line">        service.submit(consumer2);</span><br><span class="line">        service.submit(producer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考博客<br><a href="http://www.cnblogs.com/chengxiao/p/7043529.html" target="_blank" rel="noopener">1.Java线程间通信之wait/notify</a><br><a href="http://blog.csdn.net/zhuqiuhui/article/details/52083821" target="_blank" rel="noopener">2. Java并发之生产者-消费者几种实现</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java异常处理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 20:01:27 / 修改时间：20:04:20" itemprop="dateCreated datePublished" datetime="2020-06-03T20:01:27+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="JAVA异常机制"><a href="#JAVA异常机制" class="headerlink" title="JAVA异常机制"></a>JAVA异常机制</h4><h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>在Java中这种在程序中运行时可能出现的一些错误称为异常。Java处理异常时，如果某个方法抛出异常，既可以在当前方法中进行捕捉，然后处理该异常，也可以将异常向上抛出，由方法调用者来处理。异常产生后，如果不做任何处理，程序就会被终止。</p>
<h5 id="二、异常捕获和处理"><a href="#二、异常捕获和处理" class="headerlink" title="二、异常捕获和处理"></a>二、异常捕获和处理</h5><p><strong>1、Java异常处理涉及到五个关键字，分别是：try、catch、finally、throw、throws。</strong></p>
<ul>
<li>Try：可能发生异常的Java语句</li>
<li>Catch：激发被捕获的异常</li>
<li>finally：方法返回前总要执行的代码.</li>
<li>throw：用于抛出一个异常对象</li>
<li>throws：在声明方法时，用于指定该方法可能抛出的异常。</li>
</ul>
<p><strong>2、try、catch、finally三个语句块应注意的问题</strong></p>
<ul>
<li>第一、try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。</li>
<li>第二、try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。</li>
<li>第三、多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下。</li>
<li>第四、无论程序是否有异常，并且无论之间try-catch是否顺利执行完毕，都会执行finally语句。在以下特殊情况下，finally块不会执行：在finally语句块中发生异常；在前面代码中使用了System.exit()退出程序；程序所在线程死亡；关闭cpu。</li>
<li>第五、当程序执行try块，catch块时遇到return语句或者throw语句，这两个语句都会导致该方法立即结束，所以系统并不会立即执行这两个语句，而是去寻找该异常处理流程中的finally块，如果没有finally块，程序立即执行return语句或者throw语句，方法终止。如果有finally块，系统立即开始执行finally块，只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句，如果finally块里也使用了return或throw等导致方法终止的语句，则finally块已经终止了方法，不用再跳回去执行try块、catch块里的任何代码了。</li>
</ul>
<p><strong>3、throw与throws</strong></p>
<p>1、throws出现在方法函数头；而throw出现在函数体。throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</p>
<h5 id="三、异常结构"><a href="#三、异常结构" class="headerlink" title="三、异常结构"></a>三、异常结构</h5><p>Throwable类派生了两个子类。Error类用来描述Java运行系统中的内部错误以及资源耗尽的错误；Exception类为非致命性类，可以通过捕捉处理使程序继续执行。Exception类根据错误发生的原因分为运行时异常和检查异常。如图所示。</p>
<p><strong>1、检查异常</strong></p>
<p>检查异常是RuntimeException以外的异常（IOException、SQLException等），必须显示的地处理否则无法编译通过。处理方法有两种，一是用try…catch捕捉异常，二是使用throws声明抛出该异常。</p>
<p><strong>2、运行时异常</strong></p>
<p>运行时异常的特点是Java编译器不会检查它，程序中可以选择捕获处理，也可以不处理。</p>
<p><strong>3、错误</strong></p>
<p>Error（错误）:是程序无法处理的错误，表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。</p>
<h5 id="四、自定义异常"><a href="#四、自定义异常" class="headerlink" title="四、自定义异常"></a>四、自定义异常</h5><p>自定义异常只需编写一个类继承Exception类（Throwable及其子类均可）即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E7%B2%BE%E7%AE%80%E7%89%88LruCache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E7%B2%BE%E7%AE%80%E7%89%88LruCache/" class="post-title-link" itemprop="url">精简版LruCache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 19:56:42 / 修改时间：19:57:31" itemprop="dateCreated datePublished" datetime="2020-06-03T19:56:42+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java已经为我们提供了这种形式的数据结构-LinkedHashMap！它甚至提供可覆盖回收策略的方法。唯一需要我们注意的事情是，改链表的顺序是插入的顺序，而不是访问的顺序。但是，有一个构造函数提供了一个选项，可以使用访问的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public LRUCache extends LinkedHashMap &#123;</span><br><span class="line">  private int cacheSize;</span><br><span class="line"></span><br><span class="line">  public LRUCache(int cacheSize) &#123;</span><br><span class="line">    &#x2F;&#x2F;true for access-order, false for insertion-order</span><br><span class="line">    super(16, 0.75, true);</span><br><span class="line">    this.cacheSize &#x3D; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">    return size() &gt;&#x3D; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java线程池原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 19:30:49 / 修改时间：19:49:01" itemprop="dateCreated datePublished" datetime="2020-06-03T19:30:49+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>new Thread 的弊端：</p>
<ul>
<li>每次new Thread新建对象性能差</li>
<li>线程缺乏统一管理，可能无限制新建线程、相互之间竞争，可能占用过多的系统资源导致死机活着OOM</li>
<li>缺乏更多的功能，如定时执行、定期执行、线程中断</li>
</ul>
<p>线程池的好处：</p>
<ul>
<li>重用存在的线程、减少对象的创建、消亡的开销、性能佳</li>
<li>可有控制最大并发线程数、提高系统资源的利用率，同时避免过多的资源竞争、避免堵塞</li>
<li>提供定时、定期、单线程、并发数控制等功能</li>
</ul>
<h3 id="Java-线程池种类"><a href="#Java-线程池种类" class="headerlink" title="Java 线程池种类"></a>Java 线程池种类</h3><p>JDK 为我们内置了4种常见线程池的实现，均可以使用 Executors 工厂类创建。</p>
<ul>
<li>CachedThreadPool 用于并发执行大量短期的小任务，或者是负载较轻的服务器。</li>
<li>FixedThreadPool 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</li>
<li>SingleThreadExecutor 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行。</li>
<li>ScheduledThreadPoolExecutor 用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。</li>
<li>自定义线程池时，<ul>
<li>如果任务是 CPU 密集型（需要进行大量计算、处理），则应该配置尽量少的线程，比如 CPU 个数 + 1，这样可以避免出现每个线程都需要使用很长时间但是有太多线程争抢资源的情况； </li>
<li>如果任务是 IO密集型（主要时间都在 I/O，CPU 空闲时间比较多），则应该配置多一些线程，比如 CPU 数的两倍，这样可以更高地压榨 CPU。</li>
</ul>
</li>
</ul>
<p>为了错误避免创建过多线程导致系统奔溃，建议使用有界队列。因为它在无法添加更多任务时会拒绝任务，这样可以提前预警，避免影响整个系统。</p>
<p>执行时间、顺序有要求的话可以选择优先级队列，同时也要保证低优先级的任务有机会被执行。</p>
<p>创建线程池需要使用<strong>ThreadPoolExecutor</strong>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, &#x2F;&#x2F;核心线程的数量</span><br><span class="line">    int maximumPoolSize,    &#x2F;&#x2F;最大线程数量</span><br><span class="line">    long keepAliveTime,    &#x2F;&#x2F;超出核心线程数量以外的线程空余存活时间</span><br><span class="line">    TimeUnit unit,    &#x2F;&#x2F;存活时间的单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,    &#x2F;&#x2F;保存待执行任务的队列</span><br><span class="line">    ThreadFactory threadFactory,    &#x2F;&#x2F;创建新线程使用的工厂</span><br><span class="line">    RejectedExecutionHandler handler &#x2F;&#x2F; 当任务无法执行时的处理器</span><br><span class="line">    ) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>其核心的方法<strong>execute</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    &#x2F;&#x2F;1.当前池中线程比核心数少，新建一个线程执行任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;   </span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2.核心池已满，但任务队列未满，添加到队列中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   </span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))    </span><br><span class="line">        &#x2F;&#x2F;如果这时被关闭了，拒绝任务</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)    </span><br><span class="line">        &#x2F;&#x2F;如果之前的线程已被销毁完，新建一个线程</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;3.核心池已满，队列已满，试着创建一个新线程</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);    </span><br><span class="line">        &#x2F;&#x2F;如果创建新线程失败了，说明线程池被关闭或者线程池完全满了，拒绝任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下线程池的主要工作流程：</p>
<img src="/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/2169292-54031fde31b2a847.jpg" class="" title="[线程池的主要工作流程]">

<p>由于 1 和 3 新建线程时需要获取全局锁，这将严重影响性能。因此 ThreadPoolExecutor 这样的处理流程是为了在执行 execute() 方法时尽量少地执行 1 和 3，多执行 2。</p>
<p>在 ThreadPoolExecutor 完成预热后（当前线程数不少于核心线程数），几乎所有的 execute() 都是在执行步骤 2。</p>
<p>前面提到的 ThreadPoolExecutor 构造函数的参数，分别影响以下内容：</p>
<ul>
<li>corePoolSize：核心线程池数量<br>在线程数少于核心数量时，有新任务进来就新建一个线程，即使有的线程没事干<br>等超出核心数量后，就不会新建线程了，空闲的线程就得去任务队列里取任务执行了</li>
<li>maximumPoolSize：最大线程数量<br>包括核心线程池数量 + 核心以外的数量<br>如果任务队列满了，并且池中线程数小于最大线程数，会再创建新的线程执行任务</li>
<li>keepAliveTime：核心池以外的线程存活时间，即没有任务的外包的存活时间<br>如果给线程池设置 allowCoreThreadTimeOut(true)，则核心线程在空闲时头上也会响起死亡的倒计时<br>如果任务是多而容易执行的，可以调大这个参数，那样线程就可以在存活的时间里有更大可能接受新任务</li>
<li>workQueue：保存待执行任务的阻塞队列<br>不同的任务类型有不同的选择，下一小节介绍</li>
<li>threadFactory：每个线程创建的地方<br>可以给线程起个好听的名字，设置个优先级啥的</li>
<li>handler：饱和策略，大家都很忙，咋办呢，有四种策略 <ul>
<li>CallerRunsPolicy：只要线程池没关闭，就直接用调用者所在线程来运行任务</li>
<li>AbortPolicy：直接抛出 RejectedExecutionException 异常</li>
<li>DiscardPolicy：悄悄把任务放生，不做了</li>
<li>DiscardOldestPolicy：把队列里待最久的那个任务扔了，然后再调用execute() 试试看能行不</li>
<li>我们也可以实现自己的 RejectedExecutionHandler 接口自定义策略，比如如记录日志什么的</li>
</ul>
</li>
</ul>
<h3 id="保存待执行任务的阻塞队列"><a href="#保存待执行任务的阻塞队列" class="headerlink" title="保存待执行任务的阻塞队列"></a>保存待执行任务的阻塞队列</h3><p>当线程池中的核心线程数已满时，任务就要保存到队列中了。</p>
<p>线程池中使用的队列是 BlockingQueue 接口，常用的实现有如下几种：</p>
<ul>
<li>ArrayBlockingQueue：基于数组、有界，按FIFO（先进先出）原则对元素进行排序</li>
<li>LinkedBlockingQueue：基于链表，按FIFO （先进先出） 排序元素 <ul>
<li>吞吐量通常要高于 ArrayBlockingQueue               </li>
<li>Executors.newFixedThreadPool() 使用了这个队列</li>
</ul>
</li>
<li>SynchronousQueue：不存储元素的阻塞队列 <ul>
<li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>
<li>吞吐量通常要高于 LinkedBlockingQueue</li>
<li>Executors.newCachedThreadPool使用了这个队列</li>
</ul>
</li>
<li>PriorityBlockingQueue：具有优先级的、无限阻塞队列</li>
</ul>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolManager &#123;</span><br><span class="line">    private final String TAG &#x3D; this.getClass().getSimpleName();</span><br><span class="line">    private static final int CORE_POOL_SIZE &#x3D; Runtime.getRuntime().availableProcessors() * 2; </span><br><span class="line">    &#x2F;&#x2F; 核心线程数为 CPU数＊2</span><br><span class="line">    private static final int MAXIMUM_POOL_SIZE &#x3D; 64;    </span><br><span class="line">    &#x2F;&#x2F; 线程队列最大线程数</span><br><span class="line">    private static final int KEEP_ALIVE_TIME &#x3D; 1;    </span><br><span class="line">    &#x2F;&#x2F; 保持存活时间 1秒</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    ** 如果是要求高吞吐量的，可以使用 SynchronousQueue 队列；如果对执行顺序有要求，可以使用 PriorityBlockingQueue；如果最大积攒的待做任务有上限，可以使用 LinkedBlockingQueue</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private final BlockingQueue&lt;Runnable&gt; mWorkQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(128);</span><br><span class="line"></span><br><span class="line">    private final ThreadFactory DEFAULT_THREAD_FACTORY &#x3D; new ThreadFactory() &#123;</span><br><span class="line">        private final AtomicInteger mCount &#x3D; new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">        public Thread newThread(Runnable r) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(r, TAG + &quot; #&quot; + mCount.getAndIncrement());</span><br><span class="line">            thread.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            return thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ThreadPoolExecutor mExecutor &#x3D; new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS, mWorkQueue, DEFAULT_THREAD_FACTORY,</span><br><span class="line">            new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    private static volatile ThreadPoolManager mInstance &#x3D; new ThreadPoolManager();</span><br><span class="line"></span><br><span class="line">    public static ThreadPoolManager getInstance() &#123;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addTask(Runnable runnable) &#123;</span><br><span class="line">        mExecutor.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public void shutdownNow() &#123;</span><br><span class="line">        mExecutor.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两种提交任务的方法"><a href="#两种提交任务的方法" class="headerlink" title="两种提交任务的方法"></a>两种提交任务的方法</h3><p>ExecutorService 提供了两种提交任务的方法：</p>
<ul>
<li>execute()：提交不需要返回值的任务<br>execute() 的参数是一个 Runnable，也没有返回值。因此提交后无法判断该任务是否被线程池执行成功。</li>
<li>submit()：提交需要返回值的任务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
submit() 有三种重载，参数可以是 Callable 也可以是 Runnable。<br>同时它会返回一个 Funture 对象，通过它我们可以判断任务是否执行成功。<br>获得执行结果调用 Future.get()方法，这个方法会阻塞当前线程直到任务完成。<br>提交一个 Callable 任务时，需要使用 FutureTask 包一层<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FutureTask futureTask &#x3D; new FutureTask(new Callable&lt;String&gt;() &#123;    &#x2F;&#x2F;创建 Callable 任务</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        String result &#x3D; &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;?&gt; submit &#x3D; executor.submit(futureTask);    &#x2F;&#x2F;提交到线程池</span><br><span class="line">try &#123;</span><br><span class="line">    Object result &#x3D; submit.get();    &#x2F;&#x2F;获取结果</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>线程池即使不执行任务也会占用一些资源，所以在我们要退出任务时最好关闭线程池。</p>
<p>有两个方法关闭线程池：</p>
<ul>
<li>shutdown()<br>将线程池的状态设置为 SHUTDOWN，然后中断所有没有正在执行的线程</li>
<li>shutdownNow()<br>将线程池设置为 STOP，然后尝试停止所有线程，并返回等待执行任务的列表</li>
</ul>
<p>它们的共同点是：都是通过遍历线程池中的工作线程，逐个调用 Thread.interrup()来中断线程，所以一些无法响应中断的任务可能永远无法停止（比如 Runnable）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/Hexo%E4%BD%BF%E7%94%A8next.Pisces%E4%B8%BB%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/Hexo%E4%BD%BF%E7%94%A8next.Pisces%E4%B8%BB%E9%A2%98/" class="post-title-link" itemprop="url">Hexo使用next.Pisces主题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 17:53:16 / 修改时间：17:55:37" itemprop="dateCreated datePublished" datetime="2020-06-03T17:53:16+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前Hexo博客一直是使用的Jacman主题,用久的有点儿审美疲劳，最近看上比较简洁的主题Next,视觉上确实要好看很多,配色简洁看着比较舒服.</p>
<p>首先进入到你的博客的根目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ </span><br><span class="line">➜  Blog git:(master) ✗ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>接下来就是把主题配置成Next,修改博客根目录下的配置文件_config.yml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Extensions</span><br><span class="line"></span><br><span class="line"># Themes: http:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>然后启动博客就可以看到效果了.</p>
<p>修改next样式</p>
<p>不过默认的博客样式不是很好,一些标签页展示的不是很好,所以还需要改下样式.进入themes/next文件夹,修改_config.yml</p>
<p>修改导航菜单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">修改了这几个之后还不够,需要创建这几个的导航页面(home导航页为根目录不需要创建):</span><br><span class="line"></span><br><span class="line">创建归档页面</span><br><span class="line">创建页面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;hexo new page categories</span><br><span class="line">修改内容:</span><br></pre></td></tr></table></figure>
<p>title: 分类<br>date: 2018-05-14 23:34:12<br>type: “categories”</p>
<hr>
<p>创建标签页<br>创建标签页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;hexo new page tags</span><br><span class="line">修改内容:</span><br></pre></td></tr></table></figure>
<p>title: 标签<br>date: 2018-05-14 23:36:18<br>type: “tags”</p>
<hr>
<p>个人主页<br>创建个人主页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;hexo new page about</span><br><span class="line">修改内容:</span><br></pre></td></tr></table></figure>
<p>title: 个人简介<br>date: 2018-05-14 23:38:55</p>
<hr>
<p>切换主题布局<br>可以看到_config.yaml文件中默认是使用的Muse主题,这个主题是把标签之类的放到顶部,我更喜欢双栏布局，所以把对应部分改成下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>设置语言<br>默认语言在~/Blog/next/languages下面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  next git:(master) ✗ ls -l languages&#x2F;zh-*</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2100 5月  15 10:47 languages&#x2F;zh-CN.yml</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2094 5月  15 10:47 languages&#x2F;zh-HK.yml</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2094 5月  15 10:47 languages&#x2F;zh-TW.yml</span><br></pre></td></tr></table></figure>

<p>默认zh-CN.yml就已经给我们映射好了，只需要把博客设置成对应的语言,修改~/Blog/_config.yml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia&#x2F;Chongqing</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 12:56:07 / 修改时间：12:53:22" itemprop="dateCreated datePublished" datetime="2020-06-03T12:56:07+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1.什么是线程"></a>1.什么是线程</h2><p><strong>基本概念</strong></p>
<p>我们先从线程的基本概念开始，给大家复习一下，不知道有多少同学是基础不太好，说什么是线程都不知道的，如果这样的话，花时间去补初级内容的课。</p>
<p><img src="img/01_02.jpg" alt="01_02"></p>
<p>什么是叫一个进程？ 什么叫一个线程？ </p>
<ul>
<li><p>Program app -&gt;QQ.exe</p>
<p><strong>进程：</strong>做一个简单的解释，你的硬盘上有一个简单的程序，这个程序叫QQ.exe，这是一个程序，这个程序是一个静态的概念，它被扔在硬盘上也没人理他，但是当你双击它，弹出一个界面输入账号密码登录进去了，OK，这个时候叫做一个进程。进程相对于程序来说它是一个动态的概念</p>
<p><strong>线程：</strong>作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路径就叫做一个线程</p>
</li>
</ul>
<p><strong>示例：什么叫做线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_000;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_WhatIsThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.MICROSECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">"T1"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new T1().run();</span></span><br><span class="line">        <span class="keyword">new</span> T1().start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 观察上面程序的数据结果，你会看到字符串“T1”和“Main”的交替输出，这就是程序中有两条不同的执行路径在交叉执行，这就是直观概念上的线程，概念性的东西，理解就好，没有必要咬文嚼字的去背文字的定义。</p>
<h2 id="2-线程常用方法"><a href="#2-线程常用方法" class="headerlink" title="2.线程常用方法"></a>2.线程常用方法</h2><p><strong>我们来认识几个线程的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_000;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T03_Sleep_Yield_Join</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">					<span class="comment">//testSleep();</span></span><br><span class="line">					<span class="comment">//testYield();</span></span><br><span class="line">        testJoin();</span><br><span class="line">    &#125; </span><br><span class="line">		<span class="comment">/*Sleep,意思就是睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活的？由你的睡眠时间而定，等睡眠到规定的时间自动复活*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/*Yield,就是当前线程正在执行的时候停止下来进入等待队列，回到等待队列里在系统的调度算法里头呢还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testYield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) Thread.yield();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"------------B"</span> + i);</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">10</span> == <span class="number">0</span>) Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/*join， 意思就是在自己当前线程加入你调用Join的线程（），本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行（自己join自己没有意义） */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A"</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    <span class="comment">//TimeUnit.Milliseconds.sleep(500)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-启动线程的五种方式"><a href="#3-启动线程的五种方式" class="headerlink" title="3.启动线程的五种方式"></a>3.启动线程的五种方式</h2><p><strong>创建线程的几种方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_000;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_HowToCreateThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello MyThread!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello MyRun!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello MyCall"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动线程的5种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Lambda!"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyCall()));</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        service.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello ThreadPool"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>分享一道面试题</strong></p>
<p>请你告诉我启动线程的三种方式 ?<br>你说第一个：new Thread().start()； 第二个: new Thread(Runnable).start() 这没问题 ；那第三个呢，要回答线程池也是用的这两种之一，他这么问有些吹毛求疵的意思，你就可以说通过线程池也可以启动一个新的线程 3:Executors.newCachedThreadPool()或者FutureTask + Callable</p>
<h2 id="4-线程同步的基本概念"><a href="#4-线程同步的基本概念" class="headerlink" title="4.线程同步的基本概念"></a>4.线程同步的基本概念</h2><p><strong>synchronized</strong></p>
<p>下面我们来讲synchronized关键字，有不少同学已经耳熟能详了，不过作为复习还是要复习一下。第一个是多个线程去访问同一个资源的时候对这个资源上锁。</p>
<p>为什么要上锁呢？访问某一段代码或者某临界资源的时候是需要有一把锁的概念在这儿的。</p>
<p><img src="img/01_04.jpg" alt="01_04"></p>
<p>比如：我们对一个数字做递增，两个程序对它一块儿来做递增，递增就是把一个程序往上加1啊，如果两个线程共同访问的时候，第一个线程一读它是0，然后把它加1，在自己线程内部内存里面算还没有写回去的时候而第二个线程读到了它还是0，加1在写回去，本来加了两次，但还是1，那么我们在对这个数字递增的过程当中就上把锁，就是说第一个线程对这个数字访问的时候是独占的，不允许别的线程来访问，不允许别的线程来对它计算，我必须加完1收释放锁，其他线程才能对它继续加。</p>
<p>实质上，这把锁并不是对数字进行锁定的， 你可以任意指定，想锁谁就锁谁。</p>
<p>我第一个小程序是这么写的 ，如果说你想上了把锁之后才能对count进行减减访问，你可以new一个Object，所以这里锁定就是o，当我拿到这把锁的时候才能执行这段代码。是锁定的某一个对象，synchronized有一个锁升级的概念，我们一会儿会讲到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*synchronized关键字</span></span><br><span class="line"><span class="comment">*对某个对象加锁</span></span><br><span class="line"><span class="comment">*<span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_001;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(o) &#123; <span class="comment">//任何线程要想执行下面的代码，必须先拿到o的锁</span></span><br><span class="line">			count--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       </p>
<p>我们来谈一下synchronized它的一些特性。如果说你每次都定义个一个锁的对象Object o 把它new出来那加锁的时候太麻烦每次都要new一个新的对象出来，所以呢，有一个简单的方式就是<strong>synchronized(this)</strong>锁定当前对象就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_002;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; ߳<span class="comment">//任何线程想要执行那个下面的代码，必须先要拿到this的锁</span></span><br><span class="line">      count--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你要是锁定当前对象呢，你也可以写成如下方法。synchronized方法和synchronized(this)执行这段代码它是等值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_003;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//等同于在方法的代码执行时要synchronized(this)</span></span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道静态方法static是没有this对象的，你不需要new出一个对象来就能执行这个方法，但如果这个这个上面加一个synchronized的话就代表synchronized(T.class)。这里这个synchronized(T.class)锁的就是T类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_004;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123; <span class="comment">//这里等同于synchronized(T.class)</span></span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(T<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">//考虑一下这里写synchronized(this)是否可以？</span></span><br><span class="line">			count --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>问题：T.class是单例的吗？</strong></p>
<p>一个class load到内存它是不是单例的，想想看。一般情况下是，如果是在同一个ClassLoader空间那它一定是。不是同一个类加载器就不是了，不同的类加载器互相之间也不能访问。所以说你能访问它，那他一定就是单例</p>
<p>下面程序：很有可能读不到别的线程修改过的内容，除了这点之外count减减完了之后下面的count输出和你减完的结果不对，很容易分析：如果有一个线程把它从10减到9了，然后又有一个线程在前面一个线程还没有输出呢进来了把9又减到了8，继续输出的8，而不是9。如果你想修正它，前面第一个是在上面加volatile，改了马上就能得到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析一下这个程序的输出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_005;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="comment">/*volatile*/</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">new</span> T();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外这个之外还可以加synchronized，加了synchronized就没有必要在加volatile了，因为synchronized既保证了原子性，又保证了可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对比上一个小程序</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_006;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">			T t = <span class="keyword">new</span> T();</span><br><span class="line">			<span class="keyword">new</span> Thread(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如下代码：同步方法和非同步方法是否可以同时调用？就是我有一个synchronized的m1方法，我调用m1的时候能不能调用m2，拿大腿想一想这个是肯定可以的，线程里面访问m1的时候需要加锁，可是访问m2的时候我又不需要加锁，所以允许执行m2。</p>
<p>这些小实验的设计是比较考验功力的，学习线程的时候自己要多动手进行试验，任何一个理论，都可以进行验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *同步和非同步方法是否可以同时调用？</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_007;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start..."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m2 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">new</span> T();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*new Thread(()-&gt;t.m1(), "t1").start();</span></span><br><span class="line"><span class="comment">		new Thread(()-&gt;t.m2(), "t2").start();*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(t::m1, <span class="string">"t1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(t::m2, <span class="string">"t2"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//1.8之前的写法</span></span><br><span class="line"><span class="comment">		new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			@Override</span></span><br><span class="line"><span class="comment">			public void run() &#123;</span></span><br><span class="line"><span class="comment">				t.m1();</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们在来看一个synchronized应用的例子</p>
<p>我们定义了一个class账户，有名称、余额。写方法给哪个用户设置它多少余额，读方法通过这个名字得到余额值。如果我们给写方法加锁，给读方法不加锁，你的业务允许产生这种问题吗？业务说我中间读到了一些不太好的数据也没关系，如果不允许客户读到中间不好的数据那这个就有问题。正因为我们加了锁的方法和不加锁的方法可以同时运行。</p>
<p><strong>问题</strong>比如说：张三，给他设置100块钱启动了，睡了1毫秒之后呢去读它的值，然后再睡2秒再去读它的值这个时候你会看到读到的值有问题，原因是在设定的过程中this.name你中间睡了一下，这个过程当中我模拟了一个线程来读，这个时候调用的是getBalance方法，而调用这个方法的时候是不用加锁的，所以说我不需要等你整个过程执行完就可以读到你中间结果产生的内存，这个现象就叫做脏读。这问题的产生就是synchronized方法和非synchronized方法是同时运行的。<strong>解决</strong>就是把getBalance加上synchronized就可以了，如果你的业务允许脏读，就可以不用加锁，加锁之后的效率低下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：模拟银行账户</span></span><br><span class="line"><span class="comment"> * 对业务写方法加锁</span></span><br><span class="line"><span class="comment"> * 对业务读方法不加锁</span></span><br><span class="line"><span class="comment"> * 这样行不行？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 容易产生脏读问题（dirtyRead）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">double</span> balance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">double</span> <span class="title">getBalance</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Account a = <span class="keyword">new</span> Account();</span><br><span class="line">		<span class="keyword">new</span> Thread(()-&gt;a.set(<span class="string">"zhangsan"</span>, <span class="number">100.0</span>)).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再来看synchronized的另外一个属性：可重入，是synchronized必须了解的一个概念。</p>
<p>如果是一个同步方法调用另外一个同步方法，有一个方法加了锁，另外一个方法也需要加锁，加的是同一把锁也是同一个线程，那这个时候申请仍然会得到该对象的锁。比如说是synchronized可重入的，有一个方法m1 是synchronized有一个方法m2也是synchrionzed，m1里能不能调m2。我们m1开始的时候这个线程得到了这把锁，然后在m1里面调用m2，如果说这个时候不允许任何线程再来拿这把锁的时候就死锁了。这个时候调m2它发现是同一个线程，因为你m2也需要申请这把锁，它发现是同一个线程申请的这把锁，允许，可以没问题，这就叫可重入锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。</span></span><br><span class="line"><span class="comment"> * 也就是说synchronized获得锁是可重入的</span></span><br><span class="line"><span class="comment"> * synchronized</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mashibing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_009;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		m2();</span><br><span class="line">		System.out.println(<span class="string">"m1 end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"m2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> T().m1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模拟一个父类子类的概念，父类synchronized，子类调用super.m的时候必须得可重入，否则就会出问题（调用父类是同一把锁）。所谓的重入锁就是你拿到这把锁之后不停加锁加锁，加好几道，但锁定的还是同一个对象，去一道就减个1，就是这么个概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_010;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> TT().m();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TT</span> <span class="keyword">extends</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"child m start"</span>);</span><br><span class="line">		<span class="keyword">super</span>.m();</span><br><span class="line">		System.out.println(<span class="string">"child m end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
