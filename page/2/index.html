<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/07/JSBridge%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/07/JSBridge%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">JsBridge 源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-07 15:21:38 / 修改时间：16:48:49" itemprop="dateCreated datePublished" datetime="2021-02-07T15:21:38+08:00">2021-02-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、JsBridge-简介"><a href="#一、JsBridge-简介" class="headerlink" title="一、JsBridge 简介"></a>一、JsBridge 简介</h2><h3 id="1-1-集成"><a href="#1-1-集成" class="headerlink" title="1.1 集成"></a>1.1 集成</h3><p>JsBridge <a href="https://github.com/lzyzsd/JsBridge" target="_blank" rel="noopener">源码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123; url &quot;https:&#x2F;&#x2F;jitpack.io&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &#39;com.github.lzyzsd:jsbridge:1.0.4&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">webView.registerHandler(&quot;submitFromWeb&quot;, new BridgeHandler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handler(String data, CallBackFunction function) &#123;</span><br><span class="line">        Log.i(TAG, &quot;handler &#x3D; submitFromWeb, data from web &#x3D; &quot; + data);</span><br><span class="line">        function.onCallBack(&quot;submitFromWeb exe, response data from Java&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">WebViewJavascriptBridge.callHandler(</span><br><span class="line">    &#39;submitFromWeb&#39;</span><br><span class="line">    , &#123;&#39;param&#39;: str1&#125;</span><br><span class="line">    , function(responseData) &#123;</span><br><span class="line">        document.getElementById(&quot;show&quot;).innerHTML &#x3D; &quot;send get responseData from java, data &#x3D; &quot; + responseData</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">webView.callHandler(&quot;functionInJs&quot;, new Gson().toJson(user), new CallBackFunction() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCallBack(String data) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="二、JsBridge-源码"><a href="#二、JsBridge-源码" class="headerlink" title="二、JsBridge 源码"></a>二、JsBridge 源码</h2><h3 id="2-1-BridgeWebView-源码"><a href="#2-1-BridgeWebView-源码" class="headerlink" title="2.1 BridgeWebView 源码"></a>2.1 BridgeWebView 源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class BridgeWebView extends WebView implements WebViewJavascriptBridge &#123;</span><br><span class="line">    &#x2F;&#x2F; 缓存向WebView注册的方法，以及回调</span><br><span class="line">    Map&lt;String, BridgeHandler&gt; messageHandlers &#x3D; new HashMap&lt;String, BridgeHandler&gt;();</span><br><span class="line">    Map&lt;String, CallBackFunction&gt; responseCallbacks &#x3D; new HashMap&lt;String, CallBackFunction&gt;();</span><br><span class="line">	</span><br><span class="line">    public BridgeWebView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">		super(context, attrs);</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    private void init() &#123;</span><br><span class="line">		this.setVerticalScrollBarEnabled(false);</span><br><span class="line">		this.setHorizontalScrollBarEnabled(false);</span><br><span class="line">		this.getSettings().setJavaScriptEnabled(true);</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            WebView.setWebContentsDebuggingEnabled(true);</span><br><span class="line">        &#125;</span><br><span class="line">		this.setWebViewClient(generateBridgeWebViewClient());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    protected BridgeWebViewClient generateBridgeWebViewClient() &#123;</span><br><span class="line">        return new BridgeWebViewClient(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 注册方法</span><br><span class="line">	public void registerHandler(String handlerName, BridgeHandler handler) &#123;</span><br><span class="line">		if (handler !&#x3D; null) &#123;</span><br><span class="line">			messageHandlers.put(handlerName, handler);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 执行</span><br><span class="line">	public void callHandler(String handlerName, String data, CallBackFunction callBack) &#123;</span><br><span class="line">        doSend(handlerName, data, callBack);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void doSend(String handlerName, String data, CallBackFunction responseCallback) &#123;</span><br><span class="line">		Message m &#x3D; new Message();</span><br><span class="line">		if (!TextUtils.isEmpty(data)) &#123;</span><br><span class="line">			m.setData(data);</span><br><span class="line">		&#125;</span><br><span class="line">		if (responseCallback !&#x3D; null) &#123;</span><br><span class="line">			String callbackStr &#x3D; String.format(&quot;javascript:WebViewJavascriptBridge._handleMessageFromNative(&#39;%s&#39;);&quot;, ++uniqueId + (BridgeUtil.UNDERLINE_STR + SystemClock.currentThreadTimeMillis()));</span><br><span class="line">			responseCallbacks.put(callbackStr, responseCallback);</span><br><span class="line">			m.setCallbackId(callbackStr);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!TextUtils.isEmpty(handlerName)) &#123;</span><br><span class="line">			m.setHandlerName(handlerName);</span><br><span class="line">		&#125;</span><br><span class="line">		queueMessage(m);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void queueMessage(Message m) &#123;</span><br><span class="line">		if (startupMessage !&#x3D; null) &#123;</span><br><span class="line">			startupMessage.add(m);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			dispatchMessage(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	void dispatchMessage(Message m) &#123;</span><br><span class="line">        String messageJson &#x3D; m.toJson();</span><br><span class="line">        messageJson &#x3D; messageJson.replaceAll(&quot;(\\\\)([^utrn])&quot;, &quot;\\\\\\\\$1$2&quot;);</span><br><span class="line">        messageJson &#x3D; messageJson.replaceAll(&quot;(?&lt;&#x3D;[^\\\\])(\&quot;)&quot;, &quot;\\\\\&quot;&quot;);</span><br><span class="line">        String javascriptCommand &#x3D; String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);</span><br><span class="line">        if (Thread.currentThread() &#x3D;&#x3D; Looper.getMainLooper().getThread()) &#123;</span><br><span class="line">            this.loadUrl(javascriptCommand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理页面返回数据</span><br><span class="line">	void handlerReturnData(String url) &#123;</span><br><span class="line">		String functionName &#x3D; BridgeUtil.getFunctionFromReturnUrl(url);</span><br><span class="line">		CallBackFunction f &#x3D; responseCallbacks.get(functionName);</span><br><span class="line">		String data &#x3D; BridgeUtil.getDataFromReturnUrl(url);</span><br><span class="line">		if (f !&#x3D; null) &#123;</span><br><span class="line">			f.onCallBack(data);</span><br><span class="line">			responseCallbacks.remove(functionName);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-BridgeWebViewClient源码"><a href="#2-2-BridgeWebViewClient源码" class="headerlink" title="2.2 BridgeWebViewClient源码"></a>2.2 BridgeWebViewClient源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class BridgeWebViewClient extends WebViewClient &#123;</span><br><span class="line">    private BridgeWebView webView;</span><br><span class="line"></span><br><span class="line">    public BridgeWebViewClient(BridgeWebView webView) &#123;</span><br><span class="line">        this.webView &#x3D; webView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            url &#x3D; URLDecoder.decode(url, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (url.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果是返回数据</span><br><span class="line">            webView.handlerReturnData(url);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (url.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; </span><br><span class="line">            &#x2F;&#x2F; 刷新消息列队</span><br><span class="line">            webView.flushMessageQueue();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">        super.onPageFinished(view, url);</span><br><span class="line">        if (BridgeWebView.toLoadJs !&#x3D; null) &#123;</span><br><span class="line">            BridgeUtil.webViewLoadLocalJs(view, BridgeWebView.toLoadJs);</span><br><span class="line">        &#125;</span><br><span class="line">        if (webView.getStartupMessage() !&#x3D; null) &#123;</span><br><span class="line">            for (Message m : webView.getStartupMessage()) &#123;</span><br><span class="line">                webView.dispatchMessage(m);</span><br><span class="line">            &#125;</span><br><span class="line">            webView.setStartupMessage(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/04/xCrash-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/xCrash-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">xCrash 源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-04 17:12:34" itemprop="dateCreated datePublished" datetime="2021-02-04T17:12:34+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、-xCrash介绍"><a href="#一、-xCrash介绍" class="headerlink" title="一、 xCrash介绍"></a>一、 xCrash介绍</h2><p>xCrash 能为安卓 app 提供捕获 java 崩溃，native 崩溃和 ANR 的能力。不需要 root 权限或任何系统权限。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>支持 Android 4.1 - 11（API level 16 - 30）。</li>
<li>支持 armeabi-v7a，arm64-v8a，x86 和 x86_64。</li>
<li>捕获 java 崩溃，native 崩溃和 ANR。</li>
<li>获取详细的进程、线程、内存、FD、网络统计信息。</li>
<li>通过正则表达式设置需要获取哪些线程的信息。</li>
<li>不需要 root 权限或任何系统权限。</li>
</ul>
<h2 id="二、xCrash集成"><a href="#二、xCrash集成" class="headerlink" title="二、xCrash集成"></a>二、xCrash集成</h2><ol>
<li><p>在app目录下面的build.gradle添加依赖库支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters &#39;armeabi-v7a&#39;, &#39;arm64-v8a&#39;, &#39;x86&#39;, &#39;x86_64&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;    </span><br><span class="line">    implementation &#39;com.iqiyi.xcrash:xcrash-android-lib:3.0.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>xCrash初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在Application的onCreate方法里进行初始化</span><br><span class="line">xcrash.XCrash.init(this);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="三、xCrash-源码"><a href="#三、xCrash-源码" class="headerlink" title="三、xCrash 源码"></a>三、xCrash 源码</h2><h3 id="1-xcrash-XCrash-init-this"><a href="#1-xcrash-XCrash-init-this" class="headerlink" title="1. xcrash.XCrash.init(this)"></a>1. xcrash.XCrash.init(this)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class XCrash &#123;</span><br><span class="line">    </span><br><span class="line">    public static int init(Context ctx) &#123;</span><br><span class="line">        return init(ctx, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized int init(Context ctx, InitParameters params) &#123;</span><br><span class="line">        &#x2F;&#x2F; 参数初始化</span><br><span class="line">        ......</span><br><span class="line">        &#x2F;&#x2F; [重要] Java层Crash监控</span><br><span class="line">        JavaCrashHandler.getInstance().initialize(...);</span><br><span class="line">        &#x2F;&#x2F; [重要] 应用ANR监控</span><br><span class="line">        AnrHandler.getInstance().initialize(...);</span><br><span class="line">        &#x2F;&#x2F; [重要] Native层Crash监控</span><br><span class="line">        NativeHandler.getInstance().initialize(...);</span><br><span class="line">        &#x2F;&#x2F; 读写文件辅助类</span><br><span class="line">        FileManager.getInstance().maintain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-JavaCrashHandler"><a href="#2-JavaCrashHandler" class="headerlink" title="2. JavaCrashHandler"></a>2. JavaCrashHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class JavaCrashHandler implements UncaughtExceptionHandler &#123;</span><br><span class="line">    private UncaughtExceptionHandler defaultHandler &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    void initialize(...) &#123;</span><br><span class="line">        this.defaultHandler &#x3D; Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread thread, Throwable throwable) &#123;</span><br><span class="line">        if (defaultHandler !&#x3D; null) &#123;</span><br><span class="line">            Thread.setDefaultUncaughtExceptionHandler(defaultHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        handleException(thread, throwable);</span><br><span class="line">        if (this.rethrow) &#123;</span><br><span class="line">            if (defaultHandler !&#x3D; null) &#123;</span><br><span class="line">                defaultHandler.uncaughtException(thread, throwable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ActivityMonitor.getInstance().finishAllActivities();</span><br><span class="line">            Process.killProcess(this.pid);</span><br><span class="line">            System.exit(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void handleException(Thread thread, Throwable throwable) &#123;</span><br><span class="line">        StringWriter sw &#x3D; new StringWriter();</span><br><span class="line">        PrintWriter pw &#x3D; new PrintWriter(sw);</span><br><span class="line">        throwable.printStackTrace(pw);</span><br><span class="line">        String stacktrace &#x3D; sw.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-AnrHandler"><a href="#3-AnrHandler" class="headerlink" title="3. AnrHandler"></a>3. AnrHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class AnrHandler &#123;</span><br><span class="line">    private FileObserver fileObserver &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    void initialize(...) &#123;</span><br><span class="line">        &#x2F;&#x2F; [重要] &lt; Android 5.0 以下可以访问&#x2F;data&#x2F;anr目录</span><br><span class="line">        fileObserver &#x3D; new FileObserver(&quot;&#x2F;data&#x2F;anr&#x2F;&quot;, FileObserver.CLOSE_WRITE) &#123;</span><br><span class="line">            public void onEvent(int event, String path) &#123;</span><br><span class="line">                if (path !&#x3D; null) &#123;</span><br><span class="line">                    String filepath &#x3D; &quot;&#x2F;data&#x2F;anr&#x2F;&quot; + path;</span><br><span class="line">                    if (filepath.contains(&quot;trace&quot;)) &#123;</span><br><span class="line">                        handleAnr(filepath);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        fileObserver.startWatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [重要] Android 5.0以上实际上是捕获了SIGQUIT信号，这个是Android App发生ANR时由ActivityMangerService向App发送的信号。</span><br><span class="line">int xcc_signal_trace_register(void (*handler)(int, siginfo_t *, void *))</span><br><span class="line">&#123;</span><br><span class="line">    int              r;</span><br><span class="line">    sigset_t         set;</span><br><span class="line">    struct sigaction act;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;un-block the SIGQUIT mask for current thread, hope this is the main thread</span><br><span class="line">    sigemptyset(&amp;set);</span><br><span class="line">    sigaddset(&amp;set, SIGQUIT);</span><br><span class="line">    if(0 !&#x3D; (r &#x3D; pthread_sigmask(SIG_UNBLOCK, &amp;set, &amp;xcc_signal_trace_oldset))) return r;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;register new signal handler for SIGQUIT</span><br><span class="line">    memset(&amp;act, 0, sizeof(act));</span><br><span class="line">    sigfillset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_sigaction &#x3D; handler;</span><br><span class="line">    act.sa_flags &#x3D; SA_RESTART | SA_SIGINFO;</span><br><span class="line">    if(0 !&#x3D; sigaction(SIGQUIT, &amp;act, &amp;xcc_signal_trace_oldact))</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_sigmask(SIG_SETMASK, &amp;xcc_signal_trace_oldset, NULL);</span><br><span class="line">        return XCC_ERRNO_SYS;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-NativeHandler"><a href="#4-NativeHandler" class="headerlink" title="4. NativeHandler"></a>4. NativeHandler</h3><p>Native层崩溃捕获建议提前参考：<a href="https://www.cnblogs.com/mingfeng002/p/9118253.html" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class NativeHandler &#123;</span><br><span class="line">    int initialize(...) &#123;</span><br><span class="line">        System.loadLibrary(&quot;xcrash&quot;);</span><br><span class="line">        int r &#x3D; nativeInit(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 映射 xc_jni_init函数</span><br><span class="line">    private static native int nativeInit(...) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 映射 xc_jni_notify_java_crashed函数</span><br><span class="line">    private static native void nativeNotifyJavaCrashed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static jint xc_jni_init(JNIEnv *env, jobject thiz,) &#123;</span><br><span class="line">    xc_crash_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int xc_crash_init(JNIEnv *env,...) &#123;</span><br><span class="line">    xcc_signal_crash_register(xc_crash_signal_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void xc_crash_signal_handler(int sig, siginfo_t *si, void *uc) &#123;</span><br><span class="line">    pid_t dumper_pid &#x3D; xc_crash_fork(xc_crash_exec_dumper);</span><br><span class="line">    if(-1 &#x3D;&#x3D; dumper_pid) &#123;</span><br><span class="line">        xcc_util_write_format_safe(xc_crash_log_fd, XC_CRASH_ERR_TITLE&quot;fork failed, errno&#x3D;%d\n\n&quot;, errno);</span><br><span class="line">        goto end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;parent process ...</span><br><span class="line">    int wait_r &#x3D; XCC_UTIL_TEMP_FAILURE_RETRY(waitpid(dumper_pid, &amp;status, __WALL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static xcc_signal_crash_info_t xcc_signal_crash_info[] &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">    &#123;.signum &#x3D; SIGABRT&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGBUS&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGFPE&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGILL&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGSEGV&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGTRAP&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGSYS&#125;,</span><br><span class="line">    &#123;.signum &#x3D; SIGSTKFLT&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int xcc_signal_crash_register(void (*handler)(int, siginfo_t *, void *))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 设置额外栈空间，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文</span><br><span class="line">    stack_t ss;</span><br><span class="line">    if(NULL &#x3D;&#x3D; (ss.ss_sp &#x3D; calloc(1, XCC_SIGNAL_CRASH_STACK_SIZE))) return XCC_ERRNO_NOMEM;</span><br><span class="line">    ss.ss_size  &#x3D; XCC_SIGNAL_CRASH_STACK_SIZE;</span><br><span class="line">    ss.ss_flags &#x3D; 0;</span><br><span class="line">    if(0 !&#x3D; sigaltstack(&amp;ss, NULL)) return XCC_ERRNO_SYS;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置信号处理函数</span><br><span class="line">    struct sigaction act;</span><br><span class="line">    memset(&amp;act, 0, sizeof(act));</span><br><span class="line">    sigfillset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_sigaction &#x3D; handler;</span><br><span class="line">    act.sa_flags &#x3D; SA_RESTART | SA_SIGINFO | SA_ONSTACK;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 注册信号量</span><br><span class="line">    size_t i;</span><br><span class="line">    for(i &#x3D; 0; i &lt; sizeof(xcc_signal_crash_info) &#x2F; sizeof(xcc_signal_crash_info[0]); i++)</span><br><span class="line">        if(0 !&#x3D; sigaction(xcc_signal_crash_info[i].signum, &amp;act, &amp;(xcc_signal_crash_info[i].oldact)))</span><br><span class="line">            return XCC_ERRNO_SYS;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/04/BlockCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/04/BlockCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">BlockCanary 源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-04 14:34:48 / 修改时间：16:55:53" itemprop="dateCreated datePublished" datetime="2021-02-04T14:34:48+08:00">2021-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、-BlockCanary介绍"><a href="#一、-BlockCanary介绍" class="headerlink" title="一、 BlockCanary介绍"></a>一、 BlockCanary介绍</h2><p>BlockCanary是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。</p>
<h2 id="二、BlockCanary集成"><a href="#二、BlockCanary集成" class="headerlink" title="二、BlockCanary集成"></a>二、BlockCanary集成</h2><ol>
<li><p>在app目录下面的build.gradle添加依赖库支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;    </span><br><span class="line">    debugImplementation &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;</span><br><span class="line">    releaseImplementation &#39;com.github.markzhai:blockcanary-no-op:1.5.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BlockCanary初始化以及自定义监控下上文配置(可选)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在Application的onCreate方法里进行初始化</span><br><span class="line">BlockCanary.install(this, new AppBlockCanaryContext()).start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义监控下上文</span><br><span class="line">public class AppBlockCanaryContext extends BlockCanaryContext &#123;</span><br><span class="line">    public int provideMonitorDuration() &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean displayNotification() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String providePath() &#123;</span><br><span class="line">        return &quot;&#x2F;blockcanary&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; provideWhiteList() &#123;</span><br><span class="line">        LinkedList&lt;String&gt; whiteList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        whiteList.add(&quot;org.chromium&quot;);</span><br><span class="line">        return whiteList;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="三、BlockCanary-源码"><a href="#三、BlockCanary-源码" class="headerlink" title="三、BlockCanary 源码"></a>三、BlockCanary 源码</h2><h3 id="1-BlockCanary-install-this-new-AppBlockCanaryContext-start"><a href="#1-BlockCanary-install-this-new-AppBlockCanaryContext-start" class="headerlink" title="1. BlockCanary#install(this, new AppBlockCanaryContext()).start();"></a>1. BlockCanary#install(this, new AppBlockCanaryContext()).start();</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public final class BlockCanary &#123;</span><br><span class="line">    public static BlockCanary install(Context context, BlockCanaryContext blockCanaryContext) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化BlockCanaryContext里面的sApplicationContext、sInstance</span><br><span class="line">        BlockCanaryContext.init(context, blockCanaryContext);</span><br><span class="line">        &#x2F;&#x2F; 设置DisplayActivity是否可用，根据自定义displayNotification()判断</span><br><span class="line">        setEnabled(context, DisplayActivity.class, BlockCanaryContext.get().displayNotification());</span><br><span class="line">        &#x2F;&#x2F; 初始化BlockCanary对象</span><br><span class="line">        return get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 源码里面没有volatile关键字???</span><br><span class="line">    private static volatile BlockCanary sInstance;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 双重校验锁</span><br><span class="line">    public static BlockCanary get() &#123;</span><br><span class="line">        if (sInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (BlockCanary.class) &#123;</span><br><span class="line">                if (sInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    sInstance &#x3D; new BlockCanary();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private BlockCanary() &#123;</span><br><span class="line">        BlockCanaryInternals.setContext(BlockCanaryContext.get());</span><br><span class="line">        mBlockCanaryCore &#x3D; BlockCanaryInternals.getInstance();</span><br><span class="line">        &#x2F;&#x2F; 1. 添加用户自定义Block拦截器</span><br><span class="line">        mBlockCanaryCore.addBlockInterceptor(BlockCanaryContext.get());</span><br><span class="line">        if (!BlockCanaryContext.get().displayNotification()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 2. 添加DisplayService拦截器,当发生卡顿的时候，用于显示给用户</span><br><span class="line">        mBlockCanaryCore.addBlockInterceptor(new DisplayService());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean mMonitorStarted &#x3D; false;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        if (!mMonitorStarted) &#123;</span><br><span class="line">            mMonitorStarted &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; [**重要**]设置Looper自定义Printer</span><br><span class="line">            Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-BlockCanaryInternals"><a href="#2-BlockCanaryInternals" class="headerlink" title="2. BlockCanaryInternals"></a>2. BlockCanaryInternals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public final class BlockCanaryInternals &#123;</span><br><span class="line">    LooperMonitor monitor;</span><br><span class="line">    &#x2F;&#x2F; 卡顿拦截器集合</span><br><span class="line">    private List&lt;BlockInterceptor&gt; mInterceptorChain &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public BlockCanaryInternals() &#123;</span><br><span class="line">        &#x2F;&#x2F; 收集Looper主线程的堆栈信息，具体方法mCurrentThread.getStackTrace()</span><br><span class="line">        stackSampler &#x3D; new StackSampler(</span><br><span class="line">                Looper.getMainLooper().getThread(),</span><br><span class="line">                sContext.provideDumpInterval());</span><br><span class="line">        &#x2F;&#x2F; 收集&#x2F;proc&#x2F;&#123;pid&#125;&#x2F;stat</span><br><span class="line">        cpuSampler &#x3D; new CpuSampler(sContext.provideDumpInterval());</span><br><span class="line"></span><br><span class="line">        setMonitor(new LooperMonitor(new LooperMonitor.BlockListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onBlockEvent(long realTimeStart, long realTimeEnd,</span><br><span class="line">                                     long threadTimeStart, long threadTimeEnd) &#123;</span><br><span class="line">                &#x2F;&#x2F; 搜集卡顿线程堆栈信息</span><br><span class="line">                ArrayList&lt;String&gt; threadStackEntries &#x3D; stackSampler</span><br><span class="line">                        .getThreadStackEntries(realTimeStart, realTimeEnd);</span><br><span class="line">                if (!threadStackEntries.isEmpty()) &#123;</span><br><span class="line">                    BlockInfo blockInfo &#x3D; BlockInfo.newInstance()</span><br><span class="line">                            .setMainThreadTimeCost(realTimeStart, realTimeEnd, threadTimeStart, threadTimeEnd)</span><br><span class="line">                            .setCpuBusyFlag(cpuSampler.isCpuBusy(realTimeStart, realTimeEnd))</span><br><span class="line">                            .setRecentCpuRate(cpuSampler.getCpuRateInfo())</span><br><span class="line">                            .setThreadStackEntries(threadStackEntries)</span><br><span class="line">                            .flushString();</span><br><span class="line">                    LogWriter.save(blockInfo.toString());</span><br><span class="line">                    &#x2F;&#x2F; 循环遍历拦截器链</span><br><span class="line">                    if (mInterceptorChain.size() !&#x3D; 0) &#123;</span><br><span class="line">                        for (BlockInterceptor interceptor : mInterceptorChain) &#123;</span><br><span class="line">                            interceptor.onBlock(getContext().provideContext(), blockInfo);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getContext().provideBlockThreshold(), getContext().stopWhenDebugging()));</span><br><span class="line">        LogWriter.cleanObsolete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-LooperMonitor-检测卡顿"><a href="#3-LooperMonitor-检测卡顿" class="headerlink" title="3. LooperMonitor 检测卡顿"></a>3. LooperMonitor 检测卡顿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class LooperMonitor implements Printer &#123;</span><br><span class="line">    private static final int DEFAULT_BLOCK_THRESHOLD_MILLIS &#x3D; 3000;</span><br><span class="line">    &#x2F;&#x2F; 默认卡顿检测时间间隔3s</span><br><span class="line">    private long mBlockThresholdMillis &#x3D; DEFAULT_BLOCK_THRESHOLD_MILLIS;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void println(String x) &#123;</span><br><span class="line">        if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!mPrintingStarted) &#123;</span><br><span class="line">            mStartTimestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">            mStartThreadTimestamp &#x3D; SystemClock.currentThreadTimeMillis();</span><br><span class="line">            mPrintingStarted &#x3D; true;</span><br><span class="line">            startDump(); &#x2F;&#x2F; 收集主线程的堆栈信息</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">            mPrintingStarted &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F; 判断主线程处理消息是否超时</span><br><span class="line">            if (isBlock(endTime)) &#123;</span><br><span class="line">                notifyBlockEvent(endTime);</span><br><span class="line">            &#125;</span><br><span class="line">            stopDump();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断主线程Looper处理一个消息时间间隔是否超过3s</span><br><span class="line">    private boolean isBlock(long endTime) &#123;</span><br><span class="line">        return endTime - mStartTimestamp &gt; mBlockThresholdMillis;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-卡顿原理解密"><a href="#4-卡顿原理解密" class="headerlink" title="4. 卡顿原理解密"></a>4. 卡顿原理解密</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final class Looper &#123;</span><br><span class="line">    private Printer mLogging;</span><br><span class="line"></span><br><span class="line">    public void setMessageLogging(@Nullable Printer printer) &#123;</span><br><span class="line">        mLogging &#x3D; printer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void loop() &#123;</span><br><span class="line">        final MessageQueue queue &#x3D; me.mQueue;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block</span><br><span class="line"></span><br><span class="line">            final Printer logging &#x3D; me.mLogging;</span><br><span class="line">            if (logging !&#x3D; null) &#123;</span><br><span class="line">                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                        msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 在dispatchMessage的前后都有打印日志信息</span><br><span class="line">            &#x2F;&#x2F; 判断日志打印间隔就可以知道是否存在卡顿</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            if (logging !&#x3D; null) &#123;</span><br><span class="line">                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/23/Smail%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/Smail%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">Smail简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 14:56:12 / 修改时间：15:10:09" itemprop="dateCreated datePublished" datetime="2020-11-23T14:56:12+08:00">2020-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Smail简介"><a href="#Smail简介" class="headerlink" title="Smail简介"></a>Smail简介</h2><h3 id="Smali简介"><a href="#Smali简介" class="headerlink" title="Smali简介"></a>Smali简介</h3><p>Dalvik虚拟机和Jvm一样，也有自己的一套指令集，类似汇编语言, smali文件就是Dalvik的寄存器语言.</p>
<h3 id="Smali文件结构解"><a href="#Smali文件结构解" class="headerlink" title="Smali文件结构解"></a>Smali文件结构解</h3><p>smali文件是由Dalvik指令组成的，它有自己的一套规则，它的指令都是以“.”开头，常用的指令如下：</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.class</td>
<td align="left">包名+类名</td>
</tr>
<tr>
<td align="left">.super</td>
<td align="left">父类类名</td>
</tr>
<tr>
<td align="left">.source</td>
<td align="left">源文件名称</td>
</tr>
<tr>
<td align="left">.implements</td>
<td align="left">接口实现</td>
</tr>
<tr>
<td align="left">.field</td>
<td align="left">定义字段</td>
</tr>
<tr>
<td align="left">.method/.end method</td>
<td align="left">方法的开始与结束</td>
</tr>
<tr>
<td align="left">.locals</td>
<td align="left">方法内使用的v开口的寄存器个数</td>
</tr>
<tr>
<td align="left">.prologue</td>
<td align="left">表示方法中代码的开始处</td>
</tr>
<tr>
<td align="left">.line</td>
<td align="left">对应java中的行数</td>
</tr>
<tr>
<td align="left">.param</td>
<td align="left">指定了方法的参数</td>
</tr>
<tr>
<td align="left">.paramter</td>
<td align="left">和.paramter含义相同</td>
</tr>
<tr>
<td align="left">.param</td>
<td align="left">指定了方法的参数</td>
</tr>
<tr>
<td align="left">.annotation/.end annotation</td>
<td align="left">注解的开始和结束</td>
</tr>
</tbody></table>
<p>现在来看下smali文件的结构：</p>
<h4 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件"></a>1.头文件</h4><p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &lt;访问权限修饰符&gt; [非权限修饰符] &lt;类名&gt;</span><br><span class="line">.super &lt;父类名&gt;</span><br><span class="line">.source &lt;源文件名称&gt;</span><br></pre></td></tr></table></figure>

<p>访问权限修饰符即所谓的public,protected,private，而非权限修饰符则指的是final,abstract,static，两者都可以为空。<br>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class public final Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;PreferencesFactory;</span><br><span class="line">.super Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">.source &quot;PreferencesFactory.java&quot;</span><br></pre></td></tr></table></figure>

<p>如果原java代码有经过混淆，那一般.class里面的类名和.source的源文件名会不一样，以下是经过混淆的(类名正常是xxx/PreferencesFactory，混淆以后变成xxx/d)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class public final Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;d;</span><br><span class="line">.super Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">.source &quot;PreferencesFactor</span><br></pre></td></tr></table></figure>

<h4 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2.接口实现"></a>2.接口实现</h4><p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#interfaces</span><br><span class="line">.implements &lt;接口名称&gt;</span><br></pre></td></tr></table></figure>

<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># interfaces</span><br><span class="line">.implements Landroid&#x2F;view&#x2F;View$OnClickListener;</span><br></pre></td></tr></table></figure>

<p>其中# interfaces为注释</p>
<h4 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h4><p>如果一个类中使用了注解，就会出现.annotation，格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#annotations</span><br><span class="line">.annotation [注解的属性] &lt;注解类名&gt;</span><br><span class="line">    [注解字段&#x3D;值]</span><br><span class="line">    ...</span><br><span class="line">.end annotation</span><br></pre></td></tr></table></figure>

<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># annotations</span><br><span class="line">.annotation build Landroid&#x2F;annotation&#x2F;TargetApi;</span><br><span class="line">    value &#x3D; 0xb</span><br><span class="line">.end annotation</span><br></pre></td></tr></table></figure>
<p>其中# annotations为注释</p>
<h4 id="4-变量定义"><a href="#4-变量定义" class="headerlink" title="4.变量定义"></a>4.变量定义</h4><p>使用.field描述字段的定义，分为静态变量和普通变量两种：</p>
<p>静态变量<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#static fields</span><br><span class="line">.field &lt;访问权限&gt; static [修饰词] &lt;字段名&gt;:&lt;变量类型&gt;</span><br></pre></td></tr></table></figure>
<p>使用# static fields注释，并加了static修饰符，</p>
<p>举例说明：<br>smali:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># static fields</span><br><span class="line">.field public static mStr:Ljava&#x2F;lang&#x2F;String;</span><br></pre></td></tr></table></figure>
<p>java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String mStr;</span><br></pre></td></tr></table></figure>
<p>普通变量<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#instance fields</span><br><span class="line">.field &lt;访问权限修饰符&gt; [非权限修饰符] &lt;变量名&gt;:&lt;变量类型&gt;</span><br></pre></td></tr></table></figure>
<p>使用# instance fields注释，</p>
<p>举例说明：<br>smali:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.field private bool:Z</span><br></pre></td></tr></table></figure>
<p>java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private boolean bool;</span><br></pre></td></tr></table></figure>

<h4 id="5-方法描述"><a href="#5-方法描述" class="headerlink" title="5.方法描述"></a>5.方法描述</h4><p>smali中的方法以.method/.end method进行描述，有分两种方法，一种是直接方法，一种是虚方法，<br>什么事直接方法和虚方法呢？直接方法就是不能被覆写的方法，包括用static，private修饰的方法，虚方法表示可以被覆写的方法，包括public，protected修饰的方法。<br>两者在smali中的注释分别是直接方法(#direct methods)，虚方法(#virtual methods),一般直接方法在smali文件的前半部分，虚方法在后半部分。<br>方法的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#direct methods&#x2F;#virtual methods</span><br><span class="line">.method &lt;访问权限修饰符&gt; [非访问权限修饰符] &lt;方法原型&gt;</span><br><span class="line">      &lt;.locals&gt;</span><br><span class="line">      [.parameter]</span><br><span class="line">      [.prologue]</span><br><span class="line">      [.line]</span><br><span class="line">      &lt;代码逻辑&gt;</span><br><span class="line">.end</span><br></pre></td></tr></table></figure>
<p>其中.parameter,.prologue,.line是可选的。<br>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># virtual methods</span><br><span class="line">.method public final onClick(Landroid&#x2F;view&#x2F;View;)V</span><br><span class="line">    .locals 1</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 71</span><br><span class="line">    iget-object v0, p0, Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;a;-&gt;a:Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;FTPServerPreferences;</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0&#125;, Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;FTPServerPreferences;-&gt;a(Llutey&#x2F;FTPServer&#x2F;preferences&#x2F;sdk11&#x2F;pre&#x2F;FTPServerPreferences;)V</span><br><span class="line"></span><br><span class="line">    .line 72</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>注意几个特殊的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.method xxx constructor &lt;clinit&gt;()V  &#x2F;&#x2F;类中final变量的初始化</span><br><span class="line">.method xxx constructor &lt;init&gt;()V   &#x2F;&#x2F;类中的构造行数</span><br><span class="line">.method static synthetic methodName(xxxx)V &#x2F;&#x2F;加synthetic修饰符的方法，synthetic是合成的意思，即这个方法在原java代码里面是没有的，是在java编译成Dalvik字节码的时候合成的，后续会详细分析这类方法</span><br></pre></td></tr></table></figure>
<p>方法中具体的语法在文章的后半部分详细说明。</p>
<h4 id="smali数据类型"><a href="#smali数据类型" class="headerlink" title="smali数据类型"></a>smali数据类型</h4><p>Dalvik字节码和Java一样，都只有两种数据类型：基本类型和引用类型，8中基本数据类型，对象和数组是引用类型，Dalvik字节码和Jvm中对数据类型的描述是一致的，对于基本类型和无返回类型用一个大写字母表示，对象类型用一个大写字母L加对象的全限定名表示，如Ljava/lang/String表示字符串对象类型，一维数组用一个”[“加数据类型或对象类型表示.</p>
<p>java数据类型和Dalvik字节码的数据类型一一对应，对应关系如下表：</p>
<table>
<thead>
<tr>
<th>java类型</th>
<th>smali描述符</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>L</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>void</td>
<td>V</td>
</tr>
<tr>
<td>对象类型</td>
<td>L</td>
</tr>
<tr>
<td>数组类型</td>
<td>[</td>
</tr>
<tr>
<td>基本数据类型</td>
<td>Z,B,S,C,I,L,F,D为基本数据类型，从上表可以看出，Dalvik字节码基本类型的描述符基本上是java基本类型的首字母，除了boolean对应为Z外</td>
</tr>
</tbody></table>
<ul>
<li><p>对象类型<br>L加上类或者接口的全称表示对象类型，即Lpackage/objectName，如String类型描述符为Ljava/lang/String，包com.biyou下面的test类的类型描述符为Lcom/biyou/test</p>
</li>
<li><p>数组类型<br>基本类型的数组为”[“加上基本类型描述符来表示，一维数组前面是一个”[“,多一个维度前面多加一个”[“,比如int类型，一维是:[I,二维是:[[I,依次类推。<br>对象类型的数组为”[“加上对象类型表示符来表示，如String类型表示为:[Ljava/lang/String。</p>
</li>
</ul>
<h3 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h3><p>smali的语法跟汇编语言有点类似，但没有汇编那么复杂，可以很轻松的看懂，推荐使用source insight来看。</p>
<p>变量的描述<br>格式为：</p>
<p>对象类型描述符-&gt;变量名:类型描述符;<br>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lcom&#x2F;biyou&#x2F;test;-&gt;count:I  &#x2F;&#x2F;基本类型</span><br><span class="line">Lcom&#x2F;biyou&#x2F;test;-&gt;str:Ljava&#x2F;lang&#x2F;String  &#x2F;&#x2F;对象类型</span><br></pre></td></tr></table></figure>
<p>Dalvik对变量的描述都会指明变量定义的和变量的类型，如例子中的count变量的描述，说明它定义在com.biyou.test类，是int类型的变量</p>
<p>方法的描述<br>格式为:</p>
<p>对象类型描述符-&gt;方法名(参数类型描述符)返回值类型描述符;</p>
<p>下面我们通过几个例子来说明,以java.lang.String为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java方法:public char charAt(int index)&#123;...&#125;</span><br><span class="line">Davilk描述:Ljava&#x2F;lang&#x2F;String;-&gt;charAt(I)C</span><br><span class="line"></span><br><span class="line">java方法:public void getChars(int srcBegin,int srcEnd,char dst[],int dstBegin)&#123;...&#125;</span><br><span class="line">Davilk描述:Ljava&#x2F;lang&#x2F;String;-&gt;getChars(II[CI)V</span><br><span class="line"></span><br><span class="line">java方法:public boolean equals(Object anObject)&#123;...&#125;</span><br><span class="line">Davilk描述:Ljava&#x2F;lang&#x2F;String;-&gt;equals(Ljava&#x2F;lang&#x2F;Object)Z</span><br></pre></td></tr></table></figure>

<h3 id="Dalvik指令集"><a href="#Dalvik指令集" class="headerlink" title="Dalvik指令集"></a>Dalvik指令集</h3><p>掌握以上的字段和方法的描述,只能说我们懂了如何描述一个字段和方法,而关于方法中具体的逻辑则需要了解Dalvik中的指令集.因为Dalvik是基于寄存器的架构的,因此指令集和JVM中的指令集区别较大,反而更类似x86的中的汇编指令。</p>
<p>1.空操作指令<br>空操作指令的助记符为nop，它的值为00，通常nop指令被用来作对齐代码之用，无实际操作。</p>
<p>2.数据定义指令<br>数据定义指令用于定义代码中使用的常量,字符串，类等数据,基础字节码是const</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>const/4 vA,#+B</td>
<td>将数值符号扩展为32后赋值给寄存器vA</td>
</tr>
<tr>
<td>const/16 vAA, #+BBBB</td>
<td>将数据符号扩展为32位后赋给寄存器vAA</td>
</tr>
<tr>
<td>const vAA, #+BBBBBBBB</td>
<td>将数值赋给寄存器vAA</td>
</tr>
<tr>
<td>const/high16 vAA, #+BBBB0000</td>
<td>将数值右边零扩展为32位后赋给寄存器vAA</td>
</tr>
<tr>
<td>const-wide/16 vAA,#+BBBB</td>
<td>将数值符号扩展为64位后赋值个寄存器对vAA</td>
</tr>
<tr>
<td>const-wide/32 vAA,#+BBBB</td>
<td>将数值符号扩展为64位后赋值个寄存器对vAA</td>
</tr>
<tr>
<td>const-wide vAA, #+BBBBBBBBBBBBBBBB</td>
<td>将数值赋给寄存器对vAA</td>
</tr>
<tr>
<td>const-wide/high16 vAA, #+BBBB000000000000</td>
<td>将数值右边零扩展为64位后赋给寄存器对vAA</td>
</tr>
<tr>
<td>const-string vAA,string@BBBB</td>
<td>通过字符串索引高走字符串赋值给寄存器vAA</td>
</tr>
<tr>
<td>const-string/jumbo vAA, string@BBBBBBBB</td>
<td>通过字符串索引（较大）构造一个字符串并赋给寄存器vAA</td>
</tr>
<tr>
<td>const-class vAA,type@BBBB</td>
<td>通过类型索引获取一个类的引用赋值给寄存器vAA</td>
</tr>
<tr>
<td>const-class/jumbo vAAAA, type@BBBBBBBB</td>
<td>通过给定的类型索引获取一个类引用并赋给寄存器vAAAA。这条指令占用两个字节，值为0xooff(Android4.0中新增的指令)</td>
</tr>
</tbody></table>
<p>3.锁指令<br>锁指令多用在多线程程序中对同一对象的操作。Dalvik指令集中有两条锁指令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitor-enter vAA：为指定的对象获取锁。</span><br><span class="line">monitor-exit vAA：释放指定的对象的锁。</span><br></pre></td></tr></table></figure>

<p>如java的com.biyou.test类需要需要加锁：<br>java为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized (test.class)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>smali为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const-class v0, Lcom&#x2F;biyou&#x2F;test;</span><br><span class="line">monitor-enter v0</span><br><span class="line">...</span><br><span class="line">monitor-exit v0</span><br></pre></td></tr></table></figure>

<p>4.变量操作指令<br>字段操作指令表示对对象字段进行设值和取值操作,就像是你在代码中长些的set和get方法.基本指令是iput-type,iget-type,sput-type,sget-type.type表示数据类型.</p>
<p>普通字段读写操作<br>前缀是i的iput-type和iget-type指令用于字段的读写操作.</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>iget-object vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id对象的引用值给vBB寄存器</td>
</tr>
<tr>
<td>iget-boolean vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>iget-wide vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>iget vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>iput-object vAA,vBB,filed_id</td>
<td>把vAA寄存器指向的对象的引用赋值给vBB寄存器中的filed_id对象</td>
</tr>
<tr>
<td>iput-boolean vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的boolean类型</td>
</tr>
<tr>
<td>iput-wide vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的wide类型</td>
</tr>
<tr>
<td>iput vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的int类型</td>
</tr>
</tbody></table>
<p>静态字段读写操作<br>前缀是s的sput-type和sget-type指令用于静态字段的读写操作</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sget-object vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id对象的引用值给vBB寄存器</td>
</tr>
<tr>
<td>sget-boolean vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>sget-wide vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>sget vAA,vBB,filed_id</td>
<td>读取vAA寄存器中的对象中的filed_id的值给vBB寄存器</td>
</tr>
<tr>
<td>sput-object vAA,vBB,filed_id</td>
<td>把vAA寄存器指向的对象的引用赋值给vBB寄存器中的filed_id对象</td>
</tr>
<tr>
<td>sput-boolean vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的boolean类型</td>
</tr>
<tr>
<td>sput-wide vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的wide类型</td>
</tr>
<tr>
<td>sput vAA,vBB,filed_id</td>
<td>把vAA寄存器的值给vBB寄存器中的int类型</td>
</tr>
</tbody></table>
<p>5.跳转指令<br>跳转指令用于从当前地址跳转到指定的偏移处。Dalvik指令集中有三种跳转指令：无条件跳转（goto），分支跳转（switch）与条件跳转（if）。</p>
<p>goto +AA：无条件跳转到指定偏移处，偏移量AA不能为0。</p>
<p>goto/16 +AAAA：无条件跳转到指定偏移处，偏量AAAA不能为0。</p>
<p>goto/32 +AAAAAAAA：无条件跳转到指定偏移处。</p>
<p>packed-switch vAA, +BBBBBBBB：分支跳转指令。vAA寄存器为switch分支中需要判断的值，BBBBBBBB指向一个packed-switch-payload格式的偏移表，表中的值是有规律递增的。</p>
<p>sparse-switch vAA, +BBBBBBBB：分支跳转指令。vAA寄存器为switch分支中需要判断的值，BBBBBBBB指向一个sparse-switch-payload格式的偏移表，表中的值是无规律的偏移量。</p>
<p>if-test vA, vB, +CCCC：条件跳转指令。比较vA寄存器与vB寄存器的值，如果比较结果满足就跳转到CCCC指定的偏移处。偏移量CCCC不能为0。if-test类型的指令有以下几条：</p>
<p>if-eq：如果vA等于vB则跳转。Java语法表示为“if(vA == vB)”</p>
<p>if-ne：如果vA不等于vB则跳转。Java语法表示为“if(vA != vB)”</p>
<p>if-lt：如果vA小于vB则跳转。Java语法表示为“if(vA &lt; vB)”</p>
<p>if-ge：如果vA大于等于vB则跳转。Java语法表示为“if(vA &gt;= vB)”</p>
<p>if-gt：如果vA大于vB则跳转。Java语法表示为“if(vA &gt; vB)”</p>
<p>if-le：如果vA小于等于vB则跳转。Java语法表示为“if(vA &lt;= vB)”</p>
<p>if-testz vAA, +BBBB：条件跳转指令。拿vAA寄存器与0比较，如果比较结果满足或值为0时就跳转到BBBB指定的偏移处。偏移量BBBB不能为0。if-testz类型的指令有以下几条：</p>
<p>if-eqz：如果vAA为0则跳转。Java语法表示为“if(vAA == 0)”</p>
<p>if-nez：如果vAA不为0则跳转。Java语法表示为“if(vAA != 0)”</p>
<p>if-ltz：如果vAA小于0则跳转。Java语法表示为“if(vAA &lt; 0)”</p>
<p>if-gez：如果vAA大于等于0则跳转。Java语法表示为“if(vAA &gt;= 0)”</p>
<p>if-gtz：如果vAA大于0则跳转。Java语法表示为“if(vAA &gt; 0)”</p>
<p>if-lez：如果vAA小于等于0则跳转。Java语法表示为“if(vAA &lt;= 0)”</p>
<p>6.比较指令<br>比较指令用于对两个寄存器的值（浮点型或长整型）进行比较。它的格式为“cmpkind vAA, vBB, vCC”，其中vBB寄存器与vCC寄存器是需要比较的两个寄存器或寄存器对，比较的结果放到vAA寄存器。Dalvik指令集中共有5条比较指令：</p>
<p>cmpl-float vAA,vBB,vCC：比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1</p>
<p>cmpg-float vAA,vBB,vCC：比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，则结果为1，相等则结果为0，小于的话结果为-1</p>
<p>cmpl-double vAA,vBB,vCC：比较两个双精度浮点数。如果vBB寄存器对大于vCC寄存器对，则结果为-1，相等则结果为0，小于则结果为1</p>
<p>cmpg-double vAA,vBB,vCC：比较两个双精度浮点数。如果vBB寄存器对大于vCC寄存器对，则结果为1，相等则结果为0，小于的话，则结果为-1</p>
<p>cmp-long vAA,vBB,vCC：比较两个长整型数。如果vBB寄存器大于vCC寄存器，则结果为1，相等则结果为0，小则结果为-1</p>
<p>7.数据转换指令<br>数据转换指令用于将一种类型的数值转换成另一种类型。它的格式为“unop vA, vB”，vB寄存器或vB寄存器对存放需要转换的数据，转换后的结果保存在vA寄存器或vA寄存器对中。</p>
<p>•“neg-int”：对整型数求补。</p>
<p>•“not-int”：对整型数求反。</p>
<p>•“neg-long”：对长整型数求补。</p>
<p>•“not-long”：对长整型数求反。</p>
<p>•“neg-float”：对单精度浮点型数求补。</p>
<p>•“neg-double”：对双精度浮点型数求补。</p>
<p>•“int-to-long”：将整型数转换为长整型。</p>
<p>•“int-to-float”：将整型数转换为单精度浮点型数。</p>
<p>•“int-to-dobule”：将整型数转换为双精度浮点数。</p>
<p>•“long-to-int”：将长整型数转换为整型。</p>
<p>•“long-to-float”：将长整型数转换为单精度浮点型。</p>
<p>•“long-to-double”：将长整型数转换为双精度浮点型。</p>
<p>•“float-to-int”：将单精度浮点数转换为整型。</p>
<p>•“float-to-long”：将单精度浮点数转换为长整型数。</p>
<p>•“float-to-double”：将单精度浮点数转换为双精度浮点型数。</p>
<p>•“double-to-int”：将双精度浮点数转换为整型。</p>
<p>•“double-to-long”：将双精度浮点数转换为长整型。</p>
<p>•“double-to-float”：将双精度浮点数转换为单精度浮点型。</p>
<p>•“int-to-byte”：将整型转换为字节型。</p>
<p>•“int-to-char”：将整型转换为字符型。</p>
<p>•“int-to-short”：将整型转换为短整型。</p>
<p>8.数据运行指令<br>数据运算指令包括算术运算指令与逻辑运算指令。算术运算指令主要进行数值间如加，减，乘，除，模，移位等运算。逻辑运算指令主要进行数值间与，或，非，抑或等运算。数据运算指令有如下四类（数据运算时可能是在寄存器或寄存器对间进行，下面的指令作用讲解时使用寄存器来描述）：</p>
<p>•“binop vAA, vBB, vCC”：将vBB寄存器与vCC寄存器进行运算，结果保存到vAA寄存器。</p>
<p>•“binop/2addr vA, vB”：将vA寄存器与vB寄存器进行运算，结果保存到vA寄存器。</p>
<p>•“binop/lit16 vA, vB, #+CCCC”：将vB寄存器与常量 CCCC进行运算，结果保存到vA寄存器。</p>
<p>•“binop/lit8 vAA, vBB, #+CC”：将vBB寄存器与常量CC进行运算，结果保存到vAA寄存器。</p>
<p>后面3类指令比第1类指令分别多出了2addr，lit16，lit8等指令后缀。四类指令中基础字节码相同的指令执行的运算操作是类似的，第1类指令中，根据数据的类型不同会在基础字节码后面加上数据类型后缀，如 -int 或 -long 分别表示操作的数据类型为整型与长整型。第1类指令可归类如下：</p>
<p>•“add-type”：vBB寄存器与vCC寄存器值进行加法运算（vBB + vCC）</p>
<p>•”sub-type”：vBB寄存器与vCC寄存器值进行减法运算（vBB - vCC）</p>
<p>•”mul-type”：vBB寄存器与vCC寄存器值进行乘法运算（vBB * vCC）</p>
<p>•”div-type”：vBB寄存器与vCC寄存器值进行除法运算（vBB / vCC）</p>
<p>•”rem-type”：vBB寄存器与vCC寄存器值进行模运算（vBB % vCC）</p>
<p>•”and-type”：vBB寄存器与vCC寄存器值进行与运算（vBB &amp; vCC）</p>
<p>•”or-type”：vBB寄存器与vCC寄存器值进行或运算（vBB | vCC）</p>
<p>•”xor-type”：vBB寄存器与vCC寄存器值进行异或运算（vBB ^ vCC）</p>
<p>•”shl-type”：vBB寄存器值（有符号数）左移vCC位（vBB &lt;&lt; vCC ）</p>
<p>•”shr-type”：vBB寄存器值（有符号）右移vCC位（vBB &gt;&gt; vCC）</p>
<p>•”ushr-type”：vBB寄存器值（无符号数）右移vCC位（vBB &gt;&gt;&gt; vCC）</p>
<p>其中基础字节码后面的-type可以是-int，-long， -float，-double。后面3类指令与之类似。</p>
<p>9.方法调用指令<br>方法调用指令负责调用类实例的方法。它的基础指令为 invoke，方法调用指令有“invoke-kind {vC, vD, vE, vF, vG},meth@BBBB”与“invoke-kind/range {vCCCC .. vNNNN},meth@BBBB”两类，两类指令在作用上并无不同，只是后者在设置参数寄存器时使用了range来指定寄存器的范围。根据方法类型的不同，共有如下五条方法调用指令：<br>•invoke-virtual或 invoke-virtual/range调用实例的虚方法。<br>•invoke-super或”invoke-super/range调用实例的父类方法。<br>•invoke-direct或“invoke-direct/range调用实例的直接方法。<br>•invoke-static或invoke-static/range调用实例的静态方法。<br>•invoke-interface或invoke-interface/range调用实例的接口方法。</p>
<p>在Android4.0系统中，Dalvik指令集中增加了“invoke-kind/jumbo {vCCCC .. vNNNN},meth@BBBBBBBB”这类指令，它与上面介绍的两类指令作用相同，只是在指令中增加了jumbo字节码后缀，且寄存器值与指令的索引取值范围更大。</p>
<p>方法调用指令的返回值必须使用move-result*指令来获取。如下面两条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;&#125;, Landroid&#x2F;os&#x2F;Parcel;-&gt;obtain() Landroid&#x2F;os&#x2F;Parcel;</span><br><span class="line">move-result-object v0</span><br></pre></td></tr></table></figure>

<p>10.异常处理指令<br>  Dalvik指令集中有一条指令用来抛出异常。</p>
<p>•throw vAA：抛出vAA寄存器中指定类型的异常。</p>
<p>11.实例操作指令<br>与实例相关的操作包括实例的类型转换，检查及新建等：</p>
<p>•check-cast vAA, type@BBBB：将vAA寄存器中的对象引用转换成指定的类型，如果失败会抛出ClassCastException异常。如果类型B指定的是基本类型，对于非基本类型的A来说，运行时始终会失败。</p>
<p>•instance-of vA, vB, type@CCCC：判断vB寄存器中的对象引用是否可以转换成指定的类型，如果可以vA寄存器赋值为1，否则vA寄存器赋值为0。</p>
<p>•new-instance vAA, type@BBBB：构造一个指定类型对象的新实例，并将对象引用赋值给vAA寄存器，类型符type指定的类型不能是数组类。</p>
<p>•check-cast/jumbo vAAAA, type@BBBBBBBB：指令功能与“check-cast vAA, type@BBBB”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•instance-of/jumbo vAAAA, vBBBB, type@CCCCCCCC：指令功能与“instance-of vA, vB, type@CCCC”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•new-instance/jumbo vAAAA, type@BBBBBBBB：指令功能与“new-instance vAA, type@BBBB”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>12.返回指令<br>  返回指令指的是函数结尾时运行的最后一条指令。它的基础字节码为teturn，共有以下四条返回指令：</p>
<p>•return-void：表示函数从一个void方法返回。<br>•return vAA：表示函数返回一个32位非对象类型的值，返回值寄存器为8位的寄存器vAA。<br>•return-wide vAA：表示函数返回一个64位非对象类型的值，返回值为8位的寄存器对vAA。<br>•return-object vAA：表示函数返回一个对象类型的值。返回值为8位的寄存器vAA。</p>
<p>13.数据操作指令<br>数据操作指令为move。move指令的原型为“move destination,source”，move指令根据字节码的大小与类型不同，后面会跟上不同的后缀。</p>
<p>•move vA, vB：将vB寄存器的值赋给vA寄存器，A源寄存器与目的寄存器都为4位。<br>•move/from16 vAA, vBBBB：将vBBBB寄存器的值赋给vAA寄存器，源寄存器为16位，目的寄存器为8位。<br>•move/16 vAAAA, vBBBB：将vBBBB寄存器的值赋给vAAAA寄存器，源寄存器与目的寄存器都为16位。<br>•move-wide vA, vB：为4位的寄存器对赋值。源寄存器与目的寄存器都为4位。<br>•move-wide/from16 vAA, vBBBB 与“move-wide/16 vAAAA, vBBBB”实现与“move-wide”相同。<br>•move-object vA, vB：为对象赋值。源寄存器与目的寄存器都为4位。<br>•move-object/from16 vAA, vBBBB：为对象赋值。源寄存器为16位，目的寄存器为8位。<br>•move-object/16 vAA, vBBBB：为对象赋值。源寄存器与目的寄存器都为16位。<br>•move-result vAA：将上一个invoke类型指令操作的单字非对象结果赋给vAA寄存器。<br>•move-result-wide vAA：将上一个invoke类型指令操作的双字非对象结果赋给vAA寄存器。<br>•move-result-object vAA：将上一个invoke类型指令操作的对象结果赋给vAA寄存器。<br>•move-exception vAA：保存一个运行时发生的异常到vAA寄存器，这条指令必须是异常发生时的异常处理器的一条指令。否则的话，指令无效。</p>
<p>14.对象操作指令<br>与对象实例相关的操作,比如对象创建,对象检查等.</p>
<p>15.数组操作指令<br>数组操作包括获取数组长度，新建数组，数组赋值，数组元素取值与赋值等操作。</p>
<p>•array-length vA, vB：获取给定vB寄存器中数组的长度并将值赋给vA寄存器，数组长度指的是数组的条目个数。</p>
<p>•new-array vA, vB, type@CCCC：构造指定类型（type@CCCC）与大小（vB）的数组，并将值赋给vA寄存器。</p>
<p>•filled-new-array {vC, vD, vE, vF, vG},type@BBBB：构造指定类型（type@BBBB）与大小（vA）的数组并填充数组内容。vA寄存器是隐含使用的，除了指定数组的大小外还指定了参数的个数，vC~vG是使用到的参数寄存序列。</p>
<p>•filled-new-array/range {vCCCC ..vNNNN}, type@BBBB：指令功能与“filled-new-array {vC, vD, vE, vF, vG},type@BBBB”相同，只是参数寄存器使用range字节码后缀指定了取值范围 ，vC是第一个参数寄存器，N = A +C -1。</p>
<p>•fill-array-data vAA, +BBBBBBBB：用指定的数据来填充数组，vAA寄存器为数组引用，引用必须为基础类型的数组，在指令后面会紧跟一个数据表。</p>
<p>•new-array/jumbo vAAAA, vBBBB,type@CCCCCCCC：指令功能与“new-</p>
<p>array vA,vB,type@CCCC”相同，只是寄存器值与指令的索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•filled-new-array/jumbo {vCCCC ..vNNNN},type@BBBBBBBB：指令功能与“filled-new-array/range {vCCCC ..vNNNN},type@BBBB”相同，只是索引取值范围更大（Android4.0中新增的指令）。</p>
<p>•arrayop vAA, vBB, vCC：对vBB寄存器指定的数组元素进入取值与赋值。vCC寄存器指定数组元素索引，vAA寄存器用来存放读取的或需要设置的数组元素的值。读取元素使用aget类指令，元素赋值使用aput类指定，根据数组中存储的类型指令后面会紧跟不同的指令后缀，指令列表有 aget, aget-wide, aget-object, aget-boolean, aget-byte,aget-char, aget-short, aput, aput-wide, aput-object, aput-boolean, aput-byte, aput-char, aput-short。</p>
<h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://blog.csdn.net/lixpjita39/article/details/75193833" target="_blank" rel="noopener">Android逆向世界之一:smali文件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/20/Utils%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/Utils%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Utils框架解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-20 10:04:17" itemprop="dateCreated datePublished" datetime="2020-10-20T10:04:17+08:00">2020-10-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Utils框架解析"><a href="#Utils框架解析" class="headerlink" title="Utils框架解析"></a>Utils框架解析</h2><h3 id="View-注入"><a href="#View-注入" class="headerlink" title="View 注入"></a>View 注入</h3><ol>
<li>Class&lt;?&gt; thisCls = activity.getClass() 获取Class对象</li>
<li>thisCls.getAnnotation(ContentView.class) 获取注解对象</li>
<li>activity.setContentView(viewId)</li>
<li>Field[] fields = thisCls.getDeclaredFields(); 遍历activity的所有fields字段获取ViewInject注解对象</li>
<li></li>
</ol>
<h2 id="仿小红书ViewPage滑动指示器"><a href="#仿小红书ViewPage滑动指示器" class="headerlink" title="仿小红书ViewPage滑动指示器"></a>仿小红书ViewPage滑动指示器</h2><ol>
<li><p>布局文件<br> &lt;RelativeLayout</p>
<pre><code>android:layout_width=&quot;66dp&quot;
android:layout_height=&quot;wrap_content&quot;
android:layout_gravity=&quot;bottom|right&quot;
android:layout_marginEnd=&quot;20dp&quot;
android:layout_marginBottom=&quot;10dp&quot;&gt;

&lt;com.vid007.videobuddy.xlui.widget.SlidingIndicator
    android:id=&quot;@+id/sliding_indicator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre> </RelativeLayout>
</li>
<li><p>自定义指示器SlidingIndicator<br>public class SlidingIndicator extends HorizontalScrollView {<br> private int mNumber = 1;<br> private int mLastCursorPosition = 0;<br> private Context mContext;<br> private LinearLayout mLinearLayout;<br> private FrameLayout mFrameLayout;<br> private int ivWidth = 40;<br> private int ivHeight = 20;<br> private int mDotNormalBackgroundResource = R.drawable.commonui_white_oval;<br> private int mDotSelectedBackgroundResource = R.drawable.web_find_video_guide_title_icon;</p>
<p> public SlidingIndicator(Context context) {</p>
<pre><code>this(context, null);</code></pre><p> }</p>
<p> public SlidingIndicator(Context context, AttributeSet attrs) {</p>
<pre><code>this(context, attrs, 0);</code></pre><p> }</p>
<p> public SlidingIndicator(Context context, AttributeSet attrs, int defStyleAttr) {</p>
<pre><code>super(context, attrs, defStyleAttr);
mContext = context;</code></pre><p> }</p>
<p> public void setNumber(int number) {</p>
<pre><code>if (number &gt; 0) {
    mNumber = number;
}</code></pre><p> }</p>
<p> public void setIvWidth(int width) {</p>
<pre><code>if (width &gt; 0 &amp;&amp; width &lt;= 100) {
    this.ivWidth = width;
}</code></pre><p> }</p>
<p> public void setIvHeight(int height) {</p>
<pre><code>if (height &gt; 0 &amp;&amp; height &lt;= 100) {
    this.ivHeight = height;
}</code></pre><p> }</p>
<p> public void slidingIndicatorShow() {</p>
<pre><code>init(mContext, ivWidth, ivHeight);</code></pre><p> }</p>
<p> public void setDotBg(@DrawableRes int drawableId) {</p>
<pre><code>mDotNormalBackgroundResource = drawableId;</code></pre><p> }</p>
<p> public void setIvSlidingBg(@DrawableRes int drawableId) {</p>
<pre><code>mDotSelectedBackgroundResource = drawableId;</code></pre><p> }</p>
<p> private void init(Context context, int width, int height) {</p>
<pre><code>mFrameLayout = new FrameLayout(context);
mFrameLayout.setLayoutParams(new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
mLinearLayout = new LinearLayout(context);
mLinearLayout.setOrientation(LinearLayout.HORIZONTAL);
mLinearLayout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));

for (int i = 0; i &lt; mNumber; i++) {
    ImageView imageView = new ImageView(context);
    imageView.setBackgroundResource(mDotNormalBackgroundResource);
    MarginLayoutParams vm = null;
    if (i == 4 &amp;&amp; mNumber &gt;= 5) {
        vm = new MarginLayoutParams(15, 15);
        vm.setMargins(height / 2, 3, height / 2, 0);
    } else {
        vm = new MarginLayoutParams(width / 2, height);
        vm.setMargins(height / 2, 0, height / 2, 0);
    }
    imageView.setLayoutParams(vm);
    mLinearLayout.addView(imageView);
}
mFrameLayout.addView(mLinearLayout);
addView(mFrameLayout);</code></pre><p> }</p>
<p> public void setDotSelected(int position) {</p>
<pre><code>for (int i = 0; i &lt; mNumber; i++) {
    ImageView imageView = (ImageView) mLinearLayout.getChildAt(i);
    if (position == i) {
        imageView.setBackgroundResource(mDotSelectedBackgroundResource);
    } else {
        imageView.setBackgroundResource(mDotNormalBackgroundResource);
    }
    imageView.setAlpha(0.8f);
}
setItemScrollAnimation(position);</code></pre><p> }</p>
<p> public void setItemScrollAnimation(int position) {</p>
<pre><code>if (mNumber &lt;= 5) return;
if (position &lt; 3) return;
if (position == mNumber - 1) return;
if (position == (mLastCursorPosition + 1)) {
    smoothScrollBy(40, 0);
    tryChangeItemToSmall(position);
} else if (position == (mLastCursorPosition - 1)) {
    smoothScrollBy(-40, 0);
    tryChangeItemToSmall(position);
}
mLastCursorPosition = position;</code></pre><p> }</p>
<p> public void tryChangeItemToSmall(int position) {</p>
<pre><code>for (int i = 0; i &lt; mNumber; i++) {
    ImageView imageView = (ImageView) mLinearLayout.getChildAt(i);
    LinearLayout.LayoutParams vm = new LinearLayout.LayoutParams(ivWidth / 2, ivHeight);
    vm.setMargins(ivHeight / 2, 0, ivHeight / 2, 0);
    imageView.setLayoutParams(vm);
}

if (position == 3) {
    return;
}
ImageView imageView2 = (ImageView) mLinearLayout.getChildAt(position - 3);
LinearLayout.LayoutParams vm2 = new LinearLayout.LayoutParams(15, 15);
vm2.setMargins(ivHeight / 2, 3, ivHeight / 2, 0);
imageView2.setLayoutParams(vm2);

if (position == mNumber - 2) {
    return;
}
ImageView imageView3 = (ImageView) mLinearLayout.getChildAt(position + 1);
LinearLayout.LayoutParams vm3 = new LinearLayout.LayoutParams(15, 15);
vm3.setMargins(ivHeight / 2, 3, ivHeight / 2, 0);
imageView3.setLayoutParams(vm3);</code></pre><p> }<br>}</p>
</li>
<li><p>对接</p>
<pre><code>mSlidingIndicator = findViewById(R.id.sliding_indicator);
mSlidingIndicator.setOnTouchListener(new View.OnTouchListener(){
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return true;
    }
});</code></pre></li>
</ol>
<p>mSlidingIndicator.setDotSelected(position);<br>        mSlidingIndicator.setNumber(bannerSize);<br>        mSlidingIndicator.slidingIndicatorShow();<br>        mSlidingIndicator.setDotSelected(0);    </p>
<ol start="4">
<li>完整备份<br>package com.vid007.videobuddy.xlui.widget;</li>
</ol>
<p>import android.content.Context;<br>import android.os.Handler;<br>import android.os.Looper;<br>import android.os.Message;<br>import android.util.AttributeSet;<br>import android.util.SparseArray;<br>import android.view.LayoutInflater;<br>import android.view.MotionEvent;<br>import android.view.View;<br>import android.view.ViewGroup;<br>import android.widget.FrameLayout;<br>import android.widget.HorizontalScrollView;<br>import android.widget.ImageView;<br>import android.widget.LinearLayout;</p>
<p>import androidx.annotation.CallSuper;<br>import androidx.annotation.NonNull;<br>import androidx.viewpager.widget.PagerAdapter;<br>import androidx.viewpager.widget.ViewPager;</p>
<p>import com.vid007.videobuddy.R;<br>import com.xl.basic.coreutils.android.DimensionUtil;<br>import com.xl.basic.coreutils.android.HandlerTimer;<br>import com.xl.basic.coreutils.log.XLLog;<br>import com.xl.basic.xlui.widget.AspectRatioViewPager;</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>/**</p>
<ul>
<li><p>轮播图控件</p>
</li>
<li><p></li>
<li><p>Created by lixianpeng on 2019/1/23.</p>
</li>
<li><p>Copyright (c) 2019 Xunlei. All rights reserved.</p>
</li>
<li></li>
<li><p>@author lixianpeng</p>
</li>
<li><p>@since 2019/1/23</p>
</li>
<li><p>/<br>public class SliderView extends FrameLayout {<br>  public static final String TAG = SliderView.class.getSimpleName();</p>
<p>  private static final int WHAT_CHANGE_BAR_MESSAGE = 1201;<br>  protected SlidingIndicator mSlidingIndicator;<br>  protected LinearLayout mDotLinearLayout;<br>  protected AspectRatioViewPager mViewPager;<br>  protected SliderAdapter&lt;?&gt; mAdapter;</p>
<p>  protected int mDotSize;<br>  protected int mDotSpace; //dot间距<br>  protected int mBannerVisible;<br>  protected int mCurrentPosition;<br>  protected OnItemShowListener mOnItemShowListener;<br>  protected OnItemClickListener mOnItemClickListener;</p>
<p>  private int mDotNormalBackgroundResource;<br>  private int mDotSelectedBackgroundResource;<br>  private int mPeriod = 1000 * 20;<br>  private boolean mIsVisibleToUser = true;<br>  private boolean mIsUserScrolling = false;</p>
<p>  private Handler.Callback mMsgCallback = new Handler.Callback() {</p>
<pre><code>@Override
public boolean handleMessage(Message msg) {
    switch (msg.what) {
        case WHAT_CHANGE_BAR_MESSAGE: {
            XLLog.d(TAG, &quot;handleMessage&quot;);
            if (!mIsUserScrolling) {
                XLLog.d(TAG, &quot;handleMessage scrollToNextPosition&quot;);
                scrollToNextPosition();
            }
        }
        break;
    }
    return false;
}</code></pre><p>  };<br>  private Handler mHandler = new Handler(Looper.getMainLooper(), mMsgCallback);<br>  private HandlerTimer mHandlerTimer = new HandlerTimer(mHandler) {</p>
<pre><code>@Override
public void onTimer() {
    if (mBannerVisible == View.VISIBLE &amp;&amp; mIsVisibleToUser) {
        XLLog.d(TAG, &quot;mTimer schedule visible&quot;);
        mHandler.sendMessage(mHandler.obtainMessage(WHAT_CHANGE_BAR_MESSAGE));
    }
    XLLog.d(TAG, &quot;mTimer schedule&quot;);
}</code></pre><p>  };</p>
<p>  public SliderView(Context context, AttributeSet attrs, int defStyleAttr) {</p>
<pre><code>super(context, attrs, defStyleAttr);
init(context);</code></pre><p>  }</p>
<p>  public SliderView(Context context, AttributeSet attrs) {</p>
<pre><code>super(context, attrs);
init(context);</code></pre><p>  }</p>
<p>  public SliderView(Context context) {</p>
<pre><code>super(context);
init(context);</code></pre><p>  }</p>
<p>  protected int getRealPosition(int position) {</p>
<pre><code>if (mDotLinearLayout != null) {
    int count = mDotLinearLayout.getChildCount();
    if (count &gt; 0) {
        return position % count;
    }
}
return 0;</code></pre><p>  }</p>
<p>  // if: Banner &gt; 5<br>  protected int getDotViewRealPosition(int position) {</p>
<pre><code>if (mDotLinearLayout != null) {
    int count = mRealBannerDotViewSize;
    if (count &gt; 0) {
        return position % count;
    }
}
return 0;</code></pre><p>  }</p>
<p>  public void setOnItemShowListener(OnItemShowListener listener) {</p>
<pre><code>mOnItemShowListener = listener;</code></pre><p>  }</p>
<p>  public void setOnItemClickListener(OnItemClickListener listener) {</p>
<pre><code>mOnItemClickListener = listener;</code></pre><p>  }</p>
<p>  @CallSuper<br>  protected void init(Context context) {</p>
<pre><code>LayoutInflater.from(context).inflate(R.layout.layout_silder_view, this);

mDotSize = DimensionUtil.dip2px(6);
mDotSpace = DimensionUtil.dip2px(3);
mDotNormalBackgroundResource = R.drawable.commonui_white_oval;
mDotSelectedBackgroundResource = R.drawable.web_find_video_guide_title_icon;

mViewPager = findViewById(R.id.banner_viewpager);
mSlidingIndicator = findViewById(R.id.sliding_indicator);
mSlidingIndicator.setOnTouchListener(new View.OnTouchListener(){
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return true;
    }
});
//mDotLinearLayout = findViewById(R.id.banner_dot_lin);
mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

    }

    @Override
    public void onPageSelected(int position) {
        mSlidingIndicator.setDotSelected(position);
        //setDotSelected(position);
        reportSliderItemViewShow();
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        if (state == ViewPager.SCROLL_STATE_IDLE) {
            mIsUserScrolling = false;
        } else {
            mIsUserScrolling = true;
        }
    }
});
mViewPager.setOffscreenPageLimit(2);
mViewPager.setPageMargin(DimensionUtil.dip2px(8));</code></pre><p>  }</p>
<p>  public void shouldStartTimer() {</p>
<pre><code>if (mAdapter != null) {
    if (mAdapter.getRealSize() &gt; 1) {
        startTimer();
    } else {
        cancelTimer();
    }
}</code></pre><p>  }</p>
<p>  public void setAdapter(SliderAdapter&lt;?&gt; adapter) {</p>
<pre><code>mAdapter = adapter;
mViewPager.setAdapter(mAdapter);</code></pre><p>  }</p>
<p>  @CallSuper<br>  public void destroy() {</p>
<pre><code>if (mAdapter != null) {
    mAdapter.setData(null);
}
mHandler.removeCallbacks(null);</code></pre><p>  }</p>
<p>  protected void reportSliderItemViewShow() {</p>
<pre><code>if (mOnItemShowListener != null &amp;&amp; mAdapter != null &amp;&amp; mBannerVisible == View.VISIBLE) {
    mOnItemShowListener.onSliderItemShow(mCurrentPosition % mAdapter.getData().size());
}</code></pre><p>  }</p>
<p>  protected void setDotSelected(int position) {</p>
<pre><code>mCurrentPosition = position;
int count = mDotLinearLayout.getChildCount();
if (count &gt; 0) {
    int realPosition = getDotViewRealPosition(position);
    // 如果超过5个最后一个也是点点点
    if (realPosition &gt;= 4) realPosition = 4;
    for (int i = 0; i &lt; count; i++) {
        ImageView imageView = (ImageView) mDotLinearLayout.getChildAt(i);
        if (realPosition == i) {
            imageView.setBackgroundResource(mDotSelectedBackgroundResource);
        } else {
            imageView.setBackgroundResource(mDotNormalBackgroundResource);
        }
        imageView.setAlpha(0.8f);
    }
}</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li><p>滑动到下一个位置</p>
</li>
<li><p>/<br>protected void scrollToNextPosition() {<br>  if (mViewPager != null &amp;&amp; mAdapter != null) {</p>
<pre><code>int position = mViewPager.getCurrentItem();
position++;
if (position + 1 &gt;= mAdapter.getCount()) {
    position = mAdapter.getMiddlePosition(getRealPosition(position));
    XLLog.e(TAG, &quot;handleMessage out reposition&quot;);
}
XLLog.d(TAG, &quot;scrollToNextPosition &quot;);
mViewPager.setCurrentItem(position);</code></pre><p>  }<br>}</p>
<p>protected void cancelTimer() {<br>  if (mHandlerTimer != null) {</p>
<pre><code>mHandlerTimer.stop();
XLLog.d(TAG, &quot;cancelTimer &quot;);</code></pre><p>  }<br>}</p>
<p>@Override<br>protected void onAttachedToWindow() {<br>  super.onAttachedToWindow();<br>  XLLog.d(TAG, “onAttachedToWindow”);<br>  if (mAdapter != null &amp;&amp; mAdapter.getRealSize() &gt; 1) {</p>
<pre><code>startTimer();
XLLog.d(TAG, &quot;onAttachedToWindow startTimer&quot;);</code></pre><p>  }<br>}</p>
<p>@Override<br>protected void onVisibilityChanged(@NonNull View changedView, int visibility) {<br>  super.onVisibilityChanged(changedView, visibility);<br>  mBannerVisible = visibility;<br>  XLLog.d(TAG, “onVisibilityChanged “ + visibility);<br>  setTimerAccordingToVisible();<br>}</p>
<p>@Override<br>protected void onDetachedFromWindow() {<br>  super.onDetachedFromWindow();<br>  cancelTimer();<br>  mHandler.removeCallbacksAndMessages(null);<br>  XLLog.d(TAG, “onDetachedFromWindow”);<br>}</p>
<p>protected void startTimer() {<br>  mHandlerTimer.start(mPeriod, true);<br>  XLLog.d(TAG, “startTimer “);<br>}</p>
<p>private int mRealBannerDotViewSize = 0;</p>
<p>protected void addBannerDotView(int bannerSize) {<br>  mSlidingIndicator.setNumber(bannerSize);<br>  mSlidingIndicator.slidingIndicatorShow();<br>  mSlidingIndicator.setDotSelected(0);<br>//        mRealBannerDotViewSize = bannerSize;<br>//        if (bannerSize &lt;= 5) {<br>//            for (int i = 0; i &lt; bannerSize; i++) {<br>//                addDotView();<br>//            }<br>//        } else {<br>//            for (int i = 0; i &lt; bannerSize - 1; i++) {<br>//                addDotView();<br>//            }<br>//            addSmallDotView();<br>//        }<br>}</p>
<p>protected void addDotView() {<br>  LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(mDotSize, mDotSize);<br>  params.leftMargin = mDotSpace;<br>  params.rightMargin = mDotSpace;<br>  ImageView imageView = new ImageView(getContext());<br>  imageView.setScaleType(ImageView.ScaleType.FIT_XY);<br>  mDotLinearLayout.addView(imageView, params);<br>}</p>
<p>protected void addSmallDotView() {<br>  int dotSize = DimensionUtil.dip2px(4);<br>  int dotSpace = DimensionUtil.dip2px(3);<br>  int topMargin = DimensionUtil.dip2px(1);<br>  LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(dotSize, dotSize);<br>  params.leftMargin = dotSpace;<br>  params.rightMargin = dotSpace;<br>  params.topMargin = topMargin;<br>  ImageView imageView = new ImageView(getContext());<br>  imageView.setScaleType(ImageView.ScaleType.FIT_XY);<br>  mDotLinearLayout.addView(imageView, params);<br>}</p>
<p>private void setTimerAccordingToVisible() {<br>  if (mBannerVisible == View.VISIBLE &amp;&amp; mIsVisibleToUser) {</p>
<pre><code>shouldStartTimer();</code></pre><p>  } else {</p>
<pre><code>cancelTimer();</code></pre><p>  }<br>}</p>
<p>public void setUserVisibleHint(boolean isVisibleToUser) {<br>  mIsVisibleToUser = isVisibleToUser;<br>  setTimerAccordingToVisible();<br>}</p>
<p>public interface OnItemShowListener {<br>  void onSliderItemShow(int position);<br>}</p>
<p>public interface OnItemClickListener {<br>  void onItemClick(int position);<br>}</p>
<p>public abstract class SliderAdapter<DATA> extends PagerAdapter {<br>  private final int COUNT = 10 * 10000;<br>  private ArrayList<DATA> mData = new ArrayList&lt;&gt;();<br>  private SparseArray<View> mRecoverItemArray = new SparseArray&lt;&gt;();<br>  private static final int MAX_RECOVER_SIZE = 7;</p>
<p>  public ArrayList<DATA> getData() {</p>
<pre><code>return mData;</code></pre><p>  }</p>
<p>  public int getRealSize() {</p>
<pre><code>if (mData != null) {
    return mData.size();
}
return 0;</code></pre><p>  }</p>
<p>  public void clearData() {</p>
<pre><code>mData.clear();
mRecoverItemArray.clear();
notifyDataSetChanged();</code></pre><p>  }</p>
<p>  public void setData(List<DATA> data) {</p>
<pre><code>mData.clear();
if (data != null) {
    mData.addAll(data);
}
notifyDataSetChanged();</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li><p>中间位置的第relativePosition项</p>
</li>
<li></li>
<li><p>@return 中间位置的第relativePosition项</p>
</li>
<li><p>/<br>public int getMiddlePosition(int relativePosition) {<br>  if (mData.size() &gt; 0) {</p>
<pre><code>return COUNT / 2 - COUNT / 2 % mData.size() + relativePosition;</code></pre><p>  }<br>  return 0;<br>}</p>
<p>@Override<br>public int getCount() {<br>  if (mData.size() == 1) {</p>
<pre><code>return 1;</code></pre><p>  }<br>  return mData.size() &gt; 0 ? COUNT : 0;<br>}</p>
<p>@Override<br>public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {<br>  return view == object;<br>}</p>
<p>@NonNull<br>@Override<br>public final Object instantiateItem(@NonNull ViewGroup container, int position) {<br>  View itemView = mRecoverItemArray.get(position % MAX_RECOVER_SIZE);<br>  if (itemView == null) {</p>
<pre><code>itemView = onCreateSliderItemView(container, position);</code></pre><p>  } else {</p>
<pre><code>mRecoverItemArray.remove(position % MAX_RECOVER_SIZE);</code></pre><p>  }<br>  container.addView(itemView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);<br>  onSliderItemViewInstantiated(itemView, position);<br>  XLLog.d(TAG, “SliderAdapter instantiateItem position=” + position + “,itemView=” + itemView);<br>  return itemView;<br>}</p>
<p>@Override<br>public final void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {<br>  View itemView = (View) object;<br>  container.removeView(itemView);<br>  if (itemView instanceof ImageView) {</p>
<pre><code>((ImageView) itemView).setImageDrawable(null);</code></pre><p>  }<br>  XLLog.d(TAG, “SliderAdapter destroyItem position=” + position + “,itemView=” + itemView);<br>  mRecoverItemArray.put(position % MAX_RECOVER_SIZE, itemView);<br>  onSliderItemViewDestroyed(itemView);<br>}</p>
<p>@Override<br>public int getItemPosition(@NonNull Object object) {<br>  return POSITION_NONE;<br>}</p>
<p>@NonNull<br>abstract public View onCreateSliderItemView(@NonNull ViewGroup container, int position);</p>
<p>abstract public void onSliderItemViewInstantiated(@NonNull View itemView, int position);</p>
<p>public void onSliderItemViewDestroyed(@NonNull View itemView) {<br>}<br>}<br>}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/21/%E8%87%AA%E5%AE%9A%E4%B9%89Native%20Crash%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/21/%E8%87%AA%E5%AE%9A%E4%B9%89Native%20Crash%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/" class="post-title-link" itemprop="url">自定义Native Crash异常捕获</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-21 10:43:49 / 修改时间：10:43:34" itemprop="dateCreated datePublished" datetime="2020-08-21T10:43:49+08:00">2020-08-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Native-Crash-异常捕获"><a href="#Native-Crash-异常捕获" class="headerlink" title="Native Crash 异常捕获"></a>Native Crash 异常捕获</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>在Android平台，native crash一直是crash里的大头。native crash具有上下文不全、出错信息模糊、难以捕捉等特点，比java crash更难修复。所以一个合格的异常捕获组件也要能达到以下目的：</p>
<h3 id="二、信号机制"><a href="#二、信号机制" class="headerlink" title="二、信号机制"></a>二、信号机制</h3><p>1.程序奔溃<br>在Unix-like系统中，所有的崩溃都是编程错误或者硬件错误相关的，系统遇到不可恢复的错误时会触发崩溃机制让程序退出，如除零、段地址错误等。<br>异常发生时，CPU通过异常中断的方式，触发异常处理流程。不同的处理器，有不同的异常中断类型和中断处理方式。<br>linux把这些中断处理，统一为信号量，可以注册信号量向量进行处理。<br>信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号。</p>
<p>2.信号机制<br>函数运行在用户态，当遇到系统调用、中断或是异常的情况时，程序会进入内核态。信号涉及到了这两种状态之间的转换。</p>
<p>(1) 信号的接收<br>接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。</p>
<p>(2) 信号的检测<br>进程陷入内核态后，有两种场景会对信号进行检测：</p>
<p>进程从内核态返回到用户态前进行信号检测<br>进程在内核态中，从睡眠状态被唤醒的时候进行信号检测<br>当发现有新信号时，便会进入下一步，信号的处理。</p>
<p>(3) 信号的处理<br>信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。</p>
<p>接下来进程返回到用户态中，执行相应的信号处理函数。</p>
<p>信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。</p>
<p>至此，一个完整的信号处理流程便结束了，如果同时有多个信号到达，上面的处理流程会在第2步和第3步骤间重复进行。</p>
<p>(4) 常见信号量类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#define SIGHUP 1  &#x2F;&#x2F; 终端连接结束时发出(不管正常或非正常)</span><br><span class="line">#define SIGINT 2  &#x2F;&#x2F; 程序终止(例如Ctrl-C)</span><br><span class="line">#define SIGQUIT 3 &#x2F;&#x2F; 程序退出(Ctrl-\)</span><br><span class="line">#define SIGILL 4 &#x2F;&#x2F; 执行了非法指令，或者试图执行数据段，堆栈溢出</span><br><span class="line">#define SIGTRAP 5 &#x2F;&#x2F; 断点时产生，由debugger使用</span><br><span class="line">#define SIGABRT 6 &#x2F;&#x2F; 调用abort函数生成的信号，表示程序异常</span><br><span class="line">#define SIGIOT 6 &#x2F;&#x2F; 同上，更全，IO异常也会发出</span><br><span class="line">#define SIGBUS 7 &#x2F;&#x2F; 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数</span><br><span class="line">#define SIGFPE 8 &#x2F;&#x2F; 计算错误，比如除0、溢出</span><br><span class="line">#define SIGKILL 9 &#x2F;&#x2F; 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略</span><br><span class="line">#define SIGUSR1 10 &#x2F;&#x2F; 未使用，保留</span><br><span class="line">#define SIGSEGV 11 &#x2F;&#x2F; 非法内存操作，与SIGBUS不同，他是对合法地址的非法访问，比如访问没有读权限的内存，向没有写权限的地址写数据</span><br><span class="line">#define SIGUSR2 12 &#x2F;&#x2F; 未使用，保留</span><br><span class="line">#define SIGPIPE 13 &#x2F;&#x2F; 管道破裂，通常在进程间通信产生</span><br><span class="line">#define SIGALRM 14 &#x2F;&#x2F; 定时信号,</span><br><span class="line">#define SIGTERM 15 &#x2F;&#x2F; 结束程序，类似温和的SIGKILL，可被阻塞和处理。通常程序如果终止不了，才会尝试SIGKILL</span><br><span class="line">#define SIGSTKFLT 16  &#x2F;&#x2F; 协处理器堆栈错误</span><br><span class="line">#define SIGCHLD 17 &#x2F;&#x2F; 子进程结束时, 父进程会收到这个信号。</span><br><span class="line">#define SIGCONT 18 &#x2F;&#x2F; 让一个停止的进程继续执行</span><br><span class="line">#define SIGSTOP 19 &#x2F;&#x2F; 停止进程,本信号不能被阻塞,处理或忽略</span><br><span class="line">#define SIGTSTP 20 &#x2F;&#x2F; 停止进程,但该信号可以被处理和忽略</span><br><span class="line">#define SIGTTIN 21 &#x2F;&#x2F; 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号</span><br><span class="line">#define SIGTTOU 22 &#x2F;&#x2F; 类似于SIGTTIN, 但在写终端时收到</span><br><span class="line">#define SIGURG 23 &#x2F;&#x2F; 有紧急数据或out-of-band数据到达socket时产生</span><br><span class="line">#define SIGXCPU 24 &#x2F;&#x2F; 超过CPU时间资源限制时发出</span><br><span class="line">#define SIGXFSZ 25 &#x2F;&#x2F; 当进程企图扩大文件以至于超过文件大小资源限制</span><br><span class="line">#define SIGVTALRM 26 &#x2F;&#x2F; 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.</span><br><span class="line">#define SIGPROF 27 &#x2F;&#x2F; 类似于SIGALRM&#x2F;SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间</span><br><span class="line">#define SIGWINCH 28 &#x2F;&#x2F; 窗口大小改变时发出</span><br><span class="line">#define SIGIO 29 &#x2F;&#x2F; 文件描述符准备就绪, 可以开始进行输入&#x2F;输出操作</span><br><span class="line">#define SIGPOLL SIGIO &#x2F;&#x2F; 同上，别称</span><br><span class="line">#define SIGPWR 30 &#x2F;&#x2F; 电源异常</span><br><span class="line">#define SIGSYS 31 &#x2F;&#x2F; 非法的系统调用</span><br></pre></td></tr></table></figure>

<p>通常我们在做 crash 收集的时候，主要关注这几个信号量：</p>
<blockquote>
<p>const int signal_array[] = {SIGILL, SIGABRT, SIGBUS, SIGFPE, SIGSEGV, SIGSTKFLT, SIGSYS};</p>
</blockquote>
<h3 id="三、捕捉native-crash"><a href="#三、捕捉native-crash" class="headerlink" title="三、捕捉native crash"></a>三、捕捉native crash</h3><p>** 1. 注册信号处理函数**</p>
<p>第一步就是要用信号处理函数捕获到native crash(SIGSEGV, SIGBUS等)。在posix系统，可以用sigaction()：</p>
<blockquote>
<p>#include &lt;signal.h&gt;<br>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact));<br>signum：代表信号编码，可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号，如果为这两个信号定义自己的处理函数，将导致信号安装错误。<br>act：指向结构体sigaction的一个实例的指针，该实例指定了对特定信号的处理，如果设置为空，进程会执行默认处理。<br>oldact：和参数act类似，只不过保存的是原来对相应信号的处理，也可设置为NULL。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册信号处理函数</span><br><span class="line">void signal_handle(int code, siginfo_t *si, void *context) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    struct sigaction old_signal_handlers[SIGNALS_LEN];</span><br><span class="line">    </span><br><span class="line">    struct sigaction handler;  </span><br><span class="line">    memset(&amp;handler, 0, sizeof(handler));  </span><br><span class="line">    sigemptyset(&amp;handler.sa_mask);  </span><br><span class="line">    handler.sa_sigaction &#x3D; signal_handle;  </span><br><span class="line">    handler.sa_flags &#x3D; SA_SIGINFO;  </span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; SIGNALS_LEN; ++i) &#123;</span><br><span class="line">        sigaction(signal_array[i], &amp;handler, &amp; old_signal_handlers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 2. 设置额外栈空间**</p>
<blockquote>
<p>#include &lt;signal.h&gt;<br>int sigaltstack(const stack_t *ss, stack_t *oss);<br>SIGSEGV很有可能是栈溢出引起的，如果在默认的栈上运行很有可能会破坏程序运行的现场，无法获取到正确的上下文。而且当栈满了（太多次递归，栈上太多对象），系统会在同一个已经满了的栈上调用SIGSEGV的信号处理函数，又再一次引起同样的信号。</p>
</blockquote>
<p>我们应该开辟一块新的空间作为运行信号处理函数的栈。可以使用sigaltstack在任意线程注册一个可选的栈，保留一下在紧急情况下使用的空间。（系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">    stack_t stack;  </span><br><span class="line">    memset(&amp;stack, 0, sizeof(stack));  </span><br><span class="line">    &#x2F;* Reserver the system default stack size. We don&#39;t need that much by the way. *&#x2F;  </span><br><span class="line">    stack.ss_size &#x3D; SIGSTKSZ;  </span><br><span class="line">    stack.ss_sp &#x3D; malloc(stack.ss_size);  </span><br><span class="line">    stack.ss_flags &#x3D; 0;  </span><br><span class="line">    &#x2F;* Install alternate stack size. Be sure the memory region is valid until you revert it. *&#x2F;  </span><br><span class="line">    if (stack.ss_sp !&#x3D; NULL &amp;&amp; sigaltstack(&amp;stack, NULL) &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">      ...  </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 3. 兼容其他signal处理**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void signal_handle(int code, siginfo_t *si, void *context) &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* Call previous handler. *&#x2F;  </span><br><span class="line">    old_handler.sa_sigaction(code, si, sc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些信号可能在之前已经被安装过信号处理函数，而sigaction一个信号量只能注册一个处理函数，这意味着我们的处理函数会覆盖其他人的处理信号<br>保存旧的处理函数，在处理完我们的信号处理函数后，在重新运行老的处理函数就能完成兼容。</p>
<h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><p>1.防止死锁或者死循环<br>首先我们要了解async-signal-safe和可重入函数概念：</p>
<p>A signal handler function must be very careful, since processing elsewhere may be interrupted at some arbitrary point in the execution of the program.<br>POSIX has the concept of “safe function”. If a signal interrupts the execution of an unsafe function, and handler either calls an unsafe function or handler terminates via a call to longjmp() or siglongjmp() and the program subsequently calls an unsafe function, then the behavior of the program is undefined.</p>
<p>回想下在“信号机制”一节中的图示，进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断，它首先执行该信号处理程序中的指令（类似发生硬件中断）。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。如果进程正在执行malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号而插入执行该信号处理程序，其中又调用malloc，这时会发生什么？这可能会对进程造成破坏，因为malloc通常为它所分配的存储区维护一个链表，而插入执行信号处理程序时，进程可能正在更改此链表。（参考《UNIX环境高级编程》）</p>
<p>Single UNIX Specification说明了在信号处理程序中保证调用安全的函数。这些函数是可重入的并被称为是异步信号安全（async-signal-safe）。除了可重入以外，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送。下面是这些异步信号安全函数：</p>
<p>但即使我们自己在信号处理程序中不使用不可重入的函数，也无法保证保存的旧的信号处理程序中不会有非异步信号安全的函数。所以要使用alarm保证信号处理程序不会陷入死锁或者死循环的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void signal_handler(const int code, siginfo_t *const si,</span><br><span class="line">                                    void *const sc) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure we do not deadlock. Default of ALRM is to die.</span><br><span class="line">    * (signal() and alarm() are signal-safe) *&#x2F;</span><br><span class="line">    signal(code, SIG_DFL);</span><br><span class="line">    signal(SIGALRM, SIG_DFL);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure we do not deadlock. Default of ALRM is to die.</span><br><span class="line">      * (signal() and alarm() are signal-safe) *&#x2F;</span><br><span class="line">    (void) alarm(8);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 2. 在哪里打印堆栈**</p>
<p><strong>(1) 子进程</strong></p>
<p>考虑到信号处理程序中的诸多限制，一般会clone一个新的进程，在其中完成解析堆栈等任务。</p>
<p>下面是Google Breakpad的流程图，在新的进程中DoDump，使用ptrace解析crash进程的堆栈，同时信号处理程序等待子进程完成任务后，再调用旧的信号处理函数。父子进程使用管道通信。</p>
<p>(2) 子线程<br>在我的实验中，在子进程或者信号处理函数中，经常无法回调给java层。于是我选择了在初始化的时候就建立了子线程并一直等待，等到捕捉到crash信号时，唤醒这条线程dump出crash堆栈，并把crash堆栈回调给java。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static void nativeInit(JNIEnv* env, jclass javaClass, jstring packageNameStr, jstring tombstoneFilePathStr, jobject obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">    initCondition();</span><br><span class="line"></span><br><span class="line">    pthread_t thd;</span><br><span class="line">    int ret &#x3D; pthread_create(&amp;thd, NULL, DumpThreadEntry, NULL);</span><br><span class="line">    if(ret) &#123;</span><br><span class="line">        qmlog(&quot;%s&quot;, &quot;pthread_create error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void* DumpThreadEntry(void *argv) &#123;</span><br><span class="line">    JNIEnv* env &#x3D; NULL;</span><br><span class="line">     if((*g_jvm)-&gt;AttachCurrentThread(g_jvm, &amp;env, NULL) !&#x3D; JNI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;AttachCurrentThread() failed&quot;);</span><br><span class="line">        estatus &#x3D; 0;</span><br><span class="line">        return &amp;estatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F;等待信号处理函数唤醒</span><br><span class="line">        waitForSignal();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;回调native异常堆栈给java层</span><br><span class="line">        throw_exception(env);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;告诉信号处理函数已经处理完了</span><br><span class="line">        notifyThrowException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if((*g_jvm)-&gt;DetachCurrentThread(g_jvm) !&#x3D; JNI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        LOGE(&quot;DetachCurrentThread() failed&quot;);</span><br><span class="line">        estatus &#x3D; 0;</span><br><span class="line">        return &amp;estatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &amp;estatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、收集native-crash原因"><a href="#六、收集native-crash原因" class="headerlink" title="六、收集native crash原因"></a>六、收集native crash原因</h3><p>信号处理函数的入参中有丰富的错误信息，下面我们来一一分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*信号处理函数*&#x2F;</span><br><span class="line">void (*sa_sigaction)(const int code, siginfo_t *const si, void * const sc) </span><br><span class="line"></span><br><span class="line">siginfo_t &#123;</span><br><span class="line">   int      si_signo;     &#x2F;* Signal number 信号量 *&#x2F;</span><br><span class="line">   int      si_errno;     &#x2F;* An errno value *&#x2F;</span><br><span class="line">   int      si_code;      &#x2F;* Signal code 错误码 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 1. code**</p>
<p>发生native crash之后，logcat中会打出如下一句信息：</p>
<blockquote>
<p>signal 11 (SIGSEGV), code 0 (SI_USER), fault addr 0x0</p>
</blockquote>
<p>根据code去查表，其实就可以知道发生native crash的大致原因：</p>
<p>代码的一部分如下，其实就是根据不同的code，输出不同信息，这些都是固定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">case SIGFPE:</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">    case FPE_INTDIV:</span><br><span class="line">      return &quot;Integer divide by zero&quot;;</span><br><span class="line">    case FPE_INTOVF:</span><br><span class="line">      return &quot;Integer overflow&quot;;</span><br><span class="line">    case FPE_FLTDIV:</span><br><span class="line">      return &quot;Floating-point divide by zero&quot;;</span><br><span class="line">    case FPE_FLTOVF:</span><br><span class="line">      return &quot;Floating-point overflow&quot;;</span><br><span class="line">    case FPE_FLTUND:</span><br><span class="line">      return &quot;Floating-point underflow&quot;;</span><br><span class="line">    case FPE_FLTRES:</span><br><span class="line">      return &quot;Floating-point inexact result&quot;;</span><br><span class="line">    case FPE_FLTINV:</span><br><span class="line">      return &quot;Invalid floating-point operation&quot;;</span><br><span class="line">    case FPE_FLTSUB:</span><br><span class="line">      return &quot;Subscript out of range&quot;;</span><br><span class="line">    default:</span><br><span class="line">      return &quot;Floating-point&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  case SIGSEGV:</span><br><span class="line">    switch(code) &#123;</span><br><span class="line">    case SEGV_MAPERR:</span><br><span class="line">      return &quot;Address not mapped to object&quot;;</span><br><span class="line">    case SEGV_ACCERR:</span><br><span class="line">      return &quot;Invalid permissions for mapped object&quot;;</span><br><span class="line">    default:</span><br><span class="line">      return &quot;Segmentation violation&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<p>** 2. pc值**</p>
<p>信号处理函数中的第三个入参sc是uc_mcontext的结构体，是cpu相关的上下文，包括当前线程的寄存器信息和奔溃时的pc值。能够知道崩溃时的pc，就能知道崩溃时执行的是那条指令。</p>
<p>不过这个结构体的定义是平台相关，不同平台、不同cpu架构中的定义都不一样：</p>
<p>x86-64架构：uc_mcontext.gregs[REG_RIP]<br>arm架构：uc_mcontext.arm_pc</p>
<p>** 3. 共享库名字和相对偏移地址**<br>(1) dladdr()<br>pc值是程序加载到内存中的绝对地址，我们需要拿到奔溃代码相对于共享库的相对偏移地址，才能使用addr2line分析出是哪一行代码。通过dladdr()可以获得共享库加载到内存的起始地址，和pc值相减就可以获得相对偏移地址，并且可以获得共享库的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dl_info info;  </span><br><span class="line">if (dladdr(addr, &amp;info) !&#x3D; 0 &amp;&amp; info.dli_fname !&#x3D; NULL) &#123;  </span><br><span class="line">  void * const nearest &#x3D; info.dli_saddr;  </span><br><span class="line">  &#x2F;&#x2F;相对偏移地址</span><br><span class="line">  const uintptr_t addr_relative &#x3D;  </span><br><span class="line">    ((uintptr_t) addr - (uintptr_t) info.dli_fbase);  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为有追求的我们，肯定不满足于仅仅通过一个函数就获得答案。我们尝试下如何手工分析出相对地址。首先要了解下进程的地址空间布局。</p>
<p>(2) Linux下进程的地址空间布局</p>
<p>任何一个程序通常都包括代码段和数据段，这些代码和数据本身都是静态的。程序要想运行，首先要由操作系统负责为其创建进程，并在进程的虚拟地址空间中为其代码段和数据段建立映射。光有代码段和数据段是不够的，进程在运行过程中还要有其动态环境，其中最重要的就是堆栈。</p>
<p>上图中Random stack offset和Random mmap offset等随机值意在防止恶意程序。Linux通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱布局，以免恶意程序通过计算访问栈、库函数等地址。</p>
<p>栈(stack)，作为进程的临时数据区,增长方向是从高地址到低地址。</p>
<p>(3) /proc/self/maps：检查各个模块加载在内存的地址范围<br>在Linux系统中，/proc/self/maps保存了各个程序段在内存中的加载地址范围，grep出共享库的名字，就可以知道共享库的加载基值是多少。</p>
<p>得到相对偏移地址之后，使用readelf查看共享库的符号表，就可以知道是哪个函数crash了。</p>
<h3 id="七、获取堆栈"><a href="#七、获取堆栈" class="headerlink" title="七、获取堆栈"></a>七、获取堆栈</h3><p>1.原理<br>在前一步，我们获取了奔溃时的pc值和各个寄存器的内容，通过SP和FP所限定的stack frame，就可以得到母函数的SP和FP，从而得到母函数的stack frame（PC，LR，SP，FP会在函数调用的第一时间压栈），以此追溯，即可得到所有函数的调用顺序。</p>
<p>2.实现<br>在4.1.1以上，5.0以下：使用安卓系统自带的libcorkscrew.so<br>5.0以上：安卓系统中没有了libcorkscrew.so，使用自己编译的libunwind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifdef USE_UNWIND</span><br><span class="line">    &#x2F;* Frame buffer initial position. *&#x2F;</span><br><span class="line">    t-&gt;frames_size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Skip us and the caller. *&#x2F;</span><br><span class="line">   t-&gt;f rames_skip &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 使用libcorkscrew解堆栈 *&#x2F;</span><br><span class="line">#ifdef USE_CORKSCREW</span><br><span class="line">    t-&gt;frames_size &#x3D; backtrace_signal(si, sc, t-&gt;frames, 0, BACKTRACE_FRAMES_MAX);</span><br><span class="line">#else</span><br><span class="line">    &#x2F;* Unwind frames (equivalent to backtrace()) *&#x2F;</span><br><span class="line">    _Unwind_Backtrace(coffeecatch_unwind_callback, t);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;* 如果无法加载libcorkscrew，则使用自己编译的libunwind解堆栈 *&#x2F;</span><br><span class="line">#ifdef USE_LIBUNWIND</span><br><span class="line">    if (t-&gt;frames_size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        size_t i;</span><br><span class="line">        t-&gt;frames_size &#x3D; unwind_signal(si, sc, t-&gt;uframes, 0,BACKTRACE_FRAMES_MAX);</span><br><span class="line">        for(i &#x3D; 0 ; i &lt; t-&gt;frames_size ; i++) &#123;</span><br><span class="line">            t-&gt;frames[i].absolute_pc &#x3D; (uintptr_t) t-&gt;uframes[i];</span><br><span class="line">            t-&gt;frames[i].stack_top &#x3D; 0;</span><br><span class="line">            t-&gt;frames[i].stack_size &#x3D; 0;</span><br><span class="line">            __android_log_print(ANDROID_LOG_DEBUG, TAG, &quot;absolute_pc:%x&quot;, t-&gt;frames[i].absolute_pc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>libunwind是一个独立的开源库，高版本的安卓源码中也使用了libunwind作为解堆栈的工具，并针对安卓做了一些适配。下面是使用libunwind解堆栈的主循环，每次循环解一层堆栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE int</span><br><span class="line">slow_backtrace (void **buffer, int size, unw_context_t *uc)</span><br><span class="line">&#123;</span><br><span class="line">  unw_cursor_t cursor;</span><br><span class="line">  unw_word_t ip;</span><br><span class="line">  int n &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  if (unlikely (unw_init_local (&amp;cursor, uc) &lt; 0))</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  while (unw_step (&amp;cursor) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (n &gt;&#x3D; size)</span><br><span class="line">          return n;</span><br><span class="line"></span><br><span class="line">      if (unw_get_reg (&amp;cursor, UNW_REG_IP, &amp;ip) &lt; 0)</span><br><span class="line">          return n;</span><br><span class="line">      buffer[n++] &#x3D; (void *) (uintptr_t) ip;</span><br><span class="line">    &#125;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>八、获取函数符号<br>(1) libcorkscrew<br>可以通过libcorkscrew中的get_backtrace_symbols函数获得函数符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* Describes the symbols associated with a backtrace frame.</span><br><span class="line">*&#x2F;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    uintptr_t relative_pc;</span><br><span class="line">    uintptr_t relative_symbol_addr;</span><br><span class="line">    char* map_name;</span><br><span class="line">    char* symbol_name;</span><br><span class="line">    char* demangled_name;</span><br><span class="line">&#125; backtrace_symbol_t;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">* Gets the symbols for each frame of a backtrace.</span><br><span class="line">* The symbols array must be big enough to hold one symbol record per frame.</span><br><span class="line">* The symbols must later be freed using free_backtrace_symbols.</span><br><span class="line">*&#x2F;</span><br><span class="line">void get_backtrace_symbols(const backtrace_frame_t* backtrace, size_t frames,</span><br><span class="line">        backtrace_symbol_t* backtrace_symbols);</span><br></pre></td></tr></table></figure>

<p>** (2) dladdr**<br>更通用的方法是通过dladdr获得函数名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int dladdr(void *addr, Dl_info *info);</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">   const char *dli_fname;  &#x2F;* Pathname of shared object that</span><br><span class="line">                              contains address *&#x2F;</span><br><span class="line">   void       *dli_fbase;  &#x2F;* Base address at which shared</span><br><span class="line">                              object is loaded *&#x2F;</span><br><span class="line">   const char *dli_sname;  &#x2F;* Name of symbol whose definition</span><br><span class="line">                              overlaps addr *&#x2F;</span><br><span class="line">   void       *dli_saddr;  &#x2F;* Exact address of symbol named</span><br><span class="line">                              in dli_sname *&#x2F;</span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure>
<p>传入每一层堆栈的相对偏移地址，就可以从dli_fname中获得函数名字。</p>
<p>九、获得java堆栈<br>如何获得native crash所对应的java层堆栈，这个问题曾经困扰了我一段时间。这里有一个前提：我们认为crash线程就是捕获到信号的线程，虽然这在SIGABRT下不一定可靠。有了这个认知，接下来就好办了。在信号处理函数中获得当前线程的名字，然后把crash线程的名字传给java层，在java里dump出这个线程的堆栈，就是crash所对应的java层堆栈了。</p>
<p>在c中获得线程名字：</p>
<p>char* getThreadName(pid_t tid) {<br>    if (tid &lt;= 1) {<br>        return NULL;<br>    }<br>    char* path = (char <em>) calloc(1, 80);<br>    char</em> line = (char *) calloc(1, THREAD_NAME_LENGTH);</p>
<pre><code>snprintf(path, PATH_MAX, &quot;proc/%d/comm&quot;, tid);
FILE* commFile = NULL;
if (commFile = fopen(path, &quot;r&quot;)) {
    fgets(line, THREAD_NAME_LENGTH, commFile);
    fclose(commFile);
}
free(path);
if (line) {
    int length = strlen(line);
    if (line[length - 1] == &apos;\n&apos;) {
        line[length - 1] = &apos;\0&apos;;
    }
}
return line;</code></pre><p>}<br>然后传给java层：</p>
<pre><code>/**
 * 根据线程名获得线程对象，native层会调用该方法，不能混淆
 * @param threadName
 * @return
 */
@Keep
public static Thread getThreadByName(String threadName) {
    if (TextUtils.isEmpty(threadName)) {
        return null;
    }

    Set&lt;Thread&gt; threadSet = Thread.getAllStackTraces().keySet();
    Thread[] threadArray = threadSet.toArray(new Thread[threadSet.size()]);

    Thread theThread = null;
    for(Thread thread : threadArray) {
        if (thread.getName().equals(threadName)) {
            theThread =  thread;
        }
    }

    Log.d(TAG, &quot;threadName: &quot; + threadName + &quot;, thread: &quot; + theThread);
    return theThread;
}</code></pre><p>十、 结果展示<br>经过诸多探索，终于得到了完美的堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Error: signal 11 (Address not mapped to object) at address 0x0</span><br><span class="line">  at dalvik.system.NativeStart.run(Native Method)</span><br><span class="line">Caused by: java.lang.Error: signal 11 (Address not mapped to object) at address 0x0</span><br><span class="line">  at &#x2F;data&#x2F;app-lib&#x2F;com.tencent.moai.crashcatcher.demo-1&#x2F;libQMCrashGenerator.so.0xd8e(dangerousFunction:0x5:0)</span><br><span class="line">  at &#x2F;data&#x2F;app-lib&#x2F;com.tencent.moai.crashcatcher.demo-1&#x2F;libQMCrashGenerator.so.0xd95(wrapDangerousFunction:0x2:0)</span><br><span class="line">  at &#x2F;data&#x2F;app-lib&#x2F;com.tencent.moai.crashcatcher.demo-1&#x2F;libQMCrashGenerator.so.0xd9d(nativeInvalidAddressCrash:0x2:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x1ee8c(dvmPlatformInvoke:0x70:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x503b7(dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*):0x1ee:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x28268(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2f738(dvmMterpStd(Thread*):0x44:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2cda8(dvmInterpret(Thread*, Method const*, JValue*):0xb8:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x648e3(dvmInvokeMethod(Object*, Method const*, ArrayObject*, ArrayObject*, ClassObject*, bool):0x1aa:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x6cff9(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x28268(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2f738(dvmMterpStd(Thread*):0x44:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x2cda8(dvmInterpret(Thread*, Method const*, JValue*):0xb8:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x643d9(dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list):0x14c:0)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libdvm.so.0x4bca1(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so.0x50ac3(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so.0x518e7(android::AndroidRuntime::start(char const*, char const*):0x206:0)</span><br><span class="line">  at &#x2F;system&#x2F;bin&#x2F;app_process.0xf33(Native Method)</span><br><span class="line">  at &#x2F;system&#x2F;lib&#x2F;libc.so.0xf584(__libc_init:0x64:0)</span><br><span class="line">  at &#x2F;system&#x2F;bin&#x2F;app_process.0x107c(Native Method)</span><br><span class="line">Caused by: java.lang.Error: java stack</span><br><span class="line">  at com.tencent.crashcatcher.CrashCatcher.nativeInvalidAddressCrash(Native Method)</span><br><span class="line">  at com.tencent.crashcatcher.CrashCatcher.invalidAddressCrash(CrashCatcher.java:33)</span><br><span class="line">  at com.tencent.moai.crashcatcher.demo.MainActivity$4.onClick(MainActivity.java:56)</span><br><span class="line">  at android.view.View.performClick(View.java:4488)</span><br><span class="line">  at android.view.View$PerformClick.run(View.java:18860)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:808)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:103)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:222)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5484)</span><br><span class="line">  at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:515)</span><br><span class="line">  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:860)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:676)</span><br><span class="line">  at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure>

<p>在native层构造了一个Error传给java，所以在java层可以很轻松地根据堆栈进行业务上的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface CrashHandleListener &#123;</span><br><span class="line">    @Keep</span><br><span class="line">    void onCrash(int id, Error e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外初始化时就建立等待回调线程的方式，提供了稳定的给java层的回调。在回调中我们打印了app的状态信息，包括activity的堆栈、app是否在前台等，以及打印crash前的logcat日志和把应用日志flush进文件。针对某些具体的native crash还做了业务上的处理，例如遇到热补丁框架相关的crash时就回滚补丁。</p>
<p>在用户环境中的很多native crash单靠堆栈是解决不了的，logcat是非常重要的补充。好几例webview crash都是通过发生crash时的logcat定位的。比如我们曾经遇到过的一个的webview crash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#00 pc 00039874  &#x2F;system&#x2F;lib&#x2F;libc.so (tgkill+12)</span><br><span class="line">#01 pc 00013b5d  &#x2F;system&#x2F;lib&#x2F;libc.so (pthread_kill+52)</span><br><span class="line">#02 pc 0001477b  &#x2F;system&#x2F;lib&#x2F;libc.so (raise+10)</span><br><span class="line">#03 pc 00010ff5  &#x2F;system&#x2F;lib&#x2F;libc.so (__libc_android_abort+36)</span><br><span class="line">#04 pc 0000f554  &#x2F;system&#x2F;lib&#x2F;libc.so (abort+4)</span><br><span class="line">#05 pc 00239885  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#06 pc 00219da3  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#07 pc 00206459  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#08 pc 001fb6c7  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#09 pc 001edc97  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#10 pc 001ec5ad  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#11 pc 001ec617  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#12 pc 001ec5e5  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#13 pc 001ec5bf  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#14 pc 0022c941  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#15 pc 0022c92b  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#16 pc 0022e6a1  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#17 pc 0022ebcd  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#18 pc 0022ee1d  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#19 pc 0022c511  &#x2F;system&#x2F;lib&#x2F;libwebviewchromium.so</span><br><span class="line">#20 pc 00013347  &#x2F;system&#x2F;lib&#x2F;libc.so (_ZL15__pthread_startPv+30)</span><br><span class="line">#21 pc 0001135f  &#x2F;system&#x2F;lib&#x2F;libc.so (__start_thread+6)</span><br></pre></td></tr></table></figure>
<p>单凭堆栈根本看不出来是什么问题，但是在logcat中却看到这样一个warning log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">05-21 15:09:28.423 W&#x2F;System.err(16811): java.lang.NullPointerException: Attempt to get length of null array</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at java.io.ByteArrayInputStream.&lt;init&gt;(ByteArrayInputStream.java:60)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.fetcher.HttpImageFetcher.fetchFromNetwork(HttpImageFetcher.java:86)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.fetcher.BaseFetcher.fetch(BaseFetcher.java:24)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.delaystream.DelayInputStream.read(DelayInputStream.java:36)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at com.tencent.*.InlineImage.delaystream.DelayHttpInputStream.read(DelayHttpInputStream.java:12)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at java.io.InputStream.read(InputStream.java:181)</span><br><span class="line">05-21 15:09:28.424 W&#x2F;System.err(16811):     at org.chromium.android_webview.InputStreamUtil.read(InputStreamUtil.java:54)</span><br><span class="line">查代码发现是我们在WebViewClient的shouldInterceptRequest接口中的业务代码发生了NullPointerException， 传进去WebView内部变成了natvie crash，问题解决。</span><br></pre></td></tr></table></figure>





<p>=============================================================</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *head_cpu &#x3D; nullptr;</span><br><span class="line">asprintf(&amp;head_cpu, &quot;r0 %08lx  r1 %08lx  r2 %08lx  r3 %08lx\n&quot;</span><br><span class="line">                 &quot;r4 %08lx  r5 %08lx  r6 %08lx  r7 %08lx\n&quot;</span><br><span class="line">                 &quot;r8 %08lx  r9 %08lx  sl %08lx  fp %08lx\n&quot;</span><br><span class="line">                 &quot;ip %08lx  sp %08lx  lr %08lx  pc %08lx  cpsr %08lx\n&quot;,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r0, t-&gt;uc_mcontext.arm_r1, t-&gt;uc_mcontext.arm_r2,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r3, t-&gt;uc_mcontext.arm_r4, t-&gt;uc_mcontext.arm_r5,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r6, t-&gt;uc_mcontext.arm_r7, t-&gt;uc_mcontext.arm_r8,</span><br><span class="line">         t-&gt;uc_mcontext.arm_r9, t-&gt;uc_mcontext.arm_r10, t-&gt;uc_mcontext.arm_fp,</span><br><span class="line">         t-&gt;uc_mcontext.arm_ip, t-&gt;uc_mcontext.arm_sp, t-&gt;uc_mcontext.arm_lr,</span><br><span class="line">         t-&gt;uc_mcontext.arm_pc, t-&gt;uc_mcontext.arm_cpsr);</span><br></pre></td></tr></table></figure>
<p>不过uc_mcontext结构体的定义是平台相关的，比如我们熟知的arm、x86这种都不是同一个结构体定义，上面的代码只列出了arm架构的寄存器信息，要兼容其他架构的 cpu 在处理的时候，就得要寄出宏编译大法，不同的架构使用不同的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t pc_from_ucontext(const ucontext_t *uc) &#123;</span><br><span class="line">#if (defined(__arm__))</span><br><span class="line">    return uc-&gt;uc_mcontext.arm_pc;</span><br><span class="line">#elif defined(__aarch64__)</span><br><span class="line">    return uc-&gt;uc_mcontext.pc;</span><br><span class="line">#elif (defined(__x86_64__))</span><br><span class="line">    return uc-&gt;uc_mcontext.gregs[REG_RIP];</span><br><span class="line">#elif (defined(__i386))</span><br><span class="line">  return uc-&gt;uc_mcontext.gregs[REG_EIP];</span><br><span class="line">#elif (defined (__ppc__)) || (defined (__powerpc__))</span><br><span class="line">  return uc-&gt;uc_mcontext.regs-&gt;nip;</span><br><span class="line">#elif (defined(__hppa__))</span><br><span class="line">  return uc-&gt;uc_mcontext.sc_iaoq[0] &amp; ~0x3UL;</span><br><span class="line">#elif (defined(__sparc__) &amp;&amp; defined (__arch64__))</span><br><span class="line">  return uc-&gt;uc_mcontext.mc_gregs[MC_PC];</span><br><span class="line">#elif (defined(__sparc__) &amp;&amp; !defined (__arch64__))</span><br><span class="line">  return uc-&gt;uc_mcontext.gregs[REG_PC];</span><br><span class="line">#else</span><br><span class="line">#error &quot;Architecture is unknown, please report me!&quot;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pc值转内存地址<br>pc值是程序加载到内存中的绝对地址，绝对地址不能直接使用，因为每次程序运行创建的内存肯定都不是固定区域的内存，所以绝对地址肯定每次运行都不一致。我们需要拿到崩溃代码相对于当前库的相对偏移地址，这样才能使用 addr2line 分析出是哪一行代码。通过dladdr()可以获得共享库加载到内存的起始地址，和pc值相减就可以获得相对偏移地址，并且可以获得共享库的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dl_info info;  </span><br><span class="line">if (dladdr(addr, &amp;info) &amp;&amp; info.dli_fname) &#123;  </span><br><span class="line">  void * const nearest &#x3D; info.dli_saddr;  </span><br><span class="line">  uintptr_t addr_relative &#x3D; addr - info.dli_fbase;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 Crash 发生时的函数调用栈<br>获取函数调用栈是最麻烦的，至今没有一个好用的，全都要做一些大改动。常见的做法有四种：</p>
<p>第一种：直接使用系统的&lt;unwind.h&gt;库，可以获取到出错文件与函数名。只不过需要自己解析函数符号，同时经常会捕获到系统错误，需要手动过滤。<br>第二种：在4.1.1以上，5.0以下，使用系统自带的libcorkscrew.so，5.0开始，系统中没有了libcorkscrew.so，可以自己编译系统源码中的libunwind。libunwind是一个开源库，事实上高版本的安卓源码中就使用了他的优化版替换libcorkscrew。<br>第三种：使用开源库coffeecatch，但是这种方案也不能百分之百兼容所有机型。<br>第四种：使用 Google 的breakpad，这是所有 C/C++堆栈获取的权威方案，基本上业界都是基于这个库来做的。只不过这个库是全平台的 android、iOS、Windows、Linux、MacOS 全都有，所以非常大，在使用的时候得把无关的平台剥离掉减小体积。<br>下</p>
<p>面以第一种为例讲一下实现：<br>核心方法是使用&lt;unwind.h&gt;库提供的一个方法_Unwind_Backtrace()这个函数可以传入一个函数指针作为回调，指针指向的函数有一个重要的参数是_Unwind_Context类型的结构体指针。<br>可以使用_Unwind_GetIP()函数将当前函数调用栈中每个函数的绝对内存地址（也就是上文中提到的 pc 值），写入到_Unwind_Context结构体中，最终返回的是当前调用栈的全部函数地址了，_Unwind_Word实际上就是一个unsigned int。<br>而capture_backtrace()返回的就是当前我们获取到调用栈中内容的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * callback used when using &lt;unwind.h&gt; to get the trace for the current context</span><br><span class="line"> *&#x2F;</span><br><span class="line">_Unwind_Reason_Code unwind_callback(struct _Unwind_Context *context, void *arg) &#123;</span><br><span class="line">    backtrace_state_t *state &#x3D; (backtrace_state_t *) arg;</span><br><span class="line">    _Unwind_Word pc &#x3D; _Unwind_GetIP(context);</span><br><span class="line">    if (pc) &#123;</span><br><span class="line">        if (state-&gt;current &#x3D;&#x3D; state-&gt;end) &#123;</span><br><span class="line">            return _URC_END_OF_STACK;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *state-&gt;current++ &#x3D; (void *) pc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _URC_NO_REASON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * uses built in &lt;unwind.h&gt; to get the trace for the current context</span><br><span class="line"> *&#x2F;</span><br><span class="line">size_t capture_backtrace(void **buffer, size_t max) &#123;</span><br><span class="line">    backtrace_state_t state &#x3D; &#123;buffer, buffer + max&#125;;</span><br><span class="line">    _Unwind_Backtrace(unwind_callback, &amp;state);</span><br><span class="line">    return state.current - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当所有的函数的绝对内存地址(pc 值)都获取到了，就可以用上文讲的办法将 pc 值转换为相对偏移量，获取到真正的函数信息和相对内存地址了。</p>
<p>void *buffer[max_line];<br>int frames_size = capture_backtrace(buffer, max_line);<br>for (int i = 0; i &lt; frames_size; i++) {<br>    Dnfo; l_info i<br>    const void *addr = buffer[i];<br>    if (dladdr(addr, &amp;info) &amp;&amp; info.dli_fname) {<br>      void * const nearest = info.dli_saddr;<br>      uintptr_t addr_relative = addr - info.dli_fbase;<br>}<br>Dl_info是一个结构体，内部封装了函数所在文件、函数名、当前库的基地址等信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    const char *dli_fname;  &#x2F;* Pathname of shared object that</span><br><span class="line">                               contains address *&#x2F;</span><br><span class="line">    void       *dli_fbase;  &#x2F;* Address at which shared object</span><br><span class="line">                               is loaded *&#x2F;</span><br><span class="line">    const char *dli_sname;  &#x2F;* Name of nearest symbol with address</span><br><span class="line">                               lower than addr *&#x2F;</span><br><span class="line">    void       *dli_saddr;  &#x2F;* Exact address of symbol named</span><br><span class="line">                               in dli_sname *&#x2F;</span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure>
<p>有了这个对象，我们就能获取到全部想要的信息了。虽然获取到全部想要的信息，但&lt;unwind.h&gt;有个麻烦的就是不想要的信息也给你了，所以需要手动过滤掉各种系统错误，最终得到的数据，就可以上报到自己的服务器了。</p>
<p>数据回传到服务器<br>数据回传有两种方式，一种是直接将信息写入文件，下次启动的时候直接由 Java 上报；另一种就是回调 Java 代码，让 Java 去处理。用 Java 处理的好处是 Java 层可以继续在当前上下文上加上 Java 层的各种状态信息，写入到同一个文件中，使得开发在解决 bug 的时候能更方便。<br>这里就简单将数据写入文件了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void save(const char *name, char *content) &#123;</span><br><span class="line">    FILE *file &#x3D; fopen(name, &quot;w+&quot;);</span><br><span class="line">    fputs(content, file);</span><br><span class="line">    fflush(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    &#x2F;&#x2F;可以在写入文件以后，再通知 Java 层，直接将文件名传给 Java 层更简单。  </span><br><span class="line">    report();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你按照本文讲的，应该是可以创建一个可以工作的 Native Crash 收集库了，但是还有很多细节上的问题，比如数据的丢失问题，写文件的时候使用w+可能造成上次存储的文件丢失；如果当前函数发生了无限递归造成堆栈溢出，在统计的时候需要考虑到这种情况而新开堆栈否则本来就满了的堆栈又在当前堆栈处理溢出信号，处理肯定是会失败的；再比方说多进程多线程在 C 上的各种问题，真的是很复杂。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/27834417" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a><br><a href="https://blog.csdn.net/JMW1407/article/details/107737137" target="_blank" rel="noopener">什么是信号（signal）？信号的处理机制？利用信号进行简单的进程通信过程设计（c++）?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/14/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/14/LeetCode%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">LeetCode初级算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-14 10:19:30 / 修改时间：10:20:14" itemprop="dateCreated datePublished" datetime="2020-08-14T10:19:30+08:00">2020-08-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LeetCode-初级算法"><a href="#LeetCode-初级算法" class="headerlink" title="LeetCode 初级算法"></a>LeetCode 初级算法</h2><ol>
<li>删除排序数组中的重复项</li>
</ol>
<p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/" target="_blank" rel="noopener"></a></p>
<p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/11/Leetcode%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/11/Leetcode%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Leetcode基础算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-11 10:24:20" itemprop="dateCreated datePublished" datetime="2020-08-11T10:24:20+08:00">2020-08-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode-初级算法"><a href="#Leetcode-初级算法" class="headerlink" title="Leetcode 初级算法"></a>Leetcode 初级算法</h2><h3 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h3><p><strong>1. 删除排序数组中的重复项</strong><br>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。(不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; 快慢指针思想i慢指针,j为快指针，举例[1,1,2]</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int i&#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 1; j&lt;nums.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 快慢指针不相等， 慢指针加1</span><br><span class="line">            if (nums[i] !&#x3D; nums[j]) &#123;</span><br><span class="line">                nums[++i] &#x3D; nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i+1;&#x2F;&#x2F; 返回数组长度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 买卖股票的最佳时机 II</strong><br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; prices.length - 1; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 相邻2个元素比较大小，取差值</span><br><span class="line">            if (prices[i+1] - prices[i] &gt; 0) &#123;</span><br><span class="line">                sum +&#x3D; prices[i+1] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.1 买卖股票的最佳时机</strong><br>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。<br>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        &#x2F;&#x2F; 双指针发， minPrice 记录最小的一个值， maxPrice记录最大的一个值</span><br><span class="line">        int minPrice &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        int maxPrice &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; prices.length ;i++) &#123;</span><br><span class="line">            if (prices[i] &lt; minPrice) &#123;</span><br><span class="line">                minPrice &#x3D; prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (prices[i] - minPrice &gt; maxPrice) &#123;</span><br><span class="line">                maxPrice &#x3D; prices[i] - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 旋转数组</strong><br>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br>要求使用空间复杂度为 O(1) 的<strong>原地</strong>算法。<br>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        &#x2F;&#x2F; 常规操作：移动数组，时间复杂度：O(k*n)</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">            int temp &#x3D; nums[nums.length - 1];</span><br><span class="line">            for (int j &#x3D; nums.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">                nums[j] &#x3D; nums[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[0] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 存在重复元素</strong><br>给定一个整数数组，判断是否存在重复元素。<br>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (map.containsKey(nums[i])) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(nums[i], 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 只出现一次的数字</strong><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ret ^&#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 两个数组的交集 II</strong><br>给定两个数组，编写一个函数来计算它们的交集。<br>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2,2]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>移动零</strong><br>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>示例:<br>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">            if (nums[j] !&#x3D; 0) &#123;</span><br><span class="line">                nums[i++] &#x3D; nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int k &#x3D; i; k &lt; nums.length; k++) &#123;</span><br><span class="line">            nums[k] &#x3D; 0;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两数之和</strong><br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] result &#x3D; new int[2];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[0] &#x3D; i;</span><br><span class="line">                result[1] &#x3D; map.get(target - nums[i]);</span><br><span class="line">                if (result[0] &#x3D;&#x3D; result[1]) &#123;</span><br><span class="line">                    continue;   </span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>爬楼梯</strong><br>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">        if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">        int[] climb &#x3D; new int[n + 1];</span><br><span class="line">        climb[1] &#x3D; 1;</span><br><span class="line">        climb[2] &#x3D; 2;</span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            climb[i] &#x3D; climb[i-1] + climb[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return climb[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>买卖股票的最佳时机</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>最大子序和</strong><br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp &#x3D; new int[nums.length];</span><br><span class="line">        dp[0] &#x3D; nums[0];</span><br><span class="line">        for (int i &#x3D; 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] &#x3D; Math.max(nums[i], dp[i-1] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int max &#x3D; dp[0];</span><br><span class="line">        for (int j &#x3D; 0; j &lt; dp.length; j++) &#123;</span><br><span class="line">            if (dp[j] &gt; max) max &#x3D; dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打家劫舍</strong><br>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if (nums.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        if (nums.length &#x3D;&#x3D; 1) return nums[0];</span><br><span class="line">        int[] dp &#x3D; new int[nums.length];</span><br><span class="line">        dp[0] &#x3D; nums[0];</span><br><span class="line">        dp[1] &#x3D; Math.max(nums[1], nums[0]);</span><br><span class="line">        for (int i &#x3D; 2; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] &#x3D; Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int max &#x3D; dp[0];</span><br><span class="line">        for (int m &#x3D; 0; m &lt; dp.length; m++) &#123;</span><br><span class="line">            if (dp[m] &gt; max) max &#x3D; dp[m];</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">HashMap源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 14:42:30" itemprop="dateCreated datePublished" datetime="2020-08-10T14:42:30+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="自定义HashMap"><a href="#自定义HashMap" class="headerlink" title="自定义HashMap"></a>自定义HashMap</h2><h3 id="定义interface-Map、interface-Entry-接口"><a href="#定义interface-Map、interface-Entry-接口" class="headerlink" title="定义interface Map、interface Entry 接口"></a>定义interface Map、interface Entry 接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K, V&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean containsKey(Object key);</span><br><span class="line">    V get(Object key);</span><br><span class="line">    V put(K key, V value);</span><br><span class="line">    V remove(Object key);</span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    interface Entry&lt;K, V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        V setValue(V value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始大小桶大小</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</span><br><span class="line">    &#x2F;&#x2F; 填装因子</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;红黑树阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 取对象的hashCode值高16位和低16位异或</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回大于输入参数且最近的2的整数次幂的数, 比如10，则返回16</span><br><span class="line">    static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 未初始化table，在首次添加元素的时候，会触发扩容</span><br><span class="line">    public HashMap() &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; 16</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 未初始化table，在首次添加元素的时候，会触发扩容</span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 未初始化table，在首次添加元素的时候，会触发扩容</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点】put操作</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        &#x2F;&#x2F; 初始化tab、n变量</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F; 扩容机制</span><br><span class="line">        &#x2F;&#x2F; 根据hash值从tab数组中查找元素</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F; 不存在，则创建新Node节点</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 插入的节点已经存在，接下来就要根据key找到该节点</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F; hash相等并且 key相等 或者equals相同</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                &#x2F;&#x2F; 在红黑树中查找</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; 在链表中查找</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        &#x2F;&#x2F; 新添加链表之后，判断链表长度&gt;&#x3D; 8 会触发转红黑树</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 替换之前的节点值，返回之前的旧值</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            &#x2F;&#x2F; 扩容</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点】get操作</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F; 初始化tab、n、first变量, 根据hash查找Node节点</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F; 如果hash相等并且key也相等</span><br><span class="line">                return first;</span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    &#x2F;&#x2F; 在红黑树中查找</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                &#x2F;&#x2F; 顺序遍历链表</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点】remove</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class="line">            null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                               boolean matchValue, boolean movable) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                node &#x3D; p;</span><br><span class="line">            else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">                if (p instanceof TreeNode)</span><br><span class="line">                    node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                else &#123;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                            ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                             (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node &#x3D; e;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p &#x3D; e;</span><br><span class="line">                    &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                                 (value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                if (node instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">                else if (node &#x3D;&#x3D; p)</span><br><span class="line">                    tab[index] &#x3D; node.next;</span><br><span class="line">                else</span><br><span class="line">                    p.next &#x3D; node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点JDK 1.8】tab扩容</span><br><span class="line">    final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table; &#x2F;&#x2F; 将当前table暂存到oldtab来操作</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123; &#x2F;&#x2F; 旧table容量大于最大容量</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; 设置装载因子为最大值</span><br><span class="line">                return oldTab; &#x2F;&#x2F; 不用扩容</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                &#x2F;&#x2F; 新table长度扩大一倍，装载因子扩大一倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0)</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        else &#123;</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        &#x2F;&#x2F; 重新hash过程</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            &#x2F;&#x2F; 此时，旧数组上的数据就会根据(e.hash &amp; oldCap) 是否等于0这个算法,被很巧妙地分为2类:</span><br><span class="line">                            &#x2F;&#x2F; ① 等于0时，则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置,记为低位区链表lo开头-low;</span><br><span class="line">                            &#x2F;&#x2F; ② 不等于0时,则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置再加上旧数组长度，记为高位区链表hi开头high.</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里插入图片描述<br>HashMap在扩容时，需要先创建一个新数组,然后再将旧数组中的数据转移到新数组上来oldCap<br>此时，旧数组上的数据就会根据(e.hash &amp; oldCap) 是否等于0这个算法,被很巧妙地分为2类:<br>① 等于0时，则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置,记为低位区链表lo开头-low;<br>② 不等于0时,则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置再加上旧数组长度，记为高位区链表hi开头high.<br>具体,详见下述的算法推导解析:<br>算法：<br>(e.hash &amp; oldCap)=0<br>前提：<br> e.hash代表的是旧数组中节点或元素或数据e的hash值，该hash值是根据key确定过的：(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) ；<br> oldCap为旧数组的数组长度，是2的n次幂的整数。即e.hash&amp;2^n=0</p>
<p>推导过程1(e.hash &amp; oldCap)=0：</p>
<p>因为oldCap是2的n次幂的整数,其二进制表达为1个1后面跟n个0：1000…0，若想要e.hash&amp;oldCap的结果为0，则e.hash的二进制形式中与对应oldCap的二进制的1的位置一定为0，其他位置的可以随意，这样即可保证结果为0；<br>假设：<br>oldCap= 2 ^ 3 =8 = 1000<br>则e.hash可以是 0101<br>e.hash&amp;oldCap 0000=0<br>3. (2oldCap -1)=2 ^ 4-1=01111，其二进制位数比oldCap多一位，但多的这一位是0,其余都是1(其低三位肯定也是1);(oldCap-1)=2 ^ 3-1=0111，其二进制位数与oldCap相同,且其低3位的值都是1。故(2oldCap-1)和(oldCap -1)两者与只有4位且首位为0的e.hash=0101计算时，其实只有低3位真正能影响计算结果，而两者的低3位相同，都是111；<br>4. 故在前提条件下，(2oldCap-1)和(oldCap -1)两者与e.hash进行&amp;运算之后的结果一样：<br>(2oldCap -1)=2 ^ 4-1= 01111 (oldCap-1)=2 ^ 3-1= 0111<br>e.hash 0101 e.hash 0101</p>
<p>e.hash&amp;oldCap 00101=5 e.hash&amp;oldCap 0101=5<br>5. 而(oldCap -1) &amp;e.hash恰巧代表的就是e元素在旧数组中的索引位置；<br>而(2oldCap -1) &amp;e.hash则代表的就是e元素在旧数组长度扩容2倍后的新数组里的索引位置<br>6. 综上，可得出满足e.hash&amp;oldCap=0的元素，其在新旧数组中的索引位置不变；</p>
<p>推导过程2(e.hash &amp; oldCap)不等于0：</p>
<p>因为oldCap是2的n次幂的整数,其二进制表达为1个1后面跟n个0：1000…0，若想要e.hash&amp;oldCap的结果不为0，则e.hash的二进制形式中与对应oldCap的二进制的1的位置一定不为0，其他位置的可以随意，这样即可保证结果不为0；<br>假设：<br>oldCap= 2 ^ 3 =8 = 1000<br>则e.hash可以是 1101<br>e.hash&amp;oldCap 1000=13<br>3. (2oldCap -1)=2 ^ 4-1=01111,其二进制位数比oldCap多一位,但多的这一位是0,其余都是1(其低三位肯定也是1,其从左到右数的第4位为1);(oldCap-1)=2 ^ 3-1=0111,其二进制位数与oldCap相同,且其低3位的值都是1, 其从左到右数的第4位为0,。故(2oldCap-1)和(oldCap -1)两者与只有4位且首位为1的e.hash=1101计算时,其实也只有从左到右数的第4位(0)真正能影响计算结果,因为低3位完全一样都是1;<br>4. 故在前提条件下，(2oldCap-1)和(oldCap -1)两者与e.hash进行&amp;运算后结果相差了oldCap：<br>(2oldCap -1)=2^4-1= 01111 ( oldCap - 1 ) =2 ^ 3-1= 0111<br>e.hash 1101 e.hash 1101</p>
<p>(2oldCap -1)&amp; e.hash 01101=8+5 (2oldCap -1)&amp;e.hash 0101=5<br>5. 而(oldCap -1) &amp;e.hash恰巧代表的就是e元素在旧数组中的索引位置；<br>而(2oldCap -1) &amp;e.hash则代表的就是e元素在旧数组长度扩容2倍后的新数组里的索引位置<br>6. 综上，可得出满足e.hash&amp;oldCap不等于0的元素，其在新数组中的索引位置是其在旧数组中索引位置的基础上再加上旧数组长度个偏移量。</p>
<p>【JDK1.7 扩容】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">　　　　&#x2F;&#x2F;判断当前Hashmap(底层是Entry数组)是否存值（是否为空数组）</span><br><span class="line">　　　　if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">　　　　　　inflateTable(threshold);&#x2F;&#x2F;如果为空，则初始化</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　&#x2F;&#x2F;判断key是否为空</span><br><span class="line">　　　　if (key &#x3D;&#x3D; null)</span><br><span class="line">　　　　　　return putForNullKey(value);&#x2F;&#x2F;hashmap允许key为空</span><br><span class="line">　　　　</span><br><span class="line">　　　　&#x2F;&#x2F;计算当前key的哈希值　　　　</span><br><span class="line">　　　　int hash &#x3D; hash(key);</span><br><span class="line">　　　　&#x2F;&#x2F;通过哈希值和当前数据长度，算出当前key值对应在数组中的存放位置</span><br><span class="line">　　　　int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">　　　　for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">　　　　　　Object k;</span><br><span class="line">　　　　　　&#x2F;&#x2F;如果计算的哈希位置有值（及hash冲突），且key值一样，则覆盖原值value，并返回原值value</span><br><span class="line">　　　　　　if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">　　　　　　　　V oldValue &#x3D; e.value;</span><br><span class="line">　　　　　　　　e.value &#x3D; value;</span><br><span class="line">　　　　　　　　e.recordAccess(this);</span><br><span class="line">　　　　　　　　return oldValue;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line"> </span><br><span class="line">　　　　modCount++;</span><br><span class="line">　　　　&#x2F;&#x2F;存放值的具体方法</span><br><span class="line">　　　　addEntry(hash, key, value, i);</span><br><span class="line">　　　　return null;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2倍扩容</span><br><span class="line">    void resize(int newCapacity) &#123;</span><br><span class="line">    	&#x2F;&#x2F;这里获取老table的长度，如果老table的长度已经是最大的容量了，那就没必要扩容了，直接返回。</span><br><span class="line">        Entry[] oldTable &#x3D; table;</span><br><span class="line">        int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">        if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果可以扩容，则new一个新的数组</span><br><span class="line">        Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">        &#x2F;&#x2F;transfer方法将老数组的数据copy到新数组当中</span><br><span class="line">        transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">        &#x2F;&#x2F;transfer完了， 就把新数组赋给全局变量table</span><br><span class="line">        table &#x3D; newTable;</span><br><span class="line">        &#x2F;&#x2F;再用新数组的容量计算新的阈值</span><br><span class="line">        threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 头插法，容易形成环形结构</span><br><span class="line">    void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">        int newCapacity &#x3D; newTable.length;</span><br><span class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">            while(null !&#x3D; e) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">                if (rehash) &#123;</span><br><span class="line">                    e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key); &#x2F;&#x2F;重新计算hash值</span><br><span class="line">                &#125;</span><br><span class="line">                int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next &#x3D; newTable[i];</span><br><span class="line">                newTable[i] &#x3D; e;</span><br><span class="line">                e &#x3D; next;&#x2F;&#x2F;继续下一个元素</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>（1）为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？<br>（2）为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢（面试蘑菇街问过）？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98Ashmem%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/10/%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98Ashmem%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">匿名共享内存Ashmem原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-10 11:17:27" itemprop="dateCreated datePublished" datetime="2020-08-10T11:17:27+08:00">2020-08-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="匿名共享内存Ashmem原理"><a href="#匿名共享内存Ashmem原理" class="headerlink" title="匿名共享内存Ashmem原理"></a>匿名共享内存Ashmem原理</h3><p>Android可以使用Linux的一切IPC通信方式，包括共享内存，不过Android主要使用的方式是匿名共享内存Ashmem（Anonymous Shared Memory），跟原生的不太一样，比如它在自己的驱动中添加了互斥锁，另外通过fd的传递来实现共享内存的传递。MemoryFile是Android为匿名共享内存而封装的一个对象，这里通过使用MemoryFile来分析，Android中如何利用共享内存来实现大数据传递，同时MemoryFile也是进程间大数据传递的一个手段，开发的时候可以使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IMemoryAidlInterface &#123;</span><br><span class="line">    ParcelFileDescriptor getParcelFileDescriptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class MemoryFetchService extends Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new MemoryFetchStub();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class MemoryFetchStub extends IMemoryAidlInterface.Stub &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public ParcelFileDescriptor getParcelFileDescriptor() throws RemoteException &#123;</span><br><span class="line">            MemoryFile memoryFile &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                memoryFile &#x3D; new MemoryFile(&quot;test_memory&quot;, 1024);</span><br><span class="line">                memoryFile.getOutputStream().write(new byte[]&#123;1, 2, 3, 4, 5&#125;);</span><br><span class="line">                Method method &#x3D; MemoryFile.class.getDeclaredMethod(&quot;getFileDescriptor&quot;);</span><br><span class="line">                FileDescriptor des &#x3D; (FileDescriptor) method.invoke(memoryFile);</span><br><span class="line">                return ParcelFileDescriptor.dup(des);</span><br><span class="line">            &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Intent intent &#x3D; new Intent(MainActivity.this, MemoryFetchService.class);</span><br><span class="line">bindService(intent, new ServiceConnection() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">        byte[] content &#x3D; new byte[10];</span><br><span class="line">        IMemoryAidlInterface iMemoryAidlInterface</span><br><span class="line">                        &#x3D; IMemoryAidlInterface.Stub.asInterface(service);</span><br><span class="line">                try &#123;</span><br><span class="line">                    ParcelFileDescriptor parcelFileDescriptor &#x3D; iMemoryAidlInterface.getParcelFileDescriptor();</span><br><span class="line">                    FileDescriptor descriptor &#x3D; parcelFileDescriptor.getFileDescriptor();</span><br><span class="line">                    FileInputStream fileInputStream &#x3D; new FileInputStream(descriptor);</span><br><span class="line">                    fileInputStream.read(content);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                &#125;&#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, Service.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<p>以上是应用层使用匿名共享内存的方法，关键点就是文件描述符（FileDescriptor）的传递，文件描述符是Linux系统中访问与更新文件的主要方式。从MemoryFile字面上看出，共享内存被抽象成了文件，不过本质也是如此，就是在tmpfs临时文件系统中创建一个临时文件，（只是创建了节点，而没有看到实际的文件） 该文件与Ashmem驱动程序创建的匿名共享内存对应，可以直接去proc/pid下查看：</p>
<p>下面就基于MemoryFile主要分析两点，共享内存的分配与传递，先看下MemoryFile的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public MemoryFile(String name, int length) throws IOException &#123;</span><br><span class="line">    mLength &#x3D; length;</span><br><span class="line">    mFD &#x3D; native_open(name, length);</span><br><span class="line">    if (length &gt; 0) &#123;</span><br><span class="line">        mAddress &#x3D; native_mmap(mFD, length, PROT_READ | PROT_WRITE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mAddress &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Java层只是简单的封装，具体实现在native层 ，首先是通过native_open调用ashmem_create_region创建共享内存，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_MemoryFile_open(JNIEnv* env, jobject clazz, jstring name, jint length) &#123;</span><br><span class="line">    const char* namestr &#x3D; (name ? env-&gt;GetStringUTFChars(name, NULL) : NULL);</span><br><span class="line">    int result &#x3D; ashmem_create_region(namestr, length);</span><br><span class="line">    if (name) env-&gt;ReleaseStringUTFChars(name, namestr);</span><br><span class="line">    if (result &lt; 0) &#123;</span><br><span class="line">        jniThrowException(env, &quot;java&#x2F;io&#x2F;IOException&quot;, &quot;ashmem_create_region failed&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return jniCreateFileDescriptor(env, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着通过native_mmap调用mmap将共享内存映射到当前进程空间，之后Java层就能利用FileDescriptor，像访问文件一样访问共享内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static jint android_os_MemoryFile_mmap(JNIEnv* env, jobject clazz, jobject fileDescriptor,</span><br><span class="line">        jint length, jint prot) &#123;</span><br><span class="line">    int fd &#x3D; jniGetFDFromFileDescriptor(env, fileDescriptor);</span><br><span class="line">    &lt;!--系统调用mmap，分配内存--&gt;</span><br><span class="line">    jint result &#x3D; (jint)mmap(NULL, length, prot, MAP_SHARED, fd, 0);</span><br><span class="line">    if (!result) jniThrowException(env, &quot;java&#x2F;io&#x2F;IOException&quot;, &quot;mmap failed&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ashmem_create_region这个函数是如何向Linux申请一块共享内存的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ashmem_create_region(const char *name, size_t size) &#123;</span><br><span class="line">    int fd, ret;</span><br><span class="line">    fd &#x3D; open(ASHMEM_DEVICE, O_RDWR);</span><br><span class="line">    if (fd &lt; 0) return fd;</span><br><span class="line">    if (name) &#123;</span><br><span class="line">        char buf[ASHMEM_NAME_LEN];</span><br><span class="line">        strlcpy(buf, name, sizeof(buf));</span><br><span class="line">        ret &#x3D; ioctl(fd, ASHMEM_SET_NAME, buf);</span><br><span class="line">        if (ret &lt; 0) goto error;</span><br><span class="line">    &#125;</span><br><span class="line">    ret &#x3D; ioctl(fd, ASHMEM_SET_SIZE, size);</span><br><span class="line">    if (ret &lt; 0) goto error;</span><br><span class="line">    return fd;</span><br><span class="line">error:</span><br><span class="line">    close(fd);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASHMEM_DEVICE其实就是抽象的共享内存设备，它是一个杂项设备（字符设备的一种），在驱动加载之后，就会在/dev下创建ashem文件，之后用户就能够访问该设备文件，同一般的设备文件不同，它仅仅是通过内存抽象的，同普通的磁盘设备文件、串行端口字段设备文件不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ASHMEM_DEVICE   &quot;&#x2F;dev&#x2F;ashmem&quot;   </span><br><span class="line">static struct miscdevice ashmem_misc &#x3D; &#123;</span><br><span class="line">    .minor &#x3D; MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name &#x3D; &quot;ashmem&quot;,</span><br><span class="line">    .fops &#x3D; &amp;ashmem_fops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着进入驱动看一下，如何申请共享内存，open函数很普通，主要是创建一个ashmem_area对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static int ashmem_open(struct inode *inode, struct file *file) &#123;</span><br><span class="line">    struct ashmem_area *asma;</span><br><span class="line">    int ret;</span><br><span class="line">    ret &#x3D; nonseekable_open(inode, file);</span><br><span class="line">    if (unlikely(ret)) return ret;</span><br><span class="line">    asma &#x3D; kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL);</span><br><span class="line">    if (unlikely(!asma)) return -ENOMEM;</span><br><span class="line">    INIT_LIST_HEAD(&amp;asma-&gt;unpinned_list);</span><br><span class="line">    memcpy(asma-&gt;name, ASHMEM_NAME_PREFIX, ASHMEM_NAME_PREFIX_LEN);</span><br><span class="line">    asma-&gt;prot_mask &#x3D; PROT_MASK;</span><br><span class="line">    file-&gt;private_data &#x3D; asma;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着利用ashmem_ioctl设置共享内存的大小，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static long ashmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg) &#123;</span><br><span class="line">    struct ashmem_area *asma &#x3D; file-&gt;private_data;</span><br><span class="line">    long ret &#x3D; -ENOTTY;</span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case ASHMEM_SET_SIZE:</span><br><span class="line">            ret &#x3D; -EINVAL;</span><br><span class="line">            if (!asma-&gt;file) &#123;</span><br><span class="line">                ret &#x3D; 0;</span><br><span class="line">                asma-&gt;size &#x3D; (size_t) arg;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">   return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其实并未真正的分配内存，这也符合Linux的风格，只有等到真正的使用的时候，才会通过缺页中断分配内存，接着mmap函数，它会分配内存吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static int ashmem_mmap(struct file *file, struct vm_area_struct *vma) &#123;</span><br><span class="line">    struct ashmem_area *asma &#x3D; file-&gt;private_data;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    mutex_lock(&amp;ashmem_mutex);</span><br><span class="line">    ...</span><br><span class="line">    if (!asma-&gt;file) &#123;</span><br><span class="line">        char *name &#x3D; ASHMEM_NAME_DEF;</span><br><span class="line">        struct file *vmfile;</span><br><span class="line"></span><br><span class="line">        if (asma-&gt;name[ASHMEM_NAME_PREFIX_LEN] !&#x3D; &#39;\0&#39;)</span><br><span class="line">            name &#x3D; asma-&gt;name;</span><br><span class="line">        &#x2F;&#x2F; 这里创建的临时文件其实是备份用的临时文件，之类的临时文件有文章说只对内核态可见，用户态不可见，我们也没有办法通过命令查询到 ，可以看做是个隐藏文件，用户空间看不到！！</span><br><span class="line">        &lt;!--校准真正操作的文件--&gt;</span><br><span class="line">        vmfile &#x3D; shmem_file_setup(name, asma-&gt;size, vma-&gt;vm_flags);</span><br><span class="line">        asma-&gt;file &#x3D; vmfile;</span><br><span class="line">    &#125;</span><br><span class="line">    get_file(asma-&gt;file);</span><br><span class="line">    if (vma-&gt;vm_flags &amp; VM_SHARED)</span><br><span class="line">        shmem_set_file(vma, asma-&gt;file);</span><br><span class="line">    else &#123;</span><br><span class="line">        if (vma-&gt;vm_file)</span><br><span class="line">            fput(vma-&gt;vm_file);</span><br><span class="line">        vma-&gt;vm_file &#x3D; asma-&gt;file;</span><br><span class="line">    &#125;</span><br><span class="line">    vma-&gt;vm_flags |&#x3D; VM_CAN_NONLINEAR;</span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;ashmem_mutex);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里就复用了Linux的共享内存机制，虽然说是匿名共享内存，但底层其实还是给共享内存设置了名称（前缀ASHMEM_NAME_PREFIX+名字），如果名字未设置，那就默认使用ASHMEM_NAME_PREFIX作为名称。不过，在这里没直接看到内存分配的函数。但是，有两个函数shmem_file_setup与shmem_set_file很重要，也是共享内存比较不好理解的地方，shmem_file_setup是原生linux的共享内存机制，不过Android也修改Linux共享内存的驱动代码，匿名共享内存其实就是在Linux共享内存的基础上做了改进，</p>
<p>struct file <em>shmem_file_setup(char *name, loff_t size, unsigned long flags) {<br>    int error;<br>    struct file *file;<br>    struct inode *inode;<br>    struct dentry *dentry, *root;<br>    struct qstr this;<br>    error = -ENOMEM;<br>    this.name = name;<br>    this.len = strlen(name);<br>    this.hash = 0; /</em> will go <em>/<br>    root = shm_mnt-&gt;mnt_root;<br>    dentry = d_alloc(root, &amp;this);//分配dentry cat/proc/pid/maps可以查到<br>    error = -ENFILE;<br>    file = get_empty_filp();      //分配file<br>    error = -ENOSPC;<br>    inode = shmem_get_inode(root-&gt;d_sb, S_IFREG | S_IRWXUGO, 0, flags);//分配inode，分配成功就好比建立了文件，也许并未存在真实文件映射<br>    d_instantiate(dentry, inode);//绑定<br>    inode-&gt;i_size = size;<br>    inode-&gt;i_nlink = 0; /</em> It is unlinked */<br>        // 文件操作符，这里似乎真的是不在内存里面创建什么东西？？？<br>    init_file(file, shm_mnt, dentry, FMODE_WRITE | FMODE_READ,<br>          &amp;shmem_file_operations);//绑定，并指定该文件操作指针为shmem_file_operations<br>    …<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过shmem_file_setup在tmpfs临时文件系统中创建一个临时文件（也许只是内核中的一个inode节点），该文件与Ashmem驱动程序创建的匿名共享内存对应，不过用户态并不能看到该临时文件，之后就能够使用该临时文件了，注意共享内存机制真正使用map的对象其实是这个临时文件，而不是ashmem设备文件，这里之所以是一次mmap，主要是通过vma-&gt;vm_file &#x3D; asma-&gt;file完成map对象的替换，当映射的内存引起缺页中断的时候，就会调用shmem_file_setup创建的对象的函数，而不是ashmem的，看下临时文件的对应的hook函数，</span><br></pre></td></tr></table></figure>
<p>void shmem_set_file(struct vm_area_struct *vma, struct file *file) {<br>    if (vma-&gt;vm_file)<br>        fput(vma-&gt;vm_file);<br>    vma-&gt;vm_file = file;<br>    vma-&gt;vm_ops = &shmem_vm_ops;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">到这里回到之前的MemoryFile，看一下写操作：</span><br></pre></td></tr></table></figure>
<p>public void writeBytes(byte[] buffer, int srcOffset, int destOffset, int count)<br>        throws IOException {<br>    if (isDeactivated()) {<br>        throw new IOException(“Can’t write to deactivated memory file.”);<br>    }<br>    if (srcOffset &lt; 0 || srcOffset &gt; buffer.length || count &lt; 0<br>            || count &gt; buffer.length - srcOffset<br>            || destOffset &lt; 0 || destOffset &gt; mLength<br>            || count &gt; mLength - destOffset) {<br>        throw new IndexOutOfBoundsException();<br>    }<br>    native_write(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">进入native代码</span><br><span class="line"></span><br><span class="line">static jint android_os_MemoryFile_write(JNIEnv* env, jobject clazz,</span><br><span class="line">        jobject fileDescriptor, jint address, jbyteArray buffer, jint srcOffset, jint destOffset,</span><br><span class="line">        jint count, jboolean unpinned)</span><br><span class="line">&#123;</span><br><span class="line">    int fd &#x3D; jniGetFDFromFileDescriptor(env, fileDescriptor);</span><br><span class="line">    if (unpinned &amp;&amp; ashmem_pin_region(fd, 0, 0) &#x3D;&#x3D; ASHMEM_WAS_PURGED) &#123;</span><br><span class="line">        ashmem_unpin_region(fd, 0, 0);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;GetByteArrayRegion(buffer, srcOffset, count, (jbyte *)address + destOffset);</span><br><span class="line">    if (unpinned) &#123;</span><br><span class="line">        ashmem_unpin_region(fd, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">在内核中，一块内存对应的数据结构是ashmem_area：</span><br><span class="line"></span><br><span class="line">struct ashmem_area &#123;</span><br><span class="line">    char name[ASHMEM_FULL_NAME_LEN];&#x2F;* optional name for &#x2F;proc&#x2F;pid&#x2F;maps *&#x2F;</span><br><span class="line">    struct list_head unpinned_list; &#x2F;* list of all ashmem areas *&#x2F;</span><br><span class="line">    struct file *file;      &#x2F;* the shmem-based backing file *&#x2F;</span><br><span class="line">    size_t size;            &#x2F;* size of the mapping, in bytes *&#x2F;</span><br><span class="line">    unsigned long prot_mask;    &#x2F;* allowed prot bits, as vm_flags *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">当使用Ashmem分配了一块内存，部分不被使用时，就可以将这块内存unpin掉，内核可以将unpin对应的物理页面回收,回收后的内存还可以再次被获得(通过缺页handler)，因为unpin操作并不会改变已经mmap的地址空间，不过，MemoryFile只会操作整个共享内存，而不会分块访问，所以pin与unpin对于它没多大意义，可以看做整个区域都是pin或者unpin的，首次通过env-&gt;GetByteArrayRegion访问会引发缺页中断，进而调用tmpfs 文件的相应操作，分配物理页，在Android现在的内核中，缺页中断对应的vm_operations_struct中的函数是fault，在共享内存实现中，对应的是shmem_fault如下，</span><br><span class="line"></span><br><span class="line">static struct vm_operations_struct shmem_vm_ops &#x3D; &#123;</span><br><span class="line">    .fault      &#x3D; shmem_fault,</span><br><span class="line">    </span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">    .set_policy     &#x3D; shmem_set_policy,</span><br><span class="line">    .get_policy     &#x3D; shmem_get_policy,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line">当mmap的tmpfs文件引发缺页中断时， 就会调用shmem_fault函数，</span><br><span class="line"></span><br><span class="line">static int shmem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)</span><br><span class="line">&#123;</span><br><span class="line">    struct inode *inode &#x3D; vma-&gt;vm_file-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line">    int error;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    if (((loff_t)vmf-&gt;pgoff &lt;&lt; PAGE_CACHE_SHIFT) &gt;&#x3D; i_size_read(inode))</span><br><span class="line">        return VM_FAULT_SIGBUS;</span><br><span class="line"></span><br><span class="line">    error &#x3D; shmem_getpage(inode, vmf-&gt;pgoff, &amp;vmf-&gt;page, SGP_CACHE, &amp;ret);</span><br><span class="line">    if (error)</span><br><span class="line">        return ((error &#x3D;&#x3D; -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS);</span><br><span class="line"></span><br><span class="line">    return ret | VM_FAULT_LOCKED;</span><br><span class="line">&#125;</span><br><span class="line">到这里，就可以看到会调用shmem_getpage函数分配真实的物理页，具体的分配策略比较复杂，不在分析。</span><br><span class="line"></span><br><span class="line">Android匿名共享内存的pin与unpin</span><br><span class="line">pin本身的意思是压住，定住，ashmem_pin_region和ashmem_unpin_region这两个函数从字面上来说，就是用来对匿名共享内存锁定和解锁，标识哪些内存正在使用需要锁定，哪些内存是不使用的，这样，ashmem驱动程序可以一定程度上辅助内存管理，提供一定的内存优化能力。匿名共享内存创建之初时，所有的内存都是pinned状态，只有用户主动申请，才会unpin一块内存，只有对于unpinned状态的内存块，用户才可以重新pin。现在仔细梳理一下驱动，看下pin与unpin的实现</span><br><span class="line"></span><br><span class="line"> static int __init ashmem_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    &lt;!--创建 ahemem_area 高速缓存--&gt;</span><br><span class="line">    ashmem_area_cachep &#x3D; kmem_cache_create(&quot;ashmem_area_cache&quot;,</span><br><span class="line">                      sizeof(struct ashmem_area),</span><br><span class="line">                      0, 0, NULL);</span><br><span class="line">    ...</span><br><span class="line">    &lt;!--创建 ahemem_range高速缓存--&gt;</span><br><span class="line">    ashmem_range_cachep &#x3D; kmem_cache_create(&quot;ashmem_range_cache&quot;,</span><br><span class="line">                      sizeof(struct ashmem_range),</span><br><span class="line">                      0, 0, NULL);</span><br><span class="line">    ...</span><br><span class="line">    &lt;!--注册杂项设备去送--&gt;               </span><br><span class="line">    ret &#x3D; misc_register(&amp;ashmem_misc);</span><br><span class="line">    ...</span><br><span class="line">    register_shrinker(&amp;ashmem_shrinker);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">打开ashem的时候 ，会利用ashmem_area_cachep告诉缓存新建ashmem_area对象，并初始化unpinned_list，开始肯定为null</span><br></pre></td></tr></table></figure>
<p>static int ashmem_open(struct inode *inode, struct file *file) {<br>    struct ashmem_area *asma;<br>    int ret;</p>
<pre><code>ret = nonseekable_open(inode, file);
asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL);
&lt;!--关键是初始化unpinned_list列表--&gt;
INIT_LIST_HEAD(&amp;asma-&gt;unpinned_list);
memcpy(asma-&gt;name, ASHMEM_NAME_PREFIX, ASHMEM_NAME_PREFIX_LEN);
asma-&gt;prot_mask = PROT_MASK;
file-&gt;private_data = asma;
return 0;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一开始都是pin的，看一下pin与unpin的调用范例：</span><br></pre></td></tr></table></figure>
<p>int ashmem_pin_region(int fd, size_t offset, size_t len) {<br>    struct ashmem_pin pin = { offset, len };<br>    return ioctl(fd, ASHMEM_PIN, &amp;pin);<br>}</p>
<p>int ashmem_unpin_region(int fd, size_t offset, size_t len) {<br>    struct ashmem_pin pin = { offset, len };<br>    return ioctl(fd, ASHMEM_UNPIN, &amp;pin);<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接着看ashmem_unpin</span><br></pre></td></tr></table></figure>
<p>static int ashmem_unpin(struct ashmem_area *asma, size_t pgstart, size_t pgend) {<br>    struct ashmem_range *range, *next;<br>    unsigned int purged = ASHMEM_NOT_PURGED;<br>    restart:<br>    list_for_each_entry_safe(range, next, &amp;asma-&gt;unpinned_list, unpinned) {</p>
<pre><code>    if (range_before_page(range, pgstart))
        break;

    if (page_range_subsumed_by_range(range, pgstart, pgend))
        return 0;
    if (page_range_in_range(range, pgstart, pgend)) {
        pgstart = min_t(size_t, range-&gt;pgstart, pgstart),
        pgend = max_t(size_t, range-&gt;pgend, pgend);
        purged |= range-&gt;purged;
        range_del(range);
        goto restart;
    }
}
return range_alloc(asma, range, purged, pgstart, pgend);</code></pre><p>}<br>这个函数主要作用是创建一个ashmem_range ，并插入ashmem_area的unpinned_list，在插入的时候可能会有合并为，这个时候要首先删除原来的unpin ashmem_range，之后新建一个合并后的ashmem_range插入unpinned_list。</p>
<p>下面来看一下pin函数的实现，先理解了unpin，pin就很好理解了，其实就是将一块共享内存投入使用，如果它位于unpinedlist，就将它摘下来：</p>
<p>static int ashmem_pin(struct ashmem_area *asma, size_t pgstart, size_t pgend)<br>{<br>    struct ashmem_range *range, *next;<br>    int ret = ASHMEM_NOT_PURGED;</p>
<pre><code>list_for_each_entry_safe(range, next, &amp;asma-&gt;unpinned_list, unpinned) {
    /* moved past last applicable page; we can short circuit */

    if (range_before_page(range, pgstart))
        break;
    if (page_range_in_range(range, pgstart, pgend)) {
        ret |= range-&gt;purged;

        if (page_range_subsumes_range(range, pgstart, pgend)) {
            range_del(range);
            continue;
        }

        if (range-&gt;pgstart &gt;= pgstart) {
            range_shrink(range, pgend + 1, range-&gt;pgend);
            continue;
        }
        if (range-&gt;pgend &lt;= pgend) {
            range_shrink(range, range-&gt;pgstart, pgstart-1);
            continue;
        }

        range_alloc(asma, range, range-&gt;purged,
                pgend + 1, range-&gt;pgend);
        range_shrink(range, range-&gt;pgstart, pgstart - 1);
        break;
    }
}
return ret;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Android进程共享内存的传递-fd文件描述符的传递</span><br><span class="line">原生Linux共享内存是通过传递已知的key来处理的，但是Android中不存在这种机制，Android是怎么处理的呢？那就是通过Binder传递文件描述符来处理，Android的Binder对于fd的传递也做了适配，原理其实就是在内核层为要传递的目标进程转换fd，因为在linux中fd只是对本进程是有效、且唯一，进程A打开一个文件得到一个fd，不能直接为进程B使用，因为B中那个fd可能压根无效、或者对应其他文件，不过，虽然同一个文件可以有多个文件描述符，但是文件只有一个，在内核层也只会对应一个inode节点与file对象，这也是内核层可以传递fd的基础，Binder驱动通过当前进程的fd找到对应的文件，然后为目标进程新建fd，并传递给目标进程，核心就是把进程A中的fd转化成进程B中的fd，看一下Android中binder的实现：</span><br></pre></td></tr></table></figure>
<p>void binder_transaction() {<br>   …<br>        case BINDER_TYPE_FD: {<br>        int target_fd;<br>        struct file *file;<br>        <!--关键点1 可以根据fd在当前进程获取到file ，多个进程打开同一文件，在内核中对应的file是一样--><br>        file = fget(fp-&gt;handle);<br>        <!--关键点2,为目标进程获取空闲fd--><br>        target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);<br>        <!--关键点3将目标进程的空闲fd与file绑定--><br>        task_fd_install(target_proc, target_fd, file);<br>        fp-&gt;handle = target_fd;<br>    } break;<br>    …<br> }</p>
<!--从当前进程打开的files中找到file在内核中的实例-->
<p>struct file *fget(unsigned int fd)<br>{<br>    struct file *file;<br>    struct files_struct *files = current-&gt;files;<br>    rcu_read_lock();<br>    file = fcheck_files(files, fd);<br>    rcu_read_unlock();<br>    return file;<br>}</p>
<p>static void task_fd_install(<br>    struct binder_proc *proc, unsigned int fd, struct file *file)<br>{<br>    struct files_struct *files = proc-&gt;files;<br>    struct fdtable *fdt;<br>    if (files == NULL)<br>        return;<br>    spin_lock(&amp;files-&gt;file_lock);<br>    fdt = files_fdtable(files);<br>    rcu_assign_pointer(fdt-&gt;fd[fd], file);<br>    spin_unlock(&amp;files-&gt;file_lock);<br>}<br>fd传递.jpg<br>为什么看不到匿名共享内存对应的文件呢<br>为什么Android用户看不到共享内存对应的文件，Google到的说法是：在内核没有定义defined(CONFIG_TMPFS) 情况下，tmpfs对用户不可见：</p>
<p>If CONFIG_TMPFS is not set, the user visible part of tmpfs is not build. But the internal mechanisms are always present.</p>
<p>而在Android的shmem.c驱动中确实没有defined(CONFIG_TMPFS) ，这里只是猜测，也许还有其他解释，如有了解，望能指导。</p>
<ul>
<li><p>匿名共享内存的优点也是BUG: 匿名共享内存不会占用Dalvik Heap与Native Heap，不会导致OOM，这是优点，同时也是缺点，因为如果肆意使用，会导致系统资源不足，性能下降，</p>
</li>
<li><p>匿名共享内存不占用: 另外共享存占用空间的计算，只会计算到第一个创建它的进程中，其他进程不将ashmem计算在内。</p>
</li>
</ul>
<p>总结<br>Android匿名共享内存是基于Linux共享内存的，都是在tmpfs文件系统上新建文件，并将其映射到不同的进程空间，从而达到共享内存的目的，只是，Android在Linux的基础上进行了改造，并借助Binder+fd文件描述符实现了共享内存的传递。</p>
<p><a href="https://www.jianshu.com/p/d9bc9c668ba6" target="_blank" rel="noopener"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
