<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/Android%E5%9F%BA%E7%A1%80%20--%20%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/Android%E5%9F%BA%E7%A1%80%20--%20%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">Android基础 -- 四大组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 10:33:14 / 修改时间：10:35:51" itemprop="dateCreated datePublished" datetime="2020-06-01T10:33:14+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/FrameWork/" itemprop="url" rel="index"><span itemprop="name">FrameWork</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="Activity生命周期.png"/>

<p>注意：当activityB在activityA之前启动时，将在A上调用onPause()回调。在A的onPause()返回之前，将不会创建B，因此请确保onPause()中不要做任何冗长的操作。</p>
<ol>
<li><p>Activity实例是由系统自动创建，并在不同的状态期间回调相应的方法。一个最简单的完整的Activity生命周期会按照如下顺序回调：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestroy。称之为entire lifetime。</p>
</li>
<li><p>当执行onStart回调方法时，Activity开始被用户所见（也就是说，onCreate时用户是看不到此Activity的，那用户看到的是哪个？当然是此Activity之前的那个Activity），一直到onStop之前，此阶段Activity都是被用户可见，称之为visible lifetime。</p>
</li>
<li><p>当执行到onResume回调方法时，Activity可以响应用户交互，一直到onPause方法之前，此阶段Activity称之为foreground lifetime。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序启动</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.687</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.819</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.823</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.802</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.815</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.824</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">54.156</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.672</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.716</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.717</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br><span class="line"><span class="comment">// 按下home键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.703</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.722</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.723</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 返回应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.968</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">20.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.274</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.925</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.959</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.963</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入task</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.056</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.068</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.088</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 后台终止</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">51.310</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="打印生命周期"><a href="#打印生命周期" class="headerlink" title="打印生命周期"></a>打印生命周期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BaseActivity"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onCreate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onResume"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onPause"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onRestart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onStop"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="keyword">this</span> + <span class="string">" onNewIntent"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onActivityResult"><a href="#onActivityResult" class="headerlink" title="onActivityResult"></a>onActivityResult</h2><p>MainActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivityForResult(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>), 0)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"MainActivity-onActivityResult"</span>);</span><br><span class="line">    Log.d(<span class="string">"LLL"</span>, <span class="string">"result = "</span> + data.getStringExtra(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecondActivity:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"value"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">setResult(<span class="number">1</span>, intent);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.038</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.070</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.166</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">34.170</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.659</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.672</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.679</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">39.682</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">40.015</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">48.965</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onActivityResult</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: result = hearing</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.013</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.014</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.395</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line"><span class="number">09</span>-<span class="number">25</span> <span class="number">22</span>:<span class="number">19</span>:<span class="number">49.396</span> <span class="number">14025</span>-<span class="number">14025</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br></pre></td></tr></table></figure>

<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p>通过android:launchMode配置</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是Activity默认的启动模式，在不指定Activity启动模式的情况下，所有Activity使用的都是standard模式。</p>
<p>在standard模式下，每当启动一个新的Activity，它就会进入任务栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会判断该Activity在栈中是否存在，每次启动都会创建一个新的实例。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>singleTop模式与standard类似，不同的是，当启动的Activity已经位于栈顶时，则直接使用它不创建新的实例，此时栈顶的Activity实例会调onNewIntent方法。如果启动的Activity没有位于栈顶时，则创建一个新的实例位于栈顶。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>如果希望Activity在整个应用程序中只存在一个实例，可以使用singleTask模式，当Activity的启动模式指定为 singleTask，每次启动该Activity时，系统首先会检查栈中是否存在该Activity的实例，如果发现已经存在则直接使用该实例，此时栈顶的Activity实例会调onNewIntent方法，并将当前Activity之上的所有Activity出栈，如果没有发现则创建一个新的实例。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>在程序开发过程中，如果需要Activity在整个系统中都只有一个实例，这时就需要用到singleInstance模式。指定为singleInstance模式的Activity会启动一个新的任务栈来管理这个Activity。</p>
<p>singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。采用这种模式启动Activity会分为一下两种情况：</p>
<ul>
<li>如果要启动的Activity不存在，系统会创建一个新的任务栈，在创建该Activity的实例，并把该Activity加入栈顶.</li>
<li>如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。</li>
</ul>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a>allowTaskReparenting</h3><p>如果该Activity的allowTaskReparenting设置为true，它进入后台，当一个和它有相同affinity的Task进入前台时，它会重新宿主，进入到该前台的task中。</p>
<table>
<thead>
<tr>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">taskAffinity</th>
<th align="center">allowTaskReparenting</th>
</tr>
</thead>
<tbody><tr>
<td align="center">application1</td>
<td align="center">Activity1</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">application2</td>
<td align="center">Activity2</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>创建两个工程：application1和application2，分别含有Activity1和Activity2，它们的taskAffinity相同，Activity1的allowTaskReparenting为true。</p>
<p>首先，我们启动application1,加载Activity1，然后按Home键，使该task（假设为task1）进入后台。然后启动application2，默认加载Activity2。本来应该是显示Activity2，但是我们却看到了Activity1。实际上Activity2也被加载了，只是Activity1重新宿主，所以看到了Activity1。</p>
<h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>如果加载某个Activity的intent，Flag被设置成FLAG_ACTIVITY_NEW_TASK时，它会首先检查是否存在与自己taskAffinity相同的Task，如果存在，那么它会直接宿主到该Task中，如果不存在则重新创建Task。</p>
<p>写一个应用，包含两个Activity：Activity1的taskAffinity为<code>com.hearing.task</code>，Activity2为入口，且点击Activity2会以FLAG_ACTIVITY_NEW_TASK启动Activity1。再写一个应用MyActivity，它包含一个Activity（MyActivity），其taskAffinity为<code>com.hearing.task</code>。</p>
<p>首先启动MyActivity，然后Home回桌面，然后打开Activity2，点击Activity2，进入Activity1。然后按返回键。进入Activity的顺序为Activity2-&gt;Activity1，而返回时顺序为Activity1-&gt;MyActivity。这就说明了一个问题，Activity1在启动时，重新宿主到了MyActivity所在的Task中去了。</p>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul>
<li>当一个应用程序加载一个singleTask模式的Activity时，首先该Activity会检查是否存在与它的taskAffinity相同的Task。如果存在，那么检查是否实例化，如果已经实例化，那么销毁在该Activity以上的Activity并调用onNewIntent。如果没有实例化，那么该Activity实例化并入栈。如果不存在，那么就重新创建Task，并入栈。</li>
<li>当一个应用程序加载一个singleInstance模式的Activity时，如果该Activity没有被实例化，那么就重新创建一个Task，并入栈，如果已经被实例化，那么就调用该Activity的onNewIntent.singleInstance的Activity所在的Task不允许存在其他Activity，任何从该Activity加载的其它Activity（假设为Activity2）都会被放入其它的Task中，如果存在与Activity2相同affinity的Task，则在该Task内创建Activity2。如果不存在，则重新生成新的Task并入栈。</li>
</ul>
<h2 id="onSaveInstanceState与onRestoreInstanceState方法"><a href="#onSaveInstanceState与onRestoreInstanceState方法" class="headerlink" title="onSaveInstanceState与onRestoreInstanceState方法"></a>onSaveInstanceState与onRestoreInstanceState方法</h2><p>onSaveInstanceState主要是用于保存一些临时数据，当Activity恢复时，可以恢复对应的数据，onRestoreInstanceState当Activity被重新创建时调用，可以从该 方法中恢复一些之前保存过的数据。</p>
<p>onSaveInstanceState一般是在Activity被“打断”的情况下被调用，例如被覆盖，包括全覆盖或者部分覆盖，或者按home退到后台，或者灭屏。另外一种情况就是Activity被重新创建会调用，例如用户在当前Activity旋转屏幕，或者用户调用recreate方法。点击返回键该方法不会被调用。onSaveInstanceState的调用顺序是在onPause之后，onStop之前。</p>
<p>onRestoreInstanceState一般是在Activty被重新创建恢复时会被调用，例如用户切换横竖屏。用户将Activty挂后台，切换系统设置，然后再启动该Activity。</p>
<h2 id="启动方式的问题"><a href="#启动方式的问题" class="headerlink" title="启动方式的问题"></a>启动方式的问题</h2><p>MainActivity是SingleTask或者SingleInstance模式，启动TestActivity，TestActivity马上跳转到MainActivity，这种情况下，MainActivity的onResume会回调两次。日志如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onCreate</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onStart</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">TestActivity onCreate</span><br><span class="line">TestActivity onStart</span><br><span class="line">TestActivity onResume</span><br><span class="line">TestActivity onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onNewIntent</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">TestActivity onStop</span><br></pre></td></tr></table></figure>

<p>适当延时500ms再跳转回MainActivity可以解决这个问题（可能由于业务场景不同，会带来新的问题）。</p>
<p>在<a href="https://stackoverflow.com/questions/11092101/startactivity-on-foreground-application-causes-onpause-onresume" target="_blank" rel="noopener">stackoverflow</a>上也有人发现过类似的问题。</p>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>普通广播（Normal Broadcast）</li>
<li>系统广播（System Broadcast）</li>
<li>有序广播（Ordered Broadcast）</li>
<li>粘性广播（Sticky Broadcast）（已弃用）</li>
<li>App应用内广播（Local Broadcast）</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="BroadcastReceiver-1"><a href="#BroadcastReceiver-1" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><ul>
<li>继承BroadcastReceivre基类</li>
<li>必须复写抽象方法onReceive()方法</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><ul>
<li>常驻：不受任何组件声明周期影响</li>
<li>耗电，占内存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    //此<span class="attr">broadcastReceiver</span>能否接收其他<span class="attr">App</span>的发出的广播</span></span><br><span class="line"><span class="tag">    //默认值是由<span class="attr">receiver</span>中有无<span class="attr">intent-filter</span>决定的：如果有<span class="attr">intent-filter</span>，默认值为<span class="attr">true</span>，否则为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">"drawable resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"string resource"</span></span></span><br><span class="line"><span class="tag">    //继承<span class="attr">BroadcastReceiver</span>子类的类名</span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".mBroadcastReceiver"</span></span></span><br><span class="line"><span class="tag">    //具有相应权限的广播发送者发送的广播才能被此<span class="attr">BroadcastReceiver</span>所接收；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">BroadcastReceiver</span>运行所处的进程</span></span><br><span class="line"><span class="tag">    //默认为<span class="attr">app</span>的进程，可以指定独立的进程</span></span><br><span class="line"><span class="tag">    //注：<span class="attr">Android</span>四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"string"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    //用于指定此广播接收器将接收的广播类型</span><br><span class="line">    //本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.net.conn.CONNECTIVITY_CHANGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><ul>
<li>非常驻，灵活</li>
<li>手动释放</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">    mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> mBroadcastReceiver();</span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中</span></span><br><span class="line"><span class="comment">// 当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。</li>
<li>假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>生命周期:</p>
<ol>
<li><p>startService()</p>
<ul>
<li>作用：启动Service服务</li>
<li>手动调用startService()后，自动调用内部方法：onCreate()、onStartCommand() </li>
<li>如果一个service被startService多次启动，onCreate()只会调用一次 </li>
<li>onStartCommand()调用次数=startService()次数</li>
</ul>
</li>
<li><p>stopService()</p>
<ul>
<li>作用：关闭Service服务 </li>
<li>手动调用stopService()后，自动调用内部方法：onDestory() </li>
<li>如果一个service被启动且被绑定，如果没有在绑定的前提下stopService()是无法停止服务的。</li>
</ul>
</li>
<li><p>bindService()</p>
<ul>
<li>作用：绑定Service服务 </li>
<li>手动调用bindService()后，自动调用内部方法：onCreate()、onBind()</li>
</ul>
</li>
<li><p>unbindService()</p>
<ul>
<li>作用：解绑Service服务 </li>
<li>手动调用unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory()</li>
</ul>
</li>
</ol>
<p>接口函数：</p>
<ul>
<li>onStartCommand()：当其他组件调用startService()方法请求启动Service时，该方法被回调。一旦Service启动，它会在后台独立运行。当Service执行完以后，需调用stopSelf() 或 stopService()方法停止Service。（若您只希望bind Service，则无需调用这些方法）</li>
<li>onBind()：当其他组件调用bindService()方法请求绑定Service时，该方法被回调。该方法返回一个IBinder接口，该接口是Service与绑定的组件进行交互的桥梁。若Service未绑定其他组件，该方法应返回null。</li>
<li>onCreate()：当Service第一次创建时，回调该方法。该方法只被回调一次，并在onStartCommand() 或 onBind()方法被回调之前执行。若Service处于运行状态，该方法不会回调。</li>
<li>onDestroy()：当Service被销毁时回调，在该方法中应清除一些占用的资源，如停止线程、接触绑定注册的监听器或broadcast receiver 等。该方法是Service中的最后一个回调。</li>
</ul>
<p>启动方式：</p>
<ul>
<li>Started：其他组件调用startService()方法启动一个Service。一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。通常，一个被start的Service会在后台执行单独的操作，也并不给启动它的组件返回结果。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</li>
<li>Bound：其他组件调用bindService()方法绑定一个Service。通过绑定方式启动的Service是一个client-server结构，该Service可以与绑定它的组件进行交互。一个bound service仅在有组件与其绑定时才会运行（A bound service runs only as long as another application component is bound to it），多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。</li>
</ul>
<p>注意：</p>
<ul>
<li>Service运行在主线程中（A service runs in the main thread of its hosting process），Service并不是一个新的线程，也不是新的进程。也就是说，若您需要在Service中执行较为耗时的操作（如播放音乐、执行网络请求等），需要在Service中创建一个新的线程。这可以防止ANR的发生，同时主线程可以执行正常的UI操作。</li>
<li>如果某个组件通过调用startService()启动了Service（系统会回调onStartCommand()方法），那么直到在Service中手动调用stopSelf()方法、或在其他组件中手动调用stopService()方法，该Service才会停止。</li>
<li>如果某个组件通过调用bindService()绑定了Service（系统不会回调onStartCommand()方法），只要该组件与Service处于绑定状态，Service就会一直运行，当Service不再与组件绑定时，该Service将被destroy。</li>
<li>当系统内存低时，系统将强制停止Service的运行；若Service绑定了正在与用户交互的activity，那么该Service将不大可能被系统kill（ less likely to be killed）。如果创建的是前台Service，那么该Service几乎不会被kill（almost never be killed）。否则，当创建了一个长时间在后台运行的Service后，系统会降低该Service在后台任务栈中的级别——这意味着它容易被kill（lower its position in the list of background tasks over time and the service will become highly susceptible to killing），所以在开发Service时，需要使Service变得容易被restart，因为一旦Service被kill，再restart它需要其资源可用时才行</li>
</ul>
<h2 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.example.servicetest.MyService"</span> &gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承IntentService类"><a href="#继承IntentService类" class="headerlink" title="继承IntentService类"></a>继承IntentService类</h2><ul>
<li>默认在子线程中处理回传到onStartCommand()方法中的Intent；</li>
<li>在重写的onHandleIntent()方法中处理按时间排序的Intent队列，所以不用担心多线程（multi-threading）带来的问题。</li>
<li>当所有请求处理完成后，自动停止service，无需手动调用stopSelf()方法；</li>
<li>默认实现了onBind()方法，并返回null；</li>
<li>默认实现了onStartCommand()方法，并将回传的Intent以序列的形式发送给onHandleIntent()，只需重写该方法并处理Intent即可。</li>
</ul>
<h2 id="继承Service类"><a href="#继承Service类" class="headerlink" title="继承Service类"></a>继承Service类</h2><p>如果需要在Service中执行多线程而不是处理一个请求队列，那么需要继承Service类，分别处理每个Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		Log.d(TAG, <span class="string">"onCreate() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">		Log.d(TAG, <span class="string">"onStartCommand() executed"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">		Log.d(TAG, <span class="string">"onDestroy() executed"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mBinder;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="string">"TAG"</span>, <span class="string">"startDownload() executed"</span>);</span><br><span class="line">			<span class="comment">// 执行具体的下载任务</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onStartCommand()返回一个整形变量，该变量必须是下列常量之一：</p>
<ul>
<li>START_NOT_STICKY：若执行完onStartCommand()方法后，系统就kill了service，不要再重新创建service，除非系统回传了一个pending intent。这避免了在不必要的时候运行service，您的应用也可以restart任何未完成的操作。</li>
<li>START_STICKY：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()。dangerous不要重新传递最后一个Intent（do not redeliver the last intent）。相反，系统回调onStartCommand()时回传一个空的Intent，除非有 pending intents传递，否则Intent将为null。该模式适合做一些类似播放音乐的操作。</li>
<li>START_REDELIVER_INTENT：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()并将最后一个Intent回传至该方法。任何 pending intents都会被轮流传递。该模式适合做一些类似下载文件的操作。</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>startService(intent)方法将立即返回，并回调onStartCommand()（请不要手动调用该方法），若该Service未处于运行状态，系统将首先回调onCreate()，接着再回调onStartCommand()。若您希望Service可以返回结果，那么需要通过调用getBroadcast 返回的PendingIntent启动Service（将PendingIntent包装为Intent），service可使用broadcast 传递结果。</p>
<p>多个启动Service的请求可能导致onStartCommand()多次调用，但只需调用stopSelf() 、 stopService()这两个方法之一，就可停止该服务。</p>
<h2 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h2><ul>
<li>通过其他组件调用bindService()方法可以绑定一个Service以保持长连接（long-standing connection），这时一般不允许其他组件调用startService()启动Service。</li>
<li>当其他组件需要与Service交互或者需要跨进程通信时，可以创建一个bound Service。</li>
<li>为创建一个bound Service，必须重写onBind()回调，该方法返回一个IBinder接口。该接口时组件与Service通信的桥梁。组件调用bindService()与Service绑定，该组件可获取IBinder接口，一旦获取该接口，就可以调用Service中的方法。一旦没有组件与Service绑定，系统将destroy它，您不必手动停止它。</li>
<li>为创建一个bound Service，必须定义一个接口 ，该接口指定组件与Service如何通信。定义的接口在组件与Service之间，且必须实现IBinder接口。这正是onBind()的返回值。一旦组件接收了IBinder，组件与Service便可以开始通信。</li>
<li>多个组件可同时与Service绑定，当组件与Service交互结束后，可调用unbindService()方法解绑。bound Service比start Service要复杂，故我将在后续单独翻译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> MyService.MyBinder myBinder;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">			myBinder = (MyService.MyBinder) service;</span><br><span class="line">			myBinder.startDownload();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.start_service:</span><br><span class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			startService(startIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">			Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			stopService(stopIntent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">			Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">			unbindService(connection);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行前台Service"><a href="#运行前台Service" class="headerlink" title="运行前台Service"></a>运行前台Service</h2><ul>
<li>前台Service用于动态通知消息，如天气预报。该Service不易被kill。前台Service必须提供status bar，只有前台Service被destroy后，status bar才能消失。</li>
<li>举例来说，一个播放音乐的Service必须是前台Service，只有这样用户才能确知其运行状态。为前台Service提供的status bar可以显示当前音乐的播放状态，并可以启动播放音乐的Activity。</li>
<li>调用startForeground()可以启动前台Service。该方法接收两个参数，参数一是一个int型变量，用户指定该通知的唯一性标识，而参数而是一个Notification用于配置status bar</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ContentProvider为不同的应用之间数据共享提供统一的接口，Android系统中应用内部的数据是对外隔离的，要想让其它应用能够访问自己的数据，可以使用ContentProvider，其底层采用Binder机制实现跨进程共享数据。</p>
<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p>Uri的四个组成部分：content://contacts/people/5</p>
<ul>
<li>schema：已由Android固定设置为content://</li>
<li>authority：ContentProvider权限，在AndroidMenifest中设置权限</li>
<li>path：要操作的数据库表</li>
<li>id：查询的关键字（可选字段）</li>
</ul>
<p>Uri匹配模式：Uri的匹配表示要查询的数据，对于单个数据查询，可直接使用Uri定位具体的资源位置，但当范围查询时就需要结合通配符的使用，Uri提供以下两种通配符：</p>
<ul>
<li><code>*</code>：匹配由任意长度的任何有效字符组成的字符串</li>
<li><code>#</code>：匹配由任意长度的数字字符组成的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table2/*  //多数据查询</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/#</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/6  //单数据查询</span></span><br></pre></td></tr></table></figure>

<p>Uri的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(“content:<span class="comment">//contacts/people/5")</span></span><br></pre></td></tr></table></figure>

<p>Uri创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过将 ID 值追加到 URI 末尾来访问表中的单个行</span></span><br><span class="line">Uri singleUri = ContentUris.withAppendedId(UserDictionary.Words.CONTENT_URI,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="ContentUris"><a href="#ContentUris" class="headerlink" title="ContentUris"></a>ContentUris</h2><p>核心方法有两个：</p>
<ul>
<li>withAppendedId()：向Uri追加一个id</li>
<li>parseId()：从Uri中获取id</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>)</span><br><span class="line"><span class="comment">// 生成的Uri为：content://cn.scu.myprovider/user/7</span></span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user/7"</span>)</span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>

<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p>UriMatcher的作用：</p>
<ul>
<li>在ContentProvider 中注册Uri</li>
<li>根据 Uri 匹配 ContentProvider 中对应的数据表</li>
</ul>
<p>使用步骤：</p>
<ol>
<li>初始化UriMatcher对象</li>
<li>在ContentProvider 中注册URI（addURI()）</li>
<li>根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match()）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line"><span class="comment">// 常量UriMatcher.NO_MATCH：不匹配任何路径的返回码</span></span><br><span class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI</span></span><br><span class="line"><span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user1"</span>, URI_CODE_a); </span><br><span class="line">matcher.addURI(<span class="string">"cn.scu.myprovider"</span>, <span class="string">"user2"</span>, URI_CODE_b); </span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a</span></span><br><span class="line"><span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">"content://cn.scu.myprovider/user1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(matcher.match(uri)) &#123;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_a:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser1;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_b:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentProvider-1"><a href="#ContentProvider-1" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>ContentProvider主要以表格的形式组织数据，同时也支持文件数据。它一般配合数据库共同使用，实现对外共享数据的目的，所以它需要对数据库的增删改查操作，ContentProvider也为我们提供了相应的操作方法，使用时只需实现即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后或打开系统后其它进程第一次访问该ContentProvider时由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前 Uri 所代表数据的MIME类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>上述CRUD方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</li>
<li>存在多线程并发访问，需要实现线程同步<ul>
<li>若ContentProvider的数据存储方式是使用一个SQLite，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</li>
<li>若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</li>
</ul>
</li>
</ol>
<h2 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a>ContentResolver</h2><p>外部进程通过 ContentResolver类，从而与ContentProvider类进行交互。一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大，所以在ContentProvider类上加多了一个 ContentResolver类对所有的ContentProvider进行统一管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver resolver = getContentResolver();</span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.hearing.provider.myprovider/tablename"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条记录</span></span><br><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"name"</span>, <span class="string">"hearing"</span>);</span><br><span class="line">values.put(<span class="string">"age"</span>, <span class="number">26</span>);</span><br><span class="line">resolver.insert(uri, values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tablename表中所有记录</span></span><br><span class="line">Cursor cursor = resolver.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"tablename data"</span>);</span><br><span class="line"><span class="keyword">while</span>(cursor.moveToNext()) &#123;</span><br><span class="line">   Log.i(<span class="string">"ContentTest"</span>, <span class="string">"tablename_id="</span>+ cursor.getInt(<span class="number">0</span>)+ <span class="string">", name="</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把id为1的记录的name字段值更改新为zhang1</span></span><br><span class="line">ContentValues updateValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">updateValues.put(<span class="string">"name"</span>, <span class="string">"zhang1"</span>);</span><br><span class="line">Uri updateIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.update(updateIdUri, updateValues, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除id为2的记录，即字段age</span></span><br><span class="line">Uri deleteIdUri = ContentUris.withAppendedId(uri, <span class="number">2</span>);</span><br><span class="line">resolver.delete(deleteIdUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>com.hearing.provider.myprovider需要在 AndroidManifest.xml 中进行注册：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:authorities</span>=<span class="string">"com.hearing.provider.myprovider"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ContentObserver"><a href="#ContentObserver" class="headerlink" title="ContentObserver"></a>ContentObserver</h2><p>观察者模式：当ContentProvider中指定Uri中的数据变化时通知外界。</p>
<p>自定义ContentObserver：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, myOberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">        db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values); </span><br><span class="line">        getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line">getContentResolver().unregisterContentObserver(myOberver);</span><br></pre></td></tr></table></figure>

<h2 id="MimeType"><a href="#MimeType" class="headerlink" title="MimeType"></a>MimeType</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>ContentProvider 类具有两个返回 MIME 类型的方法：</p>
<ul>
<li>getType()：任何ContentProvider程序都需要实现的方法</li>
<li>getStreamTypes()：当ContentProvider程序提供文件时要求实现</li>
</ul>
<h3 id="table的-MIME-类型"><a href="#table的-MIME-类型" class="headerlink" title="table的 MIME 类型"></a>table的 MIME 类型</h3><p>getType() 方法会返回一个 MIME 格式的 String，后者描述内容 URI 参数返回的数据类型。Uri 参数可以是pattern，而不是特定 URI；在这种情况下应该返回与匹配该模式的内容 URI 关联的数据类型。</p>
<p>对于文本、HTML 或 JPEG 等常见数据类型，getType() 应该为该数据返回标准 MIME 类型。</p>
<p>对于指向一个或多个表数据行的内容 URI，getType() 应该以 Android 供应商特有 MIME 格式返回 MIME 类型：</p>
<ol>
<li>类型部分：vnd</li>
<li>子类型部分：<ul>
<li>如果 URI 模式用于单个行：android.cursor.item/</li>
<li>如果 URI 模式用于多个行：android.cursor.dir/</li>
</ul>
</li>
<li>程序特有部分：<code>vnd.&lt;name&gt;.&lt;type&gt;</code><br> <code>&lt;name&gt;</code>值应具有全局唯一性，<type> 值应在对应的 URI pattern 中具有唯一性。通常使用包名或者公司域名作为<code>&lt;name&gt;</code>。适合选择 URI 关联表的标识字符串作为<code>&lt;type&gt;</code>。</li>
</ol>
<p>例如，如果ContentProvider的authority是 com.example.app.provider，并且它公开了一个名为 table1 的表，则 table1 中多个行的 MIME 类型是：<code>vnd.android.cursor.dir/vnd.com.example.provider.table1</code>；对于 table1 的单个行，MIME 类型是：<code>vnd.android.cursor.item/vnd.com.example.provider.table1</code>。</p>
<h3 id="文件的-MIME-类型"><a href="#文件的-MIME-类型" class="headerlink" title="文件的 MIME 类型"></a>文件的 MIME 类型</h3><p>如果 ContentProvider 程序提供文件，则需要实现 getStreamTypes()。该方法返回一个 MIME 类型的 String 数组，表示给定的 URI 返回的文件类型。</p>
<p>例如，假设提供程序以 .jpg、.png 和 .gif 格式文件形式提供照片图像。如果应用调用 ContentResolver.getStreamTypes() 时使用了过滤器字符串 image/*，则 ContentProvider.getStreamTypes() 方法应返回数组：<code>{ &quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;}</code></p>
<p>如果应用只对 .jpg 文件感兴趣，则可以在调用 ContentResolver.getStreamTypes() 时使用过滤器字符串 */jpeg，ContentProvider.getStreamTypes() 应返回：<code>{&quot;image/jpeg&quot;}</code></p>
<p>如果程序未提供过滤器字符串中请求的任何 MIME 类型，则 getStreamTypes() 应返回 null。</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>指定其他应用访问提供程序的数据所必须具备权限的属性。</p>
<h3 id="grantUriPermssions"><a href="#grantUriPermssions" class="headerlink" title="grantUriPermssions"></a>grantUriPermssions</h3><p><code>android:grantUriPermssions</code>：表示是否可以通过临时权限访问数据，默认为false，在开发中可以只对限定的内容提供临时权限，如对照片的内容 URI 设置临时权限。</p>
<ul>
<li><p>true：系统会向整个系统授予临时权限，并替代其他设置的权限。</p>
</li>
<li><p>false：需添加<code>&lt;grant-uri-permission&gt;</code>并表明可以授权临时权限所对应的URI</p>
<ul>
<li><p>path：表示绝对路径Uri</p>
</li>
<li><p>pathPattern：表示限定完整的路径但可以使用./*通配符匹配</p>
</li>
<li><p>pathPrefix：限定路径的初始部分后面可以变化，只要初始部分符合即可授权</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:grantUriPermissions="false"</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">grant-uri-permission</span> <span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h3><ul>
<li>android:permission：统一提供程序范围读取/写入权限</li>
<li>android:readPermission：提供程序范围读取权限，优先于permission权限</li>
<li>android:writePermission：提供程序范围写入权限，优先于permission权限</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:readPermission="com.hearing.provider.permission.READ_PERMISSION"</span><br><span class="line">android:writePermission="com.hearing.provider.permission.WRITE_PERMISSION"</span><br><span class="line">android:permission="com.hearing.provider.permission.PERMISSION"</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建两个程序A和B，在程序A中使用ContentProvider保存数据，在程序B中进行查询，在开始A程序中不设置任何权限，B程序进行访问数据会报错；</li>
<li>修改A程序清单文件添加android:exported=”true”，再次访问数据访问成功；</li>
<li>在A程序的清单文件中，为Provider添加两个读写权限，添加完权限后再次在B程序中获取数据，还是会报错，也很正常因为已经对数据的访问设置了门槛，所以在B程序中声明读写权限即可。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A程序 --&gt;</span></span><br><span class="line">android:writePermission="com.alex.kotlin.job.provider.WRITE"</span><br><span class="line">android:readPermission="com.alex.kotlin.job.provider.READ"</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- B程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.READ"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.alex.kotlin.job.provider.WRITE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="系统ContentProvider"><a href="#系统ContentProvider" class="headerlink" title="系统ContentProvider"></a>系统ContentProvider</h2><p>举几个实例：铃声，联系人部分操作。</p>
<h3 id="铃声"><a href="#铃声" class="headerlink" title="铃声"></a>铃声</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改系统铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File sdFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">    values.put(MediaStore.MediaColumns.DATA, sdFile.getAbsolutePath());</span><br><span class="line">    values.put(MediaStore.MediaColumns.TITLE, sdFile.getName());</span><br><span class="line">    values.put(MediaStore.MediaColumns.MIME_TYPE, <span class="string">"audio/*"</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_RINGTONE, <span class="keyword">true</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_NOTIFICATION, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_ALARM, <span class="keyword">false</span>);</span><br><span class="line">    values.put(MediaStore.Audio.Media.IS_MUSIC, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Uri uri = MediaStore.Audio.Media.getContentUriForPath(sdFile.getAbsolutePath());</span><br><span class="line">    <span class="keyword">if</span> (uri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"uri is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String delete = MediaStore.MediaColumns.DATA + <span class="string">"=\""</span> + sdFile.getAbsolutePath() + <span class="string">"\""</span>;</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + delete);</span><br><span class="line">    Log.d(TAG, <span class="string">"delete = "</span> + context.getContentResolver().delete(uri, delete, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    Uri newUri = context.getContentResolver().insert(uri, values);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, <span class="string">"uri = "</span> + uri);</span><br><span class="line">    Log.d(TAG, <span class="string">"new uri = "</span> + newUri);</span><br><span class="line"></span><br><span class="line">    RingtoneManager.setActualDefaultRingtoneUri(context, RingtoneManager.TYPE_RINGTONE, newUri);</span><br><span class="line">    Toast.makeText(context, <span class="string">"设置来电铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定电话号码的来电铃声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRing</span><span class="params">(Context context, String path, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, number);</span><br><span class="line">    <span class="keyword">final</span> String[] projection = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            ContactsContract.Contacts._ID, ContactsContract.Contacts.LOOKUP_KEY</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">final</span> Cursor data = context.getContentResolver().query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; data.moveToFirst()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> contactId = data.getLong(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> String lookupKey = data.getString(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> Uri contactUri = ContactsContract.Contacts.getLookupUri(contactId, lookupKey);</span><br><span class="line">            <span class="keyword">if</span> (contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Invalid arguments"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(path);</span><br><span class="line">            <span class="keyword">final</span> String value = Uri.fromFile(file).toString();</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, <span class="string">"uri = "</span> + contactUri);</span><br><span class="line">            Log.d(TAG, <span class="string">"value = "</span> + value);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ContentValues values = <span class="keyword">new</span> ContentValues(<span class="number">1</span>);</span><br><span class="line">            values.put(ContactsContract.Contacts.CUSTOM_RINGTONE, value);</span><br><span class="line">            context.getContentResolver().update(contactUri, values, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Toast.makeText(context, <span class="string">"设置联系人铃声成功！"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联系人"><a href="#联系人" class="headerlink" title="联系人"></a>联系人</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据uri查询指定联系人电话(uri可以通过跳转联系人页面返回得到：intent.getData())</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContacts</span><span class="params">(Context context, Uri contactUri)</span> </span>&#123;</span><br><span class="line">    String phoneNumber = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || contactUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor cursor = context.getContentResolver().query(contactUri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        String id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));</span><br><span class="line">        Cursor phones = context.getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,</span><br><span class="line">                <span class="keyword">null</span>, ContactsContract.CommonDataKinds.Phone.CONTACT_ID</span><br><span class="line">                        + <span class="string">"="</span> + id, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (phones != <span class="keyword">null</span> &amp;&amp; phones.moveToNext()) &#123;</span><br><span class="line">            phoneNumber = phones.getString(phones.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));</span><br><span class="line">            phones.close();</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, <span class="string">"number = "</span> + phoneNumber);</span><br><span class="line">    <span class="keyword">return</span> phoneNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据电话获取联系人名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContactName</span><span class="params">(Context context, String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">    Uri lookupUri;</span><br><span class="line">    String[] projection = <span class="keyword">new</span> String[]&#123;ContactsContract.PhoneLookup._ID, ContactsContract.PhoneLookup.DISPLAY_NAME&#125;;</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI, Uri.encode(number));</span><br><span class="line">        cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lookupUri = Uri.withAppendedPath(android.provider.Contacts.Phones.CONTENT_FILTER_URL,</span><br><span class="line">                    Uri.encode(number));</span><br><span class="line">            cursor = resolver.query(lookupUri, projection, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = context.getResources().getString(R.string.unknown_contract);</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.getCount() &gt; <span class="number">0</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">        ret = cursor.getString(<span class="number">1</span>);</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程内通信"><a href="#进程内通信" class="headerlink" title="进程内通信"></a>进程内通信</h2><h3 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"finch.db"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_TABLE_NAME = <span class="string">"job"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 数据库版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DATABASE_NAME, <span class="keyword">null</span>, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个表格:用户表 和职业表</span></span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" name TEXT)"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"CREATE TABLE IF NOT EXISTS "</span> + JOB_TABLE_NAME + <span class="string">"(_id INTEGER PRIMARY KEY AUTOINCREMENT,"</span> + <span class="string">" job TEXT)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义ContentProvider"><a href="#自定义ContentProvider" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    DBHelper mDbHelper = <span class="keyword">null</span>;</span><br><span class="line">    SQLiteDatabase db = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOHORITY = <span class="string">"cn.scu.myprovider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> User_Code = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Job_Code = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UriMatcher类使用:在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher mMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        mMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        mMatcher.addURI(AUTOHORITY,<span class="string">"user"</span>, User_Code);</span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">"job"</span>, Job_Code);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化ContentProvider</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">// 在ContentProvider创建时对数据库进行初始化，不能做耗时操作，此处仅作展示</span></span><br><span class="line">        mDbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(1,'Carson');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into user values(2,'Kobe');"</span>);</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">"delete from job"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(1,'Android');"</span>);</span><br><span class="line">        db.execSQL(<span class="string">"insert into job values(2,'iOS');"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">return</span> db.query(table,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> User_Code:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Job_Code:</span><br><span class="line">                tableName = DBHelper.JOB_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册ContentProvider"><a href="#注册ContentProvider" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"cn.scu.myprovider"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="访问ContentProvider的数据"><a href="#访问ContentProvider的数据" class="headerlink" title="访问ContentProvider的数据"></a>访问ContentProvider的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://cn.scu.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Iverson"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user, values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://cn.scu.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">3</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 =  getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="进程1"><a href="#进程1" class="headerlink" title="进程1"></a>进程1</h3><h4 id="创建数据库类-1"><a href="#创建数据库类-1" class="headerlink" title="创建数据库类"></a>创建数据库类</h4><p>同上。</p>
<h4 id="自定义ContentProvider-1"><a href="#自定义ContentProvider-1" class="headerlink" title="自定义ContentProvider"></a>自定义ContentProvider</h4><p>同上。</p>
<h4 id="注册ContentProvider-1"><a href="#注册ContentProvider-1" class="headerlink" title="注册ContentProvider"></a>注册ContentProvider</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"MyProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"scut.carson_ho.myprovider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">"scut.carson_ho.PROVIDER"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span> = <span class="string">"scut.carson_ho.Read"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:writePermission</span> = <span class="string">"scut.carson_ho.Write"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="进程2"><a href="#进程2" class="headerlink" title="进程2"></a>进程2</h3><h4 id="声明权限"><a href="#声明权限" class="headerlink" title="声明权限"></a>声明权限</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.PROVIDER"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Read"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"scut.carson_ho.Write"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="访问ContentProvider"><a href="#访问ContentProvider" class="headerlink" title="访问ContentProvider"></a>访问ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/user"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values.put(<span class="string">"name"</span>, <span class="string">"Jordan"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user,values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query book:"</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">"content://scut.carson_ho.myprovider/job"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">"_id"</span>, <span class="number">4</span>);</span><br><span class="line">        values2.put(<span class="string">"job"</span>, <span class="string">"NBA Player"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>,<span class="string">"job"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"query job:"</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">" "</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>对于面向Android 7.0及以上的应用，Android禁止在应用外部公开<code>file://url</code>。如果一项包含文件URI的intent离开应用，则应用会抛出FileUriExposedException异常。</p>
<p>解决方案：要在应用间共享文件，应发送一项content://URI，并授予URI临时访问权限。进行此授权的最简单方式是使用FileProvider类。FileProvider是ContentProvider的一个特殊的子类，它让应用间共享文件变得更加容易，其通过创建一个Content URI来代替File URI。</p>
<h3 id="注册FileProvider"><a href="#注册FileProvider" class="headerlink" title="注册FileProvider"></a>注册FileProvider</h3><p>由于FileProvider中已经包含了为file生成Content URI的基本代码了，所以开发者不必再去定义一个FileProvider的子类。你可以在XML文件中指定一个FileProvider：在manifest中使用<code>&lt;provider&gt;</code>标签来指定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.hearing.fileprovider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name的值一般都固定为android.support.v4.content.FileProvider。如果开发者继承了FileProvider，则可以写上其绝对路径。</li>
<li>authorities字段的值用来表明使用的使用者，在FileProvider的函数getUriForFile需要传入该参数。</li>
<li>exported 的值为false，表示该FileProvider只能本应用使用，不是public的。</li>
<li>grantUriPermissions 的值为true，表示允许赋予临时权限。</li>
</ul>
<h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>只有事先指定了目录，一个FileProvider才可以为文件生成一个对应的Content URI。要指定一个路径，需要在XML文件中指定其存储的路径。使用<code>&lt;paths&gt;</code>标签。例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/files/path/</code></li>
<li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>/data/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalFilesDir(null) + &quot;/path/&quot;</code>，<code>/storage/emulated/0/Android/data/&lt;package_name&gt;/files/path/</code></li>
<li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Context.getExternalCacheDir() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/Android/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：<code>Environment.getExternalStorageDirectory() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/path/</code></li>
</ul>
<p>在res目录下新建xml目录，然后新建文件file_paths.xml，根据上述内容编写。</p>
<h3 id="获取Content-Uri"><a href="#获取Content-Uri" class="headerlink" title="获取Content Uri"></a>获取Content Uri</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">Uri data;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    data = FileProvider.getUriForFile(mContext, <span class="string">"com.hearing.fileprovider"</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋予临时权限"><a href="#赋予临时权限" class="headerlink" title="赋予临时权限"></a>赋予临时权限</h3><p>两种方法：（通常使用第2种）</p>
<ol>
<li>Context.grantUriPermission(package, Uri, mode_flags)</li>
<li>Intent.setFlags()：<code>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);</code></li>
</ol>
<p>Flag意义如下：</p>
<ul>
<li>FLAG_GRANT_READ_URI_PERMISSION：表示读取权限； </li>
<li>FLAG_GRANT_WRITE_URI_PERMISSION：表示写入权限。</li>
</ul>
<h3 id="分享文件URI"><a href="#分享文件URI" class="headerlink" title="分享文件URI"></a>分享文件URI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"shareFile: "</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="string">"com.hearing.fileproviderclient"</span>,</span><br><span class="line">            <span class="string">"com.hearing.fileproviderclient.MainActivity"</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">"/text"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">    Uri data;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        data = FileProvider.getUriForFile(mContext, FILE_PROVIDER_AUTHORITIES, file);</span><br><span class="line">        <span class="comment">// 给目标应用一个临时授权</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">    intent.setData(data);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>安全</p>
<p>  ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据根据需求开放给 其他应用进行增、删、改、查，而不用担心因为直接开放数据库权限而带来的安全问题</p>
</li>
<li><p>访问简单 &amp; 高效</p>
</li>
</ul>
<h1 id="Mime-Type"><a href="#Mime-Type" class="headerlink" title="Mime Type"></a>Mime Type</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>MIME：多用途互联网邮件扩展（Multipurpose Internet Mail Extensions）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。</p>
<p>MIME TYPE一般以这种形式出现：<code>[type]/[subtype]</code></p>
<p>type标识内容type，有下面的形式：</p>
<ul>
<li>Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</li>
<li>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</li>
<li>Application：用于传输应用程序数据或者二进制数据；</li>
<li>Message：用于包装一个E-mail消息；</li>
<li>Image：用于传输静态图片数据；</li>
<li>Audio：用于传输音频或者音声数据；</li>
<li>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。</li>
</ul>
<p>subtype用于指定type的详细形式。<code>content-type/subtype</code>配对的集合和与此相关的参数，将随着时间而增长。为了确保这些值在一个有序而且公开的状态下开发，MIME使用Internet Assigned Numbers Authority (IANA)作为中心的注册机制来管理这些值。常用的subtype值如下所示：</p>
<ul>
<li>text/plain（纯文本）</li>
<li>text/html（HTML文档）</li>
<li>application/xhtml+xml（XHTML文档）</li>
<li>image/gif（GIF图像）</li>
<li>image/jpeg（JPEG图像）</li>
<li>image/png（PNG图像）</li>
<li>video/mpeg（MPEG动画）</li>
<li>application/octet-stream（任意的二进制数据）</li>
<li>application/pdf（PDF文档）</li>
<li>application/msword（Microsoft Word文件）</li>
<li>message/rfc822（RFC 822形式）</li>
<li>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）</li>
<li>application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）</li>
<li>multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>当Android系统接收到一个隐式Intent要启动一个Activity(或其他组件)时，Android会根据以下三个信息比较Intent的信息与注册的组件的intent-filter的信息，从而为该Intent选择出最匹配的Activity(或其他组件)：</p>
<ul>
<li>intent中的action</li>
<li>intent中的category</li>
<li>intent中的data（包含Uri以及data的MIME类型）</li>
</ul>
<p>也就是隐式intent对象要满足要启动的目标组件中注册的intent-filter中的<code>&lt;action/&gt;</code>、<code>&lt;category/&gt;</code>、<code>&lt;data/&gt;</code>三个标签中的信息，即要分别通过action测试、category测试以及data测试。</p>
<p>MINI类型即在data中指定。</p>
<h1 id="Intent和Intent-filter"><a href="#Intent和Intent-filter" class="headerlink" title="Intent和Intent-filter"></a>Intent和Intent-filter</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Intent 是一个消息传递对象，可以用来从其他应用组件请求操作，尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ol>
<li>启动 Activity：通过将 Intent 传递给 startActivity()，可以启动新的 Activity 实例，Intent 用于描述要启动的 Activity，并携带任何必要的数据。</li>
<li>启动 Service：使用 Android 5.0（API 级别 21）及更高版本，可以启动包含 JobScheduler 的服务。对于 Android 5.0（API 级别 21）之前的版本，可以使用 Service 类的方法来启动服务，通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 用于描述要启动的服务，并携带任何必要的数据。如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，可以从其他组件绑定到此服务。</li>
<li>传递 BroadCast：广播是任何应用均可接收的消息，系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播，通过将 Intent 传递给 sendBroadcast() 或 sendOrderedBroadcast()，可以将广播传递给其他应用。</li>
</ol>
<h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><ul>
<li>显式 Intent：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。例如，启动应用内的新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li>隐式 Intent ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。使用隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent-filter进行比较，从而找到要启动的相应组件。如果 Intent 与 Intent-filter匹配，则系统将启动该组件，并向其传递 Intent 对象。如果多个 Intent-filter兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</li>
</ul>
<p>Intent-filter是应用清单文件中的一个表达式，用于指定该组件要接收的 Intent 类型。例如，通过为 Activity 声明 Intent-filter，可以使其他应用能够直接使用某一特定类型的 Intent 启动 Activity。同样，如果您没有为 Activity 声明任何 Intent-filter，则 Activity 只能通过显式 Intent 启动。</p>
<p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent-filter。使用隐式 Intent 启动服务存在安全隐患，因为您无法确定哪些服务将响应 Intent，且用户无法看到哪些服务已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p>
<h2 id="构建Intent"><a href="#构建Intent" class="headerlink" title="构建Intent"></a>构建Intent</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>如Component name，Action，Data以及Category，这些属性（组件名称、操作、数据和category）表示 Intent 的既定特征。通过读取这些属性，Android 系统能够解析应当启动哪个应用组件。但是，Intent 也有可能会携带一些不影响其如何解析为应用组件的信息。Intent 还可以提供以下信息：Extras和Flags。</p>
<h4 id="Component-name"><a href="#Component-name" class="headerlink" title="Component name"></a>Component name</h4><p>这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。如果没有组件名称，则 Intent 则为隐式，且系统将根据其他 Intent 信息（例如，以下所述的操作、数据和category）决定哪个组件应当接收 Intent。如需在应用中启动特定的组件，则应指定该组件的名称。</p>
<p>启动 Service 时，应始终指定组件名称。否则无法确定哪项服务会响应 Intent，且用户无法看到哪项服务已启动。</p>
<p>Intent 的这一字段是 ComponentName 对象，可以使用目标组件的完全限定类名指定此对象，其中包括应用的软件包名称。例如，com.example.ExampleActivity，可以使用 setComponent()、setClass()、setClassName()，或 Intent 构造函数设置组件名称。</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>指定要执行的通用操作（例如，查看或选取）的字符串。</p>
<p>对于广播 Intent，这是指已发生且正在报告的操作。action会在很大程度上决定其余 Intent 的构成，特别是 data 和 extra 中包含的内容。可以指定自己的操作，供 Intent 在您的应用内使用（或者供其他应用在您的应用中调用组件）。但是，您通常应该使用由Intent 类或其他框架类定义的操作常量。以下是一些用于启动 Activity 的常见操作：</p>
<ol>
<li>ACTION_VIEW：如果您拥有一些某项 Activity 可向用户显示的信息（例如，要使用图库应用查看的照片；或者要使用地图应用查看的地址），请通过 Intent 将此操作与 startActivity() 结合使用。</li>
<li>ACTION_SEND：这也称为共享 Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此操作与 startActivity() 结合使用。</li>
</ol>
<p>可以使用 setAction() 或 Intent 构造函数为 Intent 指定操作。</p>
<p>如以下示例所示，如果定义自己的操作，请确保加入应用的软件包名称作为前缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String ACTION_TIMETRAVEL = <span class="string">"com.example.action.TIMETRAVEL"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。</p>
<p>创建 Intent 时，除了指定 URI 以外，指定数据类型（MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件。但有时 MIME 类型可以从 URI 中推断得出，特别当数据是 content:URI 时尤其如此。content:URI 表明数据位于设备中，且由 ContentProvider 控制，这使得数据 MIME 类型对系统可见。</p>
<p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，您可以使用 setDataAndType() 同时显式设置二者。</p>
<p>注意：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType() 同时设置 URI 和 MIME 类型。</p>
<h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的Category放入一个 Intent 中，但大多数 Intent 均不需要 Category。以下是一些常见category：</p>
<ul>
<li>CATEGORY_BROWSABLE：目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。</li>
<li>CATEGORY_LAUNCHER：该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</li>
<li>CATEGORY_HOME：桌面应用需要声明。</li>
<li>CATEGORY_DEFAULT：通过隐式启动Activity时，Android会默认加上一个CATEGORY_DEFAULT，所以如果Activity要支持隐式启动的话，除了默认LaunchActivity，其余都需要加上CATEGORY_DEFAULT。</li>
</ul>
<p>可以使用 addCategory() 指定category。</p>
<h4 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h4><p>携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。可以使用各种 putExtra() 方法添加 extra 数据，每种方法均接受两个参数：键名和值。还可以创建一个包含所有 extra 数据的 Bundle 对象，然后使用 putExtras() 将 Bundle 插入 Intent 中。</p>
<p>例如，使用 ACTION_SEND 创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL 键指定目标收件人，并使用 EXTRA_SUBJECT 键指定主题。</p>
<p>Intent 类将为标准化的数据类型指定多个 EXTRA_* 常量。如需声明自己的 extra 键（对于应用接收的 Intent），请确保将应用的软件包名称作为前缀，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_GIGAWATTS = <span class="string">"com.example.EXTRA_GIGAWATTS"</span>;</span><br></pre></td></tr></table></figure>

<p>注意：在发送您希望另一个应用接收的 Intent 时，请勿使用 Parcelable 或 Serializable 数据。如果某个应用尝试访问 Bundle 对象中的数据，但没有对打包或序列化类的访问权限，则系统将提出一个 RuntimeException。</p>
<h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><p>Flags 在 Intent 类中定义，充当 Intent 的元数据。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理（例如，Activity 是否属于最近的 Activity 列表）。</p>
<p>可以使用 setFlags() 方法添加Flags。</p>
<h3 id="显式-Intent-示例"><a href="#显式-Intent-示例" class="headerlink" title="显式 Intent 示例"></a>显式 Intent 示例</h3><p>显式 Intent 是指用于启动某个特定应用组件（例如，应用中的某个特定 Activity 或服务）的 Intent，要创建显式 Intent，需要为 Intent 对象定义组件名称，Intent 的所有其他属性均为可选属性。</p>
<p>例如，如果在应用中构建一个名为 DownloadService、旨在从网页下载文件的服务，则可使用以下代码启动该服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executed in an Activity, so 'this' is the Context</span></span><br><span class="line"><span class="comment">// The fileUrl is a string URL, such as "http://www.example.com/image.png"</span></span><br><span class="line">Intent downloadIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, DownloadService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">downloadIntent.setData(Uri.parse(fileUrl));</span><br><span class="line">startService(downloadIntent);</span><br></pre></td></tr></table></figure>

<p>Intent(Context, Class) 构造函数分别为应用和组件提供 Context 和 Class 对象。因此，此 Intent 将显式启动该应用中的 DownloadService 类。</p>
<h3 id="隐式-Intent-示例"><a href="#隐式-Intent-示例" class="headerlink" title="隐式 Intent 示例"></a>隐式 Intent 示例</h3><p>隐式 Intent 指定能够在可以执行相应操作的设备上调用任何应用的操作。如果您的应用无法执行该操作而其他应用可以，且您希望用户选取要使用的应用，则使用隐式 Intent 非常有用。例如，如果您希望用户与他人分享您的内容，请使用 ACTION_SEND 操作创建 Intent，并添加指定共享内容的 extra。使用该 Intent 调用 startActivity() 时，用户可以选取分享内容所使用的应用。</p>
<p>注意：用户可能没有任何应用处理您发送到 startActivity() 的隐式 Intent。或者，由于配置文件限制或管理员执行的设置，可能无法访问应用。如果发生这样的情况，调用失败，应用也会崩溃。要验证 Activity 是否会接收 Intent，请对 Intent 对象调用 resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，并且可以安全调用 startActivity()。如果结果为空，不要使用该 Intent。以下示例说明如何验证 Intent 是否解析为 Activity。此示例没有使用 URI，但已声明 Intent 的数据类型，用于指定 extra 携带的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the text message with a string</span></span><br><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">sendIntent.setAction(Intent.ACTION_SEND);</span><br><span class="line">sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</span><br><span class="line">sendIntent.setType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify that the intent will resolve to an activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(sendIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 startActivity() 时，系统将检查已安装的所有应用，确定哪些应用能够处理这种 Intent（即：含 ACTION_SEND 操作并携带“text/plain”数据的 Intent）。如果只有一个应用能够处理，则该应用将立即打开并为其提供 Intent。如果多个 Activity 接受 Intent，则系统将显示一个对话框，使用户能够选取要使用的应用。</p>
<h3 id="强制使用应用选择器"><a href="#强制使用应用选择器" class="headerlink" title="强制使用应用选择器"></a>强制使用应用选择器</h3><p>如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。如果用户可能希望每次使用相同的应用执行某项操作（例如，打开网页时，用户往往倾向于仅使用一种网络浏览器），则选择默认选项的功能十分有用。</p>
<p>但是，如果多个应用可以响应 Intent，且用户可能希望每次使用不同的应用，则应采用显式方式显示选择器对话框。选择器对话框会要求用户选择用于操作的应用（用户无法为该操作选择默认应用）。例如，当应用使用 ACTION_SEND 操作执行“共享”时，用户根据目前的状况可能需要使用另一不同的应用，因此应当始终使用选择器对话框。</p>
<p>要显示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()，如下例所示。此示例将显示一个对话框，其中有响应传递给 createChooser() 方法的 Intent 的应用列表，并且将提供的文本用作对话框标题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intent sendIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Always use string resources for UI text.</span></span><br><span class="line"><span class="comment">// This says something like "Share this photo with"</span></span><br><span class="line">String title = getResources().getString(R.string.chooser_title);</span><br><span class="line"><span class="comment">// Create intent to show the chooser dialog</span></span><br><span class="line">Intent chooser = Intent.createChooser(sendIntent, title);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the original intent will resolve to at least one activity</span></span><br><span class="line"><span class="keyword">if</span> (sendIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><h3 id="接收隐式-Intent-1"><a href="#接收隐式-Intent-1" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h3><p>要公布应用可以接收哪些隐式 Intent，请在 Manifest 文件中使用 <code>&lt;intent-filter&gt;</code> 元素为每个应用组件声明一个或多个 Intent-filter。每个 Intent-filter均根据 Intent 的操作、数据和category指定自身接受的 Intent 类型。仅当隐式 Intent 可以通过 Intent-filter之一传递时，系统才会将该 Intent 传递给应用组件。</p>
<p>请注意：显式 Intent 始终会传递给其目标，无论组件声明的 Intent-filter如何均是如此。</p>
<p>应用组件应当为自身可执行的每个独特作业声明单独的filter。例如，图像库应用中的一个 Activity 可能会有两个filter，分别用于查看图像和编辑图像。当 Activity 启动时，将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。</p>
<p>每个 Intent-filter均由应用Manifest文件中的 <code>&lt;intent-filter&gt;</code> 元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code> 元素）中。在 <code>&lt;intent-filter&gt;</code> 内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<ul>
<li><code>&lt;action&gt;</code>：在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。</li>
<li><code>&lt;data&gt;</code>：使用一个或多个指定数据 URI（scheme、host、port、path）各个方面和 MIME 类型的属性，声明接受的数据类型。</li>
<li><code>&lt;category&gt;</code>：在 name 属性中，声明接受的 Intent category。该值必须是操作的文本字符串值，而不是类常量。</li>
</ul>
<p>请注意：要接收隐式 Intent，必须将 CATEGORY_DEFAULT category包括在 Intent-filter中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT category的方式处理所有 Intent。如果未在 Intent-filter中声明此category，则隐式 Intent 不会解析为您的 Activity。</p>
<p>例如，以下是一个使用包含 Intent-filter的 Activity 声明，当数据类型为文本时，系统将接收 ACTION_SEND Intent ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您可以创建一个包括多个 <code>&lt;action&gt;</code>、<code>&lt;data&gt;</code> 或 <code>&lt;category&gt;</code> 实例的filtet。创建时，需确定组件能够处理这些filter元素的任何及所有组合。</p>
<p>如需仅以操作、数据和类别类型的特定组合来处理多种 Intent，则需创建多个 Intent-filter。</p>
<p>系统通过将 Intent 与所有这三个元素进行比较，根据filter测试隐式 Intent。隐式 Intent 若要传递给组件，必须通过所有这三项测试。如果 Intent 无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件。但是，由于一个组件可能有多个 Intent-filter，因此未能通过某一组件filter的 Intent 可能会通过另一filter。</p>
<p>注意：使用 Intent-filter时，无法安全地防止其他应用启动组件。尽管 Intent-filter将组件限制为仅响应特定类型的隐式 Intent，但如果开发者确定您的组件名称，则其他应用有可能通过使用显式 Intent 启动您的应用组件。如果必须确保只有您自己的应用才能启动您的某一组件，请勿在您的清单中声明 Intent-filter，将该组件的 exported 属性设置为 “false”。</p>
<p>同样，为了避免无意中运行不同应用的 Service，请始终使用显式 Intent 启动您自己的服务。</p>
<p>请注意：对于所有 Activity，您必须在清单文件中声明 Intent-filter。但是，广播接收器的filter可以通过调用 registerReceiver() 动态注册。这样一来，应用便可仅在应用运行时的某一指定时间段内侦听特定的广播。</p>
<h3 id="filter示例"><a href="#filter示例" class="headerlink" title="filter示例"></a>filter示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"MainActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity is the main entry, should appear in app launcher --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">"ShareActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity handles "SEND" actions with text data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"text/plain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This activity also handles "SEND" and "SEND_MULTIPLE" with media data --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND_MULTIPLE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.google.panorama360+jpg"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个 Activity MainActivity 是应用的主要入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开：</p>
<ul>
<li>ACTION_MAIN 操作指示这是主要入口点，且不要求输入任何 Intent 数据。</li>
<li>CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。如果 <code>&lt;activity&gt;</code> 元素未使用 icon 指定图标，则系统将使用 <code>&lt;application&gt;</code> 元素中的图标。</li>
</ul>
<p>这两个元素必须配对使用，Activity 才会显示在应用启动器中。</p>
<p>第二个 Activity ShareActivity 旨在便于共享文本和媒体内容。尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent-filter之一匹配）的另一应用中直接进入 ShareActivity。</p>
<h2 id="使用PendingIntent"><a href="#使用PendingIntent" class="headerlink" title="使用PendingIntent"></a>使用PendingIntent</h2><p>PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含的 Intent，就像是它从您应用本身的进程中执行的一样。</p>
<p>PendingIntent 的主要用例包括：</p>
<ul>
<li>声明用户使用您的通知执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。</li>
<li>声明用户使用您的应用微件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。</li>
<li>声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。</li>
</ul>
<p>由于每个 Intent 对象均设计为由特定类型的应用组件进行处理（Activity、Service 或 BroadcastReceiver），因此还必须基于相同的考虑因素创建 PendingIntent。使用待定 Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的创建器方法创建 PendingIntent 时，您必须声明所需的组件类型：</p>
<ul>
<li>PendingIntent.getActivity()，适用于启动 Activity 的 Intent。</li>
<li>PendingIntent.getService()，适用于启动 Service 的 Intent。</li>
<li>PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。</li>
</ul>
<p>除非您的应用正在从其他应用中接收待定 Intent，否则上述用于创建 PendingIntent 的方法可能是您所需的唯一 PendingIntent 方法。</p>
<p>每种方法均会提取当前的应用 Context、您要封装的 Intent 以及一个或多个指定应如何使用该 Intent 的标志（例如，是否可以多次使用该 Intent）。</p>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该 Intent 与 Intent-filter进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Action</li>
<li>Data（URI 和数据类型）。</li>
<li>Category</li>
</ul>
<h3 id="Action测试"><a href="#Action测试" class="headerlink" title="Action测试"></a>Action测试</h3><p>要指定接受的 Intent action，Intent-filter既可以不声明任何 <code>&lt;action&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.EDIT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要通过此filter，Intent 中指定的action必须与filter中列出的某一action匹配。</p>
<h3 id="Category测试"><a href="#Category测试" class="headerlink" title="Category测试"></a>Category测试</h3><p>要指定接受的 Intent category，Intent-filter既可以不声明任何 <code>&lt;category&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>若要使 Intent 通过category测试，则 Intent 中的每个category均必须与filter中的category匹配。Intent-filter声明的category可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。因此，不含category的 Intent 应当始终会通过此测试，无论filter中声明何种category均是如此。</p>
<p>请注意：Android 会自动将 CATEGORY_DEFAULT category应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent。如需 Activity 接收显示 Intent，则必须将 “android.intent.category.DEFAULT” 的category包括在其 Intent-filter中。</p>
<h3 id="Data测试"><a href="#Data测试" class="headerlink" title="Data测试"></a>Data测试</h3><p>要指定接受的 Intent 数据，Intent-filter既可以不声明任何 <code>&lt;data&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：scheme、host、port 和 path：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>在 <code>&lt;data&gt;</code> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p>
<ul>
<li>如果未指定scheme，则会忽略host。</li>
<li>如果未指定host，则会忽略port。</li>
<li>如果未指定scheme和host，则会忽略path。</li>
</ul>
<p>将 Intent 中的 URI 与filter中的 URI 规范进行比较时，它仅与filter中包含的部分 URI 进行比较。例如：</p>
<ul>
<li>如果filter仅指定scheme，则具有该scheme的所有 URI 均与该filter匹配。</li>
<li>如果filter指定scheme和host，但未指定path，则具有相同scheme和host的所有 URI 都会通过filter，无论其path如何均是如此。</li>
<li>如果filter指定scheme、host和path，则仅具有相同scheme、host和path的 URI 才会通过filter。</li>
</ul>
<p>请注意：path规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。</p>
<p>数据测试会将 Intent 中的 URI 和 MIME 类型与filter中指定的 URI 和 MIME 类型进行比较。规则如下：</p>
<ul>
<li>仅当filter未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与filter的 URI 格式匹配、且filter同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当filter列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与filter中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与filter中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且filter未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果filter只是列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<p>请注意：如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <code>&lt;intent-filter&gt;</code> 中没有 <code>&lt;data&gt;</code> 元素时失败。</p>
<p>最后一条规则反映出对组件能够从文件中或内容提供程序处获得本地数据的预期。因此，其filter只能列出数据类型，不需要显式命名 content: 和 file: scheme。以下是一个典型示例，说明 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从内容提供程序处获得并显示图像数据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于大部分可用数据均由内容提供程序分发，因此指定数据类型（而非 URI）的filter也许最为常见。</p>
<p>另一常见的配置是具有scheme和数据类型的filter。例如，下文中的 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从网络中检索视频数据以执行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">android:mimeType</span>=<span class="string">"video/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h3><p>通过 Intent-filter匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。例如，主页应用通过使用指定 ACTION_MAIN action和 CATEGORY_LAUNCHER category的 Intent-filter查找所有 Activity，以此填充应用启动器。如 IntentFilter 类文档所述，只有当 Intent 中的操作和category与filter匹配时，匹配才会成功。</p>
<p>您的应用可以使用类似于主页应用的方式使用 Intent 匹配。PackageManager 提供一整套 query…() 方法来返回所有能够接受特定 Intent 的组件。此外，还会提供一系列类似的 resolve…() 方法来确定响应 Intent 的最佳组件。例如，queryIntentActivities() 将返回能够执行作为参数传递的 Intent 中列出的所有 Activity，而 queryIntentServices() 则可返回类似的一系列服务。这两种方法均不会激活组件；而只是列出能够响应的组件。对于广播接收器，有一种类似的方法：queryBroadcastReceivers()。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8BDump%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">啃碎并发（四）：Java线程Dump分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 10:26:46 / 修改时间：15:33:08" itemprop="dateCreated datePublished" datetime="2020-06-01T10:26:46+08:00">2020-06-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-Thread-Dump介绍"><a href="#1-Thread-Dump介绍" class="headerlink" title="1 Thread Dump介绍"></a>1 Thread Dump介绍</h4><h5 id="1-1-什么是Thread-Dump"><a href="#1-1-什么是Thread-Dump" class="headerlink" title="1.1 什么是Thread Dump"></a>1.1 什么是Thread Dump</h5><p>Thread Dump是非常有用的诊断Java应用问题的工具。<strong>每一个Java虚拟机都有及时生成所有线程在某一点状态的thread-dump的能力，</strong>虽然各个 Java虚拟机打印的thread dump略有不同，但是<strong>大多都提供了当前活动线程的快照，及JVM中所有Java线程的堆栈跟踪信息，堆栈信息一般包含完整的类名及所执行的方法，</strong>如果可能的话还有源代码的行数。</p>
<h5 id="1-2-Thread-Dump特点"><a href="#1-2-Thread-Dump特点" class="headerlink" title="1.2 Thread Dump特点"></a>1.2 Thread Dump特点</h5><blockquote>
<p>1.能在各种操作系统下使用；<br>2.能在各种Java应用服务器下使用；<br>3.能在生产环境下使用而不影响系统的性能；<br>4.能将问题直接定位到应用程序的代码行上；</p>
</blockquote>
<h5 id="1-3-Thread-Dump抓取"><a href="#1-3-Thread-Dump抓取" class="headerlink" title="1.3 Thread Dump抓取"></a>1.3 Thread Dump抓取</h5><p><strong>一般当服务器挂起，崩溃或者性能低下时，</strong>就需要抓取服务器的线程堆栈（Thread Dump）用于后续的分析。在实际运行中，往往一次 dump的信息，还不足以确认问题。为了反映线程状态的动态变化，<strong>需要接连多次做thread dump，每次间隔10-20s，建议至少产生三次 dump信息，</strong>如果每次 dump都指向同一个问题，我们才确定问题的典型性。</p>
<p><strong>1. 操作系统命令获取ThreadDump</strong></p>
<blockquote>
<p>1.ps –ef | grep java<br>2.kill -3 <pid></p>
</blockquote>
<p><strong>注意：</strong></p>
<blockquote>
<p>一定要谨慎, 一步不慎就可能让服务器进程被杀死。kill -9 命令会杀死进程。</p>
</blockquote>
<p><strong>2. JVM 自带的工具获取线程堆栈</strong></p>
<blockquote>
<ol>
<li>jps 或 ps –ef | grep java （获取PID）</li>
<li>jstack [-l ] <pid> | tee -a jstack.log（获取ThreadDump）</li>
</ol>
</blockquote>
<h4 id="2-Thread-Dump分析"><a href="#2-Thread-Dump分析" class="headerlink" title="2 Thread Dump分析"></a>2 Thread Dump分析</h4><h5 id="2-1-Thread-Dump信息"><a href="#2-1-Thread-Dump信息" class="headerlink" title="2.1 Thread Dump信息"></a>2.1 Thread Dump信息</h5><p><strong>1. 头部信息：时间，JVM信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011-11-02 19:05:06  </span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (16.3-b01 mixed mode):</span><br></pre></td></tr></table></figure>

<p><strong>2. 线程INFO信息块：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. &quot;Timer-0&quot; daemon prio&#x3D;10 tid&#x3D;0xac190c00 nid&#x3D;0xaef in Object.wait() [0xae77d000] </span><br><span class="line"># 线程名称：Timer-0；线程类型：daemon；优先级: 10，默认是5；</span><br><span class="line"># JVM线程id：tid&#x3D;0xac190c00，JVM内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现）。</span><br><span class="line"># 对应系统线程id（NativeThread ID）：nid&#x3D;0xaef，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）</span><br><span class="line"># 线程状态：in Object.wait()；</span><br><span class="line"># 起始栈地址：[0xae77d000]，对象的内存地址，通过JVM内存查看工具，能够看出线程是在哪儿个对象上等待；</span><br><span class="line">2.  java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">3.  at java.lang.Object.wait(Native Method)</span><br><span class="line">4.  -waiting on &lt;0xb3885f60&gt; (a java.util.TaskQueue)     # 继续wait </span><br><span class="line">5.  at java.util.TimerThread.mainLoop(Timer.java:509)</span><br><span class="line">6.  -locked &lt;0xb3885f60&gt; (a java.util.TaskQueue)         # 已经locked</span><br><span class="line">7.  at java.util.TimerThread.run(Timer.java:462)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java thread statck trace：是上面2-7行的信息。到目前为止这是最重要的数据，Java stack trace提供了大部分信息来精确定位问题根源。</p>
</blockquote>
<p><strong>3. Java thread statck trace详解：</strong></p>
<p><strong>堆栈信息应该逆向解读：</strong>程序先执行的是第7行，然后是第6行，依次类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- locked &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br><span class="line">- waiting on &lt;0xb3885f60&gt; (a java.util.ArrayList)</span><br></pre></td></tr></table></figure>

<p><strong>也就是说对象先上锁，锁住对象0xb3885f60，然后释放该对象锁，进入waiting状态。</strong>为啥会出现这样的情况呢？看看下面的java代码示例，就会明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;  </span><br><span class="line">   .........  </span><br><span class="line">   obj.wait();  </span><br><span class="line">   .........  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上，线程的执行过程，先用 synchronized 获得了这个对象的 Monitor（对应于 locked &lt;0xb3885f60&gt; ）。当执行到 obj.wait()，线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on &lt;0xb3885f60&gt; ）。</p>
</blockquote>
<p><strong>在堆栈的第一行信息中，进一步标明了线程在代码级的状态，例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)</span><br></pre></td></tr></table></figure>

<p><strong>解释如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">|blocked|</span><br><span class="line"></span><br><span class="line">&gt; This thread tried to enter asynchronized block, but the lock was taken by another thread. This thread isblocked until the lock gets released.</span><br><span class="line"></span><br><span class="line">|blocked (on thin lock)|</span><br><span class="line"></span><br><span class="line">&gt; This is the same state asblocked, but the lock in question is a thin lock.</span><br><span class="line"></span><br><span class="line">|waiting|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledObject.wait() on an object. The thread will remain there until some otherthread sends a notification to that object.</span><br><span class="line"></span><br><span class="line">|sleeping|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.lang.Thread.sleep().</span><br><span class="line"></span><br><span class="line">|parked|</span><br><span class="line"></span><br><span class="line">&gt; This thread calledjava.util.concurrent.locks.LockSupport.park().</span><br><span class="line"></span><br><span class="line">|suspended|</span><br><span class="line"></span><br><span class="line">&gt; The thread&#39;s execution wassuspended by java.lang.Thread.suspend() or a JVMTI agent call.</span><br></pre></td></tr></table></figure>

<h5 id="2-2-Thread状态分析"><a href="#2-2-Thread状态分析" class="headerlink" title="2.2 Thread状态分析"></a>2.2 Thread状态分析</h5><p>线程的状态是一个很重要的东西，因此thread dump中会显示这些状态，通过对这些状态的分析，能够得出线程的运行状况，进而发现可能存在的问题。<strong>线程的状态在Thread.State这个枚举类型中定义</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public enum State   </span><br><span class="line">&#123;  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread which has not yet started. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       NEW,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a runnable thread.  A thread in the runnable </span><br><span class="line">        * state is executing in the Java virtual machine but it may </span><br><span class="line">        * be waiting for other resources from the operating system </span><br><span class="line">        * such as processor. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       RUNNABLE,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a thread blocked waiting for a monitor lock. </span><br><span class="line">        * A thread in the blocked state is waiting for a monitor lock </span><br><span class="line">        * to enter a synchronized block&#x2F;method or  </span><br><span class="line">        * reenter a synchronized block&#x2F;method after calling </span><br><span class="line">        * &#123;@link Object#wait() Object.wait&#125;. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       BLOCKED,  </span><br><span class="line">     </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread. </span><br><span class="line">        * A thread is in the waiting state due to calling one of the  </span><br><span class="line">        * following methods: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *  </span><br><span class="line">        * &lt;p&gt;A thread in the waiting state is waiting for another thread to </span><br><span class="line">        * perform a particular action.   </span><br><span class="line">        * </span><br><span class="line">        * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt; </span><br><span class="line">        * on an object is waiting for another thread to call  </span><br><span class="line">        * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on  </span><br><span class="line">        * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;  </span><br><span class="line">        * is waiting for a specified thread to terminate. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       WAITING,  </span><br><span class="line">         </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a waiting thread with a specified waiting time. </span><br><span class="line">        * A thread is in the timed waiting state due to calling one of  </span><br><span class="line">        * the following methods with a specified positive waiting time: </span><br><span class="line">        * &lt;ul&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;&#x2F;li&gt; </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;  </span><br><span class="line">        *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;&#x2F;li&gt; </span><br><span class="line">        * &lt;&#x2F;ul&gt; </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TIMED_WAITING,  </span><br><span class="line">  </span><br><span class="line">       &#x2F;** </span><br><span class="line">        * Thread state for a terminated thread. </span><br><span class="line">        * The thread has completed execution. </span><br><span class="line">        *&#x2F;  </span><br><span class="line">       TERMINATED;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. NEW：</strong></p>
<p><strong>每一个线程，在堆内存中都有一个对应的Thread对象。</strong>Thread t = new Thread();当刚刚在堆内存中创建Thread对象，还没有调用t.start()方法之前，线程就处在NEW状态。<strong>在这个状态上，线程与普通的java对象没有什么区别，就仅仅是一个堆内存中的对象。</strong></p>
<p><strong>2. RUNNABLE：</strong></p>
<p><strong>该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。</strong>这个状态的线程比较正常，但如果线程长时间停留在在这个状态就不正常了，这说明线程运行的时间很长（存在性能问题），或者是线程一直得不得执行的机会（存在线程饥饿的问题）。</p>
<p><strong>3. BLOCKED：</strong></p>
<p><strong>线程正在等待获取java对象的监视器(也叫内置锁)，即线程正在等待进入由synchronized保护的方法或者代码块。</strong>synchronized用来保证原子性，任意时刻最多只能由一个线程进入该临界区域，其他线程只能排队等待。</p>
<p><strong>4. WAITING：</strong></p>
<p><strong>处在该线程的状态，正在等待某个事件的发生，只有特定的条件满足，才能获得执行机会。</strong>而产生这个特定的事件，通常都是另一个线程。也就是说，<strong>如果不发生特定的事件，那么处在该状态的线程一直等待，不能获取执行的机会。</strong> 比如：</p>
<blockquote>
<p>1.A线程调用了obj对象的obj.wait()方法，如果没有线程调用obj.notify或obj.notifyAll，那么A线程就没有办法恢复运行；<br>2.如果A线程调用了LockSupport.park()，没有别的线程调用LockSupport.unpark(A)，那么A没有办法恢复运行。</p>
</blockquote>
<p><strong>5. TIMED_WAITING：</strong></p>
<p>J.U.C中很多与线程相关类，都提供了限时版本和不限时版本的API。 <strong>TIMED_WAITING意味着线程调用了限时版本的API，正在等待时间流逝。 **当等待时间过去后，线程一样可以恢复运行。</strong>如果线程进入了WAITING状态，一定要特定的事件发生才能恢复运行；而处在TIMED_WAITING的线程，如果特定的事件发生或者是时间流逝完毕，都会恢复运行。**</p>
<p><strong>6. TERMINATED：</strong></p>
<p><strong>线程执行完毕，执行完run方法正常返回，或者抛出了运行时异常而结束，线程都会停留在这个状态。</strong>这个时候线程只剩下Thread对象了，没有什么用了。</p>
<h5 id="2-3-关键状态分析"><a href="#2-3-关键状态分析" class="headerlink" title="2.3 关键状态分析"></a>2.3 关键状态分析</h5><ol>
<li>Wait on condition：The thread is either sleeping or waiting to be notified by another thread.<br>该状态说明它在等待另一个条件的发生，来把自己唤醒，或者干脆它是调用了 sleep(n)。</li>
</ol>
<p><strong>此时线程状态大致为以下几种：</strong></p>
<blockquote>
<p>1.java.lang.Thread.State: WAITING (parking)：一直等那个条件发生；<br>2.java.lang.Thread.State: TIMED_WAITING (parking或sleeping)：定时的，那个条件不到来，也将定时唤醒自己。</p>
</blockquote>
<ol start="2">
<li>Waiting for Monitor Entry 和 in Object.wait()：The thread is waiting to get the lock for an object (some other thread may be holding the lock). This happens if two or more threads try to execute synchronized code. Note that the lock is always for an object and not for individual methods.</li>
</ol>
<p>在多线程的JAVA程序中，实现线程之间的同步，就要说说 Monitor。 *<em>Monitor是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者Class的锁。 *</em>每一个对象都有，也仅有一个 Monitor。下面这个图，描述了线程和 Monitor之间关系，以及线程的状态转换图：<br><img src="https://upload-images.jianshu.io/upload_images/2062729-2770d7fd4e31c5fa.png" alt="A Java Monitor And Thread"></p>
<p>如上图，每个Monitor在某个时刻，只能被一个线程拥有，*<em>该线程就是 “ActiveThread”，而其它线程都是 “Waiting Thread”，分别在两个队列“Entry Set”和“Wait Set”里等候。 *</em>在“Entry Set”中等待的线程状态是“Waiting for monitor entry”，而在“Wait Set”中等待的线程状态是“in Object.wait()”。</p>
<p><strong>先看“Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了“Entry Set”队列。</strong>对应的 code就像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj) &#123;</span><br><span class="line">   .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这时有两种可能性：</strong></p>
<blockquote>
<p>1.该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码。<br>2.该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。</p>
</blockquote>
<p><strong>在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-0&quot; prio&#x3D;10 tid&#x3D;0x08222eb0 nid&#x3D;0x9 waiting for monitor entry [0xf927b000..0xf927bdb8] </span><br><span class="line">at testthread.WaitThread.run(WaitThread.java:39) </span><br><span class="line">- waiting to lock &lt;0xef63bf08&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line">at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p><strong>临界区的设置，是为了保证其内部的代码执行的原子性和完整性。</strong>但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。</p>
<p><strong>再看“Wait Set”里面的线程。</strong>当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll()，“Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;10 tid&#x3D;0x08223250 nid&#x3D;0xa in Object.wait() [0xef47a000..0xef47aa38] </span><br><span class="line"> at java.lang.Object.wait(Native Method) </span><br><span class="line"> - waiting on &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Object.wait(Object.java:474) </span><br><span class="line"> at testthread.MyWaitThread.run(MyWaitThread.java:40) </span><br><span class="line"> - locked &lt;0xef63beb8&gt; (a java.util.ArrayList) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure>

<p>综上，一般CPU很忙时，则关注runnable的线程，CPU很闲时，则关注waiting for monitor entry的线程。</p>
<ol start="3">
<li>JDK 5.0 的 Lock</li>
</ol>
<p>上面提到如果 synchronized和 monitor机制运用不当，可能会造成多线程程序的性能问题。在 JDK 5.0中，引入了 Lock机制，从而使开发者能更灵活的开发高性能的并发多线程程序，可以替代以往 JDK中的 synchronized和 Monitor的 机制。** 但是，要注意的是，因为 Lock类只是一个普通类，JVM无从得知 Lock对象的占用情况，所以在线程 DUMP中，也不会包含关于 Lock的信息，**关于死锁等问题，就不如用 synchronized的编程方式容易识别。</p>
<h5 id="2-4-关键状态示例"><a href="#2-4-关键状态示例" class="headerlink" title="2.4 关键状态示例"></a>2.4 关键状态示例</h5><p><strong>显示BLOCKED状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class BlockedState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis(); </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取object的线程会执行5分钟，这5分钟内会一直持有object的监视器，另一个线程无法执行处在B</p>
<p><strong>LOCKED状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1314 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7a800 nid&#x3D;0x1350 waiting for monitor entry [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:17)  </span><br><span class="line">     - waiting to lock &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d79400 nid&#x3D;0x1338 runnable [0x282ef000]  </span><br><span class="line"> java.lang.Thread.State: RUNNABLE  </span><br><span class="line">     at jstack.BlockedState$1.run(BlockedState.java:22)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>通过thread dump可以看到：t2线程确实处在BLOCKED (on object monitor)。waiting for monitor entry 等待进入synchronized保护的区域。</p>
<p><strong>显示WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">public class WaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    private static Object object &#x3D; new Object();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                synchronized (object)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    long begin &#x3D; System.currentTimeMillis();  </span><br><span class="line">                    long end &#x3D; System.currentTimeMillis();  </span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 让线程运行5分钟,会一直持有object的监视器  </span><br><span class="line">                    while ((end - begin) &lt;&#x3D; 5 * 60 * 1000)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        try  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            &#x2F;&#x2F; 进入等待的同时,会进入释放监视器  </span><br><span class="line">                            object.wait();  </span><br><span class="line">                        &#125; catch (InterruptedException e)  </span><br><span class="line">                        &#123;  </span><br><span class="line">                            e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x1734 waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7e000 nid&#x3D;0x17f4 in Object.wait() [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x27d7d400 nid&#x3D;0x17f0 in Object.wait() [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)  </span><br><span class="line">     at java.lang.Object.wait(Native Method)  </span><br><span class="line">     - waiting on &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Object.wait(Object.java:485)  </span><br><span class="line">     at jstack.WaitingState$1.run(WaitingState.java:26)  </span><br><span class="line">     - locked &lt;0x1cfcdc00&gt; (a java.lang.Object)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以发现t1和t2都处在WAITING (on object monitor)，进入等待状态的原因是调用了in Object.wait()。通过J.U.C包下的锁和条件队列，也是这个效果，大家可以自己实践下。</p>
<p><strong>显示TIMED_WAITING状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package jstack;  </span><br><span class="line">import java.util.concurrent.TimeUnit;  </span><br><span class="line">import java.util.concurrent.locks.Condition;  </span><br><span class="line">import java.util.concurrent.locks.Lock;  </span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line">public class TimedWaitingState  </span><br><span class="line">&#123;  </span><br><span class="line">    &#x2F;&#x2F; java的显示锁,类似java对象内置的监视器  </span><br><span class="line">    private static Lock lock &#x3D; new ReentrantLock();  </span><br><span class="line">    &#x2F;&#x2F; 锁关联的条件队列(类似于object.wait)  </span><br><span class="line">    private static Condition condition &#x3D; lock.newCondition();  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Runnable task &#x3D; new Runnable() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void run()  </span><br><span class="line">            &#123;  </span><br><span class="line">                &#x2F;&#x2F; 加锁,进入临界区  </span><br><span class="line">                lock.lock();  </span><br><span class="line">                try  </span><br><span class="line">                &#123;  </span><br><span class="line">                    condition.await(5, TimeUnit.MINUTES);  </span><br><span class="line">                &#125; catch (InterruptedException e)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                &#x2F;&#x2F; 解锁,退出临界区  </span><br><span class="line">                lock.unlock();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        new Thread(task, &quot;t1&quot;).start();  </span><br><span class="line">        new Thread(task, &quot;t2&quot;).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) Server VM (20.12-b01 mixed mode):  </span><br><span class="line">&quot;DestroyJavaVM&quot; prio&#x3D;6 tid&#x3D;0x00856c00 nid&#x3D;0x169c waiting on condition [0x00000000] </span><br><span class="line">java.lang.Thread.State: RUNNABLE  </span><br><span class="line">&quot;t2&quot; prio&#x3D;6 tid&#x3D;0x27d7d800 nid&#x3D;0xc30 waiting on condition [0x2833f000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)  </span><br><span class="line"></span><br><span class="line">&quot;t1&quot; prio&#x3D;6 tid&#x3D;0x280d0c00 nid&#x3D;0x16e0 waiting on condition [0x282ef000]  </span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (parking)  </span><br><span class="line">     at sun.misc.Unsafe.park(Native Method)  </span><br><span class="line">     - parking to wait for  &lt;0x1cfce5b8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)  </span><br><span class="line">     at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196)  </span><br><span class="line">     at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2116)  </span><br><span class="line">     at jstack.TimedWaitingState$1.run(TimedWaitingState.java:28)  </span><br><span class="line">     at java.lang.Thread.run(Thread.java:662)</span><br></pre></td></tr></table></figure>

<p>可以看到t1和t2线程都处在java.lang.Thread.State: TIMED_WAITING (parking)，这个parking代表是调用的JUC下的工具类，而不是java默认的监视器。</p>
<h4 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3 案例分析"></a>3 案例分析</h4><h5 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a>3.1 问题场景</h5><p><strong>1. CPU飙高，load高，响应很慢</strong></p>
<blockquote>
<p>1.一个请求过程中多次dump；<br>2.对比多次dump文件的runnable线程，如果执行的方法有比较大变化，说明比较正常。如果在执行同一个方法，就有一些问题了；</p>
</blockquote>
<p><strong>2. 查找占用CPU最多的线程</strong></p>
<blockquote>
<p>1.使用命令：top -H -p pid（pid为被测系统的进程号），找到导致CPU高的线程ID，对应thread dump信息中线程的nid，只不过一个是十进制，一个是十六进制；<br>2.在thread dump中，根据top命令查找的线程id，查找对应的线程堆栈信息；</p>
</blockquote>
<p><strong>3. CPU使用率不高但是响应很慢</strong></p>
<blockquote>
<p>进行dump，查看是否有很多thread struck在了i/o、数据库等地方，定位瓶颈原因；</p>
</blockquote>
<p><strong>4. 请求无法响应</strong></p>
<blockquote>
<p>多次dump，对比是否所有的runnable线程都一直在执行相同的方法，如果是的，恭喜你，锁住了！</p>
</blockquote>
<h5 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h5><p><strong>死锁经常表现为程序的停顿，或者不再响应用户的请求。</strong>从操作系统上观察，对应进程的CPU占用率为零，很快会从top或prstat的输出中消失。</p>
<p>比如在下面这个示例中，是个较为典型的死锁情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; prio&#x3D;5 tid&#x3D;0x00acc490 nid&#x3D;0xe50 waiting for monitor entry [0x02d3f000 </span><br><span class="line">..0x02d3fd68] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f18&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot; prio&#x3D;5 tid&#x3D;0x00accdb0 nid&#x3D;0xdec waiting for monitor entry [0x02cff000 </span><br><span class="line">..0x02cff9e8] </span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31) </span><br><span class="line">- waiting to lock &lt;0x22c19f20&gt; (a java.lang.Object) </span><br><span class="line">- locked &lt;0x22c19f18&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure>

<p>在 JAVA 5中加强了对死锁的检测。线程 Dump中可以直接报告出 Java级别的死锁，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock: </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line">&quot;Thread-1&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f334 (object 0x22c19f18, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-0&quot; </span><br><span class="line"></span><br><span class="line">&quot;Thread-0&quot;: </span><br><span class="line">waiting to lock monitor 0x0003f314 (object 0x22c19f20, a java.lang.Object), </span><br><span class="line">which is held by &quot;Thread-1&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-热锁"><a href="#3-3-热锁" class="headerlink" title="3.3 热锁"></a>3.3 热锁</h5><p>热锁，也往往是导致系统性能瓶颈的主要因素。其表现特征为：由于多个线程对临界区，或者锁的竞争，可能出现：</p>
<blockquote>
<p>1.频繁的线程的上下文切换：从操作系统对线程的调度来看，当线程在等待资源而阻塞的时候，操作系统会将之切换出来，放到等待的队列，当线程获得资源之后，调度算法会将这个线程切换进去，放到执行队列中。<br>2.大量的系统调用：因为线程的上下文切换，以及热锁的竞争，或者临界区的频繁的进出，都可能导致大量的系统调用。<br>3.大部分CPU开销用在“系统态”：线程上下文切换，和系统调用，都会导致 CPU在 “系统态 ”运行，换而言之，虽然系统很忙碌，但是CPU用在 “用户态 ”的比例较小，应用程序得不到充分的 CPU资源。<br>4.随着CPU数目的增多，系统的性能反而下降。因为CPU数目多，同时运行的线程就越多，可能就会造成更频繁的线程上下文切换和系统态的CPU开销，从而导致更糟糕的性能。</p>
</blockquote>
<p>上面的描述，都是一个 scalability（可扩展性）很差的系统的表现。从整体的性能指标看，由于线程热锁的存在，程序的响应时间会变长，吞吐量会降低。</p>
<p>那么，怎么去了解 “热锁 ”出现在什么地方呢？</p>
<blockquote>
<p>一个重要的方法是 结合操作系统的各种工具观察系统资源使用状况，以及收集Java线程的DUMP信息，看线程都阻塞在什么方法上，了解原因，才能找到对应的解决方法。</p>
</blockquote>
<h5 id="4-JVM重要线程"><a href="#4-JVM重要线程" class="headerlink" title="4 JVM重要线程"></a>4 JVM重要线程</h5><p>JVM运行过程中产生的一些比较重要的线程罗列如下：</p>
<table>
<thead>
<tr>
<th>线程名称</th>
<th align="right">所属</th>
<th align="right">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>Attach Listener</td>
<td align="right">JVM</td>
<td align="right">Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并把结果返回给发送者。通常我们会用一些命令去要求JVM给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在JVM启动的时候没有初始化，那么，则会在用户第一次执行JVM命令时，得到启动。</td>
</tr>
<tr>
<td>Signal Dispatcher</td>
<td align="right">JVM</td>
<td align="right">前面提到Attach Listener线程的职责是接收外部JVM命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部JVM命令时，进行初始化工作。</td>
</tr>
<tr>
<td>CompilerThread0</td>
<td align="right">JVM</td>
<td align="right">用来调用JITing，实时编译装卸class 。 通常，JVM会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：CompilerThread1。</td>
</tr>
<tr>
<td>Concurrent Mark-Sweep GC Thread</td>
<td align="right">JVM</td>
<td align="right">并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。ps：启用该垃圾回收器，需要在JVM启动参数中加上：-XX:+UseConcMarkSweepGC。</td>
</tr>
<tr>
<td>DestroyJavaVM</td>
<td align="right">JVM</td>
<td align="right">执行main()的线程，在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程，处于等待状态，等待其它线程（Java线程和Native线程）退出时通知它卸载JVM。每个线程退出时，都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，则通知DestroyJavaVM 线程卸载JVM。</td>
</tr>
<tr>
<td>Finalizer Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：1) 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；2) 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；</td>
</tr>
<tr>
<td>Low Memory Detector</td>
<td align="right">JVM</td>
<td align="right">这个线程是负责对可使用内存进行检测，如果发现可用内存低，分配新的内存空间。</td>
</tr>
<tr>
<td>Reference Handler</td>
<td align="right">JVM</td>
<td align="right">JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</td>
</tr>
<tr>
<td>VM Thread</td>
<td align="right">JVM</td>
<td align="right">这个线程就比较牛b了，是JVM里面的线程母体，根据hotspot源码（vmThread.hpp）里面的注释，它是一个单个的对象（最原始的线程）会产生或触发所有其他的线程，这个单个的VM线程是会被其他线程所使用来做一些VM操作（如：清扫垃圾等）。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">啃碎并发（二）：Java线程的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 22:37:55 / 修改时间：23:16:03" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>啃碎并发（二）：Java线程的生命周期</p>
<h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是 线程状态也会多次在运行、阻塞之间切换。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-bf153c2ed5c95f66.png" alt=""></p>
<h6 id="1-新建（New）状态"><a href="#1-新建（New）状态" class="headerlink" title="1 新建（New）状态"></a>1 新建（New）状态</h6><p>当程序使用new关键字创建了一个线程之后，该线程就处于<strong>新建状态</strong>，此时的线程情况如下：</p>
<blockquote>
<p><strong>1.此时JVM为其分配内存，并初始化其成员变量的值；<br>2.此时线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体；</strong></p>
</blockquote>
<h6 id="2-就绪（Runnable）状态"><a href="#2-就绪（Runnable）状态" class="headerlink" title="2 就绪（Runnable）状态"></a>2 就绪（Runnable）状态</h6><p>当线程对象调用了start()方法之后，该线程处于<strong>就绪状态</strong>。此时的线程情况如下：</p>
<blockquote>
<p>1.此时JVM会为其<strong>创建方法调用栈和程序计数器；</strong><br>2.该状态的线程一直处于<strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；<br>3.此时线程<strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</p>
</blockquote>
<p>调用start()方法与run()方法，对比如下：</p>
<blockquote>
<p>1.调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体；<br>2.需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常；</p>
</blockquote>
<p>如何让子线程调用start()方法之后立即执行而非”等待执行”：</p>
<blockquote>
<p>程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行；</p>
</blockquote>
<h6 id="3-运行（Running）状态"><a href="#3-运行（Running）状态" class="headerlink" title="3 运行（Running）状态"></a>3 运行（Running）状态</h6><p>当CPU开始调度处于<strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 运行状态。</p>
<blockquote>
<p><strong>1.如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；<br>2.如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；<br>3.当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</strong></p>
</blockquote>
<p>处于运行状态的线程最为复杂，它 不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。线程状态可能会变为 阻塞状态、就绪状态和死亡状态。比如：</p>
<blockquote>
<p><strong>1.对于采用 抢占式策略 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 从运行状态变为就绪状态，重新等待系统分配资源；<br>2.对于采用 协作式策略的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—也就是必须由该线程主动放弃所占用的资源，线程就会又 从运行状态变为就绪状态。</strong></p>
</blockquote>
<h5 id="4-阻塞（Blocked）状态"><a href="#4-阻塞（Blocked）状态" class="headerlink" title="4 阻塞（Blocked）状态"></a>4 阻塞（Blocked）状态</h5><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入<strong>阻塞状态</strong>。</p>
<p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p>
<blockquote>
<p><strong>1.线程调用sleep()方法，主动放弃所占用的处理器资源，暂时进入中断状态（不会释放持有的对象锁），时间到后等待系统分配CPU继续执行；<br>2.线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；<br>3.线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有;<br>4.程序调用了线程的suspend方法将线程挂起；<br>5.线程调用wait，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</strong></p>
</blockquote>
<p>阻塞状态分类：</p>
<blockquote>
<p><strong>1.等待阻塞：运行状态中的 线程执行wait()方法，使本线程进入到等待阻塞状态；<br>同步阻塞：线程在 获取synchronized同步锁失败（因为锁被其它线程占用），它会进入到同步阻塞状态；<br>其他阻塞：通过调用线程的 sleep()或join()或发出I/O请求 时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕 时，线程重新转入就绪状态；<br>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。</strong></p>
</blockquote>
<blockquote>
<p>但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。</p>
</blockquote>
<h5 id="4-1-等待（WAITING）状态"><a href="#4-1-等待（WAITING）状态" class="headerlink" title="4.1 等待（WAITING）状态"></a>4.1 等待（WAITING）状态</h5><p>线程处于 无限制等待状态，等待一个特殊的事件来重新唤醒，如：</p>
<blockquote>
<p><strong>1.通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；<br>2.通过join()方法进行等待的线程等待目标线程运行结束而唤醒；<br>以上两种一旦通过相关事件唤醒线程，线程就进入了 就绪（RUNNABLE）状态 继续运行。</strong></p>
</blockquote>
<h5 id="4-2-时限等待（TIMED-WAITING）状态"><a href="#4-2-时限等待（TIMED-WAITING）状态" class="headerlink" title="4.2 时限等待（TIMED_WAITING）状态"></a>4.2 时限等待（TIMED_WAITING）状态</h5><p>线程进入了一个 时限等待状态，如：</p>
<blockquote>
<p>sleep(3000)，等待3秒后线程重新进行 就绪（RUNNABLE）状态 继续运行。</p>
</blockquote>
<h5 id="5-死亡（Dead）状态"><a href="#5-死亡（Dead）状态" class="headerlink" title="5 死亡（Dead）状态"></a>5 死亡（Dead）状态</h5><p>线程会以如下3种方式结束，结束后就处于 死亡状态：</p>
<blockquote>
<p><strong>1.run()或call()方法执行完成，线程正常结束；<br>2.线程抛出一个未捕获的Exception或Error；<br>3.直接调用该线程stop()方法来结束该线程—该方法容易导致死锁，通常不推荐使用；</strong></p>
</blockquote>
<p>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。**</p>
<p>所以，需要注意的是：</p>
<blockquote>
<p>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态。</p>
</blockquote>
<h5 id="5-1-终止（TERMINATED）状态"><a href="#5-1-终止（TERMINATED）状态" class="headerlink" title="5.1 终止（TERMINATED）状态"></a>5.1 终止（TERMINATED）状态</h5><p>线程执行完毕后，进入终止（TERMINATED）状态。</p>
<h5 id="6-线程相关方法"><a href="#6-线程相关方法" class="headerlink" title="6 线程相关方法"></a>6 线程相关方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Thread&#123;</span><br><span class="line">    &#x2F;&#x2F; 线程的启动</span><br><span class="line">    public void start(); </span><br><span class="line">    &#x2F;&#x2F; 线程体</span><br><span class="line">    public void run(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void stop(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void resume(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void suspend(); </span><br><span class="line">    &#x2F;&#x2F; 在指定的毫秒数内让当前正在执行的线程休眠</span><br><span class="line">    public static void sleep(long millis); </span><br><span class="line">    &#x2F;&#x2F; 同上，增加了纳秒参数</span><br><span class="line">    public static void sleep(long millis, int nanos); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否处于活动状态</span><br><span class="line">    public boolean isAlive(); </span><br><span class="line">    &#x2F;&#x2F; 中断线程</span><br><span class="line">    public void interrupt(); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否已经中断</span><br><span class="line">    public boolean isInterrupted(); </span><br><span class="line">    &#x2F;&#x2F; 测试当前线程是否已经中断</span><br><span class="line">    public static boolean interrupted(); </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止</span><br><span class="line">    public void join() throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒</span><br><span class="line">    public void join(long millis) throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</span><br><span class="line">    public void join(long millis, int nanos) throws InterruptedException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/2062729-3220c4bc58f5448b.png" alt=""></p>
<h5 id="6-1-线程就绪、运行和死亡状态转换"><a href="#6-1-线程就绪、运行和死亡状态转换" class="headerlink" title="6.1 线程就绪、运行和死亡状态转换"></a>6.1 线程就绪、运行和死亡状态转换</h5><p>1.就绪状态转换为运行状态：此线程得到CPU资源；<br>2.运行状态转换为就绪状态：此线程主动调用yield()方法或在运行过程中失去CPU资源。<br>3.运行状态转换为死亡状态：此线程执行执行完毕或者发生了异常；</p>
<p><strong>注意：</strong></p>
<blockquote>
<p><strong>当调用线程中的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的那个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</strong></p>
</blockquote>
<h5 id="6-2-run-amp-start"><a href="#6-2-run-amp-start" class="headerlink" title="6.2 run &amp; start"></a>6.2 run &amp; start</h5><p>通过调用start启动线程，线程执行时会执行run方法中的代码。</p>
<blockquote>
<p><strong>1.start()：线程的启动；<br>2.run()：线程的执行体；</strong></p>
</blockquote>
<h6 id="6-3-sleep-amp-yield"><a href="#6-3-sleep-amp-yield" class="headerlink" title="6.3 sleep &amp; yield"></a>6.3 sleep &amp; yield</h6><p>sleep()：通过sleep(millis)使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<p><strong>比如，我们想要使主线程每休眠100毫秒，然后再打印出数字：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意如下几点问题：</strong></p>
<p><strong>sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。</strong>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread&#x3D;new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        &#x2F;&#x2F; 这里sleep的就是main线程，而非myThread线程 </span><br><span class="line">        myThread.sleep(1000); </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName()+&quot;线程&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(50);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看某一次的运行结果：可以发现，线程0首先执行，然后线程1执行一次，又了执行一次。发现并不是按照sleep的顺序执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0线程0次执行！  </span><br><span class="line">Thread-1线程0次执行！  </span><br><span class="line">Thread-1线程1次执行！  </span><br><span class="line">Thread-0线程1次执行！  </span><br><span class="line">Thread-0线程2次执行！  </span><br><span class="line">Thread-1线程2次执行！</span><br></pre></td></tr></table></figure>

<p><strong>yield()</strong>：与sleep类似，也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。</p>
<blockquote>
<p><strong>实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于sleep()方法和yield()方的区别如下：</strong></p>
<blockquote>
<p><strong>sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态；<br>sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常；<br>sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行；</strong></p>
</blockquote>
<h5 id="6-4-join"><a href="#6-4-join" class="headerlink" title="6.4 join"></a>6.4 join</h5><p>线程的合并的含义就是 将几个并行线程的线程合并为一个单线程执行，应用场景是 当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。</p>
<p>join有3个重载的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void join()</span><br><span class="line">当前线程等该加入该线程后面，等待该线程终止。    </span><br><span class="line">void join(long millis)    </span><br><span class="line">当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   </span><br><span class="line">void join(long millis,int nanos)    </span><br><span class="line">等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span><br></pre></td></tr></table></figure>

<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在主线程中调用thread.join(); 就是将主线程加入到thread子线程后面等待执行。不过有时间限制，为1毫秒。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread t&#x3D;new MyThread();  </span><br><span class="line">        t.start();  </span><br><span class="line">        t.join(1);&#x2F;&#x2F;将主线程加入到子线程后面，不过如果子线程在1毫秒时间内没执行完，则主线程便不再等待它执行完，进入就绪状态，等待cpu调度  </span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++)&#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在JDK中join方法的源码，如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)    throws InterruptedException &#123;  </span><br><span class="line">    long base &#x3D; System.currentTimeMillis();  </span><br><span class="line">    long now &#x3D; 0;  </span><br><span class="line">  </span><br><span class="line">    if (millis &lt; 0) &#123;  </span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">          </span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">           wait(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">            long delay &#x3D; millis - now;  </span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            wait(delay);  </span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>join方法实现是通过调用wait方法实现。当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁)，调用该对象的wait(等待时间)，直到该对象唤醒main线程，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。</strong></p>
</blockquote>
<h5 id="6-5-suspend-amp-resume-已过时"><a href="#6-5-suspend-amp-resume-已过时" class="headerlink" title="6.5 suspend &amp; resume (已过时)"></a>6.5 suspend &amp; resume (已过时)</h5><p>suspend-线程进入阻塞状态，但不会释放锁。此方法已不推荐使用，因为同步时不会释放锁，会造成死锁的问题。</p>
<p>resume-使线程重新进入可执行状态。</p>
<p>为什么<strong>Thread.suspend **和</strong>Thread.resume**被废弃了？</p>
<blockquote>
<p><strong>Thread.suspend 天生容易引起死锁。如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了。这种死锁一般自身表现为“冻结（ frozen ）”进程。</strong></p>
</blockquote>
<h5 id="6-6-stop（已过时）"><a href="#6-6-stop（已过时）" class="headerlink" title="6.6 stop（已过时）"></a>6.6 stop（已过时）</h5><p>不推荐使用，且以后可能去除，因为它不安全。为什么 Thread.stop 被废弃了？</p>
<p>因为其天生是不安全的。停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。这种对象被称为受损的 （damaged）。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。</p>
<p>不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。</p>
<h5 id="6-7-wait-amp-notify-notifyAll"><a href="#6-7-wait-amp-notify-notifyAll" class="headerlink" title="6.7 wait &amp; notify/notifyAll"></a>6.7 wait &amp; notify/notifyAll</h5><p>*<em>wait &amp; notify/notifyAll *</em>这三个都是Object类的方法。使用 wait ，notify 和 notifyAll 前提是先获得调用对象的锁。</p>
<blockquote>
<p><strong>1.调用 wait 方法后，释放持有的对象锁，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列；<br>2.调用notify 或者 notifyAll 方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回；<br>3.notify 方法：将等待队列的一个等待线程从等待队列种移到同步队列中 ，而 notifyAll 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked。</strong></p>
</blockquote>
<p>前面一直提到两个概念，等待队列（等待池），同步队列（锁池），这两者是不一样的。具体如下：</p>
<blockquote>
<p><strong>1. 同步队列（锁池）：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked。<br>2.等待队列（等待池）：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么 仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）。</strong></p>
</blockquote>
<p><strong>被notify或notifyAll唤起的线程是有规律的，具体如下：</strong></p>
<blockquote>
<p><strong>1.如果是通过notify来唤起的线程，那 先进入wait的线程会先被唤起来；<br>2. 如果是通过nootifyAll唤起的线程，默认情况是 最后进入的会先被唤起来，即LIFO的策略；</strong></p>
</blockquote>
<h5 id="6-8-线程优先级"><a href="#6-8-线程优先级" class="headerlink" title="6.8 线程优先级"></a>6.8 线程优先级</h5><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p>
<blockquote>
<p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级；</p>
</blockquote>
<p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   &#x3D;10</span><br><span class="line">MIN_PRIORITY   &#x3D;1</span><br><span class="line">NORM_PRIORITY   &#x3D;5</span><br></pre></td></tr></table></figure>
<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name,int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F;设置线程的名称  </span><br><span class="line">        setPriority(pro);&#x2F;&#x2F;设置线程的优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从执行结果可以看到 ，一般情况下，高级线程更显执行完毕。</p>
<p><strong>注意一点：</strong></p>
<blockquote>
<p>虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>
<h5 id="6-9-守护线程"><a href="#6-9-守护线程" class="headerlink" title="6.9 守护线程"></a>6.9 守护线程</h5><p>守护线程与普通线程写法上基本没啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</p>
<p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</p>
<p>setDaemon方法详细说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line"></span><br><span class="line">该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">on - 如果为 true，则将该线程标记为守护线程。</span><br><span class="line">抛出：</span><br><span class="line">IllegalThreadStateException - 如果该线程处于活动状态。</span><br><span class="line">SecurityException - 如果当前线程无法修改该线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">* Java线程：线程的调度-守护线程 </span><br><span class="line">*&#x2F;  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">        public static void main(String[] args) &#123;  </span><br><span class="line">                Thread t1 &#x3D; new MyCommon();  </span><br><span class="line">                Thread t2 &#x3D; new Thread(new MyDaemon());  </span><br><span class="line">                t2.setDaemon(true);        &#x2F;&#x2F;设置为守护线程  </span><br><span class="line">  </span><br><span class="line">                t2.start();  </span><br><span class="line">                t1.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyCommon extends Thread &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;线程1第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyDaemon implements Runnable &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (long i &#x3D; 0; i &lt; 9999999L; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;后台线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">后台线程第0次执行！  </span><br><span class="line">线程1第0次执行！  </span><br><span class="line">线程1第1次执行！  </span><br><span class="line">后台线程第1次执行！  </span><br><span class="line">后台线程第2次执行！  </span><br><span class="line">线程1第2次执行！  </span><br><span class="line">线程1第3次执行！  </span><br><span class="line">后台线程第3次执行！  </span><br><span class="line">线程1第4次执行！  </span><br><span class="line">后台线程第4次执行！  </span><br><span class="line">后台线程第5次执行！  </span><br><span class="line">后台线程第6次执行！  </span><br><span class="line">后台线程第7次执行！</span><br></pre></td></tr></table></figure>
<p>从上面的执行结果可以看出：前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。</p>
<blockquote>
<p>实际上：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。</p>
</blockquote>
<h5 id="6-10-如何结束一个线程"><a href="#6-10-如何结束一个线程" class="headerlink" title="6.10 如何结束一个线程"></a>6.10 如何结束一个线程</h5><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。</p>
<blockquote>
<p>1.正常执行完run方法，然后结束掉；<br>2.控制循环条件和判断条件的标识符来结束掉线程；</p>
</blockquote>
<p>比如run方法这样写：只要保证在一定的情况下，run方法能够执行完毕即可。而不是while(true)的无限循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                break;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    boolean next&#x3D;true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                next&#x3D;false;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                return;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>诚然，使用上面方法的标识符来结束一个线程，是一个不错的方法，但其也有弊端，如果 该线程是处于sleep、wait、join的状态时候，while循环就不会执行，那么我们的标识符就无用武之地了，当然也不能再通过它来结束处于这3种状态的线程了。</p>
<p>所以，此时可以使用interrupt这个巧妙的方式结束掉这个线程。我们先来看看sleep、wait、join方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException </span><br><span class="line">public static native void sleep(long millis) throws InterruptedException</span><br><span class="line">public final void join() throws InterruptedException</span><br></pre></td></tr></table></figure>
<p>可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。在什么时候会产生这样一个异常呢？</p>
<blockquote>
<p>每个Thread都有一个中断状状态，默认为false。可以通过Thread对象的isInterrupted()方法来判断该线程的中断状态。可以通过Thread对象的interrupt()方法将中断状态设置为true。</p>
<p>当一个线程处于sleep、wait、join这三种状态之一的时候，如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常，并将中断状态重新设置为false。</p>
</blockquote>
<p>看下面的简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;1;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            System.out.println(this.isInterrupted());  </span><br><span class="line">            try &#123;  </span><br><span class="line">                System.out.println(&quot;我马上去sleep了&quot;);  </span><br><span class="line">                Thread.sleep(2000);  </span><br><span class="line">                this.interrupt();  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;异常捕获了&quot;+this.isInterrupted());  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">false  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">2  </span><br><span class="line">true  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">异常捕获了false</span><br></pre></td></tr></table></figure>

<p>可以看到，首先执行第一次while循环，在第一次循环中，睡眠2秒，然后将中断状态设置为true。当进入到第二次循环的时候，中断状态就是第一次设置的true，当它再次进入sleep的时候，马上就抛出了InterruptedException异常，然后被我们捕获了。然后中断状态又被重新自动设置为false了（从最后一条输出可以看出来）。</p>
<p>所以，我们可以使用interrupt方法结束一个线程。具体使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">        Thread.sleep(3000);  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(1000);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;中断异常被捕获了&quot;);  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多测试几次，会发现一般有两种执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">3  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>这两种结果恰恰说明了，只要一个线程的中断状态一旦为true，只要它进入sleep等状态，或者处于sleep状态，立马回抛出InterruptedException异常。</p>
<blockquote>
<p><strong>第一种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程正处于sleep状态，立马抛出InterruptedException异常。</p>
<p><strong>第二种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程还没有处于sleep状态。然后再第3次while循环的时候，在此进入sleep状态，立马抛出InterruptedException异常。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">啃碎并发（三）：Java线程上下文切换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:37:55" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是<strong>多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</strong></p>
<p>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。<strong>一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。</strong></p>
<p>多线程比多任务更加有挑战。<strong>多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。</strong>这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着<strong>不同的线程能被不同的CPU核得到真正意义的并行执行。</strong></p>
<p>所以，<strong>在多线程、多任务情况下，线程上下文切换是必须的，</strong>然而对于CPU架构设计中的概念，应先熟悉了解，这样会有助于理解线程上下文切换原理。</p>
<h4 id="1-多核、多CPU、超线程、多线程"><a href="#1-多核、多CPU、超线程、多线程" class="headerlink" title="1 多核、多CPU、超线程、多线程"></a>1 多核、多CPU、超线程、多线程</h4><h5 id="1-1-为什么要多核"><a href="#1-1-为什么要多核" class="headerlink" title="1.1 为什么要多核"></a>1.1 为什么要多核</h5><p>先要说的是多核、多CPU、超线程，这三个其实都是CPU架构设计的概念，<strong>一个现代CPU除了处理器核心之外还包括寄存器、L1L2缓存这些存储设备、浮点运算单元、整数运算单元等一些辅助运算设备以及内部总线等。</strong>一个多核的CPU也就是一个CPU上有多个处理器核心，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，<strong>就意味着这个程序的不同线程需要经常在CPU之间的外部总线上通信，同时还要处理不同CPU之间不同缓存导致数据不一致的问题，所以在这种场景下多核单CPU的架构就能发挥很大的优势，通信都在内部总线，共用同一个缓存。</strong></p>
<h5 id="1-2-为什么要多CPU"><a href="#1-2-为什么要多CPU" class="headerlink" title="1.2 为什么要多CPU"></a>1.2 为什么要多CPU</h5><p>前面提了多核的好处，那为什么要多CPU呢？这个其实很容易想到，如果要运行多个程序（进程）的话，假如只有一个CPU的话，就意味着要经常进行进程上下文切换，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，所以 <strong>多个进程就必然要经常进行进程上下文切换，这个代价是很高的。</strong></p>
<h5 id="1-3-为什么要超线程"><a href="#1-3-为什么要超线程" class="headerlink" title="1.3 为什么要超线程"></a>1.3 为什么要超线程</h5><p>超线程这个概念是Intel提出的，<strong>简单来说是在一个CPU上真正的并发两个线程</strong>，听起来似乎不太可能，因为CPU都是分时的啊，其实这里也是分时，<strong>因为前面也提到一个CPU除了处理器核心还有其他设备，一段代码执行过程也不光是只有处理器核心工作，如果两个线程A和B，A正在使用处理器核心，B正在使用缓存或者其他设备，那AB两个线程就可以并发执行，但是如果AB都在访问同一个设备，那就只能等前一个线程执行完后一个线程才能执行。</strong>实现这种并发的原理是<strong>在CPU里加了一个协调辅助核心，</strong>根据Intel提供的数据，这样一个设备会使得设备面积增大5%，但是性能提高15%~30%。</p>
<h5 id="1-4-为什么要多线程"><a href="#1-4-为什么要多线程" class="headerlink" title="1.4 为什么要多线程"></a>1.4 为什么要多线程</h5><p>这个问题也许是面试中问的最多的一个经典问题了，<strong>一个进程里多线程之间可以共享变量，线程间通信开销也较小，可以更好的利用多核CPU的性能，多核CPU上跑多线程程序往往会比单线程更快，</strong>有的时候甚至在单核CPU上多线程程序也会有更好的性能，<strong>因为虽然多线程会有上下文切换和线程创建销毁开销，但是单线程程序会被IO阻塞无法充分利用CPU资源，加上线程的上下文开销较低以及线程池的大量应用，多线程在很多场景下都会有更高的效率。</strong></p>
<h5 id="1-5-线程与进程"><a href="#1-5-线程与进程" class="headerlink" title="1.5 线程与进程"></a>1.5 线程与进程</h5><p><strong>进程是操作系统的管理单位，而线程则是进程的管理单位；</strong>一个进程至少包含一个执行线程。不管是在单线程还是多线程中，每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）。虽然线程寄生在进程中，但与他的进程是不同的概念，并且可以分别处理：<strong>进程是系统分配资源的基本单位，线程是调度CPU的基本单位。</strong></p>
<p>一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，<strong>每条线程并行执行不同的任务。每个线程共享堆空间，拥有自己独立的栈空间。</strong></p>
<blockquote>
<p>1.线程划分尺度小于进程，线程隶属于某个进程；<br>2.进程是CPU、内存等资源占用的基本单位，线程是不能独立占有这些资源的；<br>3.进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信方便；<br>4.进程在执行过程中，包含：固定的入口、执行顺序和出口，而进程的这些过程会被应用程序控制；<br>进程&amp;线程表项</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-926d1b70a1b4cac0.png" alt=""></p>
<h4 id="2-上下文切换"><a href="#2-上下文切换" class="headerlink" title="2 上下文切换"></a>2 上下文切换</h4><p>支持多任务处理是CPU设计史上最大的跨越之一。<strong>在计算机中，多任务处理是指同时运行两个或多个程序。</strong>从使用者的角度来看，这看起来并不复杂或者难以实现，但是它确实是计算机设计史上一次大的飞跃。<strong>在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里。</strong>上下文切换就是这样一个过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。</p>
<p>多任务系统往往需要同时执行多道作业。作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者<strong>巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载, 这段过程就叫做上下文切换。</strong>时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-4c5c5e8b4fd1e2c0.png" alt="任务的状态保存及再加载, 这段过程就叫做上下文切换"></p>
<h5 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h5><p>上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程或线程切换到另一个进程或线程。</p>
<blockquote>
<p>1.进程（有时候也称做任务）是指一个程序运行的实例。<br>2.在Linux系统中，<strong>线程</strong>就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的 轻量级的进程。<br>3.<strong>上下文</strong>是指某一时间点 CPU 寄存器和程序计数器的内容。<br>4.<strong>寄存器</strong>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。<strong>寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</strong><br>5.<strong>程序计数器是一个专用的寄存器，</strong>用于表明指令序列中 CPU 正在执行的位置，<strong>存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</strong></p>
</blockquote>
<p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：</p>
<blockquote>
<p>1.挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处；<br>2.恢复一个进程，在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复；<br>3.跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</p>
</blockquote>
<h5 id="2-2-切换种类"><a href="#2-2-切换种类" class="headerlink" title="2.2 切换种类"></a>2.2 切换种类</h5><p>上下文切换在不同的场合有不同的含义，在下表中列出：</p>
<table>
<thead>
<tr>
<th>上下文切换种类</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>线程切换</td>
<td align="right">同一进程中的两个线程之间的切换</td>
</tr>
<tr>
<td>进程切换</td>
<td align="right">两个进程之间的切换</td>
</tr>
<tr>
<td>模式切换</td>
<td align="right">在给定线程中，用户模式和内核模式的切换</td>
</tr>
<tr>
<td>地址空间切换</td>
<td align="right">将虚拟内存切换到物理内存</td>
</tr>
</tbody></table>
<h5 id="2-3-切换步骤"><a href="#2-3-切换步骤" class="headerlink" title="2.3 切换步骤"></a>2.3 切换步骤</h5><p>在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。<strong>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB, process control block）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</strong></p>
<p><strong>PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，</strong>它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。</p>
<blockquote>
<p>1.保存进程A的状态（寄存器和操作系统数据）；<br>2.更新PCB中的信息，对进程A的“运行态”做出相应更改；<br>3.将进程A的PCB放入相关状态的队列；<br>4.将进程B的PCB信息改为“运行态”，并执行进程B；<br>5.B执行完后，从队列中取出进程A的PCB，恢复进程A被切换时的上下文，继续执行A；</p>
</blockquote>
<p>线程切换和进程切换的步骤也不同。进程的上下文切换分为两步：</p>
<blockquote>
<p>1.切换页目录以使用新的地址空间；<br>2.切换内核栈和硬件上下文；</p>
</blockquote>
<p>对于Linux来说，线程和进程的最大区别就在于地址空间。<strong>对于线程切换，第1步是不需要做的，</strong>第2是进程和线程切换都要做的。所以明显是进程切换代价大。线程上下文切换和进程上下文切换一个最主要的区别是<strong>线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。</strong>这两种上下文切换的处理都是<strong>通过操作系统内核来完成的。</strong>内核的这种切换过程伴随的 最显著的性能损耗是将寄存器中的内容切换出。</p>
<p>对于一个正在执行的进程包括<strong>程序计数器、寄存器、变量的当前值等 ，</strong>而这些数据都是 <strong>保存在CPU的寄存器中的，</strong>且这些寄存器只能是正在使用CPU的进程才能享用，在进程切换时，首先得保存上一个进程的这些数据（便于下次获得CPU的使用权时从上次的中断处开始继续顺序执行，而不是返回到进程开始，否则每次进程重新获得CPU时所处理的任务都是上一次的重复，可能永远也到不了进程的结束出，因为一个进程几乎不可能执行完所有任务后才释放CPU），然后将本次获得CPU的进程的这些数据装入CPU的寄存器从上次断点处继续执行剩下的任务。</p>
<p><strong>操作系统为了便于管理系统内部进程，为每个进程创建了一张进程表项：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-e2afee842676828d.png" alt="进程表项"></p>
<h5 id="2-4-切换查看"><a href="#2-4-切换查看" class="headerlink" title="2.4 切换查看"></a>2.4 切换查看</h5><p>在Linux系统下可以使用vmstat命令来查看上下文切换的次数，下面是利用vmstat查看上下文切换次数的示例：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-73c88cc6c86895f3.png" alt="上线文切换查看"></p>
<blockquote>
<p>vmstat 1指每秒统计一次, 其中cs列就是指上下文切换的数目. 一般情况下, 空闲系统的上下文切换每秒大概在1500以下.</p>
</blockquote>
<h5 id="3-切换原因"><a href="#3-切换原因" class="headerlink" title="3 切换原因"></a>3 切换原因</h5><p>引起线程上下文切换的原因，主要存在三种情况如下：</p>
<blockquote>
<p>1.中断处理：在中断处理中，其他程序”打断”了当前正在运行的程序。当CPU接收到中断请求时，会在正在运行的程序和发起中断请求的程序之间进行一次上下文切换。中断分为硬件中断和软件中断，软件中断包括因为IO阻塞、未抢到资源或者用户代码等原因，线程被挂起。<br>2.多任务处理：在多任务处理中，CPU会在不同程序之间来回切换，每个程序都有相应的处理时间片，CPU在两个时间片的间隔中进行上下文切换。<br>3.用户态切换：对于一些操作系统，当进行用户态切换时也会进行一次上下文切换，虽然这不是必须的。</p>
</blockquote>
<p>对于我们经常 使用的抢占式操作系统 而言，引起线程上下文切换的原因大概有以下几种：</p>
<blockquote>
<p>1.当前执行任务的时间片用完之后，系统CPU正常调度下一个任务；<br>2.当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务；<br>3.多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；<br>4.用户代码挂起当前任务，让出CPU时间；<br>5.硬件中断；</p>
</blockquote>
<h5 id="4-切换损耗"><a href="#4-切换损耗" class="headerlink" title="4 切换损耗"></a>4 切换损耗</h5><p>上下文切换会带来 直接和间接 两种因素影响程序性能的消耗。</p>
<blockquote>
<p>1.直接消耗：指的是CPU寄存器需要保存和加载, 系统调度器的代码需要执行, TLB实例需要重新加载, CPU 的pipeline需要刷掉；<br>2.间接消耗：指的是多核的cache之间得共享数据, 间接消耗对于程序的影响要看线程工作区操作数据的大小；</p>
</blockquote>
<h5 id="5-减少切换"><a href="#5-减少切换" class="headerlink" title="5 减少切换"></a>5 减少切换</h5><p>既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。但上下文切换又分为2种：</p>
<blockquote>
<p>1.让步式上下文切换：指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；<br>2.抢占式上下文切换：指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。</p>
</blockquote>
<p>所以，减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。</p>
<blockquote>
<p>1.无锁并发：多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据；<br>2.CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁；<br>3.最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态；<br>4.使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换；</p>
</blockquote>
<h5 id="6-线程数目"><a href="#6-线程数目" class="headerlink" title="6 线程数目"></a>6 线程数目</h5><p>合理设置线程数目，<strong>关键点是：1. 尽量减少线程切换和管理的开支；2. 最大化利用CPU；</strong></p>
<blockquote>
<p>1.对于1，要求线程数尽量少，这样可以减少线程切换和管理的开支；</p>
<p>对于2，要求尽量多的线程，以保证CPU资源最大化的利用；</p>
</blockquote>
<p>所以<strong>对于任务耗时短的情况，要求线程尽量少，</strong>如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；</p>
<p><strong>对于耗时长的任务，要分是CPU任务，还是IO等类型的任务。</strong>如果是CPU类型的任务，线程数不宜太多；但是如果是IO类型的任务，线程多一些更好，可以更充分利用CPU。</p>
<p><strong>高并发，低耗时的情况：</strong>建议少线程，只要满足并发即可，因为上下文切换本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片，反而会增加线程切换的开销；例如并发100，线程池可能设置为10就可以；</p>
<p><strong>低并发，高耗时的情况：</strong>建议多线程，保证有空闲线程，接受新的任务；例如并发10，线程池可能就要设置为20；</p>
<p><strong>高并发高耗时</strong>：1. 要分析任务类型；2. 增加排队；3. 加大线程数；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">啃碎并发（一）：Java线程总述与概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 21:14:46 / 修改时间：21:23:46" itemprop="dateCreated datePublished" datetime="2020-05-31T21:14:46+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h4><p>在JDK5之前，Java多线程以及其性能一直是个软肋，只有synchronized、Thread.sleep()、Object.wait/notify这样有限的方法，而synchronized的效率还特别地低，开销比较大。</p>
<p>在JDK5之后，相对于前面版本有了重大改进，不仅在Java语法上有了很多改进，包括：泛型、装箱、for循环、变参等，在多线程上也有了彻底提高，其引进了并发编程大师Doug Lea的java.util.concurrent包(后面简称J.U.C)，支持了现代CPU的CAS原语，不仅在性能上有了很大提升，在自由度上也有了更多的选择，此时 J.U.C的效率在高并发环境下的效率远优于synchronized。</p>
<p>在JDK6（Mustang 野马）中，对synchronized的内在机制做了大量显著的优化，加入了CAS的概念以及偏向锁、轻量级锁，使得synchronized的效率与J.U.C不相上下，并且官方说后面该关键字还有继续优化的空间，所以在现 在JDK7时代，synchronized已经成为一般情况下的首选，在某些特殊场景：可中断的锁、条件锁、等待获得锁一段时间如果失败则停止，J.U.C是适用的，所以对于 多线程研究来说，了解其原理以及各自的适用场景是必要的。</p>
<h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2 基本概念"></a>2 基本概念</h4><h5 id="2-1-线程"><a href="#2-1-线程" class="headerlink" title="2.1 线程"></a>2.1 线程</h5><p>线程是依附于进程的，进程是分配资源的最小单位，一个进程可以生成多个线程，这些线程拥有共享的进程资源。就每个线程而言，只有很少的独有资源，如：控制线程运行的线程控制块，保留局部变量和少数参数的栈空间等。线程有就绪、阻塞和运行三种状态，并可以在这之间切换。也正因为多个线程会共享进程资源，所以当它们对同一个共享变量/对象进行操作的时候，线程的冲突和不一致性就产生了。</p>
<p>多线程并发环境下，本质上要解决地是这两个问题：</p>
<blockquote>
<ol>
<li>线程之间如何通信；</li>
<li>线程之间如何同步；</li>
</ol>
</blockquote>
<p>概括起来说就是：线程之间如何正确地通信。虽然说的是在Java层面如何保证，但会涉及到 Java虚拟机、Java内存模型，以及Java这样的高级语言最终是要映射到CPU来执行（关键原因：如今的CPU有缓存、并且是多核的），虽然有些难懂，但对于深刻把握多线程是至关重要的，所以需要多花一些时间。</p>
<h5 id="2-2-锁"><a href="#2-2-锁" class="headerlink" title="2.2 锁"></a>2.2 锁</h5><p>当多个线程对同一个共享变量/对象进行操作，即使是最简单的操作，如：i++，在处理上实际也涉及到读取、自增、赋值这三个操作，也就是说 这中间存在时间差，导致多个线程没有按照如程序编写者所设想的去顺序执行，出现错位，从而导致最终结果与预期不一致。</p>
<p>Java中的多线程同步是通过锁的概念来体现。锁不是一个对象、不是一个具体的东西，而是一种机制的名称。锁机制需要保证如下两种特性：</p>
<blockquote>
<p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性；<br>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致；</p>
</blockquote>
<h5 id="2-3-挂起、休眠、阻塞与非阻塞"><a href="#2-3-挂起、休眠、阻塞与非阻塞" class="headerlink" title="2.3 挂起、休眠、阻塞与非阻塞"></a>2.3 挂起、休眠、阻塞与非阻塞</h5><p>挂起（Suspend）：当线程被挂起的时候，其会失去CPU的使用时间，直到被其他线程（用户线程或调度线程）唤醒。</p>
<p>休眠（Sleep）：同样是会失去CPU的使用时间，但是在过了指定的休眠时间之后，它会自动激活，无需唤醒（整个唤醒表面看是自动的，但实际上也得有守护线程去唤醒，只是不需编程者手动干预）。</p>
<p>阻塞（Block）：在线程执行时，所需要的资源不能得到，则线程被挂起，直到满足可操作的条件。</p>
<p>非阻塞(Block)：在线程执行时，所需要的资源不能得到，则线程不是被挂起等待，而是继续执行其余事情，待条件满足了之后，收到了通知（同样是守护线程去做）再执行。</p>
<p>挂起和休眠是独立的操作系统的概念，而阻塞与非阻塞则是在资源不能得到时的两种处理方式，不限于操作系统，当资源申请不到时，要么挂起线程等待、要么继续执行其他操作，资源被满足后再通知该线程重新请求。显然非阻塞的效率要高于阻塞，相应的实现的复杂度也要高一些。</p>
<p>在Java中显式的挂起之前是通过Thread的suspend方法来体现，现在此概念已经消失，原因是suspend/resume方法已经被废弃，它们容易产生死锁，在suspend方法的注释里有这么一段话：当suspend的线程持有某个对象锁，而resume它的线程又正好需要使用此锁的时候，死锁就产生了。</p>
<p>所以，现在的JDK版本中，挂起是JVM的系统行为，程序员无需干涉。休眠的过程中也不会释放锁，但它一定会在某个时间后被唤醒，所以不会死锁。现在我们所说的挂起，往往并非指编写者的程序里主动挂起，而是由操作系统的线程调度器去控制。</p>
<p>所以，我们常常说的“线程在申请锁失败后会被挂起、然后等待调度”这样有一定歧义，因为这里的“挂起”是操作系统级别的挂起，其实是在申请资源失败时的阻塞，和Java中的线程的挂起（可能已经获得锁，也可能没有锁，总之和锁无关）不是一个概念，很容易混淆，所以在后文中说的挂起，一般指的是操作系统的操作，而不是Thread中的suspend()。</p>
<p>相应地有必要提下java.lang.Object的wait/notify，这两个方法同样是等待/通知，但它们的前提是已经获得了锁，且在wait（等待）期间会释放锁。在wait方法的注释里明确提到：线程要调用wait方法，必须先获得该对象的锁，在调用wait之后，当前线程释放该对象锁并进入休眠（这里到底是进入休眠还是挂起？文档没有细说，从该方法能指定等待时间来看，更可能是休眠，没有指定等待时间的，则可能是挂起，不管如何，在休眠/挂起之前，JVM都会从当前线程中把该对象锁释放掉），只有以下几种情况下会被唤醒：其他线程调用了该对象的notify或notifyAll、当前线程被中断、调用wait时指定的时间已到。</p>
<h5 id="2-4-内核态与用户态"><a href="#2-4-内核态与用户态" class="headerlink" title="2.4 内核态与用户态"></a>2.4 内核态与用户态</h5><p>这是两个操作系统的概念，但理解它们对我们理解Java的线程机制有着一定帮助。</p>
<p>有一些系统级的调用，比如：清除时钟、创建进程等这些系统指令，如果这些底层系统级指令能够被应用程序任意访问的话，那么后果是危险的，系统随时可能崩溃，所以 CPU将所执行的指令设置为多个特权级别，在硬件执行每条指令时都会校验指令的特权，比如：Intel x86架构的CPU将特权分为0-3四个特权级，0级的权限最高，3权限最低。</p>
<p>而操作系统根据这系统调用的安全性分为两种：内核态和用户态。内核态执行的指令的特权是0，用户态执行的指令的特权是3。</p>
<blockquote>
<p>1.当一个任务（进程）执行系统调用而进入内核指令执行时，进程处于内核运行态（或简称为内核态）；<br>2. 当任务（进程）执行自己的代码时，进程就处于用户态；</p>
</blockquote>
<p>明白了内核态和用户态的概念之后，那么在这两种状态之间切换会造成什么样的效率影响？</p>
<blockquote>
<p>在执行系统级调用时，需要将变量传递进去、可能要拷贝、计数、保存一些上下文信息，然后内核态执行完成之后需要再将参数传递到用户进程中去，这个切换的代价相对来说是比较大的，所以应该是 尽量避免频繁地在内核态和用户态之间切换。</p>
</blockquote>
<p>那操作系统的这两种形态和我们的线程主题有什么关系呢？这里是关键。Java并没有自己的线程模型，而是使用了操作系统的原生线程！</p>
<p>如果要实现自己的线程模型，那么有些问题就特别复杂，难以解决，比如：如何处理阻塞、如何在多CPU之间合理地分配线程、如何锁定，包括创建、销毁线程这些，都需要Java自己来做，在JDK1.2之前Java曾经使用过自己实现的线程模型，后来放弃了，转向使用操作系统的线程模型，因此创建、销毁、调度、阻塞等这些事都交由操作系统来做，而 线程方面的事在操作系统来说属于系统级的调用，需要在内核态完成，所以如果频繁地执行线程挂起、调度，就会频繁造成在内核态和用户态之间切换，影响效率（当然，操作系统的线程操作是不允许外界（包括Java虚拟机）直接访问的，而是开放了叫“轻量级进程”的接口供外界使用，其与内核线程在Window和Linux上是一对一的关系，这里不多叙述）。</p>
<blockquote>
<p>前面说JDK5之前的synchronized效率低下，是 因为在阻塞时线程就会被挂起、然后等待重新调度，而线程操作属于内核态，这频繁的挂起、调度使得操作系统频繁处于内核态和用户态的转换，造成频繁的变量传递、上下文保存等，从而性能较低。</p>
</blockquote>
<h5 id="3-线程优势"><a href="#3-线程优势" class="headerlink" title="3 线程优势"></a>3 线程优势</h5><p>尽管面临很多挑战，多线程有一些优点使得它一直被使用。这些优点是：</p>
<blockquote>
<ol>
<li>资源利用率更好；</li>
<li>程序设计在某些情况下更简单；</li>
<li>程序响应更快速；</li>
</ol>
</blockquote>
<h5 id="4-创建运行"><a href="#4-创建运行" class="headerlink" title="4 创建运行"></a>4 创建运行</h5><p>编写线程运行时执行的代码有两种方式：一种是创建Thread子类的一个实例并重写run方法，第二种是创建类的时候实现Runnable接口。</p>
<h5 id="5-Main线程与子线程关系"><a href="#5-Main线程与子线程关系" class="headerlink" title="5 Main线程与子线程关系"></a>5 Main线程与子线程关系</h5><p><strong>1. Main线程是个非守护线程，不能设置成守护线程</strong></p>
<p>这是因为，Main线程是由Java虚拟机在启动的时候创建的。main方法开始执行的时候，主线程已经创建好并在运行了。对于运行中的线程，调用Thread.setDaemon()会抛出异常Exception in thread “main” java.lang.IllegalThreadStateException。</p>
<p><strong>2. Main线程结束，其他线程一样可以正常运行</strong></p>
<p>主线程，只是个普通的非守护线程，用来启动应用程序，不能设置成守护线程；除此之外，它跟其他非守护线程没有什么不同。主线程执行结束，其他线程一样可以正常执行。</p>
<p>这样其实是很合理的，按照操作系统的理论，进程是资源分配的基本单位，线程是CPU调度的基本单位。对于CPU来说，其实并不存在java的主线程和子线程之分，都只是个普通的线程。进程的资源是线程共享的，只要进程还在，线程就可以正常执行，换句话说线程是强依赖于进程的。也就是说：</p>
<blockquote>
<p>线程其实并不存在互相依赖的关系，一个线程的死亡从理论上来说，不会对其他线程有什么影响。</p>
</blockquote>
<p><strong>3. Main线程结束，其他线程也可以立刻结束，当且仅当这些子线程都是守护线程</strong></p>
<p>Java虚拟机（相当于进程）退出的时机是：虚拟机中所有存活的线程都是守护线程。只要还有存活的非守护线程虚拟机就不会退出，而是等待非守护线程执行完毕；反之，如果虚拟机中的线程都是守护线程，那么不管这些线程的死活java虚拟机都会退出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">数据结构 -- 查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:57:11 / 修改时间：20:03:58" itemprop="dateCreated datePublished" datetime="2020-05-31T19:57:11+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><p><img src="https://upload-images.jianshu.io/upload_images/2062729-6175e9c6b5ecbb36.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E4%B8%B2/" class="post-title-link" itemprop="url">数据结构 -- 串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:36:38 / 修改时间：21:07:48" itemprop="dateCreated datePublished" datetime="2020-05-31T19:36:38+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a>Java String</h4><blockquote>
<p>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;abc&quot;) ;</span><br><span class="line">System.out.println(str&#x3D;&#x3D;&quot;abc&quot;);</span><br></pre></td></tr></table></figure>
<p>=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。<br>输出为false!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class String_Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        String str1 &#x3D; new String() ;</span><br><span class="line">        String str2 &#x3D; null ;</span><br><span class="line">        String str3 &#x3D; &quot;&quot; ;</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str2);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str2));         &#x2F;&#x2F;值的比较，返回false</span><br><span class="line">        System.out.println(str2&#x3D;&#x3D;str3);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str3.equals(str2));         &#x2F;&#x2F;值的比较，返回false</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str3);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str3));         &#x2F;&#x2F;值的比较，返回true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h4><h5 id="1-朴素的模式匹配算法（BF-Brute-Force-算法）"><a href="#1-朴素的模式匹配算法（BF-Brute-Force-算法）" class="headerlink" title="1. 朴素的模式匹配算法（BF(Brute Force)算法）"></a>1. 朴素的模式匹配算法（BF(Brute Force)算法）</h5><p>朴素模式匹配算法的基本思想是穷举法，即就是将目标串S的第一个字符与模式串P的第一个字符进行匹配，若相等，则继续比较S的第二个字符和P的第二个字符；若不相等，则比较S的第二个字符和P的第一个字符，依次比较下去，直到得出最后的匹配结果（如图1所示）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int bf(String T, String P) &#123;</span><br><span class="line">    int i &#x3D; 0; &#x2F;&#x2F;目标串的下标</span><br><span class="line">    int j &#x3D; 0; &#x2F;&#x2F;模式串的下标</span><br><span class="line">    int tLen &#x3D; T.length();</span><br><span class="line">    int pLen &#x3D; P.length();</span><br><span class="line">    if (tLen &lt; pLen) return -1;&#x2F;&#x2F;长度不够直接返回</span><br><span class="line">    while(i &lt; tLen &amp; j &lt; pLen) &#123;&#x2F;&#x2F;逐个匹配</span><br><span class="line">        if(T.charAt(i) &#x3D;&#x3D; P.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i &#x3D; i-j+1;</span><br><span class="line">            j &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j &#x3D;&#x3D; pLen) &#123;</span><br><span class="line">        return i-j+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-KMP模式匹配算法"><a href="#2-KMP模式匹配算法" class="headerlink" title="2. KMP模式匹配算法"></a>2. KMP模式匹配算法</h5><p>首先是next数组的计算，下图是next数组计算公式<br><img src="https://upload-images.jianshu.io/upload_images/12455188-11a97f211ace9892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/573/format/webp" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static int[] getNext(String ps) &#123;</span><br><span class="line">    char[] p &#x3D; ps.toCharArray();</span><br><span class="line">    int[] next &#x3D; new int[p.length];</span><br><span class="line">    next[0] &#x3D; -1;</span><br><span class="line">    int j &#x3D; 0;</span><br><span class="line">    int k &#x3D; -1;</span><br><span class="line">    while (j &lt; p.length - 1) &#123;</span><br><span class="line">       if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;</span><br><span class="line">           if (p[++j] &#x3D;&#x3D; p[++k]) &#123; &#x2F;&#x2F; 当两个字符相等时要跳过</span><br><span class="line">              next[j] &#x3D; next[k];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">              next[j] &#x3D; k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           k &#x3D; next[k];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int KMP(String ts, String ps) &#123;</span><br><span class="line">    char[] t &#x3D; ts.toCharArray();</span><br><span class="line">    char[] p &#x3D; ps.toCharArray();</span><br><span class="line">    int i &#x3D; 0; &#x2F;&#x2F; 主串的位置</span><br><span class="line">    int j &#x3D; 0; &#x2F;&#x2F; 模式串的位置</span><br><span class="line">    int[] next &#x3D; getNext(ps);</span><br><span class="line">    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line">       if (j &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; p[j]) &#123; &#x2F;&#x2F; 当j为-1时，要移动的是i，当然j也要归0</span><br><span class="line">           i++;</span><br><span class="line">           j++;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; i不需要回溯了</span><br><span class="line">           &#x2F;&#x2F; i &#x3D; i - j + 1;</span><br><span class="line">           j &#x3D; next[j]; &#x2F;&#x2F; j回到指定位置</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &#x3D;&#x3D; p.length) &#123;</span><br><span class="line">       return i - j;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">数据结构 -- 红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:36:37 / 修改时间：19:56:56" itemprop="dateCreated datePublished" datetime="2020-05-31T19:36:37+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="R-B-Tree简介"><a href="#R-B-Tree简介" class="headerlink" title="R-B Tree简介"></a>R-B Tree简介</h4><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。</p>
<p>红黑树的特性:</p>
<ul>
<li>（1）每个节点或者是黑色，或者是红色。</li>
<li>（2）根节点是黑色。</li>
<li>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>注意：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p><img src="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" alt=""></p>
<h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p>
<ul>
<li>从根结点开始查找，把根结点设置为当前结点；</li>
<li>若当前结点为空，返回null；</li>
<li>若当前结点不为空，用当前结点的key跟查找key作比较；</li>
<li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li>
<li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2392382-07b47eb3722981e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p>
<h4 id="红黑树的基本操作-一-左旋和右旋"><a href="#红黑树的基本操作-一-左旋和右旋" class="headerlink" title="红黑树的基本操作(一) 左旋和右旋"></a>红黑树的基本操作(一) 左旋和右旋</h4><h5 id="1-左旋"><a href="#1-左旋" class="headerlink" title="1. 左旋"></a>1. 左旋</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251733282013849.jpg" alt="左旋"></p>
<h5 id="2-右旋"><a href="#2-右旋" class="headerlink" title="2. 右旋"></a>2. 右旋</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg" alt="左旋"></p>
<h4 id="红黑树的基本操作-二-添加"><a href="#红黑树的基本操作-二-添加" class="headerlink" title="红黑树的基本操作(二) 添加"></a>红黑树的基本操作(二) 添加</h4><table>
<thead>
<tr>
<th></th>
<th>现象说明</th>
<th align="center">处理策略</th>
</tr>
</thead>
<tbody><tr>
<td>Case 1</td>
<td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td>
<td align="center">(01) 将“父节点”设为黑色。  <br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</td>
</tr>
<tr>
<td>Case 2</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td>
<td align="center">(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</td>
</tr>
<tr>
<td>Case 3</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td>
<td align="center">(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</td>
</tr>
</tbody></table>
<h5 id="Case-1-叔叔是红色"><a href="#Case-1-叔叔是红色" class="headerlink" title="(Case 1) 叔叔是红色"></a>(Case 1) 叔叔是红色</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" alt="(Case 1)叔叔是红色"></p>
<h5 id="Case-2-叔叔是黑色，且当前节点是右孩子"><a href="#Case-2-叔叔是黑色，且当前节点是右孩子" class="headerlink" title="(Case 2)叔叔是黑色，且当前节点是右孩子"></a>(Case 2)叔叔是黑色，且当前节点是右孩子</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" alt=""></p>
<h5 id="Case-3-叔叔是黑色，且当前节点是左孩子"><a href="#Case-3-叔叔是黑色，且当前节点是左孩子" class="headerlink" title="(Case 3)叔叔是黑色，且当前节点是左孩子"></a>(Case 3)叔叔是黑色，且当前节点是左孩子</h5><p><img src="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构 -- 排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:01:45 / 修改时间：20:05:08" itemprop="dateCreated datePublished" datetime="2020-05-31T19:01:45+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><p><img src="https://upload-images.jianshu.io/upload_images/2062729-6906429ed882a5b0.png" alt="排序算法"></p>
<h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h4><p>冒泡排序算法的基本流程是：每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。 （稳定排序算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort(int[] source) &#123;</span><br><span class="line">    for(int i &#x3D; source.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 注意这里面j的范围</span><br><span class="line">        for(int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">            if(a[j] &gt; a[j+1])</span><br><span class="line">                swap(source, j, j+1); &#x2F;&#x2F;交换，具体实现略</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h4><p>选择排序是将一轮比较完后，把最小的放到最前的位置（或者把最大的放到最后） （不稳定排序算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void selectSort(int[] source) &#123;  </span><br><span class="line">    int min;  </span><br><span class="line">    for(int i &#x3D; 0; i &lt; source.length; i++) &#123;  </span><br><span class="line">        min &#x3D; i;  </span><br><span class="line">        for(int j &#x3D; i + 1; j &lt; source.length; j++) &#123;  </span><br><span class="line">            if(a[j] &lt; a[min])  </span><br><span class="line">                min &#x3D; j;    </span><br><span class="line">        &#125;  </span><br><span class="line">        swap(i, min);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h4><p>插入排序的实现步骤为：从第一个元素开始，该元素可以认为已经被排序 -&gt; 取出下一个元素，在已经排序的元素序列中从后向前扫描 -&gt; 如果该元素小于前一个元素，则将两者调换，再与前一个元素比较–&gt; 重复第三步，直到找到已排序的元素小于或者等于新元素的位置 -&gt; 将新元素插入到该位置中 -&gt; 重复第二步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void insertSort(int[] source) &#123;</span><br><span class="line">    for(int i &#x3D; 1; i &lt; source.length; i++) &#123;</span><br><span class="line">        for(int j &#x3D; i; (j &gt; 0) &amp;&amp; (source[j] &lt; source[j-1]); j--) &#123;</span><br><span class="line">            swap(j, j-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h4><p>希尔排序的中心思想是将数据进行分组，然后对每一组数据进行插入排序，在每一组数据都有序后，再对所有的分组利用插入排序进行最后一次排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void shellSort2() &#123;</span><br><span class="line">    int h &#x3D; 1;</span><br><span class="line">    while(h &lt;&#x3D; nElem &#x2F; 3) &#123;</span><br><span class="line">        h &#x3D; h * 3 + 1; &#x2F;&#x2F;增量间隔</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(h &gt; 0) &#123;</span><br><span class="line">        for(int i &#x3D; h; i &lt; nElem; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;每个增量间隔内，实现插入排序，两个for循环和插入排序一样，只不过第二个for循环里参数略有调整而已，和h有关</span><br><span class="line">            for(int j &#x3D; i; j &lt; nElem; j +&#x3D; h) &#123;</span><br><span class="line">                for(int k &#x3D; j; (k - h &gt;&#x3D; 0) &amp;&amp; a[k] &lt; a[k - h]; k -&#x3D; h) &#123;</span><br><span class="line">                    swap(k, k-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h &#x3D; (h-1) &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-快速排序-（重点）"><a href="#5-快速排序-（重点）" class="headerlink" title="5. 快速排序  （重点）"></a>5. 快速排序  （重点）</h4><p>快速排序本质上通过一个数组划分为两个子数组，然后递归地调用自身为每一个子数组进行快速排序来实现的，即算法分为三步：</p>
<ul>
<li>1 把数组或者子数组划分为左边（较小的关键字）的一组和右边（较大的关键字）的一组；</li>
<li>2 调用自身对左边的一组进行排序；</li>
<li>3 调用自身对右边的一组进行排序。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] a) &#123;</span><br><span class="line">    recQuickSort(a,0, a.length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void recQuickSort(int[] a, int left, int right) &#123;</span><br><span class="line">    if(right-left &lt;&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        int pivot &#x3D; a[right]; &#x2F;&#x2F;保存最右边的值，以这个值作为划分点</span><br><span class="line">        int partition &#x3D; partitionIt(a,left, right, pivot);&#x2F;&#x2F;将数组划分两部分，并将划分点的值放在正确位置，并返回该位置</span><br><span class="line">        recQuickSort(a, left, partition-1);&#x2F;&#x2F;调用自身对左边进行排序</span><br><span class="line">        recQuickSort(a, partition+1, right);&#x2F;&#x2F;调用自身对右边进行排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int partitionIt(int[] a, int left, int right, int pivot) &#123;</span><br><span class="line">    int leftPtr &#x3D; left - 1;</span><br><span class="line">    int rightPtr &#x3D; right;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        while(a[++leftPtr] &lt; pivot)&#123;&#125; &#x2F;&#x2F;往上找</span><br><span class="line">        while(rightPtr &gt; 0 &amp;&amp; a[--rightPtr] &gt; pivot)&#123;&#125; &#x2F;&#x2F;往下找</span><br><span class="line">        if(leftPtr &gt;&#x3D; rightPtr) break;</span><br><span class="line">        else swap(leftPtr, rightPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(leftPtr, right);&#x2F;&#x2F;将划分放在正确的位置</span><br><span class="line">    return leftPtr;&#x2F;&#x2F;返回划分点，用于再次小范围划分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<a href="https://www.cnblogs.com/l199616j/p/10597245.html" target="_blank" rel="noopener">八大排序算法——快速排序</a></p>
<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h4><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"> private int[] array;</span><br><span class="line"> private int currentIndex;</span><br><span class="line"> private int maxSize;</span><br><span class="line"> public HeapSort(int size) &#123;</span><br><span class="line">   maxSize &#x3D; size;</span><br><span class="line">   array &#x3D; new int[maxSize];</span><br><span class="line">   currentIndex &#x3D; 0;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;插入数据项，并排好序</span><br><span class="line"> public void insertSort(int[] source) &#123;</span><br><span class="line">   for(int i &#x3D; 0; i &lt; source.length; i++) &#123;</span><br><span class="line">     array[currentIndex] &#x3D; source[i]; &#x2F;&#x2F;插入到节点尾</span><br><span class="line">     tickedUp(currentIndex++); &#x2F;&#x2F;向上重新排好序，使得满足堆的条件</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> private void tickedUp(int index) &#123;</span><br><span class="line">   int parentIndex &#x3D; (index - 1) &#x2F; 2; &#x2F;&#x2F;父节点的索引</span><br><span class="line">   int temp &#x3D; array[index]; &#x2F;&#x2F;将新加的尾节点存在temp中</span><br><span class="line">   while(index &gt; 0 &amp;&amp; array[parentIndex] &lt; temp) &#123;</span><br><span class="line">     array[index] &#x3D; array[parentIndex];</span><br><span class="line">     index &#x3D; parentIndex;</span><br><span class="line">     parentIndex &#x3D; (index - 1) &#x2F; 2;</span><br><span class="line">   &#125;</span><br><span class="line">   array[index] &#x3D; temp;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;取出最大值</span><br><span class="line"> public int getMax() &#123;</span><br><span class="line">   int maxNum &#x3D; array[0];</span><br><span class="line">   array[0] &#x3D; array[--currentIndex];</span><br><span class="line">   trickleDown(0);</span><br><span class="line">   return maxNum;</span><br><span class="line"> &#125;</span><br><span class="line"> private void trickleDown(int index) &#123;</span><br><span class="line">   int top &#x3D; array[index];</span><br><span class="line">   int largeChildIndex;</span><br><span class="line">   while(index &lt; currentIndex&#x2F;2) &#123; &#x2F;&#x2F;while node has at least one child</span><br><span class="line">     int leftChildIndex &#x3D; 2 * index + 1;</span><br><span class="line">     int rightChildIndex &#x3D; leftChildIndex + 1;</span><br><span class="line">     &#x2F;&#x2F;find larger child</span><br><span class="line">     if(rightChildIndex &lt; currentIndex &amp;&amp;  &#x2F;&#x2F;rightChild exists?</span><br><span class="line">         array[leftChildIndex] &lt; array[rightChildIndex]) &#123;</span><br><span class="line">       largeChildIndex &#x3D; rightChildIndex;</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">       largeChildIndex &#x3D; leftChildIndex;</span><br><span class="line">     &#125;</span><br><span class="line">     if(top &gt;&#x3D; array[largeChildIndex]) &#123;</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     array[index] &#x3D; array[largeChildIndex];</span><br><span class="line">     index &#x3D; largeChildIndex;</span><br><span class="line">   &#125;</span><br><span class="line">   array[index] &#x3D; top;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h4><p>归并排序的思想是把一个数组分成两半，排序每一半。然后用 merge 方法将数组的两半归并成一个有序的数组。被分的每一半使用递归，再次划分排序，直到得到的子数组只含有一个数据项为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void mergeSort(int[] source) &#123;</span><br><span class="line">    int[] workSpace &#x3D; new int[source.length];</span><br><span class="line">    recMergeSort(source,workSpace, 0, source.length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void recMergeSort(int[] source, int[] workSpace, int lowerBound, int upperBound) &#123;</span><br><span class="line">    if(lowerBound &#x3D;&#x3D; upperBound) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        int mid &#x3D; (lowerBound + upperBound) &#x2F; 2;</span><br><span class="line">        recMergeSort(source, workSpace, lowerBound, mid); &#x2F;&#x2F;左边排</span><br><span class="line">        recMergeSort(source, workSpace, mid+1, upperBound); &#x2F;&#x2F;右边排</span><br><span class="line">        merge(source, workSpace, lowerBound, mid+1, upperBound);&#x2F;&#x2F;归并</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void merge(int[] a, int[] workSpace, int lowPtr, int highPtr, int upperBound) &#123;</span><br><span class="line">    int j &#x3D; 0;</span><br><span class="line">    int lowerBound &#x3D; lowPtr;</span><br><span class="line">    int mid &#x3D; highPtr - 1;</span><br><span class="line">    int n &#x3D; upperBound - lowerBound + 1;</span><br><span class="line">    while(lowPtr &lt;&#x3D; mid &amp;&amp; highPtr &lt;&#x3D; upperBound) &#123;</span><br><span class="line">        if(a[lowPtr] &lt; a[highPtr]) &#123;</span><br><span class="line">            workSpace[j++] &#x3D; a[lowPtr++];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            workSpace[j++] &#x3D; a[highPtr++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(lowPtr &lt;&#x3D; mid) &#123;</span><br><span class="line">        workSpace[j++] &#x3D; a[lowPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(highPtr &lt;&#x3D; upperBound) &#123;</span><br><span class="line">        workSpace[j++] &#x3D; a[highPtr++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">        a[lowerBound + j] &#x3D; workSpace[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-二叉排序树"><a href="#8-二叉排序树" class="headerlink" title="8. 二叉排序树"></a>8. 二叉排序树</h4><p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），也称二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>（1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</li>
<li>（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>（3）左、右子树也分别为二叉排序树；<br>二叉排序树删除：<br>二叉排序树的删除分为三种情况讨论：</li>
<li>①当删除结点仅有左子树时，只需将此结点的左孩子替换它自己，就相当于删除了该结点。</li>
<li>②当删除结点仅有右子树时，只需将此结点的右孩子替换它自己即可。</li>
<li>③当删除结点左右子树都不为空时，可以在左子树中找到小于但最接近该值的结点替换它，即找到中序遍历中的前驱；也可以在右子树中找到大于但最接近该值的结点替换，即中序遍历中的后驱。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">class BinarySortTree &#123;</span><br><span class="line">    public BiTNode root;</span><br><span class="line"></span><br><span class="line">    public BinarySortTree() &#123;</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 中序遍历</span><br><span class="line">    public void InOrderTraverse(BiTNode node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        InOrderTraverse(node.getLchild());</span><br><span class="line">        System.out.print(node.getData() + &quot; &quot;);</span><br><span class="line">        InOrderTraverse(node.getRchild());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 二叉排序树查找</span><br><span class="line">    public BiTNode search_BST(int key) &#123;</span><br><span class="line">        BiTNode current &#x3D; root;</span><br><span class="line">        while (current !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 查找成功返回对应结点</span><br><span class="line">            if (key &#x3D;&#x3D; current.getData()) &#123;</span><br><span class="line">                return current;</span><br><span class="line">            &#125; else if (key &lt; current.getData()) &#123;</span><br><span class="line">                current &#x3D; current.getLchild();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                current &#x3D; current.getRchild();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 二叉排序树插入</span><br><span class="line">    public void insert_BST(int key) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空树情况</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root &#x3D; new BiTNode(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 结点已在树中存在时</span><br><span class="line">        if (search_BST(key) !&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        BiTNode node &#x3D; new BiTNode(key);</span><br><span class="line">        BiTNode current &#x3D; root;</span><br><span class="line">        BiTNode parent &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 循环获取待插入结点的父结点位置</span><br><span class="line">        while (current !&#x3D; null) &#123;</span><br><span class="line">            parent &#x3D; current;</span><br><span class="line">            if (key &lt; current.getData()) &#123;</span><br><span class="line">                current &#x3D; current.getLchild();</span><br><span class="line">            &#125; else if (key &gt; current.getData()) &#123;</span><br><span class="line">                current &#x3D; current.getRchild();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判断插入的是左结点还是右结点</span><br><span class="line">        if (key &lt; parent.getData()) &#123;</span><br><span class="line">            parent.setLchild(node);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.setRchild(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 二叉排序树删除</span><br><span class="line">    public boolean delete_BST(int key) &#123;</span><br><span class="line">        &#x2F;&#x2F; current结点指向待删除的结点</span><br><span class="line">        BiTNode current &#x3D; root;</span><br><span class="line">        &#x2F;&#x2F; parent结点指向待删除结点的父节点</span><br><span class="line">        BiTNode parent &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 通过循环查找确定current和parent结点</span><br><span class="line">        while (current !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 待删除的结点的值小于根结点的值，查找左子树</span><br><span class="line">            if (key &lt; current.getData()) &#123;</span><br><span class="line">                parent &#x3D; current;</span><br><span class="line">                current &#x3D; current.getLchild();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 待删除的结点的值小于根结点的值，查找右子树</span><br><span class="line">            else if (key &gt; current.getData()) &#123;</span><br><span class="line">                parent &#x3D; current;</span><br><span class="line">                current &#x3D; current.getRchild();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 查找到结点后退出</span><br><span class="line">            else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 空树的情况</span><br><span class="line">        if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 右子树为空的情况</span><br><span class="line">        &#x2F;&#x2F; 待删除结点的左结点&quot;继承&quot;该结点的位置</span><br><span class="line">        if (current.getRchild() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不是空树的情况</span><br><span class="line">            if (parent !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 待删除的结点是父节点的左结点</span><br><span class="line">                if (parent.getLchild() &#x3D;&#x3D; current) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 将待删除结点的左结点设置为父结点的左结点</span><br><span class="line">                    parent.setLchild(current.getLchild());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 待删除的结点是父结点的右结点时将该结点的左结点设置为父结点的右结点</span><br><span class="line">                    parent.setRchild(current.getLchild());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 空树时将左结点赋值给根结点</span><br><span class="line">                root &#x3D; current.getLchild();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 左子树为空的情况</span><br><span class="line">        &#x2F;&#x2F; 待删除结点的右结点&quot;继承&quot;该结点的位置</span><br><span class="line">        else if (current.getLchild() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (parent !&#x3D; null) &#123;</span><br><span class="line">                if (parent.getLchild() &#x3D;&#x3D; current) &#123;</span><br><span class="line">                    parent.setLchild(current.getLchild());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    parent.setRchild(current.getRchild());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                root &#x3D; current.getRchild();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 左右子树均不为空的情况</span><br><span class="line">        &#x2F;&#x2F; 在二叉排序树中序中选择该结点的前驱或者后继替换该结点，</span><br><span class="line">        &#x2F;&#x2F; 也就是选择比该结点小或者比它大的最接近的两个数中的一个，本例选择的是比该结点小的结点</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 用于替换的结点</span><br><span class="line">            BiTNode replaceNode &#x3D; current.getLchild();</span><br><span class="line">            &#x2F;&#x2F; 替换结点的父节点,初始化为待删除的结点</span><br><span class="line">            BiTNode replaceParentNode &#x3D; current;</span><br><span class="line">            &#x2F;&#x2F; 用于替换的结点存在右子结点时，因为右结点大于根结点的值，所以右子结点更接近被删除的结点</span><br><span class="line">            while (replaceNode.getRchild() !&#x3D; null) &#123;</span><br><span class="line">                replaceParentNode &#x3D; replaceNode;</span><br><span class="line">                replaceNode &#x3D; replaceNode.getRchild();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 替换结点不存在右子结点时</span><br><span class="line">            &#x2F;&#x2F; 相等时由于使用的是前驱值代替，所以需要补充的是左子结点的值</span><br><span class="line">            if (replaceParentNode &#x3D;&#x3D; current) &#123;</span><br><span class="line">                replaceParentNode.setLchild(replaceNode.getLchild());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; replaceParentNode与current不相等时</span><br><span class="line">            &#x2F;&#x2F; replaceNode肯定是大于replaceParentNode的值的,所以需要补充的是右子结点的值</span><br><span class="line">            else &#123;</span><br><span class="line">                replaceParentNode.setRchild(replaceNode.getLchild());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 替换对应的值</span><br><span class="line">            current.setData(replaceNode.getData());</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/SharePreference%20%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/SharePreference%20%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">SharePreference 深入原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 18:54:58 / 修改时间：18:55:32" itemprop="dateCreated datePublished" datetime="2020-05-31T18:54:58+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>SharePreference 是Android 系统中的持久化存储工具其基于XML文件(/data/data/<package name>/shared_prefs/目录下面)，一次性将数据读取到内存中，适合单个进程、数据量较小的情况。</p>
<h5 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h5><p>使用SharedPreferences的正确姿势<br>1.1 创建SharedPreferences对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences spf &#x3D; context.getSharedPreferences(&quot;xx&quot;,Context.MODE_PRIVATE);</span><br><span class="line">&#x2F;&#x2F; MODE_PRIVATE，则该配置文件只能被自己的应用程序访问</span><br><span class="line">&#x2F;&#x2F; MODE_WORLD_READABLE，则该配置文件除了自己访问外还可以被其它应该程序读取</span><br><span class="line">&#x2F;&#x2F; MODE_WORLD_WRITEABLE，则该配置文件除了自己访问外还可以被其它应该程序读取和写入</span><br><span class="line">&#x2F;&#x2F; MODE_APPEND，检查文件是否存在，存在就往文件追加内容，否则就创建新文件</span><br></pre></td></tr></table></figure>

<p>1.2 获得SharedPreferences.Editor对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor &#x3D; spf.edit();</span><br><span class="line">editor.putString(key, value);</span><br></pre></td></tr></table></figure>
<p>1.3 插入、删除、查找key-value数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">editor.putString(key, value);</span><br><span class="line">editor.remove(key);</span><br><span class="line">editor.get(key,default-value);</span><br><span class="line">Map&lt;String,?&gt; key_Value&#x3D;(Map&lt;String, ?&gt;)spf.getAll(); </span><br><span class="line">&#x2F;&#x2F; 获取所有保存在对应标识下的数据，并以Map形式返回</span><br></pre></td></tr></table></figure>
<p>1.4 保存key-value数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">editor.apply(); &#x2F;&#x2F; 异步</span><br><span class="line">editor.commit();  &#x2F;&#x2F; 同步</span><br></pre></td></tr></table></figure>

<h4 id="三、原理解析"><a href="#三、原理解析" class="headerlink" title="三、原理解析"></a>三、原理解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *xml对应的SharePreferences是否已经被创建加载，如果没有那么该创建就创建，</span><br><span class="line"> *该加载就加载，在加载之后，要将所有的key-value保存到内幕才能中去</span><br><span class="line"> *&#x2F;</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        if (sSharedPrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sSharedPrefs &#x3D; new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String packageName &#x3D; getPackageName();</span><br><span class="line">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs &#x3D; sSharedPrefs.get(packageName);</span><br><span class="line">        if (packagePrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">            packagePrefs &#x3D; new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</span><br><span class="line">            sSharedPrefs.put(packageName, packagePrefs);</span><br><span class="line">        &#125;</span><br><span class="line">        sp &#x3D; packagePrefs.get(name);</span><br><span class="line">        if (sp &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 读取XML文件</span><br><span class="line">            File prefsFile &#x3D; getSharedPrefsFile(name);</span><br><span class="line">            sp &#x3D; new SharedPreferencesImpl(prefsFile, mode);</span><br><span class="line">            &#x2F;&#x2F; 缓存sp对象</span><br><span class="line">            packagePrefs.put(name, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;跨进程同步问题,不推荐使用</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) !&#x3D; 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; </span><br><span class="line">                              android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        &#x2F;&#x2F; If somebody else (some other process) changed the prefs</span><br><span class="line">        &#x2F;&#x2F; file behind our back, we reload it.  This has been the</span><br><span class="line">        &#x2F;&#x2F; historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SharedPreferencesImpl初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数传入file 、mode</span><br><span class="line"> SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile &#x3D; file;</span><br><span class="line">    mBackupFile &#x3D; makeBackupFile(file);</span><br><span class="line">    mMode &#x3D; mode;</span><br><span class="line">    mLoaded &#x3D; false;</span><br><span class="line">    mMap &#x3D; null;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 加载XML文件到内存中</span><br><span class="line">private void loadFromDiskLocked() &#123;</span><br><span class="line">   ...</span><br><span class="line">    Map map &#x3D; null;</span><br><span class="line">    StructStat stat &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stat &#x3D; Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">    &lt;!--读取xml中配置--&gt;</span><br><span class="line">                str &#x3D; new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16*1024);</span><br><span class="line">                map &#x3D; XmlUtils.readMapXml(str);</span><br><span class="line">            &#125;...</span><br><span class="line">    mLoaded &#x3D; true;</span><br><span class="line">    ...</span><br><span class="line">    &lt;!--唤起其他等待线程--&gt;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h5><ul>
<li>SharePreferences是Android基于xml实现的一种数据持久化手段</li>
<li>SharePreferences不支持多进程，不适合大数据量存储。</li>
<li>SharePreferences的commit与apply前者同步方法、后者为异步</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://www.jianshu.com/p/4984f66f9a4b" target="_blank" rel="noopener">1. SharePreference原理及跨进程数据共享的问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
