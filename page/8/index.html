<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">啃碎并发（二）：Java线程的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:37:55" itemprop="dateCreated datePublished" datetime="2020-05-31T22:37:55+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是 线程状态也会多次在运行、阻塞之间切换。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-bf153c2ed5c95f66.png" alt=""></p>
<h6 id="1-新建（New）状态"><a href="#1-新建（New）状态" class="headerlink" title="1 新建（New）状态"></a>1 新建（New）状态</h6><p>当程序使用new关键字创建了一个线程之后，该线程就处于<strong>新建状态</strong>，此时的线程情况如下：</p>
<blockquote>
<p><strong>1.此时JVM为其分配内存，并初始化其成员变量的值；<br>2.此时线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体；</strong></p>
</blockquote>
<h6 id="2-就绪（Runnable）状态"><a href="#2-就绪（Runnable）状态" class="headerlink" title="2 就绪（Runnable）状态"></a>2 就绪（Runnable）状态</h6><p>当线程对象调用了start()方法之后，该线程处于<strong>就绪状态</strong>。此时的线程情况如下：</p>
<blockquote>
<p>1.此时JVM会为其<strong>创建方法调用栈和程序计数器；</strong><br>2.该状态的线程一直处于<strong>线程就绪队列</strong>（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为CPU的调度不一定是按照先进先出的顺序来调度的），线程并没有开始运行；<br>3.此时线程<strong>等待系统为其分配CPU时间片</strong>，并不是说执行了start()方法就立即执行；</p>
</blockquote>
<p>调用start()方法与run()方法，对比如下：</p>
<blockquote>
<p>1.调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理。但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体；<br>2.需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常；</p>
</blockquote>
<p>如何让子线程调用start()方法之后立即执行而非”等待执行”：</p>
<blockquote>
<p>程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行；</p>
</blockquote>
<h6 id="3-运行（Running）状态"><a href="#3-运行（Running）状态" class="headerlink" title="3 运行（Running）状态"></a>3 运行（Running）状态</h6><p>当CPU开始调度处于<strong>就绪状态</strong> 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 运行状态。</p>
<blockquote>
<p><strong>1.如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态；<br>2.如果在一个多处理器的机器上，将会有多个线程并行执行，处于运行状态；<br>3.当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象；</strong></p>
</blockquote>
<p>处于运行状态的线程最为复杂，它 不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。线程状态可能会变为 阻塞状态、就绪状态和死亡状态。比如：</p>
<blockquote>
<p><strong>1.对于采用 抢占式策略 的系统而言，系统会给每个可执行的线程分配一个时间片来处理任务；当该时间片用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。线程就会又 从运行状态变为就绪状态，重新等待系统分配资源；<br>2.对于采用 协作式策略的系统而言，只有当一个线程调用了它的yield()方法后才会放弃所占用的资源—也就是必须由该线程主动放弃所占用的资源，线程就会又 从运行状态变为就绪状态。</strong></p>
</blockquote>
<h5 id="4-阻塞（Blocked）状态"><a href="#4-阻塞（Blocked）状态" class="headerlink" title="4 阻塞（Blocked）状态"></a>4 阻塞（Blocked）状态</h5><p>处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入<strong>阻塞状态</strong>。</p>
<p><strong>当发生如下情况时，线程将会进入阻塞状态：</strong></p>
<blockquote>
<p><strong>1.线程调用sleep()方法，主动放弃所占用的处理器资源，暂时进入中断状态（不会释放持有的对象锁），时间到后等待系统分配CPU继续执行；<br>2.线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；<br>3.线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有;<br>4.程序调用了线程的suspend方法将线程挂起；<br>5.线程调用wait，等待notify/notifyAll唤醒时(会释放持有的对象锁)；</strong></p>
</blockquote>
<p>阻塞状态分类：</p>
<blockquote>
<p><strong>1.等待阻塞：运行状态中的 线程执行wait()方法，使本线程进入到等待阻塞状态；<br>同步阻塞：线程在 获取synchronized同步锁失败（因为锁被其它线程占用），它会进入到同步阻塞状态；<br>其他阻塞：通过调用线程的 sleep()或join()或发出I/O请求 时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕 时，线程重新转入就绪状态；<br>在阻塞状态的线程只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。</strong></p>
</blockquote>
<blockquote>
<p>但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。</p>
</blockquote>
<h5 id="4-1-等待（WAITING）状态"><a href="#4-1-等待（WAITING）状态" class="headerlink" title="4.1 等待（WAITING）状态"></a>4.1 等待（WAITING）状态</h5><p>线程处于 无限制等待状态，等待一个特殊的事件来重新唤醒，如：</p>
<blockquote>
<p><strong>1.通过wait()方法进行等待的线程等待一个notify()或者notifyAll()方法；<br>2.通过join()方法进行等待的线程等待目标线程运行结束而唤醒；<br>以上两种一旦通过相关事件唤醒线程，线程就进入了 就绪（RUNNABLE）状态 继续运行。</strong></p>
</blockquote>
<h5 id="4-2-时限等待（TIMED-WAITING）状态"><a href="#4-2-时限等待（TIMED-WAITING）状态" class="headerlink" title="4.2 时限等待（TIMED_WAITING）状态"></a>4.2 时限等待（TIMED_WAITING）状态</h5><p>线程进入了一个 时限等待状态，如：</p>
<blockquote>
<p>sleep(3000)，等待3秒后线程重新进行 就绪（RUNNABLE）状态 继续运行。</p>
</blockquote>
<h5 id="5-死亡（Dead）状态"><a href="#5-死亡（Dead）状态" class="headerlink" title="5 死亡（Dead）状态"></a>5 死亡（Dead）状态</h5><p>线程会以如下3种方式结束，结束后就处于 死亡状态：</p>
<blockquote>
<p><strong>1.run()或call()方法执行完成，线程正常结束；<br>2.线程抛出一个未捕获的Exception或Error；<br>3.直接调用该线程stop()方法来结束该线程—该方法容易导致死锁，通常不推荐使用；</strong></p>
</blockquote>
<p>处于死亡状态的线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。**</p>
<p>所以，需要注意的是：</p>
<blockquote>
<p>一旦线程通过start()方法启动后就再也不能回到新建（NEW）状态，线程终止后也不能再回到就绪（RUNNABLE）状态。</p>
</blockquote>
<h5 id="5-1-终止（TERMINATED）状态"><a href="#5-1-终止（TERMINATED）状态" class="headerlink" title="5.1 终止（TERMINATED）状态"></a>5.1 终止（TERMINATED）状态</h5><p>线程执行完毕后，进入终止（TERMINATED）状态。</p>
<h5 id="6-线程相关方法"><a href="#6-线程相关方法" class="headerlink" title="6 线程相关方法"></a>6 线程相关方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Thread&#123;</span><br><span class="line">    &#x2F;&#x2F; 线程的启动</span><br><span class="line">    public void start(); </span><br><span class="line">    &#x2F;&#x2F; 线程体</span><br><span class="line">    public void run(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void stop(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void resume(); </span><br><span class="line">    &#x2F;&#x2F; 已废弃</span><br><span class="line">    public void suspend(); </span><br><span class="line">    &#x2F;&#x2F; 在指定的毫秒数内让当前正在执行的线程休眠</span><br><span class="line">    public static void sleep(long millis); </span><br><span class="line">    &#x2F;&#x2F; 同上，增加了纳秒参数</span><br><span class="line">    public static void sleep(long millis, int nanos); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否处于活动状态</span><br><span class="line">    public boolean isAlive(); </span><br><span class="line">    &#x2F;&#x2F; 中断线程</span><br><span class="line">    public void interrupt(); </span><br><span class="line">    &#x2F;&#x2F; 测试线程是否已经中断</span><br><span class="line">    public boolean isInterrupted(); </span><br><span class="line">    &#x2F;&#x2F; 测试当前线程是否已经中断</span><br><span class="line">    public static boolean interrupted(); </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止</span><br><span class="line">    public void join() throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒</span><br><span class="line">    public void join(long millis) throws InterruptedException; </span><br><span class="line">    &#x2F;&#x2F; 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒</span><br><span class="line">    public void join(long millis, int nanos) throws InterruptedException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/2062729-3220c4bc58f5448b.png" alt=""></p>
<h5 id="6-1-线程就绪、运行和死亡状态转换"><a href="#6-1-线程就绪、运行和死亡状态转换" class="headerlink" title="6.1 线程就绪、运行和死亡状态转换"></a>6.1 线程就绪、运行和死亡状态转换</h5><p>1.就绪状态转换为运行状态：此线程得到CPU资源；<br>2.运行状态转换为就绪状态：此线程主动调用yield()方法或在运行过程中失去CPU资源。<br>3.运行状态转换为死亡状态：此线程执行执行完毕或者发生了异常；</p>
<p><strong>注意：</strong></p>
<blockquote>
<p><strong>当调用线程中的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的那个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</strong></p>
</blockquote>
<h5 id="6-2-run-amp-start"><a href="#6-2-run-amp-start" class="headerlink" title="6.2 run &amp; start"></a>6.2 run &amp; start</h5><p>通过调用start启动线程，线程执行时会执行run方法中的代码。</p>
<blockquote>
<p><strong>1.start()：线程的启动；<br>2.run()：线程的执行体；</strong></p>
</blockquote>
<h6 id="6-3-sleep-amp-yield"><a href="#6-3-sleep-amp-yield" class="headerlink" title="6.3 sleep &amp; yield"></a>6.3 sleep &amp; yield</h6><p>sleep()：通过sleep(millis)使线程进入休眠一段时间，该方法在指定的时间内无法被唤醒，同时也不会释放对象锁；</p>
<p><strong>比如，我们想要使主线程每休眠100毫秒，然后再打印出数字：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 可以明显看到打印的数字在时间上有些许的间隔</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">            Thread.sleep(100);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意如下几点问题：</strong></p>
<p><strong>sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效。</strong>看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName());  </span><br><span class="line">        MyThread myThread&#x3D;new MyThread();  </span><br><span class="line">        myThread.start();  </span><br><span class="line">        &#x2F;&#x2F; 这里sleep的就是main线程，而非myThread线程 </span><br><span class="line">        myThread.sleep(1000); </span><br><span class="line">        Thread.sleep(10);  </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;  </span><br><span class="line">            System.out.println(&quot;main&quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。但是不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。因为使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">        new MyThread().start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName()+&quot;线程&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(50);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看某一次的运行结果：可以发现，线程0首先执行，然后线程1执行一次，又了执行一次。发现并不是按照sleep的顺序执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0线程0次执行！  </span><br><span class="line">Thread-1线程0次执行！  </span><br><span class="line">Thread-1线程1次执行！  </span><br><span class="line">Thread-0线程1次执行！  </span><br><span class="line">Thread-0线程2次执行！  </span><br><span class="line">Thread-1线程2次执行！</span><br></pre></td></tr></table></figure>

<p><strong>yield()</strong>：与sleep类似，也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。</p>
<blockquote>
<p><strong>实际上，当某个线程调用了yield()方法暂停之后，优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程更有可能获得执行的机会，当然，只是有可能，因为我们不可能精确的干涉cpu调度线程。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">        new MyThread(&quot;中级&quot;, 5).start();  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name, int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F; 设置线程的名称  </span><br><span class="line">        this.setPriority(pro);&#x2F;&#x2F; 设置优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">            if (i % 5 &#x3D;&#x3D; 0)  </span><br><span class="line">                Thread.yield();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于sleep()方法和yield()方的区别如下：</strong></p>
<blockquote>
<p><strong>sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态；<br>sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常；<br>sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行；</strong></p>
</blockquote>
<h5 id="6-4-join"><a href="#6-4-join" class="headerlink" title="6.4 join"></a>6.4 join</h5><p>线程的合并的含义就是 将几个并行线程的线程合并为一个单线程执行，应用场景是 当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，注意，它不是静态方法。</p>
<p>join有3个重载的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void join()</span><br><span class="line">当前线程等该加入该线程后面，等待该线程终止。    </span><br><span class="line">void join(long millis)    </span><br><span class="line">当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度   </span><br><span class="line">void join(long millis,int nanos)    </span><br><span class="line">等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span><br></pre></td></tr></table></figure>

<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 在主线程中调用thread.join(); 就是将主线程加入到thread子线程后面等待执行。不过有时间限制，为1毫秒。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread t&#x3D;new MyThread();  </span><br><span class="line">        t.start();  </span><br><span class="line">        t.join(1);&#x2F;&#x2F;将主线程加入到子线程后面，不过如果子线程在1毫秒时间内没执行完，则主线程便不再等待它执行完，进入就绪状态，等待cpu调度  </span><br><span class="line">        for(int i&#x3D;0;i&lt;30;i++)&#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在JDK中join方法的源码，如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)    throws InterruptedException &#123;  </span><br><span class="line">    long base &#x3D; System.currentTimeMillis();  </span><br><span class="line">    long now &#x3D; 0;  </span><br><span class="line">  </span><br><span class="line">    if (millis &lt; 0) &#123;  </span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">          </span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">           wait(0);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        while (isAlive()) &#123;  </span><br><span class="line">            long delay &#x3D; millis - now;  </span><br><span class="line">            if (delay &lt;&#x3D; 0) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            wait(delay);  </span><br><span class="line">            now &#x3D; System.currentTimeMillis() - base;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>join方法实现是通过调用wait方法实现。当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁)，调用该对象的wait(等待时间)，直到该对象唤醒main线程，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。</strong></p>
</blockquote>
<h5 id="6-5-suspend-amp-resume-已过时"><a href="#6-5-suspend-amp-resume-已过时" class="headerlink" title="6.5 suspend &amp; resume (已过时)"></a>6.5 suspend &amp; resume (已过时)</h5><p>suspend-线程进入阻塞状态，但不会释放锁。此方法已不推荐使用，因为同步时不会释放锁，会造成死锁的问题。</p>
<p>resume-使线程重新进入可执行状态。</p>
<p>为什么<strong>Thread.suspend **和</strong>Thread.resume**被废弃了？</p>
<blockquote>
<p><strong>Thread.suspend 天生容易引起死锁。如果目标线程挂起时在保护系统关键资源的监视器上持有锁，那么其他线程在目标线程恢复之前都无法访问这个资源。如果要恢复目标线程的线程在调用 resume 之前试图锁定这个监视器，死锁就发生了。这种死锁一般自身表现为“冻结（ frozen ）”进程。</strong></p>
</blockquote>
<h5 id="6-6-stop（已过时）"><a href="#6-6-stop（已过时）" class="headerlink" title="6.6 stop（已过时）"></a>6.6 stop（已过时）</h5><p>不推荐使用，且以后可能去除，因为它不安全。为什么 Thread.stop 被废弃了？</p>
<p>因为其天生是不安全的。停止一个线程会导致其解锁其上被锁定的所有监视器（监视器以在栈顶产生ThreadDeath异常的方式被解锁）。如果之前被这些监视器保护的任何对象处于不一致状态，其它线程看到的这些对象就会处于不一致状态。这种对象被称为受损的 （damaged）。当线程在受损的对象上进行操作时，会导致任意行为。这种行为可能微妙且难以检测，也可能会比较明显。</p>
<p>不像其他未受检的（unchecked）异常， ThreadDeath 悄无声息的杀死及其他线程。因此，用户得不到程序可能会崩溃的警告。崩溃会在真正破坏发生后的任意时刻显现，甚至在数小时或数天之后。</p>
<h5 id="6-7-wait-amp-notify-notifyAll"><a href="#6-7-wait-amp-notify-notifyAll" class="headerlink" title="6.7 wait &amp; notify/notifyAll"></a>6.7 wait &amp; notify/notifyAll</h5><p>*<em>wait &amp; notify/notifyAll *</em>这三个都是Object类的方法。使用 wait ，notify 和 notifyAll 前提是先获得调用对象的锁。</p>
<blockquote>
<p><strong>1.调用 wait 方法后，释放持有的对象锁，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列；<br>2.调用notify 或者 notifyAll 方法后，等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回；<br>3.notify 方法：将等待队列的一个等待线程从等待队列种移到同步队列中 ，而 notifyAll 方法：将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked。</strong></p>
</blockquote>
<p>前面一直提到两个概念，等待队列（等待池），同步队列（锁池），这两者是不一样的。具体如下：</p>
<blockquote>
<p><strong>1. 同步队列（锁池）：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked。<br>2.等待队列（等待池）：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么 仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）。</strong></p>
</blockquote>
<p><strong>被notify或notifyAll唤起的线程是有规律的，具体如下：</strong></p>
<blockquote>
<p><strong>1.如果是通过notify来唤起的线程，那 先进入wait的线程会先被唤起来；<br>2. 如果是通过nootifyAll唤起的线程，默认情况是 最后进入的会先被唤起来，即LIFO的策略；</strong></p>
</blockquote>
<h5 id="6-8-线程优先级"><a href="#6-8-线程优先级" class="headerlink" title="6.8 线程优先级"></a>6.8 线程优先级</h5><p>每个线程执行时都有一个优先级的属性，优先级高的线程可以获得较多的执行机会，而优先级低的线程则获得较少的执行机会。与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的也并非没机会执行。</p>
<blockquote>
<p>每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级；</p>
</blockquote>
<p>Thread类提供了setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级，其中setPriority方法的参数是一个整数，范围是1~10之间，也可以使用Thread类提供的三个静态常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY   &#x3D;10</span><br><span class="line">MIN_PRIORITY   &#x3D;1</span><br><span class="line">NORM_PRIORITY   &#x3D;5</span><br></pre></td></tr></table></figure>
<p>例子代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        new MyThread(&quot;高级&quot;, 10).start();  </span><br><span class="line">        new MyThread(&quot;低级&quot;, 1).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    public MyThread(String name,int pro) &#123;  </span><br><span class="line">        super(name);&#x2F;&#x2F;设置线程的名称  </span><br><span class="line">        setPriority(pro);&#x2F;&#x2F;设置线程的优先级  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">            System.out.println(this.getName() + &quot;线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从执行结果可以看到 ，一般情况下，高级线程更显执行完毕。</p>
<p><strong>注意一点：</strong></p>
<blockquote>
<p>虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>
<h5 id="6-9-守护线程"><a href="#6-9-守护线程" class="headerlink" title="6.9 守护线程"></a>6.9 守护线程</h5><p>守护线程与普通线程写法上基本没啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。</p>
<p>守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</p>
<p>setDaemon方法详细说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。</span><br><span class="line"></span><br><span class="line">该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">on - 如果为 true，则将该线程标记为守护线程。</span><br><span class="line">抛出：</span><br><span class="line">IllegalThreadStateException - 如果该线程处于活动状态。</span><br><span class="line">SecurityException - 如果当前线程无法修改该线程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">* Java线程：线程的调度-守护线程 </span><br><span class="line">*&#x2F;  </span><br><span class="line">public class Test &#123;  </span><br><span class="line">        public static void main(String[] args) &#123;  </span><br><span class="line">                Thread t1 &#x3D; new MyCommon();  </span><br><span class="line">                Thread t2 &#x3D; new Thread(new MyDaemon());  </span><br><span class="line">                t2.setDaemon(true);        &#x2F;&#x2F;设置为守护线程  </span><br><span class="line">  </span><br><span class="line">                t2.start();  </span><br><span class="line">                t1.start();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyCommon extends Thread &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (int i &#x3D; 0; i &lt; 5; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;线程1第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyDaemon implements Runnable &#123;  </span><br><span class="line">        public void run() &#123;  </span><br><span class="line">                for (long i &#x3D; 0; i &lt; 9999999L; i++) &#123;  </span><br><span class="line">                        System.out.println(&quot;后台线程第&quot; + i + &quot;次执行！&quot;);  </span><br><span class="line">                        try &#123;  </span><br><span class="line">                                Thread.sleep(7);  </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                                e.printStackTrace();  </span><br><span class="line">                        &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">后台线程第0次执行！  </span><br><span class="line">线程1第0次执行！  </span><br><span class="line">线程1第1次执行！  </span><br><span class="line">后台线程第1次执行！  </span><br><span class="line">后台线程第2次执行！  </span><br><span class="line">线程1第2次执行！  </span><br><span class="line">线程1第3次执行！  </span><br><span class="line">后台线程第3次执行！  </span><br><span class="line">线程1第4次执行！  </span><br><span class="line">后台线程第4次执行！  </span><br><span class="line">后台线程第5次执行！  </span><br><span class="line">后台线程第6次执行！  </span><br><span class="line">后台线程第7次执行！</span><br></pre></td></tr></table></figure>
<p>从上面的执行结果可以看出：前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。</p>
<blockquote>
<p>实际上：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。</p>
</blockquote>
<h5 id="6-10-如何结束一个线程"><a href="#6-10-如何结束一个线程" class="headerlink" title="6.10 如何结束一个线程"></a>6.10 如何结束一个线程</h5><p>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit 这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。</p>
<blockquote>
<p>1.正常执行完run方法，然后结束掉；<br>2.控制循环条件和判断条件的标识符来结束掉线程；</p>
</blockquote>
<p>比如run方法这样写：只要保证在一定的情况下，run方法能够执行完毕即可。而不是while(true)的无限循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                break;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    boolean next&#x3D;true;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (next) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                next&#x3D;false;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">或者</span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            if(i&#x3D;&#x3D;10)  </span><br><span class="line">                return;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>诚然，使用上面方法的标识符来结束一个线程，是一个不错的方法，但其也有弊端，如果 该线程是处于sleep、wait、join的状态时候，while循环就不会执行，那么我们的标识符就无用武之地了，当然也不能再通过它来结束处于这3种状态的线程了。</p>
<p>所以，此时可以使用interrupt这个巧妙的方式结束掉这个线程。我们先来看看sleep、wait、join方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException </span><br><span class="line">public static native void sleep(long millis) throws InterruptedException</span><br><span class="line">public final void join() throws InterruptedException</span><br></pre></td></tr></table></figure>
<p>可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。在什么时候会产生这样一个异常呢？</p>
<blockquote>
<p>每个Thread都有一个中断状状态，默认为false。可以通过Thread对象的isInterrupted()方法来判断该线程的中断状态。可以通过Thread对象的interrupt()方法将中断状态设置为true。</p>
<p>当一个线程处于sleep、wait、join这三种状态之一的时候，如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常，并将中断状态重新设置为false。</p>
</blockquote>
<p>看下面的简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;1;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            System.out.println(this.isInterrupted());  </span><br><span class="line">            try &#123;  </span><br><span class="line">                System.out.println(&quot;我马上去sleep了&quot;);  </span><br><span class="line">                Thread.sleep(2000);  </span><br><span class="line">                this.interrupt();  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;异常捕获了&quot;+this.isInterrupted());  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  </span><br><span class="line">false  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">2  </span><br><span class="line">true  </span><br><span class="line">我马上去sleep了  </span><br><span class="line">异常捕获了false</span><br></pre></td></tr></table></figure>

<p>可以看到，首先执行第一次while循环，在第一次循环中，睡眠2秒，然后将中断状态设置为true。当进入到第二次循环的时候，中断状态就是第一次设置的true，当它再次进入sleep的时候，马上就抛出了InterruptedException异常，然后被我们捕获了。然后中断状态又被重新自动设置为false了（从最后一条输出可以看出来）。</p>
<p>所以，我们可以使用interrupt方法结束一个线程。具体使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;  </span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;  </span><br><span class="line">        MyThread thread&#x3D;new MyThread();  </span><br><span class="line">        thread.start();  </span><br><span class="line">        Thread.sleep(3000);  </span><br><span class="line">        thread.interrupt();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class MyThread extends Thread &#123;  </span><br><span class="line">    int i&#x3D;0;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void run() &#123;  </span><br><span class="line">        while (true) &#123;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">            try &#123;  </span><br><span class="line">                Thread.sleep(1000);  </span><br><span class="line">            &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">                System.out.println(&quot;中断异常被捕获了&quot;);  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多测试几次，会发现一般有两种执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  </span><br><span class="line">1  </span><br><span class="line">2  </span><br><span class="line">3  </span><br><span class="line">中断异常被捕获了</span><br></pre></td></tr></table></figure>

<p>这两种结果恰恰说明了，只要一个线程的中断状态一旦为true，只要它进入sleep等状态，或者处于sleep状态，立马回抛出InterruptedException异常。</p>
<blockquote>
<p><strong>第一种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程正处于sleep状态，立马抛出InterruptedException异常。</p>
<p><strong>第二种情况</strong>，是当主线程从3秒睡眠状态醒来之后，调用了子线程的interrupt方法，此时子线程还没有处于sleep状态。然后再第3次while循环的时候，在此进入sleep状态，立马抛出InterruptedException异常。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">啃碎并发（一）：Java线程总述与概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 21:14:46" itemprop="dateCreated datePublished" datetime="2020-05-31T21:14:46+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">JAVA并发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h4><p>在JDK5之前，Java多线程以及其性能一直是个软肋，只有synchronized、Thread.sleep()、Object.wait/notify这样有限的方法，而synchronized的效率还特别地低，开销比较大。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%80%BB%E8%BF%B0%E4%B8%8E%E6%A6%82%E5%BF%B5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">数据结构 -- 查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 19:57:11" itemprop="dateCreated datePublished" datetime="2020-05-31T19:57:11+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><img src="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%9F%A5%E6%89%BE/2062729-6175e9c6b5ecbb36.png" class="" title="[查找算法]">

<h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h4><p>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int SequenceSearch(int a[], int value, int n) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        if(a[i] &#x3D;&#x3D; value) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2. 折半查找"></a>2. 折半查找</h4><p>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int BinarySearch1(int a[], int value, int n) &#123;</span><br><span class="line">    int low, high, mid;</span><br><span class="line">    low &#x3D; 0;</span><br><span class="line">    high &#x3D; n - 1;</span><br><span class="line">    while (low &lt;&#x3D; high) &#123;</span><br><span class="line">        mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">        if (a[mid] &#x3D;&#x3D; value)</span><br><span class="line">            return mid;</span><br><span class="line">        if (a[mid] &gt; value)</span><br><span class="line">            high &#x3D; mid - 1;</span><br><span class="line">        if (a[mid] &lt; value)</span><br><span class="line">            low &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见查找算法题"><a href="#常见查找算法题" class="headerlink" title="常见查找算法题"></a>常见查找算法题</h4><h5 id="1-找出一个无序整型数组中第k大的数"><a href="#1-找出一个无序整型数组中第k大的数" class="headerlink" title="1. 找出一个无序整型数组中第k大的数"></a>1. 找出一个无序整型数组中第k大的数</h5><p>变种： 找出无序数组中第二大的数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">取基准元素，将元素分为两个集合，一个集合元素比基准小，另一个比基准大 ，三种情况。</span><br><span class="line">1.比基准大的元素数目标志位m正好为k-1，基准就是目的元素。</span><br><span class="line">2.比基准大的元素标志位m小于k, 那么就在比基准小的集合里面找第(k-m)大的元素</span><br><span class="line">3.若是比基准大的元素为m大于k，那就继续在该集合里面找第k大的元素。</span><br><span class="line">如下是代码：</span><br><span class="line"></span><br><span class="line">static void findKMax(int[] arr, int left, int right, int k) &#123;</span><br><span class="line">    int temp &#x3D; partition(arr, left, right);</span><br><span class="line">    if (temp &#x3D;&#x3D; k - 1) &#123;</span><br><span class="line">        System.out.println(arr[temp]);</span><br><span class="line">    &#125; else if (temp &gt; k - 1) &#123;</span><br><span class="line">        findKMax(arr, left, temp - 1, k);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        findKMax(arr, temp + 1, right, k - temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">    int temp &#x3D; arr[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (temp &gt;&#x3D; arr[right] &amp;&amp; left &lt; right)</span><br><span class="line">            --right;</span><br><span class="line">           arr[left] &#x3D; arr[right];</span><br><span class="line">        while (temp &lt;&#x3D; arr[left] &amp;&amp; left &lt; right)</span><br><span class="line">            ++left;</span><br><span class="line">        arr[right] &#x3D; arr[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[right] &#x3D; temp;</span><br><span class="line">    return right;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr &#x3D; new int[] &#123; 12, 23, 2, 3, 2, 432, 43, 534, 5, 345, 3453, 53, 43 &#125;;</span><br><span class="line">    findKMax(arr,0,arr.length - 1,2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-无序数组中，和为sum的2个数-用HashMap、不用HashMap"><a href="#2-无序数组中，和为sum的2个数-用HashMap、不用HashMap" class="headerlink" title="2. 无序数组中，和为sum的2个数(用HashMap、不用HashMap)"></a>2. 无序数组中，和为sum的2个数(用HashMap、不用HashMap)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-数组中位数"><a href="#3-数组中位数" class="headerlink" title="3. 数组中位数"></a>3. 数组中位数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E4%B8%B2/" class="post-title-link" itemprop="url">数据结构 -- 串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:36:38 / 修改时间：21:07:48" itemprop="dateCreated datePublished" datetime="2020-05-31T19:36:38+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a>Java String</h4><blockquote>
<p>在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; new String(&quot;abc&quot;) ;</span><br><span class="line">System.out.println(str&#x3D;&#x3D;&quot;abc&quot;);</span><br></pre></td></tr></table></figure>
<p>=左边的是存放在栈中（stack），=右边是存放在堆中（heap）。<br>输出为false!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class String_Demo01 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;        </span><br><span class="line">        String str1 &#x3D; new String() ;</span><br><span class="line">        String str2 &#x3D; null ;</span><br><span class="line">        String str3 &#x3D; &quot;&quot; ;</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str2);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str2));         &#x2F;&#x2F;值的比较，返回false</span><br><span class="line">        System.out.println(str2&#x3D;&#x3D;str3);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str3.equals(str2));         &#x2F;&#x2F;值的比较，返回false</span><br><span class="line">        System.out.println(str1&#x3D;&#x3D;str3);                &#x2F;&#x2F;内存地址的比较，返回false</span><br><span class="line">        System.out.println(str1.equals(str3));         &#x2F;&#x2F;值的比较，返回true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h4><h5 id="1-朴素的模式匹配算法（BF-Brute-Force-算法）"><a href="#1-朴素的模式匹配算法（BF-Brute-Force-算法）" class="headerlink" title="1. 朴素的模式匹配算法（BF(Brute Force)算法）"></a>1. 朴素的模式匹配算法（BF(Brute Force)算法）</h5><p>朴素模式匹配算法的基本思想是穷举法，即就是将目标串S的第一个字符与模式串P的第一个字符进行匹配，若相等，则继续比较S的第二个字符和P的第二个字符；若不相等，则比较S的第二个字符和P的第一个字符，依次比较下去，直到得出最后的匹配结果（如图1所示）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int bf(String T, String P) &#123;</span><br><span class="line">    int i &#x3D; 0; &#x2F;&#x2F;目标串的下标</span><br><span class="line">    int j &#x3D; 0; &#x2F;&#x2F;模式串的下标</span><br><span class="line">    int tLen &#x3D; T.length();</span><br><span class="line">    int pLen &#x3D; P.length();</span><br><span class="line">    if (tLen &lt; pLen) return -1;&#x2F;&#x2F;长度不够直接返回</span><br><span class="line">    while(i &lt; tLen &amp; j &lt; pLen) &#123;&#x2F;&#x2F;逐个匹配</span><br><span class="line">        if(T.charAt(i) &#x3D;&#x3D; P.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i &#x3D; i-j+1;</span><br><span class="line">            j &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j &#x3D;&#x3D; pLen) &#123;</span><br><span class="line">        return i-j+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-KMP模式匹配算法"><a href="#2-KMP模式匹配算法" class="headerlink" title="2. KMP模式匹配算法"></a>2. KMP模式匹配算法</h5><p>首先是next数组的计算，下图是next数组计算公式<br><img src="https://upload-images.jianshu.io/upload_images/12455188-11a97f211ace9892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/573/format/webp" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static int[] getNext(String ps) &#123;</span><br><span class="line">    char[] p &#x3D; ps.toCharArray();</span><br><span class="line">    int[] next &#x3D; new int[p.length];</span><br><span class="line">    next[0] &#x3D; -1;</span><br><span class="line">    int j &#x3D; 0;</span><br><span class="line">    int k &#x3D; -1;</span><br><span class="line">    while (j &lt; p.length - 1) &#123;</span><br><span class="line">       if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123;</span><br><span class="line">           if (p[++j] &#x3D;&#x3D; p[++k]) &#123; &#x2F;&#x2F; 当两个字符相等时要跳过</span><br><span class="line">              next[j] &#x3D; next[k];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">              next[j] &#x3D; k;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           k &#x3D; next[k];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int KMP(String ts, String ps) &#123;</span><br><span class="line">    char[] t &#x3D; ts.toCharArray();</span><br><span class="line">    char[] p &#x3D; ps.toCharArray();</span><br><span class="line">    int i &#x3D; 0; &#x2F;&#x2F; 主串的位置</span><br><span class="line">    int j &#x3D; 0; &#x2F;&#x2F; 模式串的位置</span><br><span class="line">    int[] next &#x3D; getNext(ps);</span><br><span class="line">    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line">       if (j &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; p[j]) &#123; &#x2F;&#x2F; 当j为-1时，要移动的是i，当然j也要归0</span><br><span class="line">           i++;</span><br><span class="line">           j++;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; i不需要回溯了</span><br><span class="line">           &#x2F;&#x2F; i &#x3D; i - j + 1;</span><br><span class="line">           j &#x3D; next[j]; &#x2F;&#x2F; j回到指定位置</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &#x3D;&#x3D; p.length) &#123;</span><br><span class="line">       return i - j;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">数据结构 -- 红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-31 19:36:37 / 修改时间：19:56:56" itemprop="dateCreated datePublished" datetime="2020-05-31T19:36:37+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="R-B-Tree简介"><a href="#R-B-Tree简介" class="headerlink" title="R-B Tree简介"></a>R-B Tree简介</h4><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。</p>
<p>红黑树的特性:</p>
<ul>
<li>（1）每个节点或者是黑色，或者是红色。</li>
<li>（2）根节点是黑色。</li>
<li>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>注意：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p><img src="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" alt=""></p>
<h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p>
<ul>
<li>从根结点开始查找，把根结点设置为当前结点；</li>
<li>若当前结点为空，返回null；</li>
<li>若当前结点不为空，用当前结点的key跟查找key作比较；</li>
<li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li>
<li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li>
<li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2392382-07b47eb3722981e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p>
<h4 id="红黑树的基本操作-一-左旋和右旋"><a href="#红黑树的基本操作-一-左旋和右旋" class="headerlink" title="红黑树的基本操作(一) 左旋和右旋"></a>红黑树的基本操作(一) 左旋和右旋</h4><h5 id="1-左旋"><a href="#1-左旋" class="headerlink" title="1. 左旋"></a>1. 左旋</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251733282013849.jpg" alt="左旋"></p>
<h5 id="2-右旋"><a href="#2-右旋" class="headerlink" title="2. 右旋"></a>2. 右旋</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg" alt="左旋"></p>
<h4 id="红黑树的基本操作-二-添加"><a href="#红黑树的基本操作-二-添加" class="headerlink" title="红黑树的基本操作(二) 添加"></a>红黑树的基本操作(二) 添加</h4><table>
<thead>
<tr>
<th></th>
<th>现象说明</th>
<th align="center">处理策略</th>
</tr>
</thead>
<tbody><tr>
<td>Case 1</td>
<td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td>
<td align="center">(01) 将“父节点”设为黑色。  <br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</td>
</tr>
<tr>
<td>Case 2</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td>
<td align="center">(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</td>
</tr>
<tr>
<td>Case 3</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td>
<td align="center">(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</td>
</tr>
</tbody></table>
<h5 id="Case-1-叔叔是红色"><a href="#Case-1-叔叔是红色" class="headerlink" title="(Case 1) 叔叔是红色"></a>(Case 1) 叔叔是红色</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" alt="(Case 1)叔叔是红色"></p>
<h5 id="Case-2-叔叔是黑色，且当前节点是右孩子"><a href="#Case-2-叔叔是黑色，且当前节点是右孩子" class="headerlink" title="(Case 2)叔叔是黑色，且当前节点是右孩子"></a>(Case 2)叔叔是黑色，且当前节点是右孩子</h5><p><img src="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" alt=""></p>
<h5 id="Case-3-叔叔是黑色，且当前节点是左孩子"><a href="#Case-3-叔叔是黑色，且当前节点是左孩子" class="headerlink" title="(Case 3)叔叔是黑色，且当前节点是左孩子"></a>(Case 3)叔叔是黑色，且当前节点是左孩子</h5><p><img src="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构 -- 排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 19:01:45" itemprop="dateCreated datePublished" datetime="2020-05-31T19:01:45+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h4><img src="/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20--%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2062729-6906429ed882a5b0.png" class="" title="[线程池的主要工作流程]">

<h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h4><p>冒泡排序算法的基本流程是：每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。 （稳定排序算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] num) &#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; num.length - 1; i++)</span><br><span class="line">        for (int j &#x3D; 0; j &lt; num.length - i; j++) &#123;</span><br><span class="line">            if (num[j] &gt; num[j+1]) &#123;</span><br><span class="line">                swap(num, j, j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:最好O(n^2), 最坏O(n^2), 平均时间复杂度O(n^2), 空间复杂度O(1)</p>
<p>有很多人说冒泡排序的最优的时间复杂度为：O(n)；其实这是在代码中使用一个标志位来判断是否已经排序好的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int[] num) &#123;</span><br><span class="line">    int flag &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; num.length - 1; i++, flag &#x3D; 1) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; num.length - i; j++) &#123;</span><br><span class="line">            if (num[j] &gt; num[j+1]) &#123;</span><br><span class="line">                swap(num, j, j+1);</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag) break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h4><p>选择排序是将一轮比较完后，把最小的放到最前的位置（或者把最大的放到最后） （不稳定排序算法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void selectSort(int[] num) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; num.length; i++) &#123;</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; num.length - i; j++) &#123;</span><br><span class="line">                if (num[max] &lt; num[j]) max &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num, max, num.length - i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h4><p>插入排序的实现步骤为：从第一个元素开始，该元素可以认为已经被排序 -&gt; 取出下一个元素，在已经排序的元素序列中从后向前扫描 -&gt; 如果该元素小于前一个元素，则将两者调换，再与前一个元素比较–&gt; 重复第三步，直到找到已排序的元素小于或者等于新元素的位置 -&gt; 将新元素插入到该位置中 -&gt; 重复第二步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] num) &#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; num.length; i++) &#123;</span><br><span class="line">        int j &#x3D; i;</span><br><span class="line">        int temp &#x3D; num[i];</span><br><span class="line">        while(num[j - 1] &gt; temp &amp;&amp; j &gt; 0) j--;</span><br><span class="line">        for (int m &#x3D; i; m &gt; j; m--) &#123;</span><br><span class="line">            num[m] &#x3D; num[m-1];</span><br><span class="line">        &#125;</span><br><span class="line">        num[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h4><p>希尔排序的中心思想是将数据进行分组，然后对每一组数据进行插入排序，在每一组数据都有序后，再对所有的分组利用插入排序进行最后一次排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] num) &#123;</span><br><span class="line">    int h &#x3D; num.length &#x2F; 2;</span><br><span class="line">    while (h &gt;&#x3D; 1) &#123;</span><br><span class="line">        for (int i &#x3D; h; i &lt; num.length; i++) &#123;</span><br><span class="line">            int temp &#x3D; num[i];</span><br><span class="line">            int j &#x3D; i;</span><br><span class="line">            while ((j - h) &gt; 0 &amp;&amp; num[j - h] &gt; temp) &#123;</span><br><span class="line">                num[j] &#x3D; num[j-h];</span><br><span class="line">                j &#x3D; j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            num[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        h &#x3D; h &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-快速排序-（重点）"><a href="#5-快速排序-（重点）" class="headerlink" title="5. 快速排序  （重点）"></a>5. 快速排序  （重点）</h4><p>快速排序本质上通过一个数组划分为两个子数组，然后递归地调用自身为每一个子数组进行快速排序来实现的，即算法分为三步：</p>
<ul>
<li>1 把数组或者子数组划分为左边（较小的关键字）的一组和右边（较大的关键字）的一组；</li>
<li>2 调用自身对左边的一组进行排序；</li>
<li>3 调用自身对右边的一组进行排序。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void quickSort(int[] num, int left, int right) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int position &#x3D; paration(num, left, right);</span><br><span class="line">        System.out.println(&quot;position:&quot; + position);</span><br><span class="line">        quickSort(num, left, position - 1);</span><br><span class="line">        quickSort(num, position + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int paration(int[] num, int left, int right) &#123;</span><br><span class="line">    int temp &#x3D; num[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (num[right] &gt;&#x3D; temp &amp;&amp; right &gt; left) right--;</span><br><span class="line">        num[left] &#x3D; num[right];</span><br><span class="line">        while (num[left] &lt;&#x3D; temp &amp;&amp; left &lt; right) left++;</span><br><span class="line">        num[right] &#x3D; num[left];</span><br><span class="line">    &#125;</span><br><span class="line">    num[left] &#x3D; temp;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<a href="https://www.cnblogs.com/l199616j/p/10597245.html" target="_blank" rel="noopener">八大排序算法——快速排序</a></p>
<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h4><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void heapSort(int[] num) &#123;</span><br><span class="line">    int length &#x3D; num.length;</span><br><span class="line">    for (int i &#x3D; num.length &#x2F; 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        buildHeap(num, i, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; num.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(num, 0, i);</span><br><span class="line">        length--;</span><br><span class="line">        buildHeap(num, 0, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void buildHeap(int[] num, int i, int length) &#123;</span><br><span class="line">    int left &#x3D; 2 * i + 1;</span><br><span class="line">    int right &#x3D; 2 * i + 2;</span><br><span class="line">    int target &#x3D; i;</span><br><span class="line">    if (left &lt; length &amp;&amp; num[left] &gt; num[i]) target &#x3D; left;</span><br><span class="line">    if (right &lt; length &amp;&amp; num[right] &gt; num[target]) target &#x3D; right;</span><br><span class="line">    if (target !&#x3D; i) &#123;</span><br><span class="line">        swap(num, i, target);</span><br><span class="line">        buildHeap(num, target, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void swap(int[] num, int i, int j) &#123;</span><br><span class="line">    int temp &#x3D; num[i];</span><br><span class="line">    num[i] &#x3D; num[j];</span><br><span class="line">    num[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h4><p>归并排序的思想是把一个数组分成两半，排序每一半。然后用 merge 方法将数组的两半归并成一个有序的数组。被分的每一半使用递归，再次划分排序，直到得到的子数组只含有一个数据项为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static void mergeSort(int[] num, int low, int high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        int mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">        mergeSort(num, low, mid);</span><br><span class="line">        mergeSort(num, mid + 1, high);</span><br><span class="line">        merge(num, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void merge(int[] num, int low, int mid, int high) &#123;</span><br><span class="line">    int[] temp &#x3D; new int[num.length];</span><br><span class="line">    int t &#x3D; 0;</span><br><span class="line">    int i &#x3D; low;</span><br><span class="line">    int j &#x3D; mid;</span><br><span class="line">    while (i &lt; mid &amp;&amp; j &lt;&#x3D; high) &#123;</span><br><span class="line">        if (num[i] &lt; num[j]) &#123;</span><br><span class="line">            temp[t++] &#x3D; num[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[t++] &#x3D; num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (i &lt; mid) &#123;</span><br><span class="line">        temp[t++] &#x3D; num[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (j &lt;&#x3D; high) &#123;</span><br><span class="line">        temp[t++] &#x3D; num[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m &#x3D; 0;</span><br><span class="line">    for (t &#x3D; low; t &lt; high; t++) &#123;</span><br><span class="line">        num[t] &#x3D; temp[m++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-二叉排序树"><a href="#8-二叉排序树" class="headerlink" title="8. 二叉排序树"></a>8. 二叉排序树</h4><p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），也称二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>（1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</li>
<li>（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>（3）左、右子树也分别为二叉排序树；<br>二叉排序树删除：<br>二叉排序树的删除分为三种情况讨论：</li>
<li>①当删除结点仅有左子树时，只需将此结点的左孩子替换它自己，就相当于删除了该结点。</li>
<li>②当删除结点仅有右子树时，只需将此结点的右孩子替换它自己即可。</li>
<li>③当删除结点左右子树都不为空时，可以在左子树中找到小于但最接近该值的结点替换它，即找到中序遍历中的前驱；也可以在右子树中找到大于但最接近该值的结点替换，即中序遍历中的后驱。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">public class BiNode &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public BiNode left &#x3D; null;</span><br><span class="line">    public BiNode right &#x3D; null;</span><br><span class="line">    public BiNode(int t) &#123;</span><br><span class="line">        value &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中序遍历</span><br><span class="line">public void InOrderTraverse(BiNode node) &#123;</span><br><span class="line">    if (node &#x3D;&#x3D; null) return;</span><br><span class="line">    InOrderTraverse(node.left);</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    InOrderTraverse(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉排序树查找</span><br><span class="line">public BiNode searchBST(BiNode node, int key) &#123;</span><br><span class="line">    if (node &#x3D;&#x3D; null) return null;</span><br><span class="line">    if (node.value &#x3D;&#x3D; key) return node;</span><br><span class="line">    if (key &lt; node.value) &#123;</span><br><span class="line">        searchBST(node.left, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        searchBST(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉排序树查找</span><br><span class="line">public BiNode searchBST(BiNode node, int key) &#123;</span><br><span class="line">    if (node &#x3D;&#x3D; null) return null;</span><br><span class="line">    BiNode root &#x3D; node;</span><br><span class="line">    while (root !&#x3D; null) &#123;</span><br><span class="line">        if (root.value &#x3D;&#x3D; key) &#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if (key &lt; root.value) root &#x3D; root.left;</span><br><span class="line">        if (key &gt; root.value) root &#x3D; root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉排序树插入</span><br><span class="line">public void insertBST(BiNode root, int key) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">        root &#x3D; new BiNode(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (key &lt; root.value) &#123;</span><br><span class="line">        if (root.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root.left &#x3D; new BiNode(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            insertBST(root.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root.right &#x3D; new BiNode(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            insertBST(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二叉树删除</span><br><span class="line">public BiNode deleteBST(BiNode root, int value) &#123;</span><br><span class="line">    BiNode cur &#x3D; root;        &#x2F;&#x2F;当前结点</span><br><span class="line">    BiNode parent &#x3D; null;     &#x2F;&#x2F;待删结点的父结点</span><br><span class="line">    BiNode delNode &#x3D; null;    &#x2F;&#x2F;在后面用来引用待删结点</span><br><span class="line">    BiNode temp &#x3D; null;       &#x2F;&#x2F;作为一个局域内的根结点</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找待删结点p和待删结点的父结点f</span><br><span class="line">    while (cur !&#x3D; null) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; cur.value) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        parent &#x3D; cur;</span><br><span class="line">        if (value &gt; cur.value) &#123;</span><br><span class="line">            cur &#x3D; cur.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cur &#x3D; cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前结点为null，即没有找到待删结点。  此时cur指向待删结点</span><br><span class="line">    if (cur &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;待删结点只有右子树</span><br><span class="line">    if (cur.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;待删结点的父结点为null，即待删结点为根结点</span><br><span class="line">        if (parent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;根结点为待删结点的右子树</span><br><span class="line">            root &#x3D; cur.right;</span><br><span class="line">        &#125; else if (parent.left &#x3D;&#x3D; cur) &#123;    &#x2F;&#x2F;待删结点为父结点的左子树</span><br><span class="line">            &#x2F;&#x2F;把待删结点的右子树作为待删结点父结点的左子树</span><br><span class="line">            parent.left &#x3D; cur.right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;待删结点为父结点的右子树</span><br><span class="line">            parent.right &#x3D; cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;待删结点有左子树，要找左子树的最右下角的结点</span><br><span class="line">        temp &#x3D; cur;</span><br><span class="line">        delNode &#x3D; cur.left;</span><br><span class="line">        &#x2F;&#x2F;此时s指向待删结点</span><br><span class="line">        while (delNode.right !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;查找待删结点的最右下角结点</span><br><span class="line">            temp &#x3D; delNode;</span><br><span class="line">            delNode &#x3D; delNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp &#x3D;&#x3D; cur) &#123;</span><br><span class="line">            &#x2F;&#x2F;即，待删结点没有右子树，把左子树向上移动</span><br><span class="line">            temp.left &#x3D; delNode.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;即，待删结点有右子树</span><br><span class="line">            temp.right&#x3D; delNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.value &#x3D; delNode.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/%E4%BB%BFButterKnife%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E4%BB%BFButterKnife%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">仿ButterKnife注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 18:53:43" itemprop="dateCreated datePublished" datetime="2020-05-31T18:53:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、Java-注解介绍"><a href="#一、Java-注解介绍" class="headerlink" title="一、Java 注解介绍"></a>一、Java 注解介绍</h4>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/%E4%BB%BFButterKnife%E6%B3%A8%E8%A7%A3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">Java基础之基本知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 14:05:36" itemprop="dateCreated datePublished" datetime="2020-05-31T14:05:36+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java笔记连载"><a href="#Java笔记连载" class="headerlink" title="Java笔记连载"></a>Java笔记连载</h2><hr>
<h4 id="1-HashMap和HashTable的区别"><a href="#1-HashMap和HashTable的区别" class="headerlink" title="1.HashMap和HashTable的区别"></a>1.HashMap和HashTable的区别</h4><ul>
<li><input checked="" disabled="" type="checkbox"> HashMap去掉了contains方法</li>
<li><input checked="" disabled="" type="checkbox"> HashTable是同步的(线程安全)</li>
<li><input checked="" disabled="" type="checkbox"> HashMap允许空键值</li>
<li><input checked="" disabled="" type="checkbox"> HashMap执行快速失败机制</li>
<li><input disabled="" type="checkbox"> <code>Fast-fail</code>机制:在使用迭代器的过程中有其它线程修改了集合对象结构或元素数量,都将抛出ConcurrentModifiedException</li>
</ul>
<h4 id="2-java的线程安全类"><a href="#2-java的线程安全类" class="headerlink" title="2.java的线程安全类"></a>2.java的线程安全类</h4><p>Vector、Stack、HashTable、ConcurrentHashMap、Properties</p>
<h4 id="3-java集合框架"><a href="#3-java集合框架" class="headerlink" title="3.java集合框架"></a>3.java集合框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection - List - ArrayList</span><br><span class="line">Collection - List - LinkedList</span><br><span class="line">Collection - List - Vector</span><br><span class="line">Collection - List - Vector - Stack</span><br><span class="line">Collection - Set - HashSet</span><br><span class="line">Collection - Set - TreeSet</span><br><span class="line">Map - HashMap</span><br><span class="line">Map - TreeMap</span><br><span class="line">Map - HashTable</span><br></pre></td></tr></table></figure>

<p>3.1 <code>ArrayList</code>的构造函数有三个</p>
<ol>
<li>无参构造 容量为10</li>
<li>ArrayList(Collections&lt;?extends E&gt; c)构造包含指定collection的元素的列表</li>
<li>ArrayList(int initialCapacity) 指定初始容量</li>
</ol>
<p>3.2 <code>Iterator</code>支持从源集合安全地删除对象,防止并发修改异常(ConcurrentModifiedException)</p>
<h4 id="4-Java垃圾回收机制"><a href="#4-Java垃圾回收机制" class="headerlink" title="4.Java垃圾回收机制"></a>4.Java垃圾回收机制</h4><p>4.1 调用system.gc() Runtime.getRuntime.gc()</p>
<p>4.2 垃圾回收:释放那些不在持有任何引用的对象的内存</p>
<p>4.3 怎样判断是否需要收集：</p>
<ol>
<li>引用计数法：对象没有任何引用与之关联(无法解决循环引用)</li>
<li>对象引用遍历法：对象引用遍历从一组对象开始,沿着对象图的每条链接,递归确定可以到达的对象,如果某对象不能从这些根对象的一个(至少一个)到达,则将它作为垃圾收集。</li>
</ol>
<p>4.4 垃圾回收方法</p>
<ol>
<li>标记清除法(Mark-Sweeping):易产生内存碎片</li>
<li>复制回收法(Copying)：为了解决Mark-Sweep法而提出,内存空间减至一半</li>
<li>标记压缩法(Mark-Compact):为了解决Copying法的缺陷,标记后移动到一端再清楚</li>
<li>分代回收法(GenerationalCollection):新生代对象存活周期短,需要大量回收对象,需要复制的少,执行copying算法;老年代对象存活周期相对长,回收少量对象,执行mark-compact算法.<br>新生代划分：较大的eden区 和 2个survivor区</li>
</ol>
<p>4.5 内存分配</p>
<ul>
<li>新生代 |Eden Space|From Space|To Space|</li>
<li>对象主要分配在新生代的EdenSpace和FromSpace</li>
<li>如果EdenSapce和FromSpace空间不足,则发起一次GC</li>
<li>若进行GC后,EdenSpace和FromSpace能够容纳该对象,就放在Eden和FromSpace。在GC过程中会将EdenSpace和FromSpace存活的对象移动到ToSpace,然后清理Eden和From。若在清理过程中,ToSpace无法足够容纳该对象,则将该对象移入老年代中。在进行GC后,Eden和From为空,MinorGC完成。From和To标记互换。To区(逻辑上)始终为空。</li>
<li>新生代的回收成为MinorGC,对老年代的回收成为MajorGC又名FullGC</li>
</ul>
<p>其他</p>
<ul>
<li>优先在Eden上分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代</li>
<li>动态对象年龄判定 suvivor区同年龄对象总和大于suvivor区空间的一半,MinorGC时复制至老年代</li>
<li>空间分配担保 新生代放不下借用老年代,虚拟机检测GC租借的老年代内存是否大于剩余的老年代内存。若大于,MinorGC变为一次FullGC。若小于,查看虚拟机是否允许担保失败,若允许则执行一次MinorGC,否则也要变为一次FullGC</li>
</ul>
<h4 id="5-一些重要的关键字"><a href="#5-一些重要的关键字" class="headerlink" title="5.一些重要的关键字"></a>5.一些重要的关键字</h4><ul>
<li><p>volatile<br>Java 语言提供了一种稍弱的同步机制,即<code>volatile</code>变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新。 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的。<code>volatile</code>修饰变量,每次被线程访问时强迫其从主内存重读该值,修改后再写回共享内存。保证读取的可见性,对其他线程立即可见。由于不保证原子性,也就不能保证线程安全。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况。同时,volatile屏蔽了VM中必要的代码优化,效率上较低。另一个优点：禁止指令重排序</p>
</li>
<li><p>final<br><code>final</code>修饰的变量是常量，必须进行初始化，可以显示初始化，也可以通过构造进行初始化，如果不初始化编译会报错。</p>
</li>
</ul>
<h4 id="6-多线程-amp-并发-amp-同步-amp-锁"><a href="#6-多线程-amp-并发-amp-同步-amp-锁" class="headerlink" title="6.多线程 &amp; 并发 &amp; 同步 &amp; 锁"></a>6.多线程 &amp; 并发 &amp; 同步 &amp; 锁</h4><p>6.1 线程的run方法和start方法</p>
<ul>
<li><code>start方法</code><br>用start方法来启动线程,是真正实现了多线程。调用thread类的start方法来启动一个线程,此时线程处于就绪状态,一旦得到cpu时间片,就开始执行run方法。注：此时无需等待run方法执行完毕,即可执行下面的代码,所以run方法并没有实现多线程。</li>
<li><code>run方法</code><br>只是thread类的一个普通方法,若直接调用程序中依然只有主线程这一个线程,还要顺序执行,依然要等待run方法体执行完毕才可执行下面的代码。</li>
</ul>
<p>6.2 ReadWriteLock(读写锁)</p>
<p>写写互斥 读写互斥 读读并发<br>在读多写少的情况下可以提高效率 </p>
<p>6.3 resume(继续挂起的线程)和suspend(挂起线程)一起用</p>
<p>6.4 wait与notify、notifyall一起用</p>
<p>6.5 sleep与wait的异同点</p>
<ol>
<li>sleep是Thread类的静态方法,wait来自object类</li>
<li>sleep不释放锁,wait释放锁</li>
<li>wait,notify,notifyall必须在同步代码块中使用,sleep可以在任何地方使用</li>
<li>都可以抛出InterruptedException</li>
</ol>
<p>6.6 让一个线程停止执行</p>
<p>异常 - 停止执行<br>休眠 - 停止执行<br>阻塞 - 停止执行</p>
<p>6.7 ThreadLocal相关</p>
<ul>
<li>ThreadLocal解决了变量并发访问的冲突问题</li>
</ul>
<p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p>
<ul>
<li>与synchronized同步机制的比较</li>
</ul>
<p>首先,它们都是为了解决多线程中相同变量访问冲突问题。不过,在同步机制中,要通过对象的锁机制保证同一时间只有一个线程访问该变量。该变量是线程共享的,使用同步机制要求程序缜密地分析什么时候对该变量读写,什么时候需要锁定某个对象,什么时候释放对象锁等复杂的问题,程序设计编写难度较大,是一种“以时间换空间”的方式。<br>而ThreadLocal采用了以“以空间换时间”的方式。</p>
<h4 id="7-接口与抽象类"><a href="#7-接口与抽象类" class="headerlink" title="7.接口与抽象类"></a>7.接口与抽象类</h4><ol>
<li>一个子类只能继承一个抽象类,但能实现多个接口</li>
<li>抽象类可以有构造方法,接口没有构造方法</li>
<li>抽象类可以有普通成员变量,接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li>
<li>抽象类可以有静态方法，接口不能有静态方法</li>
<li>抽象类中的方法可以是public、protected和默认;接口方法只有public</li>
</ol>
<h4 id="8-Statement接口"><a href="#8-Statement接口" class="headerlink" title="8.Statement接口"></a>8.Statement接口</h4><p>8.1</p>
<ul>
<li>Statement是最基本的用法，不传参，采用字符串拼接，存在注入漏洞</li>
<li>PreparedStatement传入参数化的sql语句,同时检查合法性，效率高，可以重用,防止sql注入</li>
<li>CallableStatement接口扩展PreparedStatement，用来调用存储过程</li>
<li>public interface CallableStatement extends PreparedStatement </li>
<li>public interface PreparedStatement extends Statement </li>
<li>BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类</li>
</ul>
<p>8.2 Statement与PrepareStatement的区别</p>
<ul>
<li><p>创建时的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement statement &#x3D; conn.createStatement();</span><br><span class="line">PreparedStatement preStatement &#x3D; conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure></li>
<li><p>执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rSet &#x3D; statement.executeQuery(sql);</span><br><span class="line">ResultSet pSet &#x3D; preStatement.executeQuery();</span><br></pre></td></tr></table></figure>
<p>由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，<br>而 statement 不同，如果执行多遍，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些</p>
</li>
<li><p>安全性</p>
</li>
</ul>
<p>preStatement是预编译的，所以可以有效的防止SQL注入等问题</p>
<ul>
<li>代码的可读性和可维护性</li>
</ul>
<p>PreparedStatement更胜一筹</p>
<h4 id="9-抽象类和最终类"><a href="#9-抽象类和最终类" class="headerlink" title="9.抽象类和最终类"></a>9.抽象类和最终类</h4><p>抽象类可以没有抽象方法,最终类可以,没有最终方法</p>
<p>最终类不能被继承,最终方法不能被重写(可以重载)</p>
<h4 id="10-异常"><a href="#10-异常" class="headerlink" title="10.异常"></a>10.异常</h4><p>10.1 throw、throws、try…catch、finally</p>
<ol>
<li>throws用在方法上,方法内部通过throw抛出异常</li>
<li>try用于检测包住的语句块,若有异常,抛出并执行catch子句</li>
<li>catch捕获try块中抛出的异常并处理</li>
</ol>
<p>10.2 关于<code>finally</code></p>
<ol>
<li>finally不管有没有异常都要处理</li>
<li>finally{}比return先执行,多个return执行一个后就不在执行</li>
<li>不管有木有异常抛出,finally在return返回前执行</li>
</ol>
<p>10.3 受检查异常和运行时异常<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<ol>
<li><p>粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 </p>
</li>
<li><p>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… </p>
</li>
<li><p>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 </p>
</li>
</ol>
<h4 id="11-this-amp-super"><a href="#11-this-amp-super" class="headerlink" title="11.this &amp; super"></a>11.this &amp; super</h4><p>11.1 super出现在父类的子类中。有三种存在方式</p>
<ol>
<li>super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用</li>
<li>super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法</li>
<li>super() 调用父类构造</li>
</ol>
<ul>
<li>super只能指代其直接父类</li>
</ul>
<p>11.2 this() &amp; super()在构造方法中的区别</p>
<ol>
<li>调用super()必须写在子类构造方法的第一行,否则编译不通过</li>
<li>super从子类调用父类构造,this在同一类中调用其他构造</li>
<li>均需要放在第一行</li>
<li>尽管可以用this调用一个构造器,却不能调用2个</li>
<li>this和super不能出现在同一个构造器中,否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ol>
<h4 id="12-修饰符一览"><a href="#12-修饰符一览" class="headerlink" title="12.修饰符一览"></a>12.修饰符一览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 			类内部  	同一个包		子类 		任何地方</span><br><span class="line">private 		yes</span><br><span class="line">default         yes			yes</span><br><span class="line">protected		yes			yes				yes</span><br><span class="line">public			yes			yes				yes			yes</span><br></pre></td></tr></table></figure>

<h4 id="13-构造内部类对象"><a href="#13-构造内部类对象" class="headerlink" title="13.构造内部类对象"></a>13.构造内部类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enclosingone</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Enclosingone.Insideone obj1 = <span class="keyword">new</span> Enclosingone().<span class="keyword">new</span> Insideone();</span><br><span class="line">	Enclosingone.Insideone obj2 = <span class="keyword">new</span> Enclosingone.Insideone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-序列化"><a href="#14-序列化" class="headerlink" title="14.序列化"></a>14.序列化</h4><p>声明为static和transient类型的数据不能被序列化,序列化的笔记参见[Java-note-序列化.md][5]</p>
<h4 id="15-Java的方法区"><a href="#15-Java的方法区" class="headerlink" title="15.Java的方法区"></a>15.Java的方法区</h4><p>与堆一样,是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。</p>
<h4 id="16-正则表达式"><a href="#16-正则表达式" class="headerlink" title="16.正则表达式"></a>16.正则表达式</h4><p><strong>次数符号</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 0或多次</span><br><span class="line">+ 1或多次</span><br><span class="line">？0或1次</span><br><span class="line">&#123;n&#125; 恰n次</span><br><span class="line">&#123;n,m&#125; 从n到m次</span><br></pre></td></tr></table></figure>

<p><strong>其他符号</strong></p>
<p>符号    等价形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d		[0-9]</span><br><span class="line">\D      [^0-9]  </span><br><span class="line">\w 		[a-zA-Z_0-9]</span><br><span class="line">\W 		[^a-zA-Z_0-9]</span><br><span class="line">\s 		[\t\n\r\f]</span><br><span class="line">\S 		[^\t\n\r\f]</span><br><span class="line">. 		任何字符</span><br></pre></td></tr></table></figure>

<p><strong>边界匹配器</strong></p>
<p>行开头    ^<br>行结尾  $<br>单词边界 \b</p>
<p><strong>贪婪模式</strong>:最大长度匹配 非贪婪模式:匹配到结果就好,最短匹配</p>
<p><strong>环视</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符 				描述 					匹配对象</span><br><span class="line">.					单个任意字符			</span><br><span class="line">[...] 				字符组 					列出的任意字符</span><br><span class="line">[^...] 										未列出的任意字符</span><br><span class="line">^ 					caret 					行的起始位置</span><br><span class="line">$     				dollar 					行的结束位置</span><br><span class="line">\&lt;   										单词的起始位置</span><br><span class="line">\&gt; 											单词的结束位置</span><br><span class="line">\b   				单词边界</span><br><span class="line">\B 					非单词边界</span><br><span class="line">(?&#x3D;Expression)		顺序肯定环视			成功,如果右边能够匹配</span><br><span class="line">(?!Expression)		顺序否定环视			成功,如果右边不能够匹配</span><br><span class="line">(?&lt;&#x3D;Expression)		逆序肯定环视			成功,如果左边能够匹配</span><br><span class="line">(?&lt;!Expression) 	逆序否定环视			成功,如果左边不能够匹配</span><br></pre></td></tr></table></figure>
<p>举例:北京市(海定区)(朝阳区)(西城区)</p>
<p>Regex: .*(?=\()</p>
<p><strong>模式和匹配器的典型调用次序</strong></p>
<ol>
<li>把正则表达式编译到模式中<br>Pattern p = Pattern.compile(“a*b”);</li>
<li>创建给定输入与此模式的匹配器<br>Matcher m = p.matcher(“aaab”);</li>
<li>尝试将整个区域与此模式匹配<br>boolean b = m.matches();</li>
</ol>
<h4 id="17-Servlet-amp-JSP-amp-Tomcat"><a href="#17-Servlet-amp-JSP-amp-Tomcat" class="headerlink" title="17.Servlet &amp; JSP &amp; Tomcat"></a>17.Servlet &amp; JSP &amp; Tomcat</h4><p>17.1 Servlet继承实现结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Servlet (接口) 			--&gt;      init|service|destroy方法</span><br><span class="line">GenericServlet(抽象类)  --&gt;      与协议无关的Servlet</span><br><span class="line">HttpServlet(抽象类)		--&gt;		 实现了http协议</span><br><span class="line">自定义Servlet			--&gt;		 重写doGet&#x2F;doPost</span><br></pre></td></tr></table></figure>

<p>17.2 编写Servlet的步骤</p>
<ol>
<li>继承HttpServlet</li>
<li>重写doGet/doPost方法</li>
<li>在web.xml中注册servlet</li>
</ol>
<p>17.3 Servlet生命周期</p>
<ol>
<li><code>init</code>:仅执行一次,负责装载servlet时初始化servlet对象</li>
<li><code>service</code>:核心方法,一般get/post两种方式</li>
<li><code>destroy</code>:停止并卸载servlet,释放资源</li>
</ol>
<p>17.4 过程</p>
<ol>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若存在调用相应service方法</li>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若不存在装载Servlet类并创建实例 -&gt; 调用init初始化 -&gt; 调用service</li>
<li>加载和实例化、初始化、处理请求、服务结束</li>
</ol>
<p>17.5 doPost方法要抛出的异常:ServletExcception、IOException</p>
<p>17.6 Servlet容器装载Servlet</p>
<ol>
<li>web.xml中配置load-on-startup启动时装载</li>
<li>客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后,重新装载Servlet</li>
</ol>
<p>17.7 HttpServlet容器响应web客户请求流程</p>
<ol>
<li>Web客户向servlet容器发出http请求</li>
<li>servlet容器解析Web客户的http请求</li>
<li>servlet容器创建一个HttpRequest对象,封装http请求信息</li>
<li>servlet容器创建一个HttpResponse对象</li>
<li>servlet容器调用HttpServlet的service方法,把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象</li>
<li>HttpServlet调用httprequest的有关方法,获取http请求信息</li>
<li>httpservlet调用httpresponse的有关方法,生成响应数据</li>
<li>Servlet容器把HttpServlet的响应结果传给web客户</li>
</ol>
<p>17.8 HttpServletRequest完成的功能</p>
<ol>
<li>request.getCookie()</li>
<li>request.getHeader(String s)</li>
<li>request.getContextPath()</li>
</ol>
<p>17.9 HttpServletResponse完成的功能</p>
<ol>
<li>设http头</li>
<li>设置Cookie</li>
<li>输出返回数据</li>
</ol>
<p>17.10 <code>session</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session &#x3D; request.getSession(boolean create)</span><br><span class="line">返回当前请求的会话</span><br></pre></td></tr></table></figure>

<p>17.11 JSP的前身就是Servlet</p>
<p>17.12 Tomcat容器的等级</p>
<p>Tomcat - <strong>Container</strong> - <strong>Engine</strong> - <strong>Host</strong> - <strong>Servlet</strong> - 多个Context(一个Context对应一个web工程)-Wrapper</p>
<p>17.13 Servlet与JSP九大内置对象的关系</p>
<p>JSP对象                 怎样获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. out				-&gt;		response.getWriter</span><br><span class="line">2. request 		-&gt;		Service方法中的req参数</span><br><span class="line">3. response 		-&gt;		Service方法中的resp参数</span><br><span class="line">4. session 		-&gt;		request.getSession</span><br><span class="line">5. application 	-&gt;		getServletContext</span><br><span class="line">6. exception 		-&gt;		Throwable</span><br><span class="line">7. page  			-&gt;		this</span><br><span class="line">8. pageContext  	-&gt;		PageContext</span><br><span class="line">9. Config 			-&gt;		getServletConfig</span><br></pre></td></tr></table></figure>

<p>exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。</p>
<h4 id="18-struts"><a href="#18-struts" class="headerlink" title="18.struts"></a>18.struts</h4><ol>
<li>struts可进行文件上传</li>
<li>struts基于MVC模式</li>
<li>struts让流程结构更清晰</li>
<li>struts有许多action类,会增加类文件数目</li>
</ol>
<h4 id="19-Hibernate的7大鼓励措施"><a href="#19-Hibernate的7大鼓励措施" class="headerlink" title="19.Hibernate的7大鼓励措施"></a>19.Hibernate的7大鼓励措施</h4><ol>
<li>尽量使用many-to-one,避免使用单项one-to-many</li>
<li>灵活使用单项one-to-many</li>
<li>不用一对一,使用多对一代替一对一</li>
<li>配置对象缓存,不使用集合对象</li>
<li>一对多使用bag,多对一使用set</li>
<li>继承使用显示多态</li>
<li>消除大表,使用二级缓存</li>
</ol>
<h4 id="20-JVM"><a href="#20-JVM" class="headerlink" title="20.JVM"></a>20.JVM</h4><p>20.1 JVM内存配置参数</p>
<ol>
<li>-Xmx:最大堆大小</li>
<li>-Xms:初始堆大小(最小内存值)</li>
<li>-Xmn:年轻代大小</li>
<li>-XXSurvivorRatio:3 意思是Eden:Survivor=3:2</li>
<li>-Xss栈容量</li>
<li>-XX:+PrintGC 输出GC日志</li>
<li>-XX:+PrintGCDetails 输出GC的详细日志</li>
</ol>
<p>20.2 JVM内存结构</p>
<ol>
<li>堆:Eden、Survivor、old 线程共享</li>
<li>方法区(非堆):持久代,代码缓存,线程共享</li>
<li>JVM栈:中间结果,局部变量,线程隔离</li>
<li>本地栈:本地方法(非Java代码)</li>
<li>程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址</li>
<li>注：持久代Java8消失,取代的称为元空间(本地堆内存的一部分)</li>
</ol>
<h4 id="21-面向对象的五大基本原则-solid"><a href="#21-面向对象的五大基本原则-solid" class="headerlink" title="21.面向对象的五大基本原则(solid)"></a>21.面向对象的五大基本原则(solid)</h4><ol>
<li><p>S单一职责<code>SRP</code>:Single-Responsibility Principle<br>一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。</p>
</li>
<li><p>O开放封闭原则<code>OCP</code>:Open-Closed Principle<br>软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭</p>
</li>
<li><p>L里氏替换原则<code>LSP</code>:Liskov-Substitution Principle<br>子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。</p>
</li>
<li><p>I接口隔离原则<code>ISP</code>:Interface-Segregation Principle<br>使用多个小的接口,而不是一个大的总接口</p>
</li>
<li><p>D依赖倒置原则<code>DIP</code>:Dependency-Inversion Principle<br>依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。</p>
</li>
</ol>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><ol>
<li><p>封装变化</p>
</li>
<li><p>少用继承 多用组合</p>
</li>
<li><p>针对接口编程 不针对实现编程</p>
</li>
<li><p>为交互对象之间的松耦合设计而努力</p>
</li>
<li><p>类应该对扩展开发 对修改封闭（开闭OCP原则）</p>
</li>
<li><p>依赖抽象，不要依赖于具体类（依赖倒置DIP原则）</p>
</li>
<li><p>密友原则：只和朋友交谈（最少知识原则）</p>
<p> 说明：将方法调用保持在界限内，只调用属于以下范围的方法：<br> 该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象</p>
</li>
<li><p>别找我（调用我） 我会找你（调用你）（好莱坞原则）</p>
</li>
<li><p>一个类只有一个引起它变化的原因（单一职责SRP原则）</p>
</li>
</ol>
<h4 id="22-null可以被强制转型为任意类型的对象。"><a href="#22-null可以被强制转型为任意类型的对象。" class="headerlink" title="22.null可以被强制转型为任意类型的对象。"></a>22.null可以被强制转型为任意类型的对象。</h4><h4 id="23-代码执行次序"><a href="#23-代码执行次序" class="headerlink" title="23.代码执行次序"></a>23.代码执行次序</h4><ol>
<li>多个静态成员变量,静态代码块按顺序执行</li>
<li>单个类中: 静态代码 -&gt; main方法 -&gt; 构造块 -&gt; 构造方法</li>
<li>构造块在每一次创建对象时执行</li>
<li>涉及父类和子类的初始化过程<br> a.初始化父类中的静态成员变量和静态代码块<br> b.初始化子类中的静态成员变量和静态代码块<br> c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法(注意父类构造方法中的子类方法覆盖)<br> d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法</li>
</ol>
<h4 id="24-红黑树"><a href="#24-红黑树" class="headerlink" title="24.红黑树"></a>24.红黑树</h4><p><strong>二叉搜索树</strong>:(Binary Search Tree又名：二叉查找树,二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： 若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。</p>
<p><strong>红黑树</strong>的定义:满足以下五个性质的二叉搜索树</p>
<ol>
<li>每个结点或是红色的或是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点是黑色的</li>
<li>如果一个结点是红色的,则它的两个子结点是黑色的</li>
<li>对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点</li>
</ol>
<p>黑高</p>
<p>从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。<br>红黑树的黑高为其根结点的黑高。</p>
<p>其他</p>
<ul>
<li>一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1)</li>
<li>结点的属性(五元组):color key left right p</li>
<li>动态集合操作最坏时间复杂度为O(lgn)</li>
</ul>
<h4 id="25-排序"><a href="#25-排序" class="headerlink" title="25.排序"></a>25.排序</h4><ul>
<li><p>稳定排序:插入排序、冒泡排序、归并排序、基数排序</p>
</li>
<li><p>插入排序[稳定]<br>适用于小数组,数组已排好序或接近于排好序速度将会非常快<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>归并排序[稳定]<br>采用分治法<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(n)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>冒泡排序[稳定]<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>基数排序 分配+收集[稳定]<br>复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r)</p>
</li>
<li><p>树排序<br>应用：TreeSet的add方法、TreeMap的put方法<br>不支持相同元素,没有稳定性问题<br>复杂度：平均最差O(nlogn)</p>
</li>
<li><p>堆排序(就地排序)<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>快速排序<br>复杂度：O(nlgn) - O(nlgn) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]<br>栈空间0(lgn) - O(n)</p>
</li>
<li><p>选择排序<br>复杂度：O(n^2) - O(n^2) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>希尔排序<br>复杂度 小于O(n^2) 平均 O(nlgn) 最差O(n^s)[1&lt;s&lt;2] 空间O(1)</p>
</li>
</ul>
<h4 id="26-查找与散列"><a href="#26-查找与散列" class="headerlink" title="26.查找与散列"></a>26.查找与散列</h4><p>26.1 散列函数设计</p>
<ul>
<li>直接定址法:<code>f(key) = a*key+b</code></li>
</ul>
<p>简单、均匀,不易产生冲突。但需事先知道关键字的分布情况,适合查找表较小且连续的情况,故现实中并不常用</p>
<ul>
<li><p>除留余数法:<code>f(key) = key mod p (p&lt;=m) p取小于表长的最大质数 m为表长</code></p>
</li>
<li><p>DJBX33A算法(time33哈希算法<code>hash = hash*33+(unsigned int)str[i];</code></p>
</li>
</ul>
<p>平方取中法 折叠法 更多….</p>
<p>26.2 冲突处理</p>
<p>闭散列(开放地址方法):要求装填因子a较小，闭散列方法把所有记录直接存储在散列表中</p>
<ul>
<li>线性探测:易产生堆积现象(基地址不同堆积在一起)</li>
<li>二次探测:f(key) = (f(key)+di) % m di=1^2,-1^2,2^2,-2^2…可以消除基本聚集</li>
<li>随机探测:f(key) = (f(key)+di),di采用随机函数得到,可以消除基本聚集</li>
<li>双散列:避免二次聚集</li>
</ul>
<p>开散列(链地址法):原地处理</p>
<ul>
<li>同义词记录存储在一个单链表中,散列表中子存储单链表的头指针。</li>
<li>优点:无堆积 事先无需确定表长 删除结点易于实现 装载因子a&gt;=1,缺点:需要额外空间</li>
</ul>
<h4 id="27-枚举类"><a href="#27-枚举类" class="headerlink" title="27.枚举类"></a>27.枚举类</h4><p>JDK1.5出现 每个枚举值都需要调用一次构造函数</p>
<h4 id="28-数组复制方法"><a href="#28-数组复制方法" class="headerlink" title="28.数组复制方法"></a>28.数组复制方法</h4><ol>
<li>for逐一复制</li>
<li>System.arraycopy() -&gt; 效率最高native方法</li>
<li>Arrays.arrayOf() -&gt; 本质调用arraycopy</li>
<li>clone方法 -&gt; 返回Object[],需要强制类型转换</li>
</ol>
<h4 id="29-多态"><a href="#29-多态" class="headerlink" title="29.多态"></a>29.多态</h4><ol>
<li>Java通过方法重写和方法重载实现多态 </li>
<li>方法重写是指子类重写了父类的同名方法 </li>
<li>方法重载是指在同一个类中，方法的名字相同，但是参数列表不同 </li>
</ol>
<h4 id="30-Java文件"><a href="#30-Java文件" class="headerlink" title="30.Java文件"></a>30.Java文件</h4><p>.java文件可以包含多个类，唯一的限制就是：一个文件中只能有一个public类， 并且此public类必须与<br>文件名相同。而且这些类和写在多个文件中没有区别。</p>
<h4 id="31-Java移位运算符"><a href="#31-Java移位运算符" class="headerlink" title="31.Java移位运算符"></a>31.Java移位运算符</h4><p>java中有三种移位运算符</p>
<ol>
<li>&lt;&lt; :左移运算符,x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><blockquote>
<blockquote>
<p>:带符号右移,x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>:无符号右移,忽略符号位,空位都以0补齐</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h4 id="32-形参-amp-实参"><a href="#32-形参-amp-实参" class="headerlink" title="32.形参&amp;实参"></a>32.形参&amp;实参</h4><ol>
<li>形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。</li>
<li>形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。</li>
<li>形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。</li>
</ol>
<h4 id="33-IO"><a href="#33-IO" class="headerlink" title="33.IO"></a>33.IO</h4><p><img src="http://uploadfiles.nowcoder.com/images/20150328/138512_1427527478646_1.png" alt=""></p>
<h4 id="34-局部变量为什么要初始化"><a href="#34-局部变量为什么要初始化" class="headerlink" title="34.局部变量为什么要初始化"></a>34.局部变量为什么要初始化</h4><p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</p>
<h4 id="35-JDK提供的用于并发编程的同步器"><a href="#35-JDK提供的用于并发编程的同步器" class="headerlink" title="35.JDK提供的用于并发编程的同步器"></a>35.JDK提供的用于并发编程的同步器</h4><ol>
<li>Semaphore Java并发库的Semaphore可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</li>
<li>CyclicBarrier 主要的方法就是一个：await()。await()方法每被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此CyclicBarrier上面阻塞的线程开始运行。</li>
<li>直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</li>
</ol>
<h4 id="36-Java类加载器"><a href="#36-Java类加载器" class="headerlink" title="36.Java类加载器"></a>36.Java类加载器</h4><p>一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： </p>
<ol>
<li>Bootstrap ClassLoader(引导类加载器) 负责加载java基础类，主要是 %JRE_HOME/lib/目录下的rt.jar、resources.jar、charsets.jar等</li>
<li>Extension ClassLoader(扩展类加载器) 负责加载java扩展类，主要是 %JRE_HOME/lib/ext目录下的jar等</li>
<li>App ClassLoader(系统类加载器) 负责加载当前java应用的classpath中的所有类。<br>classloader 加载类用的是全盘负责委托机制。 所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。<br>所以，当我们自定义的classloader加载成功了com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。</li>
</ol>
<h4 id="37-Java语言的鲁棒性"><a href="#37-Java语言的鲁棒性" class="headerlink" title="37.Java语言的鲁棒性"></a>37.Java语言的鲁棒性</h4><p>Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。</p>
<h4 id="38-Java语言特性"><a href="#38-Java语言特性" class="headerlink" title="38.Java语言特性"></a>38.Java语言特性</h4><ol>
<li>Java致力于检查程序在编译和运行时的错误</li>
<li>Java虚拟机实现了跨平台接口</li>
<li>类型检查帮助检查出许多开发早期出现的错误</li>
<li>Java自己操纵内存减少了内存出错的可能性</li>
<li>Java还实现了真数组，避免了覆盖数据的可能</li>
</ol>
<h4 id="39-Hibernate延迟加载"><a href="#39-Hibernate延迟加载" class="headerlink" title="39.Hibernate延迟加载"></a>39.Hibernate延迟加载</h4><ol>
<li>Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） </li>
<li>Hibernate3 提供了属性的延迟加载功能<br>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 </li>
<li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 </li>
<li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li>
</ol>
<h4 id="40-包装类的equals-方法不处理数据转型，必须类型和值都一样才相等。"><a href="#40-包装类的equals-方法不处理数据转型，必须类型和值都一样才相等。" class="headerlink" title="40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。"></a>40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。</h4><h4 id="41-子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。"><a href="#41-子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。" class="headerlink" title="41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。"></a>41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。</h4><h4 id="42-Java语法糖"><a href="#42-Java语法糖" class="headerlink" title="42.Java语法糖"></a>42.Java语法糖</h4><ol>
<li>Java7的switch用字符串 - hashcode方法 switch用于enum枚举</li>
<li>伪泛型 - List<E>原始类型</li>
<li>自动装箱拆箱 - Integer.valueOf和Integer.intValue</li>
<li>foreach遍历 - Iterator迭代器实现</li>
<li>条件编译</li>
<li>enum枚举类、内部类</li>
<li>可变参数 - 数组</li>
<li>断言语言</li>
<li>try语句中定义和关闭资源</li>
</ol>
<h4 id="43-JVM工具"><a href="#43-JVM工具" class="headerlink" title="43.JVM工具"></a>43.JVM工具</h4><p>命令行</p>
<ol>
<li>jps(jvm processor status)虚拟机进程状况工具</li>
<li>jstat(jvm statistics monitoring)统计信息监视</li>
<li>jinfo(configuration info for java)配置信息工具</li>
<li>jmap(memory map for java)Java内存映射工具</li>
<li>jhat(JVM Heap Analysis Tool)虚拟机堆转储快照分析工具</li>
<li>jstack(Stack Trace for Java)Java堆栈跟踪工具</li>
<li>HSDIS：JIT生成代码反汇编</li>
</ol>
<p>可视化</p>
<ol>
<li>JConsole(Java Monitoring and Management Console):Java监视与管理控制台</li>
<li>VisualVM(All-in-one Java Troubleshooting Tool):多合一故障处理工具</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">Java基础之常见面试题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 14:05:35" itemprop="dateCreated datePublished" datetime="2020-05-31T14:05:35+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java面试问题列表"><a href="#Java面试问题列表" class="headerlink" title="Java面试问题列表"></a>Java面试问题列表</h2><p>Java 面试随着时间的改变而改变。在过去的日子里，当你知道 String 和 StringBuilder 的区别（String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象。因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，影响性能，可以考虑使用可变字符序列StringBuilder）就能让你直接进入第二轮面试，但是现在问题变得越来越高级，面试官问的问题也更深入。 在我初入职场的时候，类似于 Vector 与 Array 的区别、HashMap 与 Hashtable 的区别是最流行的问题，只需要记住它们，就能在面试中获得更好的机会，但这种情形已经不复存在。如今，你将会被问到许多 Java 程序员都没有看过的领域，如 NIO，设计模式，成熟的单元测试，或者那些很难掌握的知识，如并发、算法、数据结构及编码。</p>
<p>由于我喜欢研究面试题，因此我已经收集了许多的面试问题，包括许多许多不同的主题。我已经为这众多的问题准备一段时间了，现在我将它们分享给你们。这里面不但包含经典的面试问题，如线程、集合、equals 和 hashcode、socket，而且还包含了 NIO、数组、字符串、Java 8 等主题。</p>
<p>该列表包含了入门级 Java 程序员和多年经验的高级开发者的问题。无论你是 1、2、3、4、5、6、7、8、9 还是 10 年经验的开发者，你都能在其中找到一些有趣的问题。这里包含了一些超级容易回答的问题，同时包含经验丰富的 Java 程序员也会棘手的问题。</p>
<p>当然你们也是非常幸运的，当今有许多好的书来帮助你准备 Java 面试，其中有一本我觉得特别有用和有趣的是 Markham 的 Java 程序面试揭秘（Java Programming Interview Exposed）。 这本书会告诉你一些 Java 和 JEE 面试中最重要的主题，即使你不是准备 Java 面试，也值得一读。</p>
<p>该问题列表特别长，我们有各个地方的问题，所以，答案必须要短小、简洁、干脆，不拖泥带水。因此，除了这一个段落，你只会听到问题与答案，再无其他内容，没有反馈，也没有评价。为此，我已经写好了一些博文，在这些文章中你可以找到我对某些问题的观点，如我为什么喜欢这个问题，这个问题的挑战是什么？期望从面试者那获取到什么样的答案？</p>
<p>这个列表有一点不同，我鼓励你采用类似的方式去分享问题和答案，这样容易温习。我希望这个列表对面试官和候选人都有很好的用处，面试官可以对这些问题上做一些改变以获取新奇和令人惊奇的元素，这对一次好的面试来说非常重要。而候选者，可以扩展和测试 Java 程序语言和平台关键领域的知识。2015 年，会更多的关注并发概念，JVM 内部，32 位 JVM 和 64 JVM的区别，单元测试及整洁的代码。我确信，如果你读过这个庞大的 Java 面试问题列表，无论是电话面试还是面对面的面试，你都能有很好的表现。</p>
<h3 id="Java-面试中的重要话题"><a href="#Java-面试中的重要话题" class="headerlink" title="Java 面试中的重要话题"></a>Java 面试中的重要话题</h3><p>除了你看到的惊人的问题数量，我也尽量保证质量。我不止一次分享各个重要主题中的问题，也确保包含所谓的高级话题，这些话题很多程序员不喜欢准备或者直接放弃，因为他们的工作不会涉及到这些。Java NIO 和 JVM 底层就是最好的例子。你也可以将设计模式划分到这一类中，但是越来越多有经验的程序员了解 GOF 设计模式并应用这些模式。我也尽量在这个列表中包含 2015 年最新的面试问题，这些问题可能是来年关注的核心。为了给你一个大致的了解,下面列出这份 Java 面试问题列表包含的主题：</p>
<ul>
<li>多线程，并发及线程基础</li>
<li>数据类型转换的基本原则</li>
<li>垃圾回收（GC）</li>
<li>Java 集合框架</li>
<li>数组</li>
<li>字符串</li>
<li>GOF 设计模式</li>
<li>SOLID （单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）设计原则</li>
<li>抽象类与接口</li>
<li>Java 基础，如 equals 和 hashcode</li>
<li>泛型与枚举</li>
<li>Java IO 与 NIO</li>
<li>常用网络协议</li>
<li>Java 中的数据结构和算法</li>
<li>正则表达式</li>
<li>JVM 底层</li>
<li>Java 最佳实践</li>
<li>JDBC</li>
<li>Date, Time 与 Calendar</li>
<li>Java 处理 XML</li>
<li>JUnit</li>
<li>编程</li>
</ul>
<h3 id="120-大-Java-面试题及答案"><a href="#120-大-Java-面试题及答案" class="headerlink" title="120 大 Java 面试题及答案"></a>120 大 Java 面试题及答案</h3><p>现在是时候给你展示我近 5 年从各种面试中收集来的 120 个问题了。我确定你在自己的面试中见过很多这些问题，很多问题你也能正确回答。</p>
<p><strong>多线程、并发及线程的基础问题</strong></p>
<p>1）Java 中能创建 volatile 数组吗？</p>
<p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p>
<p>2）volatile 能使得一个非原子操作变成原子操作吗？</p>
<p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<p>3）volatile 修饰符的有过什么实践？</p>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
<p>4）volatile 类型变量提供什么保证？</p>
<p>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。</p>
<p>5) 10 个线程和 2 个线程的同步代码，哪个更容易写？</p>
<p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<p>6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</p>
<p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The standard idiom for using the wait method</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">while</span> (condition does not hold)</span><br><span class="line">obj.wait(); <span class="comment">// (Releases lock, and reacquires on wakeup)</span></span><br><span class="line">... <span class="comment">// Perform action appropriate to condition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。</p>
<p>7）什么是多线程环境下的伪共享（false sharing）？</p>
<p>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/11/2bccd7f52a70db95aa72524ef3a55164.gif" alt="False Sharing in Multi-threaded application"></p>
<p>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。</p>
<h3 id="有经验程序员的-Java-面试题"><a href="#有经验程序员的-Java-面试题" class="headerlink" title="有经验程序员的 Java 面试题"></a>有经验程序员的 Java 面试题</h3><p>8）什么是 Busy spin？我们为什么要使用它？</p>
<p>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</p>
<p>9）Java 中怎么获取一份线程 dump 文件？</p>
<p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。</p>
<p>10）Swing 是线程安全的？</p>
<p>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</p>
<p>11）什么是线程局部变量？</p>
<p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。</p>
<p>ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>总结：</p>
<p>a.实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的</p>
<p>b.为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p>
<p>c.在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法</p>
<p>12）用 wait-notify 写一段代码来解决生产者-消费者问题？</p>
<p>请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。</p>
<p>13) 用 Java 写一个线程安全的单例模式（Singleton）？</p>
<p>请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。</p>
<p>14）Java 中 sleep 方法和 wait 方法的区别？</p>
<p>虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。</p>
<p>15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？</p>
<p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。</p>
<p>16）我们能创建一个包含可变对象的不可变对象吗？</p>
<p>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。</p>
<p>数据类型和 Java 基础面试问题</p>
<p>17）Java 中应该使用什么数据类型来代表价格？</p>
<p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<p>18）怎么将 byte 转换为 String？</p>
<p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<p>19）Java 中怎样将 bytes 转换为 long 类型？</p>
<p>String接收bytes的构造器转成String，再Long.parseLong</p>
<p>20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</p>
<p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。</p>
<p>21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；</p>
<p>可以，向下转型。但是不建议使用，容易出现类型转型异常.</p>
<p>22）哪个类包含 clone 方法？是 Cloneable 还是 Object？</p>
<p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<p>23）Java 中 ++ 操作符是线程安全的吗？</p>
<p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p>
<p>24）a = a + b 与 a += b 的区别</p>
<p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">byte</span> a = <span class="number">127</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">127</span>;</span><br><span class="line">b = a + b; <span class="comment">// error : cannot convert from int to byte</span></span><br><span class="line">b += a; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>（因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p>
<p>25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？</p>
<p>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</p>
<p>26）3*0.1 == 0.3 将会返回什么？true 还是 false？</p>
<p>false，因为有些浮点数不能完全精确的表示出来。</p>
<p>27）int 和 Integer 哪个会占用更多的内存？</p>
<p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<p>28）为什么 Java 中的 String 是不可变的（Immutable）？</p>
<p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。</p>
<p>29）我们能在 Switch 中使用 String 吗？</p>
<p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p>
<p>30）Java 中的构造器链是什么？</p>
<p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p>
<h3 id="JVM-底层-与-GC（Garbage-Collection）-的面试问题"><a href="#JVM-底层-与-GC（Garbage-Collection）-的面试问题" class="headerlink" title="JVM 底层 与 GC（Garbage Collection） 的面试问题"></a>JVM 底层 与 GC（Garbage Collection） 的面试问题</h3><p>31）64 位 JVM 中，int 的长度是多数？</p>
<p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<p>32）Serial 与 Parallel GC之间的不同之处？</p>
<p>Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。</p>
<p>33）32 位和 64 位的 JVM，int 类型变量的长度是多数？</p>
<p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。</p>
<p>34）Java 中 WeakReference 与 SoftReference的区别？</p>
<p>Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。</p>
<p>StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收</p>
<p>WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在 JVM 内不再有强引用时, 将被GC回收</p>
<p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</p>
<p>35）WeakHashMap 是怎么工作的？</p>
<p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<p>36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？</p>
<p>当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。</p>
<p>37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</p>
<p>你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。</p>
<p>38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</p>
<p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p>
<p>39）JRE、JDK、JVM 及 JIT 之间有什么不同？</p>
<p>JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。</p>
<p><img src="http://jbcdn2.b0.upaiyun.com/2015/11/4468a2440b48658c08acc50f15c3985b.jpg" alt="JVM JRE JDK"></p>
<h3 id="3-年工作经验的-Java-面试题"><a href="#3-年工作经验的-Java-面试题" class="headerlink" title="3 年工作经验的 Java 面试题"></a>3 年工作经验的 Java 面试题</h3><p>40）解释 Java 堆空间及 GC？</p>
<p>当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。</p>
<h3 id="JVM-底层面试题及答案"><a href="#JVM-底层面试题及答案" class="headerlink" title="JVM 底层面试题及答案"></a>JVM 底层面试题及答案</h3><p>41）你能保证 GC 执行吗？</p>
<p>不能，虽然你可以调用 System.gc() 或者 Runtime.getRuntime().gc()，但是没有办法保证 GC 的执行。</p>
<p>42）怎么获取 Java 程序使用的内存？堆使用的百分比？</p>
<p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p>
<p>43）Java 中堆和栈有什么区别？</p>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。<br>Difference between stack and heap memory in Java</p>
<h3 id="关于内存的的面试问题和答案"><a href="#关于内存的的面试问题和答案" class="headerlink" title="关于内存的的面试问题和答案"></a>关于内存的的面试问题和答案</h3><p><strong>Java 基本概念面试题</strong></p>
<p>44）“a==b”和”a.equals(b)”有什么区别？</p>
<p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<p>45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</p>
<p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<p>46）final、finalize 和 finally 的不同之处？</p>
<p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>
<p>47）Java 中的编译期常量是什么？使用它又什么风险？</p>
<p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h3 id="Java-集合框架的面试题"><a href="#Java-集合框架的面试题" class="headerlink" title="Java 集合框架的面试题"></a>Java 集合框架的面试题</h3><p>这部分也包含数据结构、算法及数组的面试问题</p>
<p>48) List、Set、Map 和 Queue 之间的区别(答案)</p>
<p>List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。</p>
<p>49）poll() 方法和 remove() 方法的区别？</p>
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<p>50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？(答案)</p>
<p>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p>
<p>51）ArrayList 与 LinkedList 的不区别？(答案)</p>
<p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。</p>
<p>52）用哪两种方式来实现集合的排序？(答案)</p>
<p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p>
<p>53）Java 中怎么打印数组？(answer答案)</p>
<p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p>
<p>54）Java 中的 LinkedList 是单向链表还是双向链表？(答案)</p>
<p>是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。</p>
<p>55）Java 中的 TreeMap 是采用什么树实现的？(答案)</p>
<p>Java 中的 TreeMap 是使用红黑树实现的。</p>
<p>56) Hashtable 与 HashMap 有什么不同之处？(答案)</p>
<p>这两个类有许多不同的地方，下面列出了一部分：<br>a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。<br>b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。<br>c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。<br>更多的不同之处参见答案。</p>
<p>57）Java 中的 HashSet，内部是如何工作的？(answer答案)</p>
<p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p>
<p>58）写一段代码在遍历 ArrayList 时移除一个元素？(答案)</p>
<p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p>
<p>59）我们能自己写一个容器类，然后使用 for-each 循环吗？</p>
<p>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</p>
<p>60）ArrayList 和 HashMap 的默认大小是多数？(答案)</p>
<p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from ArrayList.java JDK 1.7</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//from HashMap.java JDK 7</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<p>61）有没有可能两个不相等的对象有有相同的 hashcode？</p>
<p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p>
<p>62）两个相同的对象会有不同的的 hash code 吗？</p>
<p>不能，根据 hash code 的规定，这是不可能的。</p>
<p>63）我们可以在 hashcode() 中使用随机数字吗？(答案)</p>
<p>不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。</p>
<p>64）Java 中，Comparator 与 Comparable 有什么不同？(答案)</p>
<p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<p>65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案)</p>
<p>因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h3 id="Java-IO-和-NIO-的面试题"><a href="#Java-IO-和-NIO-的面试题" class="headerlink" title="Java IO 和 NIO 的面试题"></a>Java IO 和 NIO 的面试题</h3><p>IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。</p>
<p>66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？</p>
<p>67）Java 中怎么创建 ByteBuffer？</p>
<p>68）Java 中，怎么读写 ByteBuffer ？</p>
<p>69）Java 采用的是大端还是小端？</p>
<p>70）ByteBuffer 中的字节序是什么？</p>
<p>71）Java 中，直接缓冲区与非直接缓冲器有什么区别？(答案)</p>
<p>72）Java 中的内存映射缓存区是什么？(answer答案)</p>
<p>73）socket 选项 TCP NO DELAY 是指什么？</p>
<p>74）TCP 协议与 UDP 协议有什么区别？(answer答案)</p>
<p>75）Java 中，ByteBuffer 与 StringBuffer有什么区别？(答案)</p>
<h3 id="Java-最佳实践的面试问题"><a href="#Java-最佳实践的面试问题" class="headerlink" title="Java 最佳实践的面试问题"></a>Java 最佳实践的面试问题</h3><p>包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。</p>
<p>76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？(答案)</p>
<p>这是我在写Java 并发程序的时候遵循的一些最佳实践：<br>a）给线程命名，这样可以帮助调试。<br>b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。<br>c）如果可以，更偏向于使用 volatile 而不是 synchronized。<br>d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。<br>e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p>
<p>77）说出几点 Java 中使用 Collections 的最佳实践(答案)</p>
<p>这是我在使用 Java 中 Collectionc 类的一些最佳实践：<br>a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。<br>b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。<br>c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。<br>d）使用迭代器来循环集合。<br>e）使用集合的时候使用泛型。</p>
<p>78）说出至少 5 点在 Java 中使用线程的最佳实践。(答案)</p>
<p>这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：<br>a）对线程命名<br>b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。<br>c）使用线程池</p>
<p>79）说出 5 条 IO 的最佳实践(答案)</p>
<p>IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：<br>a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。<br>b）使用 NIO 和 NIO2<br>c）在 finally 块中关闭流，或者使用 try-with-resource（Java7） 语句。<br>d）使用内存映射文件获取更快的 IO。</p>
<p>80）列出 5 个应该遵循的 JDBC 最佳实践(答案)</p>
<p>有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：<br>a）使用批量的操作来插入和更新数据<br>b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。<br>c）使用数据库连接池<br>d）通过列名来获取结果集，不要使用列的下标来获取。</p>
<p>81）说出几条 Java 中方法重载的最佳实践？(答案)</p>
<p>下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。<br>a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。<br>b）不要重载参数数量一致，而只是参数顺序不同的方法。<br>c）如果重载的方法参数个数多于 5 个，采用可变参数。</p>
<h3 id="Date、Time-及-Calendar-的面试题"><a href="#Date、Time-及-Calendar-的面试题" class="headerlink" title="Date、Time 及 Calendar 的面试题"></a>Date、Time 及 Calendar 的面试题</h3><p>82）在多线程环境下，SimpleDateFormat 是线程安全的吗？(答案)</p>
<p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<p>83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？(答案)</p>
<p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<p>84）Java 中，怎么在格式化的日期中显示时区？</p>
<p>pattern中加z <code>yyyy-MM-dd HH:mm:ss.SSS Z</code></p>
<p>85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？</p>
<p>java.sql.Date是针对SQL语句使用的，它只包含日期而没有时间部分,它们都有getTime方法返回毫秒数，自然就可以直接构建。java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。</p>
<p>86）Java 中，如何计算两个日期之间的差距？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dateDiff</span><span class="params">(Date d1, Date d2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">long</span> n1 = d1.getTime();</span><br><span class="line"><span class="keyword">long</span> n2 = d2.getTime();</span><br><span class="line"><span class="keyword">long</span> diff = Math.abs(n1 - n2);</span><br><span class="line"></span><br><span class="line">diff /= <span class="number">3600</span> * <span class="number">1000</span> * <span class="number">24</span>;</span><br><span class="line"><span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>87）Java 中，如何将字符串 YYYYMMDD 转换为日期？</p>
<p>SimpleDateFormat的parse方法</p>
<h3 id="单元测试-JUnit-面试题"><a href="#单元测试-JUnit-面试题" class="headerlink" title="单元测试 JUnit 面试题"></a>单元测试 JUnit 面试题</h3><p>89）如何测试静态方法？(答案)</p>
<p>可以使用 PowerMock 库来测试静态方法。</p>
<p>90）怎么利用 JUnit 来测试一个方法的异常？(答案)</p>
<p>91）你使用过哪个单元测试库来测试你的 Java 程序？(答案)</p>
<p>92）@Before 和 @BeforeClass 有什么区别？(答案)</p>
<h3 id="编程和代码相关的面试题"><a href="#编程和代码相关的面试题" class="headerlink" title="编程和代码相关的面试题"></a>编程和代码相关的面试题</h3><p>93）怎么检查一个字符串只包含数字？(解决方案)</p>
<p>94）Java 中如何利用泛型写一个 LRU 缓存？(答案)</p>
<p>95）写一段 Java 程序将 byte 转换为 long？(答案)</p>
<p>95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？(解决方案)</p>
<p>97）Java 中，怎么获取一个文件中单词出现的最高频率？(解决方案)</p>
<p>98）如何检查出两个给定的字符串是反序的？(解决方案)</p>
<p>99）Java 中，怎么打印出一个字符串的所有排列？(解决方案)</p>
<p>100）Java 中，怎样才能打印出数组中的重复元素？(解决方案)</p>
<p>101）Java 中如何将字符串转换为整数？(解决方案)</p>
<p>102）在没有使用临时变量的情况如何交换两个整数变量的值？(解决方案)</p>
<h3 id="关于-OOP-和设计模式的面试题"><a href="#关于-OOP-和设计模式的面试题" class="headerlink" title="关于 OOP 和设计模式的面试题"></a>关于 OOP 和设计模式的面试题</h3><p>这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。</p>
<p>103）接口是什么？为什么要使用接口而不是直接使用具体类？</p>
<p>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。</p>
<p>104）Java 中，抽象类与接口之间有什么不同？(答案)</p>
<p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。</p>
<p>105）除了单例模式，你在生产环境中还用过什么设计模式？</p>
<p>这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。</p>
<p>106）你能解释一下里氏替换原则吗?(答案)</p>
<p>107) 什么情况下会违反迪米特法则？为什么会有这个问题？(答案)</p>
<p>迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。</p>
<p>108）适配器模式是什么？什么时候使用？</p>
<p>适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。</p>
<p>109）什么是“依赖注入”和“控制反转”？为什么有人使用？(答案)</p>
<p>110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？(答案)</p>
<p>111）构造器注入和 setter 依赖注入，那种方式更好？(答案)</p>
<p>每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。</p>
<p>112）依赖注入和工厂模式之间有什么不同？(答案)</p>
<p>虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。</p>
<p>113）适配器模式和装饰器模式有什么区别？(答案)</p>
<p>虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。</p>
<p>114）适配器模式和代理模式之前有什么不同？(答案)</p>
<p>这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。</p>
<p>115）什么是模板方法模式？(答案)</p>
<p>模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。</p>
<p>116）什么时候使用访问者模式？(答案)</p>
<p>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。</p>
<p>117）什么时候使用组合模式？(答案)</p>
<p>组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。</p>
<p>118）继承和组合之间有什么不同？(答案)</p>
<p>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</p>
<p>119）描述 Java 中的重载和重写？(答案)</p>
<p>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。</p>
<p>120）Java 中，嵌套公共静态类与顶级类有什么不同？(答案)</p>
<p>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</p>
<p>121) OOP 中的 组合、聚合和关联有什么区别？(答案)</p>
<p>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</p>
<p>122）给我一个符合开闭原则的设计模式的例子？(答案)</p>
<p>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。</p>
<p>123）抽象工厂模式和原型模式之间的区别？(答案)</p>
<p>124）什么时候使用享元模式？(答案)</p>
<p>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。</p>
<h3 id="Java-面试中其他各式各样的问题"><a href="#Java-面试中其他各式各样的问题" class="headerlink" title="Java 面试中其他各式各样的问题"></a>Java 面试中其他各式各样的问题</h3><p>这部分包含 Java 中关于 XML 的面试题，JDBC 面试题，正则表达式面试题，Java 错误和异常及序列化面试题</p>
<p>125）嵌套静态类与顶级类有什么区别？(答案)</p>
<p>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。</p>
<p>126）你能写出一个正则表达式来判断一个字符串是否是一个数字吗？(解决方案)</p>
<p>一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，你可以下一个如下的正则表达式来判断给定的字符串是不是数字。</p>
<p>127）Java 中，受检查异常 和 不受检查异常的区别？(答案)</p>
<p>受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<p>128）Java 中，throw 和 throws 有什么区别？(答案)</p>
<p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：<br>throw new IllegalArgumentException(“size must be multiple of 2″)<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<p>129）Java 中，Serializable 与 Externalizable 的区别？(答案)</p>
<p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<p>130）Java 中，DOM 和 SAX 解析器有什么不同？(答案)</p>
<p>DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。</p>
<p>131）说出 JDK 1.7 中的三个新特性？(答案)</p>
<p>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。</p>
<p>132）说出 5 个 JDK 1.8 引入的新特性？(答案)</p>
<p>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<p>133）Java 中，Maven 和 ANT 有什么区别？(答案)</p>
<p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见答案。</p>
<p>这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP 和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web 开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建一份最新的、最优的 Java 面试问题列表。</p>
<h3 id="Java-EE-相关的面试题"><a href="#Java-EE-相关的面试题" class="headerlink" title="Java EE 相关的面试题"></a>Java EE 相关的面试题</h3><p>为了做 Java EE 的朋友，这里列出了一些 web 开发的特定问题，你们可以用来准备 JEE 部分的面试：</p>
<p>10 大 Spring 框架面试题及答案(参见)</p>
<p>10 个非常好的 XML 面试问题（Java 程序员）(参见)</p>
<p>20 个非常好的设计模式面试问题(参见)</p>
<p>10个最流行的 Struts 面试题（Java 开发者）(参见)</p>
<p>20 个 Tibco Rendezvous 及 EMS 的面试题(更多)</p>
<p>10 个最频繁被问到的 Servlet 面试问题及答案(参见)</p>
<p>20 个 jQuery 面试问题（Java Web 开发者）(列表)</p>
<p>10 个非常好的 Oracle 面试问题（Java 开发者）(参见)</p>
<p>10 大 来自 J2EE 面试中的 JSP 问题(更多)</p>
<p>12 个很好的 RESTful Web Services 面试问题(参见)</p>
<p>10 大 EJB 面试问题及答案(参见)</p>
<p>10 大 JMS 及 MQ 系列面试题及答案(列表)</p>
<p>10 个非常好 Hibernate 面试问题（Java EE 开发者）(参见)</p>
<p>10 个非常好的 JDBC 面试题（Java 开发者）(参见)</p>
<p>15 个 Java NIO 和网络面试题及答案(参见)</p>
<p>10 大 XSLT 面试题及答案(更多)</p>
<p>15 个来自 Java 面试的数据结构和算法问题(参见)</p>
<p>10 大 Java 面试难题及答案(参见)</p>
<p>40 个核心 Java 移动开发面试题及答案(列表)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E8%AF%95%E7%82%B9/" class="post-title-link" itemprop="url">Java基础之面试点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 14:05:35" itemprop="dateCreated datePublished" datetime="2020-05-31T14:05:35+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java面试题整理"><a href="#Java面试题整理" class="headerlink" title="Java面试题整理"></a>Java面试题整理</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>1.停止等待协议</p>
<p>停止等待协议是最基本的数据链路层协议，它的工作原理是这样的。</p>
<p>在发送端，每发送完一帧就停止发送，等待接收端的确认，如果收到确认就发送下一帧。</p>
<p>在接收端，每收到一个无差错的帧，就把这个帧交付上层并向发送端发送确认。若该帧有差错，就丢弃，其他什么也不做。</p>
<p>其他细节：</p>
<p>停止等待协议为了可靠交付，需要对帧进行编号，由于每次只发送一帧，所有停止等待协议使用1个比特编号，编号0和1</p>
<p>停止等待协议会出现死锁现象（A等待B的确认），解决办法，启动超时计时器，超时计时器有一个重传时间。重传时间一般选择略大于“正常情况下从发完数据帧到收到确认帧所需的平均时间”。</p>
<p>2.滑动窗口协议</p>
<p>再说滑动窗口之前，先说下连续ARQ，连续ARQ又称Go-back-N ARQ，意思是当出现差错必须重传时，要向回走N个帧，然后再开始重传，也就意味着只要有一帧出现差错，即使已经正确的帧也需要重传，白白浪费时间，增大开销。为此，应该对发送出去但未被确认的帧的数目加以限制，这就是滑动窗口协议。滑动窗口指收发两端分别维护一个发送窗口和接收窗口，发送窗口有一个窗口值Wt，窗口值Wt代表在没有收到对方确认的情况下最多可以发送的帧的数目。当发送的帧的序号被接收窗口正确收下后，接收端向前滑动并向发送端发去确认，发送端收到确认后，发送窗口向前滑动。收发两端按规律向前推进。</p>
<p>连续ARQ和选择重传ARQ均是窗口大于1的滑动窗口协议，而停止等待协议相当于收发两端窗口等于1.</p>
<p>滑动窗口指接收和发送两端的窗口按规律不断向前推进，是一种流量控制的策略。</p>
<p>3.Http1.0和Http1.1的区别</p>
<p>1.HTTP/1.0协议使用非持久连接,即在非持久连接下,一个tcp连接只传输一个Web对象。<br>2.HTTP/1.1默认使用持久连接(然而,HTTP/1.1协议的客户机和服务器可以配置成使用非持久连接)。在持久连接下,不必为每个Web对象的传送建立一个新的连接,一个连接中可以传输多个对象。</p>
<p>4.Post和Get的区别</p>
<p>1.安全性上说：get的方式是把数据在地址栏中明文的形式发送，URL中可见，POST方式对用户是透明的，安全性更高。<br>2.数据量说：Get传送的数据量较小，一般不能大于2KB，POST传送的数据量更大。<br>3.适用范围说：查询用Get，数据添加、修改和删除建议Post</p>
<p>5.TCP/IP体系各层功能及协议</p>
<p>TCP/IP体系共有四个层次，分别为网络接口层Host-to-Network Layer, 网际层 Internet Layer， 传输层Transport Layer，应用层Application Layer。</p>
<p><strong>网络接口层</strong> -&gt; 接收和发送数据报</p>
<p>主要负责将数据发送到网络传输介质上以及从网络上接收TCP/IP数据报，相当于OSI参考模型的物理层和数据链路层。在实际中，先后流行的以太网、令牌环网、ATM、帧中继等都可视为其底层协议。它将发送的信息组装成帧并通过物理层向选定网络发送，或者从网络上接收物理帧，将去除控制信息后的IP数据报交给网络层。</p>
<p><strong>网际层</strong> -&gt; 数据报封装和路由寻址</p>
<p>网际层主要功能是寻址和对数据报的封装以及路由选择功能。这些功能大部分通过IP协议完成，并通过地址解析协议ARP、逆地址解析协议RARP、因特网控制报文协议ICMP、因特网组管理协议IGMP从旁协助。所以IP协议是网络层的核心。</p>
<p>网际协议IP：IP协议是一个无连接的协议，主要负责将数据报从源结点转发到目的结点。也就是说IP协议通过对数据报中源地址和目的地址进行分析，然后进行路由选择，最后再转发到目的地。需要注意的是：IP协议只负责对数据进行转发，并不对数据进行检查，也就是说，它不负责数据的可靠性，这样设计的主要目的是提高IP协议传送和转发数据的效率。</p>
<p>ARP：该协议负责将IP地址解析转换为计算机的物理地址。</p>
<p>虽然我们使用IP地址进行通信，但IP地址只是主机在抽象的网络层中的地址。最终要传到数据链路层封装成MAC帧才能发送到实际的网络。因此不管使用什么协议最终需要的还是硬件地址。</p>
<p>每个主机拥有一个ARP高速缓存（存放所在局域网内主机和路由器的IP地址到硬件地址的映射表）</p>
<p>举例：A发送B</p>
<p>(1).A在自己的ARP高速缓存中查到B的MAC地址，写入MAC帧发往此B</p>
<p>(2)没查到，A向本局域网广播ARP请求分组，内容包括自己的地址映射和B的IP地址</p>
<p>(3)B发送ARP响应分组，内容为自己的IP地址到物理地址的映射，同时将A的映射写入自己的ARP高速缓存（单播的方式）</p>
<p>注：ARP Cache映射项目具有一个生存时间。</p>
<p>RARP：将计算机物理地址转换为IP地址</p>
<p>ICMP：该协议主要负责发送和传递包含控制信息的数据报，这些控制信息包括了哪台计算机出现了什么错误，网络路由出现了什么错误等内容。</p>
<p><strong>传输层</strong> -&gt; 应用进程间端到端的通信</p>
<p>传输层主要负责应用进程间“端到端”的通信，即从某个应用进程传输到另一个应用进程，它与OSI参考模型的传输层功能类似。</p>
<p>传输层在某个时刻可能要同时为多个不同的应用进程服务，因此传输层在每个分组中必须增加用于识别应用进程的标识，即端口。</p>
<p>TCP/IP体系的传输层主要包含两个主要协议，即传输控制协议TCP和用户数据报协议UDP。TCP协议是一种可靠的、面向连接的协议，保证收发两端有可靠的字节流传输，进行了流量控制，协调双方的发送和接收速度，达到正确传输的目的。</p>
<p>UDP是一种不可靠的、无连接的协议，其特点是协议简单、额外开销小、效率较高，不能保证可靠传输。</p>
<p>传输层提供应用进程间的逻辑通信。它使应用进程看见的就好像是在两个运输层实体间一条端到端的逻辑通信信道。</p>
<p>当运输层采用TCP时，尽管下面的网络是不可靠的，但这种逻辑通信信道相当于一条全双工的可靠信道。可以做到报文的无差错、按序、无丢失、无重复。</p>
<p>注：单单面向连接只是可靠的必要条件，不充分。还需要其他措施，如确认重传，按序接收，无丢失无重复。</p>
<p>熟知端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20 FTP数据连接 </span><br><span class="line">21 FTP控制连接 </span><br><span class="line">22 SSH </span><br><span class="line">23 TELNET </span><br><span class="line">25 SMTP </span><br><span class="line">53 DNS </span><br><span class="line">69 TFTP</span><br><span class="line">80 HTTP</span><br><span class="line">161 SNMP</span><br></pre></td></tr></table></figure>

<p><strong>UDP</strong>重要</p>
<p>UDP的优点：</p>
<p>1.发送之前无需建立连接，减小了开销和发送数据的时延</p>
<p>2.UDP不使用拥塞控制，不使用可靠交付，因此主机不需要维护复杂的参数表、连接状态表</p>
<p>3.UDP用户数据报只有8个字节的首部开销，而TCP要20字节。</p>
<p>4.由于没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（IP电话等实时应用要求源主机以恒定的速率发送数据）</p>
<p>Table，使用TCP和UDP的应用</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>应用层协议</th>
<th>运输层协议</th>
</tr>
</thead>
<tbody><tr>
<td>名字转换</td>
<td>DNS</td>
<td>UDP</td>
</tr>
<tr>
<td>文件传送</td>
<td>TFTP</td>
<td>UDP</td>
</tr>
<tr>
<td>路由选择协议</td>
<td>RIP</td>
<td>UDP</td>
</tr>
<tr>
<td>IP地址配置</td>
<td>BOOTTP,DHCP</td>
<td>UDP</td>
</tr>
<tr>
<td>网络管理</td>
<td>SNMP</td>
<td>UDP</td>
</tr>
<tr>
<td>远程文件服务器</td>
<td>NFS</td>
<td>UDP</td>
</tr>
<tr>
<td>IP电话</td>
<td>专用协议</td>
<td>UDP</td>
</tr>
<tr>
<td>流式多媒体通信</td>
<td>专用协议</td>
<td>UDP</td>
</tr>
<tr>
<td>电子邮件</td>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr>
<td>远程终端接入</td>
<td>TELNET</td>
<td>TCP</td>
</tr>
<tr>
<td>万维网</td>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr>
<td>文件传送</td>
<td>FTP</td>
<td>TCP</td>
</tr>
</tbody></table>
<p>注：TFTP：Trivial File Transfer Protocol</p>
<p>UDP的过程：</p>
<p>1.服务器进程运行着，等待TFTP客户进程的服务请求。客户端TFTP进程启动时，向操作系统申请一个临时端口号，然后操作系统为该进程创建2个队列，<br>入队列和出队列。只要进程在执行，2个队列一直存在。</p>
<p>2.客户进程将报文发送到出队列中。UDP按报文在队列的先后顺序发送。在传送到IP层前给报文加上UDP首部，其中目的端口后为69。然后发给IP层。<br>出队列若溢出，则操作系统通知应用层TFTP客户进程暂停发送。</p>
<p>3.客户端收到来自IP层的报文时，UDP检查报文中目的端口号是否正确，若正确，放入入队列队尾，客户进程按先后顺序一一取走。若不正确，UDP丢弃该报文，并请ICMP发送”端口不可达“差错报文给服务器端。入队列可能会溢出，若溢出，UDP丢弃该报文，不通知对方。</p>
<p>服务器端类似。</p>
<p>UDP首部：源端口 - 目的端口 - 长度 - 检验和，每个字段22字节。</p>
<p>IP数据报检验和只检验IP数据报的首部，而UDP的检验和将首部和数据部分一起都检验。</p>
<p><strong>TCP</strong>重要</p>
<p>细节：</p>
<p>TCP报文段是面向字节的数据流。</p>
<p>TCP首部：20字节固定首部</p>
<p>确认比特ACK，ACK=1 确认号字段才有效；同步比特SYN：SYN=1 ACK=0表示一个连接请求报文段；终止比特FIN，FIN=1时要求释放连接。</p>
<p>窗口：将TCP收发两端记为A和B，A根据TCP缓存空间的大小确定自己的接收窗口大小。并在A发送给B的窗口字段写入该值。作为B的发送窗口的上限。意味着B在未收到A的确认情况下，最多发送的字节数。</p>
<p>选项：最大报文段长度MSS，MSS告诉对方TCP：我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节。若主机未填写，默认为536字节。</p>
<p>TCP的可靠是使用了序号和确认。当TCP发送一个报文时，在自己的重传队列中存放一个副本。若收到副本，删除副本。</p>
<p>TCP使用捎带确认。</p>
<p>TCP报文段的发送时机：1.维持一个变量等于MSS，发送缓存达到MSS就发送 2.发送端应用进程指明要发送，即TCP支持的PUSH操作。3.设定计时器</p>
<p><strong>TCP的拥塞控制：TCP使用慢开始和拥塞避免算法进行拥塞控制</strong></p>
<p><strong>慢开始和拥塞避免</strong></p>
<p>接收端根据自身资源情况控制发送端发送窗口的大小。</p>
<p>每个TCP连接需要维持一下2个状态变量：</p>
<p>接收端窗口rwnd（receiver window）：接收端根据目前接收缓存大小设置的窗口值，是来自接收端的流量控制</p>
<p>拥塞窗口cwnd（congestion window）：是发送端根据自己估计的网络拥塞程度设置的窗口值，是来自发送端的流量控制</p>
<p>发送端的窗口上限值=Min(rwnd, cwnd)</p>
<p>慢开始算法原理：主机刚开始发送数据时，如果立即将较大的发送窗口的全部字节注入网络，由于不清楚网络状况，可能会引起拥塞。通常的做法是将cwnd设置为1个MSS，每收到一个确认，将cwnd+1，由小到大逐步增大cwnd，使分组注入网络的速率更加合理。为了防止拥塞窗口增长引起网络拥塞，还需设置一个状态变量ssthresh，即慢开始门限。</p>
<p>慢开始门限：ssthresh，当cwnd &lt; ssthresh,执行慢开始算法；cwnd &gt; ssthresh，改用拥塞避免算法。 cwnd = ssthresh时，都可以。</p>
<p>拥塞避免算法使发送端的拥塞窗口每经过一个RTT增加一个MSS（而不管在此期间收到多少ACK），这样，拥塞窗口cwnd按线性规律增长，拥塞窗口此时比慢开始增长速率缓慢很多。这一过程称为加法增大，目的在于使拥塞窗口缓慢增长，防止网络过早拥塞。</p>
<p>无论是慢开始还是拥塞避免，只要发送端发现网络出现拥塞（根据是没有按时收到ACK或者收到重复ACK），就将慢开始门限ssthresh设置为拥塞窗口值的一半并将拥塞窗口cwnd置为1，重新执行慢开始算法。这一过程称为乘法减小。目的在于迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>上述TCP确认都是通过捎带确认执行的。</p>
<p><strong>快重传和快恢复</strong></p>
<p>上述的慢开始和拥塞避免算法是早期TCP使用的拥塞控制算法。因为有时TCP连接会在重传时会因等待重传计时器的超时时间而空闲。为此在快重传中：只要发送端一连收到三个重复的ACK,即可断定分组丢失，不必等待重传计数器，立即重传丢失的报文。</p>
<p>与快重传搭配使用的还有快恢复：当不使用快恢复时，发送端若发现网络拥塞就将拥塞窗口降为1，然后执行慢开始算法，这样的缺点是网络不能很快恢复到正常状态。快恢复是指当发送端收到3个重复的ACK时，执行乘法减小，ssthresh变为拥塞窗口值的一半。但是cwnd不是置为1，而是ssthresh+3xMSS。若收到的重复ACK<br>为n(n &gt; 3)，则cwnd=ssthresh+n*MSS.这样做的理由是基于发送端已经收到3个重复的ACK，它表明已经有3个分组离开了网络，它们不在消耗网络的资源。</p>
<p>注意的是：在使用快恢复算法时，慢开始算法只在TCP连接建立时使用。</p>
<p>TCP的重传机制</p>
<p>每发送一个报文段，就对这个报文段设置一次计时器。新的重传时间=γ*旧的重传时间。</p>
<p><strong>TCP连接建立和释放的过程</strong></p>
<p>SYN置1和FIN的报文段要消耗一个序号。</p>
<p>客户端连接状态变迁：CLOSED -&gt; 主动打开,发送SYN=1 -&gt; SYN_SENT -&gt; 收到服务器的SYN=1和ACK时,发送三次握手的最后一个ACK<br>-&gt; ESTABLISHED -&gt; 数据传送 -&gt; 主动关闭 -&gt; 发送FIN=1,等待确认ACK的到达 -&gt; FIN_WAIT_1 -&gt; 收到确认ACK后 -&gt; FIN_WAIT_2<br>-&gt;收到服务器发送的FIN=1报文，响应，发送四次挥手的的最后一个确认ACK -&gt; 进入TIME_WAIT状态<br>-&gt; 经过2倍报文寿命，TCP删除连接记录 -&gt; 回到CLOSED状态 </p>
<p>服务器端连接状态变迁：CLOSED -&gt; 被动打开 -&gt; LISTEN -&gt; 收到SYN=1的报文，发送SYN=1和确认ACK -&gt; 进入SYN_RCVD -&gt; 收到三次握手<br>的最后一个确认ACK -&gt; ESTABLISHED -&gt; 数据传送 -&gt; 数据传送完毕，收到FIN=1 -&gt; 发送确认ACK并进入CLOSED_WAIT -&gt; 发送FIN=1给客户端 -&gt; LAST_ACK<br>-&gt; 收到客户端四次挥手的最后一个确认ACK -&gt; 删除连接记录 -&gt; 回到CLOSED状态 </p>
<p>应用层</p>
<p>应用层位于TCP/IP体系结构的最高一层，也是直接为应用进程服务的一层，即当不同的应用进程数据交换时，就去调用应用层的不同协议实体，让这些实体去调用传输层的TCP或者UDP来进行网络传输。具体的应用层协议有，SMTP 25、DNS 53、HTTP 80、FTP 20数据端口 21控制端口、TFTP 69、TELNET 23、SNMP 161等</p>
<p>6.网络的划分 </p>
<p>按网络拓扑结构：总线、星型、环型、树型、网状结构和混合型。</p>
<p>按覆盖范围：局域网、城域网、广域网</p>
<p>按传播方式：广播网络和点对点网络</p>
<p>广播式网络是指网络中的计算机使用一个共享信道进行数据传播，网络中的所有结点都能收到某一结点发出的数据信息。</p>
<p>单播：一对一的发送形式。</p>
<p>组播：采用一对一组的发送形式，将数据发送给网络中的某一组主机。</p>
<p>广播：采用一对所有，将数据发送给网络所有目的结点。</p>
<p>点对点网络中两个结点间的通信方式是点对点的。如果两台计算机之间没有直连的线路，则需要中间结点的接收、存储、转发直至目的结点。</p>
<p>7.TCP的三次握手和四次挥手的过程</p>
<p>连接建立（三次握手）：首先Client端发送连接请求报文SYN并进入SYN_SENT状态，Server收到后发送ACK+SYN报文，并为这次连接分配资源。Client端接收到Server端的SYN+ACK后发送三次握手的最后一个ACK，并分配资源，连接建立。</p>
<p>连接释放（四次挥手）：假设Client端发起断开连接请求，首先发送FIN=1,等待确认ACK的到达 -&gt; FIN_WAIT_1 -&gt; 收到确认Server端的确认ACK后时 -&gt; FIN_WAIT_2<br>-&gt;收到服务器发送的FIN=1报文，响应，发送四次挥手的的最后一个确认ACK -&gt;进入TIME_WAIT状态<br>-&gt; 经过2倍报文寿命，TCP删除连接记录 -&gt; 回到CLOSED状态</p>
<p>8.为什么连接建立是三次握手，而连接释放要四次挥手？</p>
<p>因为当Server端收到Client端发送的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK用来应答，SYN用来同步。但是关闭连接时，当Server端收到FIN报文后，并不会立即关闭socket，所以先回复一个ACK，告诉Client端“你的FIN我收到了”，只有等Server端的所有报文发送完了，Server端才发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
<p>9.为什么TIME_WAIT状态需要2MSL（最大报文段生存时间）才能返回Closed状态？</p>
<p>这是因为虽然双方都同意关闭连接了，而且四次挥手的报文也都协调发送完毕。但是我们必须假想网络是不可靠的，无法保证最后发送的ACK报文一定被对方收到，因此处于LAST_ACK状态下的<br>Server端可能会因未收到ACK而重发FIN，所以TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p>
<p>10.Http报文格式</p>
<p>Http请求报文格式：1.请求行 2.Http头 3.报文主体</p>
<p>请求行由三部分组成，分别是请求方法，请求地址，Http版本</p>
<p>Http头：有三种，分别为请求头（request header），普通头（General Header）和实体头（entity header）。Get方法没有实体头。</p>
<p>报文主体：只在POST方法请求中存在。</p>
<p>Http响应报文：1.状态行 2.Http头 3.返回内容</p>
<p>状态行：第一部分为Http版本，第二部分为响应状态码 第三部分为状态码的描述</p>
<p>其中第三部分为状态码的描述，信息类100-199 响应成功200-299 重定向类300-399 客户端错误400-499 服务器端错误500-599</p>
<p>Http头：响应头（Response Header），普通头（General Header）和实体头(Entity Header)</p>
<p>返回内容：即Http请求的信息，可以是HTML也可以是图片等等。</p>
<p>11.Http和Https的区别</p>
<p>Https即Secure Hypertext Transfer Protocol，即安全超文本传输协议，它是一个安全通信信道，基于Http开发，用于在客户机和服务器间交换信息。它使用安全套接字层SSL进行信息交换，是Http的安全版。</p>
<p>Https协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>Http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>http是80端口，https是443端口</p>
<p>12.浏览器输入一个URL的过程</p>
<ol>
<li><p>浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址</p>
</li>
<li><p>解析出IP地址后，根据IP地址和默认端口80和服务器建立TCP连接</p>
</li>
<li><p>浏览器发出Http请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</p>
</li>
<li><p>服务器做出响应，把对应的请求资源发送给浏览器</p>
</li>
<li><p>释放TCP连接</p>
</li>
<li><p>浏览器解析并显示内容</p>
</li>
</ol>
<p>13.中间人攻击</p>
<p>中间人获取server发给client的公钥，自己伪造一对公私钥，然后伪造自己让client以为它是server，然后将伪造的公钥发给client，并拦截client发给server的密文，用伪造的私钥即可得到client发出去的内容，最后用真实的公钥对内容加密发给server。</p>
<p>解决办法：数字证书，证书链，可信任的中间人</p>
<p>14.差错检测</p>
<p>误码率：传输错误的比特与传输总比特数的比率</p>
<p>CRC是检错方法并不能纠错，FCS（Frame Check Sequence）是冗余码。</p>
<p>计算冗余码（余数R）的方法：先补0（n个）再对生成多项式取模。</p>
<p>CRC只能表示以接近1的概率认为它没有差错。但不能做到可靠传输。可靠传输还需要确认和重传机制。</p>
<p>生成多项式P(X)：CRC-16，CRC-CCITT，CRC-32</p>
<p>15.数据链路层的协议</p>
<p>停止等待协议 - 连续ARQ - 选择重传ARQ - PPP - 以太网协议- 帧中继 - ATM - HDLC</p>
<p>16.截断二进制指数退避算法</p>
<p>是以太网用于解决当发生碰撞时就停止发送然后重发再碰撞这一问题。</p>
<p>截断二进制指数退避算法：基本退避时间为2τ k=min{重传次数，10} r=random(0~2^k-1) 重传所需时延为r倍的基本退避时间</p>
<h3 id="JavaSE基础"><a href="#JavaSE基础" class="headerlink" title="JavaSE基础"></a>JavaSE基础</h3><p>1.equals与==的区别</p>
<p>区别1.==是一个运算符 equals是Object类的方法</p>
<p>区别2.用于基本类型的变量比较时：==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。</p>
<p>b.用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。</p>
<p>2.Object有哪些公用方法？<br>clone equals hashcode wait notify notifyall finalize toString getClass<br>除了clone和finalize其他均为公共方法。</p>
<p>3.Java中的四种引用</p>
<p>StrongReference：JVM默认，只要StrongReference存在，GC将不会回收被引用的对象</p>
<p>SoftReference：尽可能长时间保留引用，直到JVM内存不足，适合某些缓存应用</p>
<p>WeakReference：尽可能长时间的存活于JVM内直到下一次GC发生前</p>
<p>PhantomReference：它是最弱的一种引用关系，也无法通过PhantomReference取得对象的实例。仅用来当该对象被回收时收到一个通知</p>
<p>4.Hashcode的作用<br>HashCode是Object类的一个方法。hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。也就是说，</p>
<p>如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等</p>
<p>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同</p>
<p>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false</p>
<p>如果两个对象的hashcode值相等，则equals方法得到的结果未知</p>
<p>注意的一点是：在重写equals方法的同时，必须重写hashCode方法。让equals方法和hashCode方法在逻辑上保持一致性。</p>
<p>为什么要重写：不重写可能会违反hashcode方法的约定，即“相等的对象必须具有相等的hashcode值”，导致对基于 hash 的集合类无法正常工作，比如说HashMap，它是使用Key对象的hashCode()和equals()方法去决定key-value对的。如果只重写equals方法，将某个对象用put方法放入散列桶中，get时可能从另外一个散列桶获取，因为两个方法的传入参数的equals虽然相同，但hashcode可能不同。</p>
<p>5.String、StringBuffer与StringBuilder的区别</p>
<p>第一点：可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</p>
<p>第二点：线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</p>
<p>6.并发和并行</p>
<p>“并行”是指无论从微观还是宏观，二者都是一起执行的，也就是同一时刻执行<br>而“并发”在微观上不是同时执行的。是在同一时间间隔交替轮流执行</p>
<p>7.switch能否用String做参数</p>
<p>Java1.7开始支持，但实际这是一颗Java语法糖。除此之外，byte，short，long，枚举，boolean均可用于switch，只有浮点型不可以。</p>
<p>8.Java语法糖</p>
<ol>
<li>Java7的switch用字符串 - 实际为hashcode方法</li>
<li>伪泛型 - 实际为List<E>原始类型</li>
<li>自动装箱拆箱 - 实际为Integer.valueOf和Integer.intValue</li>
<li>foreach遍历 - 实际为Iterator迭代器实现</li>
<li>条件编译</li>
<li>enum枚举类、内部类</li>
<li>可变参数 - 实际为数组实现</li>
<li>断言语言</li>
<li>try语句中定义和关闭资源</li>
</ol>
<p>9.try catch finally问题</p>
<p>1)不管有木有出现异常，finally块中代码都会执行 </p>
<p>2)当try和catch中有return时，finally仍然会执行</p>
<p>3)finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的</p>
<p>4)finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</p>
<p>10.受检查异常和运行时异常<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<p>1.粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 </p>
<p>2.绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… </p>
<p>3.而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 </p>
<p>11.封装、继承、多态</p>
<p><strong>封装</strong>：</p>
<p>1.概念：就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。</p>
<p>2.好处：</p>
<p>(1)隐藏内部实现细节。</p>
<p><strong>继承</strong>：</p>
<p>1.概念：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力</p>
<p>2.好处：提高代码的复用，缩短开发周期。</p>
<p><strong>多态</strong>：</p>
<p>1.概念：多态（Polymorphism）按字面的意思就是“多种状态，即同一个实体同时具有多种形式。一般表现形式是程序在运行的过程中，同一种类型在不同的条件下表现不同的结果。多态也称为动态绑定，一般是在运行时刻才能确定方法的具体执行对象。</p>
<p>2.好处：<br>1）将接口和实现分开，改善代码的组织结构和可读性，还能创建可拓展的程序。<br>2）消除类型之间的耦合关系。允许将多个类型视为同一个类型。<br>3）一个多态方法的调用允许有多种表现形式</p>
<p>12.抽象类与接口</p>
<p>1.一个子类只能继承一个抽象类,但能实现多个接口</p>
<p>2.抽象类可以有构造方法,接口没有构造方法</p>
<p>3.抽象类可以有普通成员变量,接口没有普通成员变量</p>
<p>4.抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</p>
<p>5.抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</p>
<p>6.抽象类可以有静态方法，接口不能有静态方法</p>
<p>7.抽象类中的方法可以是public、protected和默认;接口方法只有public abstract</p>
<p>13.静态内部类和普通内部类</p>
<p>静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>1.List集合和Set集合</p>
<p>List接口：</p>
<p>List中元素存取是有序的、可重复的；Set集合中元素是无序的，不可重复的。</p>
<p>CopyOnWriteArrayList:COW的策略，即写时复制的策略。适用于读多写少的并发场景</p>
<p>Set接口：</p>
<p>Set集合元素存取无序，且元素不可重复。</p>
<p>HashSet不保证迭代顺序，线程不安全；LinkedHashSet是Set接口的哈希表和链接列表的实现，保证迭代顺序，线程不安全。</p>
<p>TreeSet：可以对Set集合中的元素排序，元素以二叉树形式存放，线程不安全。</p>
<p>2.ArrayList、LinkedList、Vector的区别</p>
<p>首先它们均是List接口的实现。</p>
<p>ArrayList、LinkedList的区别</p>
<p>1.随机存取：ArrayList是基于可变大小的数组实现，LinkedList是链接列表的实现。这也就决定了对于随机访问的get和set的操作，ArrayList要优于LinkedList，因为LinkedList要移动指针。</p>
<p>2.插入和删除：LinkedList要好一些，因为ArrayList要移动数据，更新索引。</p>
<p>3.内存消耗：LinkedList需要更多的内存，因为需要维护指向后继结点的指针。</p>
<p>Vector从Java 1.0起就存在，在1.2时改为实现List接口，功能与ArrayList类似，但是Vector具备线程安全。</p>
<p>3.Map集合</p>
<p>Hashtable:基于Dictionary类，线程安全，速度快。底层是哈希表数据结构。是同步的。<br>不允许null作为键，null作为值。</p>
<p>Properties:Hashtable的子类。用于配置文件的定义和操作，使用频率非常高，同时键和值都是字符串。</p>
<p>HashMap：线程不安全，底层是数组加链表实现的哈希表。允许null作为键，null作为值。HashMap去掉了contains方法。<br>注意：HashMap不保证元素的迭代顺序。如果需要元素存取有序，请使用LinkedHashMap</p>
<p>TreeMap：可以用来对Map集合中的键进行排序。</p>
<p>ConcurrentHashMap:是JUC包下的一个并发集合。</p>
<p>为什么使用ConcurrentHashMap而不是HashMap或Hashtable？</p>
<p>HashMap的缺点：主要是多线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会死循环，CPU达到100%，所以在并发情况下不能使用HashMap。让HashMap同步：Map m = Collections.synchronizeMap(hashMap);而Hashtable虽然是同步的，使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。 </p>
<p>ConcurrentHashMap的原理：</p>
<p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因在于所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap的结构：</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，当对某个HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<p>ConcurrentHashMap的构造、get、put操作：</p>
<p>构造函数：传入参数分别为 1、初始容量，默认16 2、装载因子 装载因子用于rehash的判定，就是当ConcurrentHashMap中的元素大于装载因子*最大容量时进行扩容，默认0.75 3、并发级别 这个值用来确定Segment的个数，Segment的个数是大于等于concurrencyLevel的第一个2的n次方的数。比如，如果concurrencyLevel为12，13，14，15，16这些数，则Segment的数目为16(2的4次方)。默认值为static final int DEFAULT_CONCURRENCY_LEVEL = 16;。理想情况下ConcurrentHashMap的真正的并发访问量能够达到concurrencyLevel，因为有concurrencyLevel个Segment，假如有concurrencyLevel个线程需要访问Map，并且需要访问的数据都恰好分别落在不同的Segment中，则这些线程能够无竞争地自由访问（因为他们不需要竞争同一把锁），达到同时访问的效果。这也是为什么这个参数起名为“并发级别”的原因。默认16.</p>
<p>初始化的一些动作：</p>
<p>初始化segments数组（根据并发级别得到数组大小ssize），默认16</p>
<p>初始化segmentShift和segmentMask（这两个全局变量在定位segment时的哈希算法里需要使用），默认情况下segmentShift为28，segmentMask为15</p>
<p>初始化每个Segment，这一步会确定Segment里HashEntry数组的长度.</p>
<p>put操作：</p>
<p>1、判断value是否为null，如果为null，直接抛出异常。</p>
<p>2、key通过一次hash运算得到一个hash值。将得到hash值向右按位移动segmentShift位，然后再与segmentMask做&amp;运算得到segment的索引j。即segmentFor方法</p>
<p>3、使用Unsafe的方式从Segment数组中获取该索引对应的Segment对象。向这个Segment对象中put值，这个put操作也基本是一样的步骤（通过&amp;运算获取HashEntry的索引，然后set）。</p>
<p>get操作：</p>
<p>1、和put操作一样，先通过key进行hash确定应该去哪个Segment中取数据。</p>
<p>2、使用Unsafe获取对应的Segment，然后再进行一次&amp;运算得到HashEntry链表的位置，然后从链表头开始遍历整个链表（因为Hash可能会有碰撞，所以用一个链表保存），如果找到对应的key，则返回对应的value值，如果链表遍历完都没有找到对应的key，则说明Map中不包含该key，返回null。</p>
<p>定位Segment的hash算法：(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask</p>
<p>定位HashEntry所使用的hash算法：int index = hash &amp; (tab.length - 1);</p>
<p>注：tab为HashEntry数组</p>
<p>4.Collection 和 Collections的区别</p>
<p>Collection是集合类的上级接口，子接口主要有Set 和List、Queue<br>Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<p>5.Map、Set、List、Queue、Stack的特点与用法</p>
<p>Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。 List集合代表元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。 Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(LIFO后进先出) Queue用于模拟”队列”这种数据结构(先进先出 FIFO)。 Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值。</p>
<p>6.HashMap的工作原理</p>
<p>HashMap维护了一个Entry数组，Entry内部类有key,value，hash和next是个字段，其中next也是一个Entry类型。可以将Entry数组理解为一个个的散列桶。每一个桶实际上是一个单链表。当执行put操作时，会根据key的hashcode定位到相应的桶。遍历单链表检查该key是否已经存在，如果存在，覆盖该value，反之，新建一个新的Entry，并放在单链表的头部。当通过传递key调用get方法时，它再次使用key.hashCode()来找到相应的散列桶，然后使用key.equals()方法找出单链表中正确的Entry，然后返回它的值。</p>
<p>7.HashMap和Hashtable的区别</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Hashtable是基于陈旧的Dictionary的Map接口的实现，而HashMap是基于哈希表的Map接口的实现</li>
<li><input checked="" disabled="" type="checkbox"> 从方法上看，HashMap去掉了Hashtable的contains方法</li>
<li><input checked="" disabled="" type="checkbox"> HashTable是同步的(线程安全)，而HashMap线程不安全</li>
<li><input checked="" disabled="" type="checkbox"> HashMap允许空键值，而Hashtable不允许</li>
<li><input checked="" disabled="" type="checkbox"> HashMap的iterator迭代器执行快速失败机制，也就是说在迭代过程中修改集合结构，除非调用迭代器自身的remove方法，否则以其他任何方式的修改都将抛出并发修改异常。如果寻求迭代的时候修改Map，可以使用ConcurrentHashMap。而Hashtable返回的Enumeration不是快速失败的。</li>
</ul>
<p>8.Map的实现类的介绍</p>
<p>HashMap基于散列表来的实现，即使用hashCode()进行快速查询元素的位置，显著提高性能。插入和查询“键值对”的开销是固定的。可以通过设置容量和装载因子，以调整容器的性能。</p>
<p>LinkedHashMap, 类似于HashMap,但是迭代遍历它时，保证迭代的顺序是其插入的次序，因为它使用链表维护内部次序。此外可以在构造器中设定LinkedHashMap，使之采用LRU算法。使没有被访问过的元素或较少访问的元素出现在前面，访问过的或访问多的出现在后面。这对于需要定期清理元素以节省空间的程序员来说，此功能使得程序员很容易得以实现。</p>
<p>TreeMap, 是基于红黑树的实现。同时TreeMap实现了SortedMap接口，该接口可以确保键处于排序状态。所以查看“键”和“键值对”时，所有得到的结果都是经过排序的，次序由自然排序或提供的Comparator决定。SortedMap接口拥有其他额外的功能，如：返回当前Map使用的Comparator比较强，firstKey()，lastKey(),headMap(toKey),tailMap(fromKey)以及可以返回一个子树的subMap()方法等。</p>
<p>WeakHashMap，表示弱键映射，WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<p>ConcurrentHashMap， 在HashMap基础上分段锁机制实现的线程安全的HashMap。</p>
<p>IdentityHashMap 使用==代替equals() 对“键”进行比较的散列映射。专为解决特殊问题而设计。</p>
<p>HashTable：基于Dictionary类的Map接口的实现，它是线程安全的。</p>
<p>9.LinkedList 和 PriorityQueue 的区别</p>
<p>它们均是Queue接口的实现。拥有FIFO的特点，它们的区别在于排序行为。LinkedList 支持双向列表操作，<br>PriorityQueue 按优先级组织的队列，元素的出队次序由元素的自然排序或者由Comparator比较器指定。</p>
<p>10.线程安全的集合类。Vector、HashTable、Properties和Stack</p>
<p>11.BlockingQueue</p>
<p>Java.util.concurrent.BlockingQueue是一个队列，在进行获取元素时，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p>
<p>12.如何对一组对象进行排序</p>
<p>如果需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collections.sort()方法。排序时是默认根据元素的自然排序（使用Comparable）或使用Comparator外部比较器。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。</p>
<p>13.Comparable和Comparator接口区别</p>
<p>Comparator位于包java.util下，而Comparable位于包java.lang下</p>
<p>如果我们需要使用Arrays或Collections的排序方法对对象进行排序时，我们需要在自定义类中实现Comparable接口并重写compareTo方法，compareTo方法接收一个参数，如果this对象比传递的参数小，相等或大时分别返回负整数、0、正整数。Comparable被用来提供对象的自然排序。String、Integer实现了该接口。</p>
<p>Comparator比较器的compare方法接收2个参数，根据参数的比较大小分别返回负整数、0和正整数。<br>Comparator 是一个外部的比较器，当这个对象自然排序不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。</p>
<p>14.与Java集合框架相关的有哪些最好的实践</p>
<p>（1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。<br>（2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。<br>（3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。<br>（4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。<br>（5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。</p>
<h3 id="IO-NIO"><a href="#IO-NIO" class="headerlink" title="IO/NIO"></a>IO/NIO</h3><p>1.IO和NIO</p>
<p>在以前的Java IO中，都是阻塞式IO，NIO引入了非阻塞式IO。<br>第一种方式：我从硬盘读取数据，然后程序一直等，数据读完后，继续操作。这种方式是最简单的，叫阻塞IO。<br>第二种方式：我从硬盘读取数据，然后程序继续向下执行，等数据读取完后，通知当前程序（对硬件来说叫中断，对程序来说叫回调），然后此程序可以立即处理数据，也可以执行完当前操作在读取数据。</p>
<p>2.流与块的比较</p>
<p>原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。这样做是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。<br>一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>3.通道与流</p>
<p>Channel是一个对象，可以通过它读取和写入数据。通道与流功能类似，不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而通道可以用于读、写或者同时用于读写。</p>
<p>4.缓冲区Buffer</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在 NIO 库中，所有数据都是用缓冲区处理的。</p>
<p>Position: 表示下一次访问的缓冲区位置<br>Limit: 表示当前缓冲区存放的数据容量。<br>Capacity:表示缓冲区最大容量</p>
<p>flip()方法:它将 limit 设置为当前 position。它将 position 设置为 0</p>
<p>clear方法:它将 limit 设置为与 capacity 相同。它设置 position 为 0。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1.什么是线程</p>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100 毫秒，那么用十个线程完成改任务只需 10 毫秒。Java在语言层面对多线程提供了很好的支持。</p>
<p>2.线程和进程有什么区别</p>
<p>从概念上：<br>进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。<br>线程：存在于进程内，是进程内的基本调度单位。共享进程的资源。</p>
<p>从执行过程中来看：<br>进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。<br>线程：每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看：（重要区别）<br>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。</p>
<p>简言之，一个程序至少有一个进程,一个进程至少有一个线程。进程是资源分配的基本单位，线程共享进程的资源。</p>
<p>3.如何在 Java 中实现线程</p>
<p>继承Thread类或实现Runnable接口。</p>
<p>4.用 Runnable 还是 Thread</p>
<p>Java 不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是实现Runnable接口好了。</p>
<p>5.Thread 类中的 start () 和 run () 方法有什么区别</p>
<p>start ()方法被用来启动新创建的线程，而且 start ()内部调用了 run ()方法，这和直接调用 run ()方法的效果不一样。当你调用 run ()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start ()方法才会启动新线程。也就是用start方法来启动线程,才是真正实现了多线程。而run方法只是一个普通方法。</p>
<p>6.Java 中 Runnable 和 Callable 有什么不同</p>
<p>Runnable和 Callable 都代表那些要在不同的线程中执行的任务。Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的。它们的主要区别是 Callable 的 call () 方法可以返回值和抛出异常，而 Runnable 的 run ()方法没有这些功能。</p>
<p>7.Java 中 CyclicBarrier 和 CountDownLatch 有什么不同</p>
<p>它们都是JUC下的类，CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。区别在于CountdownLatch计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 </p>
<p>8.Java 内存模型是什么</p>
<p>Java 内存模型规定和指引Java 程序在不同的内存架构、CPU 和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。</p>
<p>线程内的代码能够按先后顺序执行，这被称为程序次序规则。</p>
<p>对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。</p>
<p>前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。</p>
<p>一个线程内的任何操作必需在这个线程的 start ()调用之后，也叫作线程启动规则。</p>
<p>一个线程的所有操作都会在线程终止之前，线程终止规则。</p>
<p>一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。</p>
<p>传递性</p>
<p>9.Java 中的 volatile 变量是什么</p>
<p>Java 语言提供了一种稍弱的同步机制,即<code>volatile</code>变量。但是volatile并不容器完全被正确、完整的理解。<br>一般来说，volatile具备2条语义，或者说2个特性。第一是保证volatile修饰的变量对所有线程的可见性，这里的可见性是指当一条线程修改了该变量，新值对于其它线程来说是立即可以得知的。而普通变量做不到这一点。</p>
<p>第二条语义是禁止指令重排序优化，这条语义在JDK1.5才被修复。</p>
<p>关于第一点：根据JMM，所有的变量存储在主内存，而每个线程还有自己的工作内存，线程的工作内存保存该线程使用到的变量的主内存副本拷贝，线程对变量的操作在工作内存中进行，不能直接读写主内存的变量。在volatile可见性这一点上，普通变量做不到的原因正因如此。比如，线程A修改了一个普通变量的值，然后向主内存进行回写，线程B在线程A回写完成后再从主内存读取，新变量才能对线程B可见。其实，按照虚拟机规范，volatile变量依然有工作内存的拷贝，要借助主内存来实现可见性。但由于volatile的特殊规则保证了新值能立即同步回主内存，以及每次使用从主内存刷新，以此保证了多线程操作volatile变量的可见性。</p>
<p>关于第二点：先说指令重排序，指令重排序是指CPU采用了允许将多条指令不按规定顺序分开发送给相应的处理单元处理，但并不是说任意重排，CPU需要正确处理指令依赖情况确保最终的正确结果，指令重排序是机器级的优化操作。那么为什么volatile要禁止指令重排序呢，又是如何去做的。举例，DCL（双重检查加锁）的单例模式。volatile修饰后，代码中将会插入许多内存屏障指令保证处理器不发生乱序执行。同时由于Happens-before规则的保证，在刚才的例子中写操作会发生在后续的读操作之前。</p>
<p>除了以上2点，volatile还保证对于64位long和double的读取是原子性的。因为在JMM中允许虚拟机对未被volatile修饰的64位的long和double读写操作分为2次32位的操作来执行，这也就是所谓的long和double的非原子性协定。</p>
<p>基于以上几点，我们知道volatile虽然有这些语义和特性在并发的情况下仍然不能保证线程安全。大部分情况下仍然需要加锁。</p>
<p>除非是以下2种情况，1.运算结果不依赖变量的当前值，或者能够确保只有单一线程修改变量的值；2.变量不需要与其他的状态变量共同参与不变约束。</p>
<p>10.Java 中，编写多线程程序的时候你会遵循哪些最佳实践？</p>
<p>a）给线程命名，这样可以帮助调试。<br>b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。<br>c）如果可以，更偏向于使用 volatile 而不是 synchronized。<br>d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。<br>e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p>
<p>11.什么是线程安全？Vector 是一个线程安全类吗</p>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的， 而和它相似的 ArrayList 不是线程安全的。</p>
<p>12.Java 中什么是竞态条件？ 举个例子说明。</p>
<p>竞态条件会导致程序在并发情况下出现一些 bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的 bugs。这种 bugs 很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理。</p>
<p>13.Java 中如何停止一个线程</p>
<p>当 run () 或者 call () 方法执行完的时候线程会自动结束，如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run ()方法的循环或者是取消任务来中断线程。其他情形：异常 - 停止执行 休眠 - 停止执行 阻塞 - 停止执行</p>
<p>14.一个线程运行时发生异常会怎样</p>
<p>简单的说，如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 Thread.getUncaughtExceptionHandler ()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException ()方法进行处理。</p>
<p>15.如何在两个线程间共享数据？</p>
<p>通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构</p>
<p>16.Java 中 notify 和 notifyAll 有什么区别</p>
<p>notify ()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而 notifyAll ()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p>
<p>17.为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面</p>
<p>一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的。如果线程需要等待某些锁那么调用对象中的 wait ()方法就有意义了。如果 wait ()方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。</p>
<p>18.什么是ThreadLocal</p>
<p>ThreadLocal，线程局部变量。</p>
<p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p>
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。</p>
<p>ThreadLocal是如何为每个线程创建变量的副本的：</p>
<p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>总结：</p>
<p>a.实际通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的</p>
<p>b.为何threadLocals的键为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p>
<p>c.在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法</p>
<p>19.什么是 FutureTask？</p>
<p>在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable 接口所以它可以提交给 Executor 来执行。</p>
<p>20.Java 中 interrupted 和 isInterruptedd 方法的区别</p>
<p>interrupted是静态方法，isInterruptedd是一个普通方法</p>
<p>如果当前线程被中断（没有抛出中断异常，否则中断状态就会被清除），你调用interrupted方法，第一次会返回true。然后，当前线程的中断状态被方法内部清除了。第二次调用时就会返回false。如果你刚开始一直调用isInterrupted，则会一直返回true，除非中间线程的中断状态被其他操作清除了。也就是说isInterrupted 只是简单的查询中断状态，不会对状态进行修改。</p>
<p>21.为什么 wait 和 notify 方法要在同步块中调用</p>
<p>如果不这么做，代码会抛出 IllegalMonitorStateException异常。还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</p>
<p>22.为什么你应该在循环中检查等待条件？</p>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在 notify ()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用 wait ()方法效果更好的原因。</p>
<p>23.Java 中的同步集合与并发集合有什么区别</p>
<p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java1.5加入了并发集合像 ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。它们大部分位于JUC包下。</p>
<p>24.Java 中堆和栈有什么不同</p>
<p>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时 volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<p>25.什么是线程池？ 为什么要使用它？</p>
<p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从 JDK1.5 开始，Java API 提供了 Executor 框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。</p>
<p>26.如何写代码来解决生产者消费者问题？</p>
<p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用 wait 和 notify 来解决这个问题，比较赞的办法是用 Semaphore 或者 BlockingQueue 来实现生产者消费者模型。</p>
<p>27.如何避免死锁？</p>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<p>互斥条件：一个资源每次只能被一个进程使用。</p>
<p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<p>28.Java 中活锁和死锁有什么区别？</p>
<p>活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<p>29.怎么检测一个线程是否拥有锁</p>
<p>在 java.lang.Thread 中有一个方法叫 holdsLock ()，当且仅当当前线程拥有某个具体对象的锁时它返回true。</p>
<p>30.你如何在 Java 中获取线程堆栈</p>
<p>eak 组合键来获取线程堆栈，Linux 下用 kill -3 命令。你也可以用 jstack 这个工具来获取，它对线程 id 进行操作，你可以用 jps 这个工具找到 id。</p>
<p>31.JVM内存配置参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.-Xmx:最大堆大小</span><br><span class="line">2.-Xms:初始堆大小(最小内存值)</span><br><span class="line">3.-Xmn:年轻代大小</span><br><span class="line">4.-XXSurvivorRatio:3 意思是Eden:Survivor=3:2</span><br><span class="line">5.-Xss栈容量</span><br><span class="line">6.-XX:+PrintGC 输出GC日志</span><br><span class="line">7.-XX:+PrintGCDetails 输出GC的详细日志</span><br></pre></td></tr></table></figure>

<p>32.Java 中 synchronized 和 ReentrantLock 有什么不同</p>
<p>Java 在过去很长一段时间只能通过 synchronized 关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过 Lock 接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<p>33.有三个线程 T1，T2，T3，怎么确保它们按顺序执行</p>
<p>可以用线程类的 join ()方法。具体操作是在T3的run方法中调用t2.join()，让t2执行完再执行t3；T2的run方法中调用t1.join()，让t1执行完再执行t2。这样就按T1，T2，T3的顺序执行了</p>
<p>34.Thread 类中的 yield 方法有什么作用</p>
<p>Yield 方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃 CPU 占用而不能保证使其它线程一定能占用 CPU，执行 yield ()的线程有可能在进入到暂停状态后马上又被执行。</p>
<p>35.Java 中 ConcurrentHashMap 的并发度是什么</p>
<p>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</p>
<p>36.Java 中 Semaphore是什么</p>
<p>JUC下的一种新的同步类，它是一个计数信号。从概念上讲，Semaphore信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire ()，然后再获取该许可。每个 release ()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<p>37.如果你提交任务时，线程池队列已满。会发会生什么？</p>
<p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么 ThreadPoolExecutor’s submit ()方法将会抛出一个 RejectedExecutionException 异常。</p>
<p>38.Java 线程池中 submit () 和 execute ()方法有什么区别</p>
<p>两个方法都可以向线程池提交任务，execute ()方法的返回类型是 void，它定义在 Executor 接口中， 而 submit ()方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</p>
<p>39.什么是阻塞式方法？</p>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的 accept ()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p>
<p>40.Swing 是线程安全的吗？</p>
<p>你可以很肯定的给出回答，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。</p>
<p>41.Java 中 invokeAndWait 和 invokeLater 有什么区别</p>
<p>这两个方法是 Swing API 提供给 Java 开发者用来从当前线程而不是事件派发线程更新 GUI 组件用的。InvokeAndWait ()同步更新 GUI 组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用 invokeAndWait ()方法请求事件派发线程对组件进行相应更新。而 invokeLater ()方法是异步调用更新组件的。</p>
<p>42.Swing API 中那些方法是线程安全的？</p>
<p>虽然Swing不是线程安全的但是有一些方法是可以被多线程安全调用的。如repaint ()， revalidate ()。 JTextComponent 的 setText ()方法和 JTextArea 的 insert () 和 append () 方法也是线程安全的。</p>
<p>43.如何在 Java 中创建 Immutable 对象</p>
<p>Immutable 对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是 Java 没有@Immutable 这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供 setter 方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在 getter 方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p>
<p>44.Java 中的 ReadWriteLock 是什么？</p>
<p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java 中的 ReadWriteLock 是 Java 5 中新增的一个接口，一个 ReadWriteLock 维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用 JDK 中的 ReentrantReadWriteLock 来实现这个规则，它最多支持 65535 个写锁和 65535 个读锁。</p>
<p>45.多线程中的忙循环是什么?</p>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法 wait ()， sleep () 或 yield () 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<p>46.volatile 变量和 atomic 变量有什么不同</p>
<p>volatile 变量和 atomic 变量看起来很像，但功能却不一样。volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前， 但它并不能保证原子性。例如用 volatile 修饰 count 变量那么 count++ 操作并不是原子性的。而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如 getAndIncrement ()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<p>47.如果同步块内的线程抛出异常会发生什么？</p>
<p>无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在 finally block 里释放锁实现。</p>
<p>48.如何在 Java 中创建线程安全的 Singleton</p>
<p>5种，急加载，同步方法，双检锁，静态内部类，枚举</p>
<p>49.如何强制启动一个线程？</p>
<p>这个问题就像是如何强制进行 Java 垃圾回收，目前还没有觉得方法，虽然你可以使用 System.gc ()来进行垃圾回收，但是不保证能成功。在 Java 里面没有办法强制启动一个线程，它是被线程调度器控制着且 Java 没有公布相关的 API。</p>
<p>50.Java 中的 fork join 框架是什么？</p>
<p>fork join 框架是 JDK7 中出现的一款高效的工具，Java 开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join 框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p>
<p>51.Java 多线程中调用 wait () 和 sleep ()方法有什么不同？</p>
<p>Java 程序中 wait 和 sleep 都会造成某种形式的暂停，它们可以满足不同的需要。wait ()方法意味着条件等待，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep ()方法仅仅释放 CPU 资源或者让当前线程短暂停顿，但不会释放锁。</p>
<p>52.双亲委派模型中的方法</p>
<p>findLoadedClass(),LoadClass(),findBootstrapClassOrNull(),findClass(),resolveClass()</p>
<p>53.NIO、AIO、BIO</p>
<p>BIO即同步阻塞IO，适用于连接数目较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4之前的唯一选择，但程序直观、简单、易理解。</p>
<p>NIO即同步非阻塞IO，适用于连接数目多且连接比较短的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO即异步非阻塞IO，适用于连接数目多且连接比较长的架构，如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK1.7开始支持</p>
<h3 id="GC、内存相关"><a href="#GC、内存相关" class="headerlink" title="GC、内存相关"></a>GC、内存相关</h3><p>1.对哪些区域回收<br>Java运行时数据区域：程序计数器、JVM栈、本地方法栈、方法区和堆。</p>
<p>由于程序计数器、JVM栈、本地方法栈3个区域随线程而生随线程而灭，对这几个区域内存的回收和分配具有确定性。而方法区和堆则不一样，程序需要在运行时才知道创建哪些对象，对这部分内存的分配是动态的，GC关注的也就是这部分内存。</p>
<p>2.如何判定对象需要回收<br>引用计数法：给对象加上一个计数器，当有一个地方引用它，计数器+1，引用失效时，计数器-1，当计数器为0时，判定该对象可回收。引用计数法优点是实现简单，python，flashplayer等使用引用计数法进行内存管理。引用计数法的缺点在于无法解决循环引用的问题。</p>
<p>在Java中使用可达性分析算法法判定对象是否“死亡”。可达性分析法是指通过称为GC-Roots的对象为起始点，从这些结点向下搜索，当从GCRoots到这个对象不可达时，被判定为可收回的对象。</p>
<p>3.可作为GC Roots的对象</p>
<p>可作为GC Roots的对象：虚拟机栈中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象</p>
<p>4.对象的自我救赎</p>
<p>即使在可达性算法中判定为不可达时，也并非一定被回收。对象存在自我救赎的可能。要真正宣告对象的死亡，需要经历2次标记的过程。如果对象经过可达性分析法发现不可达时，对象将被第一次标记被进行筛选，筛选的条件是此对象是否有必要执行finalize方法。如果对象没有重写finalize方法或finalize方法已经被JVM调用过，则判定为不需要执行。</p>
<p>如果对象被判定为需要执行finalize方法，该对象将被放置在一个叫做F-Queue的队列中，JVM会建立一个低优先级的线程执行finalize方法，如果对象想要完成自我救赎需要在finalize方法中与引用链上的对象关联，比如把自己也就是this赋值给某个类变量。当GC第二次对F-Queue中对象标记时，该对象将被移出“即将回收”的集合，完成自我救赎。简言之，finalize方法是对象逃脱死亡命运的最后机会，并且任何对象的finalize方法只会被JVM调用一次。</p>
<p>5.垃圾回收算法</p>
<p>Mark-Sweep法：标记清除法 容易产生内存碎片，导致分配较大对象时没有足够的连续内存空间而提前出发GC。这里涉及到另一个问题，即对象创建时的内存分配，对象创建内存分配主要有2种方法，分别是指针碰撞法和空闲列表法。指针碰撞法：使用的内存在一侧，空闲的在另一侧，中间使用一个指针作为分界点指示器，对象内存分配时只要指针向空闲的移动对象大小的距离即可。<br>空闲列表法：使用的和空闲的内存相互交错无法进行指针碰撞，JVM必须维护一个列表记录哪些内存块可用，分配时从列表中找出一个足够的分配给对象，并更新列表记录。所以，当采用Mark-Sweep算法的垃圾回收器时，内存分配通常采用空闲列表法。</p>
<p>Copy法：将内存分为2块，每次使用其中的一块，当一块满了，将存活的对象复制到另一块，把使用过的那一块一次性清除。显然，Copy法解决了内存碎片的问题，但算法的代价是内存缩小为原来的一半。现代的垃圾收集器对新生代采用的正是Copy算法。但通常不执行1:1的策略，HotSpot虚拟机默认Eden区Survivor区8:1。每次使用Eden和其中一块Survivor区。也就是说新生代可用内存为新生代内存空间的90%。</p>
<p>Mark-Compact法：标记整理法。它的第一阶段与Mark-Sweep法一样，但不直接清除，而是将存活对象向一端移动，然后清除端边界以外的内存，这样也不存在内存碎片。</p>
<p>分代收集算法：将堆内存划分为新生代，老年代，根据新生代老年代的特点选取不同的收集算法。因为新生代对象大多朝生夕死，而老年代对象存活率高，没有额外空间进行分配担保，通常对新生代执行复制算法，老年代执行Mark-Sweep算法或Mark-Compact算法。</p>
<p>6.垃圾收集器</p>
<p>通常来说，新生代老年代使用不同的垃圾收集器。新生代的垃圾收集器有Serial（单线程）、ParNew（Serial的多线程版本）、ParallelScavenge（吞吐量优先的垃圾收集器），老年代有SerialOld（单线程老年代）、ParallelOld（与ParallelScavenge搭配的多线程执行标记整理算法的老年代收集器）、CMS（标记清除算法，容易产生内存碎片，可以开启内存整理的参数），以及当前最先进的垃圾收集器G1，G1通常面向服务器端的垃圾收集器，在我自己的Java应用程序中通过-XX:+PrintGCDetails，发现自己的垃圾收集器是使用了ParallelScavenge+ParallelOld的组合。</p>
<p>7.内存分配和回收的策略</p>
<p>1.对象优先在Eden区分配，默认Eden与Survivor的比例为8:1</p>
<p>2.大对象直接进入老年代</p>
<p>3.长期存活的进入老年代：JVM给每个对象定义一个年龄计数器，当对象在Eden区出生并躲过一次MinorGC，并且Survivor可以容纳的话，将被移入Survivor区，年龄设为1。以后每在Survivor区躲过一次MinorGC，年龄加一岁，当对象年龄加到15岁时，晋升到老年代。当然15岁的默认值可以通过-XX虚拟机参数设置。</p>
<p>4.动态对象年龄判定：有的时候无需到达15岁即晋升老年代。判定方法是如果Survivor区中相同年龄的所有对象大小的总和大于Survivor区空间的一半，年龄大于或等于该年龄的对象直接进入老年代</p>
<p>5.空间分配担保</p>
<p>在发生MinorGC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象总和，如果成立，确保这次MinorGC安全。否则，虚拟机会查看HandlePromotionFailure设置是否允许担保失败。如果允许，虚拟机会接着查看老年代最大连续可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，则进行一次MinorGC，尽管这次MinorGC是有风险的，如果小于或者HandlePromotionFailure设置为不允许，要改为一次FullGC</p>
<p>8.方法区的回收</p>
<p>方法区通常会与永久代划等号，实际上二者并不等价，只不过是HotSpot虚拟机设计者用永久代实现方法区，并将GC分代扩展至方法区。<br>永久代垃圾回收通常包括两部分内容：废弃常量和无用的类。常量的回收与堆区对象的回收类似，当没有其他地方引用该字面量时，如果有必要，将被清理出常量池。</p>
<p>判定无用的类的3个条件：</p>
<p>1.该类的所有实例都已经被回收，也就是说堆中不存在该类的任何实例</p>
<p>2.加载该类的ClassLoader已经被回收</p>
<p>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>当然，这也仅仅是判定，不代表立即卸载该类。</p>
<p>9.Java中有内存泄漏吗？</p>
<p>内存泄露的定义: 当某些对象不再被应用程序所使用,但是由于仍然被引用而导致垃圾收集器不能释放。</p>
<p>内存泄漏的原因：对象的生命周期不同。比如说</p>
<p>对象A引用了对象B. A的生命周期比B的要长得多，当对象B在应用程序中不会再被使用以后, 对象 A 仍然持有着B的引用. (根据虚拟机规范)在这种情况下GC不能将B从内存中释放. 这种情况很可能会引起内存问题，倘若A还持有着其他对象的引用,那么这些被引用的(无用)对象也不会被回收,并占用着内存空间。甚至有可能B也持有一大堆其他对象的引用。这些对象由于被 B 所引用,也不会被垃圾收集器所回收，所有这些无用的对象将消耗大量宝贵的内存空间。并可能导致内存泄漏</p>
<p>怎样防止：</p>
<p>1、当心集合类,比如HashMap,ArrayList等,因为这是最容易发生内存泄露的地方.当集合对象被声明为static时,他们的生命周期一般和整个应用程序一样长。</p>
<p>10.OOM解决办法、</p>
<p>内存溢出的空间：Permanent Generation和Heap Space，也就是永久代和堆区</p>
<p>第一种情况永久代的溢出：出现这种问题的原因可能是应用程序加载了大量的jar或class，使虚拟机装载类的空间不够，与Permanent Generation Space的大小有关。</p>
<p>解决办法有2种：1、通过虚拟机参数-XX：PermSize和-XX：MaxPermSize调整永久代大小 2、清理程序中的重复的Jar文件，减少类的重复加载</p>
<p>第二种堆区的溢出：发生这种问题的原因是java虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了，与Heap Space的size有关。解决这类问题有两种思路：</p>
<p>1、检查程序，看是否存在死循环或不必要地重复创建大量对象，定位原因，修改程序和算法。</p>
<p>2、通过虚拟机参数-Xms和-Xmx设置初始堆和最大堆的大小</p>
<p>11.DirectMemory直接内存</p>
<p>直接内存并不是Java虚拟机规范定义的内存区域的一部分，但是这部分内存也被频繁使用，而且也可能导致OOM异常的出现。</p>
<p>JDK1.4引入了NIO，这是一种基于通道和缓冲区的非阻塞IO模式，它可以使用Native函数库分配直接堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，使得在某些场合显著提高性能，因为它避免了在Java堆和本地堆之间来回复制数据。</p>
<h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><p>1.如何判断链表是否有环</p>
<p>方法1：快慢指针法 2.设两个工作指针p、q，p总是向前走，但q每次都从头开始走，对于每个节点，看p走的步数是否和q一样。比如p从A走到D，用了4步，而q则用了14步。因而步数不等，出现矛盾，存在环。</p>
<p>2.红黑树</p>
<p><strong>二叉搜索树</strong>:(Binary Search Tree又名：二叉查找树，二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： 若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。</p>
<p>红黑树是一棵二叉搜索树，它在每个结点上增加一个存储位来表示结点的颜色，可以是RED或BLACK。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树没有一条路径会比其他路径长出2倍，所以红黑树是近似平衡的，使得红黑树的查找、插入、删除等操作的时间复杂度最坏为O(log n)，但需要注意到在红黑树上执行插入或删除后将不在满足红黑树性质，恢复红黑树的属性需要少量(O(log<br>n))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操<br>作时间仍可以保持为 O(log n) 次。具体如何保证？引出红黑树的5个性质。</p>
<p>红黑树的5个性质：满足以下五个性质的二叉搜索树</p>
<ol>
<li>每个结点或是红色的或是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点是黑色的</li>
<li>如果一个结点是红色的,则它的两个子结点是黑色的</li>
<li>对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点</li>
</ol>
<p>插入操作：</p>
<p>由于性质的约束，插入的结点都是红色的。插入时性质1、3始终保持。破坏性质2当且仅当当前插入结点为根节点。变一下颜色即可。如果是破坏性质4或5，则需要旋转和变色来继续满足红黑树的性质。下面说一说插入的几种情况，约定当前插入结点为N，其父结点为P，叔叔为U，祖父为G</p>
<p>情形1：树空，直接插入违反性质1，将红色改黑。</p>
<p>情形2：N的父结点为黑，不必修改，直接插入</p>
<p>从情形3开始的情形假定N结点的父结点P为红色，所以存在G，并且G为黑色。且N存在一个叔叔结点U，尽管U可能为叶结点。</p>
<p>情形3：P为红，U为红（G结点一定存在且为黑）这里不论P是G的左孩子还是右孩子；不论N是P的左孩子还是右孩子。</p>
<p>首先把P、U改黑，G改红，并以G作为一个新插入的红结点重新进行各种情况的检查，若一路检索至根节点还未结束，则将根结点变黑。</p>
<p>情形4：P为红，U为黑或不存在（G结点一定存在且为黑），且P为G的左孩子，N为P的左孩子（或者P为G的右孩子，N为P的右孩子，保证同向的）。<br>P、G右旋并将P、G变相反色。因为P取代之前黑G的位置，所以P变黑可以理解，而G变红是为了不违反性质5。</p>
<p>情形5：P为红，U为黑或不存在，且P为G的左孩子，N为P的右孩子（或P为G的右孩子，N为P的左孩子，保证是反向的），对N，P进行一次左旋转换为情形4</p>
<p>删除操作比插入复杂一些，但最多不超过三次旋转可以让红黑树恢复平衡。</p>
<p>其他</p>
<ul>
<li>黑高从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。红黑树的黑高为其根结点的黑高。</li>
<li>一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1)</li>
<li>结点的属性(五元组):color key left right p</li>
<li>动态集合操作最坏时间复杂度为O(lgn)</li>
</ul>
<p>3.数据库索引的实现</p>
<p>数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>B树：</p>
<p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录。那么B-Tree是满足下列条件的数据结构：</p>
<ol>
<li><p>d为大于1的一个正整数，称为B-Tree的度。用来表示每个结点包含的关键字个数的上界和下界。可以证明h&lt;=logd((N+1)/2)</p>
</li>
<li><p>h为一个正整数，称为B-Tree的高度。</p>
</li>
<li><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
</li>
<li><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
</li>
<li><p>所有叶节点具有相同的深度，等于树高h。</p>
</li>
<li><p>key和指针互相间隔，节点两端是指针。</p>
</li>
<li><p>一个节点中的key从左到右非递减排列。</p>
</li>
<li><p>所有节点组成树结构。</p>
</li>
<li><p>每个指针要么为null，要么指向另外一个节点。</p>
</li>
<li><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</p>
</li>
<li><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p>
</li>
<li><p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。</p>
</li>
</ol>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。</p>
<p>一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>B+树：</p>
<p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>B+树是B树的变形，它把所有的data都放在叶子结点中，只将关键字和子女指针保存于内结点，内结点完全是索引的功能。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>1、每个节点的指针上限为2d而不是2d+1。</p>
<p>2、内节点不存储data，只存储key；叶子节点存储data不存储指针。</p>
<p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针</p>
<p>例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<p>为什么B树（B+树）？</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<p>这涉及到磁盘存取原理、局部性原理和磁盘预读。</p>
<p>先从B-Tree分析，根据B-Tree的定义，<strong>可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</strong>为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p><strong>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</strong></p>
<p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</strong></p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>至于B+Tree为什么更适合外存索引，原因和内节点出度d有关。</p>
<p>由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>4.一致性Hash</p>
<p>第一：简单介绍<br>一致性哈希算法是分布式系统中常用的算法。比如，一个分布式的存储系统，要将对象存储到具体的节点上，如果采用普通的hash方法，将数据映射到具体的节点上，如key%N，N是机器节点数。</p>
<p>1、考虑到比如一个服务器down掉，服务器结点N变为N-1，映射公式必须变为key%(N-1)</p>
<p>2、访问量加重，需要添加服务器结点，N变为N+1，映射公式变为hash(object)%(N+1)</p>
<p>当出现1,2的情况意味着我们的映射都将无效，对服务器来说将是一场灾难，尤其是对缓存服务器来说，因为缓存服务器映射的失效，洪水般的访问都将冲向后台服务器。</p>
<p>第二点：hash算法的单调性</p>
<p>Hash 算法的一个衡量指标是单调性，单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p>
<p>consistent hash 也是一种hash 算法，简单的说，在移除 / 添加一个结点时，它能够尽可能小的改变已存在的映射关系，尽可能的满足单调性的要求。</p>
<p>第三点：将对象和服务器结点分别映射到环型空间</p>
<p>通常的一致性哈希做法是将 value 映射到一个 32 位的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环。</p>
<p>我们可以通过hash函数将我们的key映射到环型空间中，同时根据相同的哈希算法把服务器也映射到环型空间中，顺便提一下服务器或者某个计算节点的 hash 计算，一般的方法可以使用机器的 IP 地址或者机器名作为 hash 输入。</p>
<p>第四点：将对象映射到服务器</p>
<p>在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 服务器结点，那么就将该对象存储在这个服务器结点上，因为对象和服务器的hash 值是固定的，因此这个 cache 必然是唯一和确定的。</p>
<p>这时候考察某个服务器down机或者需要添加服务器结点，也就是移除和添加的操作，我们只需要几个对象的映射。</p>
<p>第五点：虚拟结点</p>
<p> Hash 算法的另一个指标是平衡性 (Balance)。平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p>
<p> 对于上述的做法，可能导致某些对象都映射到某个服务器，使得分布不平衡。为此可以采用“虚拟结点”的做法。</p>
<p> “虚拟结点”（ virtual node ）是实际节点在 hash 空间的复制品，一实际结点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。引入“虚拟结点”会让我们的映射分布更为平衡一些。</p>
<p>引入“虚拟结点”前：<br>Hash(“192.168.1.1”);</p>
<p>引入“虚拟结点”后：<br>Hash(“192.168.1.1#1”);<br>Hash(“192.168.1.1#2”);</p>
<h3 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h3><p>1、解析XML</p>
<p>DOM、SAX、JDOM、DOM4J</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> DOM DOM树驻留内存</li>
</ul>
<p>可以进行修改和写入,耗费内存。</p>
<p>步骤：创建DocumentBuilderFactory对象 -&gt; 创建DocumentBuilder对象 -&gt; Document document = db.parse(“xml”)</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> SAX 事件驱动模式</li>
</ul>
<p>获取一个SAXParserFactory工厂的实例 -&gt; 根据该实例获取SAXParser -&gt; 创建Handler对象 -&gt; 调用SAXParser的parse方法解析</p>
<p>用于读取节点数据 不易编码 事件有顺序 很难同时访问xml的多处数据</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> JDOM</li>
</ul>
<p>创建一个SAXBuilder的对象 -&gt; 创建一个输入流，加载xml文件 -&gt;通过saxBuilder的build方法将输入流加载至saxBuilder并接收Document对象</p>
<p>使用具体类而不使用接口</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> DOM4J</li>
</ul>
<p>通过SAXReader的read方法加载xml文件并获取document对象</p>
<p>使用接口和抽象类，灵活性好，功能强大</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.开源软件有哪些？</p>
<p>Eclipse、Linux及其Linux下的大多数软件、Git等。</p>
<p>Apache下的众多软件：Lucene、Velocity、Maven、高性能Java网络框架MINA、版本控制系统SVN、应用服务器Tomcat、Http服务器Apache、MVC框架Struts、持久层框架iBATIS、Apache SPARK、ActiveMQ</p>
<p>2.开源协议</p>
<p>MIT：相对宽松。适用：JQuery</p>
<p>Apache：相对宽松与MIT类似的协议，考虑有专利的情况。适用：Apache服务器、SVN</p>
<p>GPL：GPLV2和GPLV3，如果你在乎作品的传播和别人的修改，希望别人也以相同的协议分享出来。</p>
<p>LGPL：主要用于一些代码库。衍生代码可以以此协议发布（言下之意你可以用其他协议），但与此协议相关的代码必需遵循此协议。</p>
<p>BSD：较为宽松的协议，包含两个变种BSD 2-Clause 和BSD 3-Clause，两者都与MIT协议只存在细微差异。</p>
<p>上面各协议只是针对软件或代码作品，如果你的作品不是代码，比如视频，音乐，图片，文章等，共享于公众之前，也最好声明一下协议以保证自己的权益不被侵犯，CC协议。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
