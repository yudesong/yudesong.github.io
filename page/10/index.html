<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/06/Android-IPC-Binder%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/06/Android-IPC-Binder%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Android-IPC-Binder机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-06 14:21:03" itemprop="dateCreated datePublished" datetime="2020-01-06T14:21:03+08:00">2020-01-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E8%BF%9B%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">进程</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E8%BF%9B%E7%A8%8B/IPC/" itemprop="url" rel="index"><span itemprop="name">IPC</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E8%BF%9B%E7%A8%8B/IPC/Binder/" itemprop="url" rel="index"><span itemprop="name">Binder</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android为什么要采用Binder作为IPC方式：</p>
<ul>
<li>性能：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</li>
<li>稳定性：Binder基于C/S架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好。</li>
<li>语言：Linux基于C语言(面向过程的语言)，而Android基于Java语言(面向对象的语句)，Binder符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。</li>
<li>安全：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。</li>
<li>协议：Linux内核所开放源代码受许可协议GPL保护，该协议具有“病毒式感染”的能力，受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性。</li>
</ul>
<p>每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制，Android中的Kill Process采用的signal（信号）机制等等。而Binder更多则用在system_server进程与上层App层的IPC交互。</p>
<p>binder通信是一种client-server的通信结构，Client、Server和ServiceManager这三者之间的交互关系，如图所示：</p>
<p><img src="IPC-Binder%E5%85%B3%E7%B3%BB.jpg" alt="三者关系"></p>
<ol>
<li>Server进程要先注册一些Service到ServiceManager中，所以Server是ServiceManager的客户端，而ServiceManager就是服务端了。</li>
<li>如果某个Client进程要使用某个Service，必须先到ServiceManager中获取该Service的相关信息，所以Client是ServiceManager的客户端。</li>
<li>Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互了，所以Client也是Server的客户端。</li>
<li>最重要的一点是，三者的交互都是基于Binder通信的</li>
</ol>
<h1 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>传统的Linux通信机制如Socket，管道等都是内核支持的；但是Binder并不是Linux内核的一部分，它是怎么做到访问内核空间的呢？Linux的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p>
<p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动。</p>
<p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；驱动就是操作硬件的接口。</p>
<p>binder驱动作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。如下图：</p>
<p><img src="Binder%E9%A9%B1%E5%8A%A8.jpeg" alt="Binder驱动"></p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><ul>
<li>binder_init：注册初始化字符设备。</li>
<li>binder_open：打开binder驱动设备，创建binder_proc对象，并把当前进程等信息保存到binder_proc对象，该对象管理IPC所需的各种信息并拥有其他结构体链表的头节点，再把binder_proc对象保存到文件指针filp，以及把binder_proc加入到全局链表binder_procs。</li>
<li>binder_mmap：首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。</li>
<li>binder_ioctl：负责在两个进程间收发IPC数据和IPC reply数据。</li>
</ul>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>先列举一次完整的Binder通信过程：</p>
<p><img src="binder%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.jpg" alt="binder通信协议"></p>
<p>Binder协议包含在IPC数据中，分为两类:</p>
<ul>
<li>BINDER_COMMAND_PROTOCOL：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；</li>
<li>BINDER_RETURN_PROTOCOL ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</li>
</ul>
<p>Binder IPC通信至少是两个进程的交互：</p>
<ul>
<li>client进程执行binder_thread_write，根据BC_XXX命令，生成相应的binder_work；</li>
<li>server进程执行binder_thread_read，根据binder_work.type类型，生成BR_XXX，发送到用户空间处理。</li>
</ul>
<p>Binder通信过程如下：</p>
<p><img src="binder_protocol.jpg" alt="binder_protocol"></p>
<p>其中binder_work.type共有6种类型：</p>
<ul>
<li>BINDER_WORK_TRANSACTION</li>
<li>BINDER_WORK_TRANSACTION_COMPLETE</li>
<li>BINDER_WORK_NODE</li>
<li>BINDER_WORK_DEAD_BINDER</li>
<li>BINDER_WORK_DEAD_BINDER_AND_CLEAR</li>
<li>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</li>
</ul>
<h1 id="Binder内存机制"><a href="#Binder内存机制" class="headerlink" title="Binder内存机制"></a>Binder内存机制</h1><p>Binder进程间通信效率高的最主要原因是Binder的内存机制：虚拟进程地址空间(用户空间)和虚拟内核地址空间(内核空间)都映射到同一块物理内存空间。当Client端与Server端发送数据时，Client（作为数据发送端）先从自己的进程空间把IPC通信数据copy_from_user拷贝到内核空间，而Server端（作为数据接收端）与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可获悉内存地址，整个过程只发生一次内存拷贝。</p>
<p>而一般IPC的做法，需要Client端进程空间拷贝到内核空间，再由内核空间拷贝到Server进程空间，会发生两次拷贝。</p>
<p>对于进程和内核虚拟地址映射到同一个物理内存的操作是发生在数据接收端，而数据发送端还是需要将用户态的数据复制到内核态。</p>
<p>见图解：<a href="https://ljd1996.github.io/2019/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">操作系统-进程与线程</a>。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ServiceManager是一个进程，Server是另一个进程，Binder的实现比较巧妙：ServiceManager和其它进程同样采用Binder通信，ServiceManager是Server端，有自己的Binder对象（实体），其它进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。ServiceManager提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成ServiceManager时Binder驱动会自动为它创建Binder实体。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。</p>
<p>ServiceManager是Binder IPC通信过程中的守护进程，本身也是一个Binder服务，但并没有采用libbinder中的多线程模型来与Binder驱动通信，而是自行编写了binder.c直接和Binder驱动来通信，并且只有一个循环binder_loop来进行读取和处理事务，这样的好处是简单而高效。</p>
<p>ServiceManager本身工作相对简单，其功能：查询和注册服务。</p>
<h2 id="启动ServiceManager"><a href="#启动ServiceManager" class="headerlink" title="启动ServiceManager"></a>启动ServiceManager</h2><p>在Binder通信过程中，其启动的流程图如下：</p>
<p><img src="ServiceManager%E5%90%AF%E5%8A%A8.jpeg" alt="ServiceManager启动"></p>
<center>ServiceManager 启动</center>

<ul>
<li>ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。其所对应的可执行程序/system/bin/servicemanager，所对应的源文件是service_manager.c，进程名为/system/bin/servicemanager。</li>
<li>ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。</li>
</ul>
<h2 id="获取ServiceManager"><a href="#获取ServiceManager" class="headerlink" title="获取ServiceManager"></a>获取ServiceManager</h2><p>获取Service Manager是通过defaultServiceManager()方法来完成，当进程注册服务(addService)或获取服务(getService)之前，都需要先调用defaultServiceManager()方法来获取gDefaultServiceManager对象。对于gDefaultServiceManager对象，如果存在则直接返回；如果不存在则创建该对象，创建过程包括调用open()打开binder驱动设备，利用mmap()映射内核的地址空间。</p>
<p><code>defaultServiceManager()</code> 等价于 <code>new BpServiceManager(new BpBinder(0));</code></p>
<h2 id="addService"><a href="#addService" class="headerlink" title="addService"></a>addService</h2><p>服务注册过程(addService)核心功能：在服务所在进程创建binder_node，在servicemanager进程创建binder_ref。</p>
<ul>
<li>每个进程binder_proc所记录的binder_ref的handle值是从1开始递增的；</li>
<li>所有进程binder_proc所记录的handle=0的binder_ref都指向service manager；</li>
<li>同一个服务的binder_node在不同进程的binder_ref的handle值可以不同；</li>
</ul>
<p>以注册MediaPlayer服务为例，其注册流程如下图：</p>
<p><img src="ServiceManager%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1.jpeg" alt="ServiceManager注册服务"></p>
<center>ServiceManager注册服务</center>

<ul>
<li>通过 ServiceManager 的 addService() 方法来注册MediaPlayerService服务。</li>
<li>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。</li>
<li>Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。</li>
<li>事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。</li>
</ul>
<h2 id="getService"><a href="#getService" class="headerlink" title="getService"></a>getService</h2><p>以获取MediaPlayer服务为例，其获取流程如下图：</p>
<p><img src="ServiceManager%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1.jpeg" alt="ServiceManager获取服务"></p>
<center>ServiceManager获取服务</center>

<ul>
<li>获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。</li>
<li>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。</li>
<li>Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ServiceManager启动流程：</p>
<ol>
<li>打开binder驱动，并调用mmap()方法分配128k的内存映射空间：binder_open();</li>
<li>通知binder驱动使其成为守护进程：binder_become_context_manager()；</li>
<li>验证selinux权限，判断进程是否有权注册或查看指定服务；</li>
<li>进入循环状态，等待Client端的请求：binder_loop()。</li>
<li>注册服务的过程，根据服务名称，但同一个服务已注册，重新注册前会先移除之前的注册信息；</li>
<li>死亡通知: 当binder所在进程死亡后,会调用binder_release方法,然后调用binder_node_release.这个过程便会发出死亡通知的回调.</li>
</ol>
<p>ServiceManager最核心的两个功能为查询和注册服务：</p>
<ul>
<li>注册服务：记录服务名和handle信息，保存到svclist列表；</li>
<li>查询服务：根据服务名查询相应的的handle信息。</li>
</ul>
<h1 id="FrameWork层"><a href="#FrameWork层" class="headerlink" title="FrameWork层"></a>FrameWork层</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>FrameWork层的Binder架构如下：</p>
<p><img src="Binder%E6%9E%B6%E6%9E%84.jpeg" alt="Binder架构"></p>
<ul>
<li>图中红色代表整个framework层 binder架构相关组件；</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的。</li>
</ul>
<p>Binder类图如下：</p>
<p><img src="Binder%E7%B1%BB%E5%9B%BE.jpg" alt="Binder类图"></p>
<ul>
<li>图中浅蓝色都是Interface，其余都是Class；</li>
<li>ServiceManager：通过getIServiceManager方法获取的是ServiceManagerProxy对象；ServiceManager的addService, getService实际工作都交由ServiceManagerProxy的相应方法来处理；</li>
<li>ServiceManagerProxy：其成员变量mRemote指向BinderProxy对象，ServiceManagerProxy的addService, getService方法最终是交由mRemote来完成。</li>
<li>ServiceManagerNative：其方法asInterface()返回的是ServiceManagerProxy对象，ServiceManager便是借助ServiceManagerNative类来找到ServiceManagerProxy；</li>
<li>Binder：其成员变量mObject和方法execTransact()用于native方法</li>
<li>BinderInternal：内部有一个GcWatcher类，用于处理和调试与Binder相关的垃圾回收。</li>
<li>IBinder：接口中常量FLAG_ONEWAY：客户端利用binder跟服务端通信是阻塞式的，但如果设置了FLAG_ONEWAY，这成为非阻塞的调用方式，客户端能立即返回，服务端采用回调方式来通知客户端完成情况。另外IBinder接口有一个内部接口DeathDecipient(死亡通告)。</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>IBinder 是一个接口，它代表了一种跨进程传输的能力。只要实现了这个接口，就能将这个对象进行跨进程传递。它最重要的有这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>code：要执行的动作，类似 Handler 的 msg.what，IBinder 中定义了以下几个 code <ul>
<li>PING_TRANSACTION，表示要调用 pingBinder() 方法</li>
<li>DUMP_TRANSACTION，表示要获取 Binder 内部状态</li>
<li>SHELL_COMMAND_TRANSACTION，执行一个 shell 命令</li>
<li>INTERFACE_TRANSACTION，询问被调用方的接口描述符号</li>
<li>TWEET_TRANSACTION</li>
<li>LIKE_TRANSACTION</li>
<li>如果我们需要自定义 code，code 的值范围需要在 FIRST_CALL_TRANSACTION(0x00000001) 和 LAST_CALL_TRANSACTION(0x00ffffff) 之间</li>
</ul>
</li>
<li>data, reply：传入的参数和返回的值</li>
<li>flags：表示是否需要阻塞等待返回值，有两个值 <ul>
<li>0</li>
<li>FLAG_ONEWAY (0x00000001)，表示 Client 的 transact() 是单向调用，执行后立即返回</li>
</ul>
</li>
</ul>
<p>①经常的场景是，我们调用 IBinder.transact() 给一个 IBinder 对象发送请求，然后经过 Binder Binder.onTransact() 得到调用，接着远程操作的目标得到对应的调用。这个过程不仅在同一进程中可以进行，在跨进程（IPC）间也可以完成。IBinder.transact() 方法是同步的，它被调用后一直到 Binder.onTransact() 调用完成后才返回。</p>
<p>②通过 IBinder.transact() 方法传输的数据被保存为一个 Parcel 对象，Parcel 中保存了数据以及描述数据的元数据，元数据在缓存区中保持了 IBinder 对象的引用，这样不同进程都可以访问同一个数据。因此在一个 IBinder 对象写入 Parcel 对象然后发送到另一个进程时，另外那进程将这个 IBinder 对象发送回去时，原本进程接收到的 IBinder 对象和开始发送出去的是同一个引用。在跨进程传输后引用没有改变，这是非常关键的一点，这就使得 IBinder/Binder 对象在跨进程通信时可以作为唯一的标识（比如作为 token 什么的）。</p>
<p>③系统在每个进程中都有一个处理事物的线程池，这些线程用于调度其他进程对当前进程的跨进程访问。比如说进程 A 对进程 B 发起 IPC 时，A 中调用 transact() 的线程会阻塞。B 中的事物线程池收到 A 的 IPC，调用目标对象的 Binder.onTransact() 方法，然后返回带结果的 Parcel。一旦接收到结果，A 中阻塞的线程得以继续执行。</p>
<p>④Binder 机制还支持进程间的递归调用。比如，进程 A 向进程 B 发起 IPC，而进程 B 在其 Binder.onTransact() 中又用 transact() 向进程 A 发起 IPC，那么进程 A 在等待它发出的调用返回的同时，也会响应 B 的调用，对调用的对象执行 Binder.onTransact() 方法。</p>
<p>⑤在跨进程通信时，我们常常想要知道另外进程是否可用，IBinder 提供了三个检查的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查远程 Binder 对象是否存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当不存在时返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pingBinder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册一个 Binder 销毁的监听</span></span><br><span class="line"><span class="comment">   如果一个 Binder 被销毁（通常是它所在的进程被关闭），会回调 DeathRecipient 的 BinderDied 方法</span></span><br><span class="line"><span class="comment"> * 注意，只会监听远程的 Binder，本地 Binder 一般不会销毁，除非当前进程退出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果要注册的 Binder 进程已经销毁，就抛出 RemoteException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkToDeath</span><span class="params">(DeathRecipient recipient, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * linkToDeath 注册监听回调的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binder通信流程"><a href="#Binder通信流程" class="headerlink" title="Binder通信流程"></a>Binder通信流程</h1><p><img src="Binder%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.jpeg" alt="Binder通信流程"></p>
<ol>
<li>ServiceManager 初始化 <ol>
<li>当该应用程序启动时，ServiceManager 会和 Binder 驱动进行通信，告诉 Binder 驱动它是服务管理者</li>
<li>Binder 驱动新建 ServiceManager 对应的 Binder 实体</li>
</ol>
</li>
<li>Server 向 ServiceManager 注册自己 <ol>
<li>Server 向 Binder 驱动发起注册请求，Binder 为它创建 Binder 实体</li>
<li>然后如果 ServiceManager 中没有这个 Server 时就添加 Server 名称与 Binder 引用到它的 Binder 引用表</li>
</ol>
</li>
<li>Client 获取远程服务 <ol>
<li>Client 首先会向 Binder 驱动发起获取服务的请求，传递要获取的服务名称</li>
<li>Binder 驱动将该请求转发给 ServiceManager 进程</li>
<li>ServiceManager 查找到 Client 需要的 Server 对应的 Binder 实体的 Binder 引用信息，然后通过 Binder 驱动反馈给 Client</li>
<li>Client 收到 Server 对应的 Binder 引用后，会创建一个 Server 对应的远程服务（即 Server 在当前进程的代理）</li>
</ol>
</li>
<li>Client 通过代理调用 Server <ol>
<li>Client 调用远程服务，远程服务收到 Client 请求之后，会和 Binder 驱动通信</li>
<li>因为远程服务中有 Server 的 Binder 引用信息，因此驱动就能轻易的找到对应的 Server，进而将Client 的请求内容发送 Server</li>
</ol>
</li>
</ol>
<h1 id="实例一：同进程"><a href="#实例一：同进程" class="headerlink" title="实例一：同进程"></a>实例一：同进程</h1><p>不能跨进程，需要使用AIDL等，本质还是Binder。</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service1</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder binder = <span class="keyword">new</span> Binder1();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Binder1</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"LLL"</span>, <span class="string">"binder"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btn1</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, Service1<span class="class">.<span class="keyword">class</span>), <span class="title">new</span> <span class="title">ServiceConnection</span>() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            ((Service1.Binder1) service).binder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Context.BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实例二：跨进程"><a href="#实例二：跨进程" class="headerlink" title="实例二：跨进程"></a>实例二：跨进程</h1><p>可以跨进程</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder binder = <span class="keyword">new</span> Binder() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, @NonNull Parcel data, @Nullable Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">1</span>) &#123;</span><br><span class="line">                String name;</span><br><span class="line">                name = data.readString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reply = Parcel.obtain();</span><br><span class="line">                &#125;</span><br><span class="line">                reply.writeString(name + <span class="string">"-"</span> + name);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Parcel data = Parcel.obtain();</span><br><span class="line">            data.writeString(<span class="string">"hearing"</span>);</span><br><span class="line">            Parcel reply = Parcel.obtain();</span><br><span class="line">            IBinder binder = iBinder;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                binder.transact(<span class="number">1</span>, data, reply, <span class="number">0</span>);</span><br><span class="line">                Log.d(<span class="string">"LLL"</span>, <span class="string">"name = "</span> + reply.readString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                data.recycle();</span><br><span class="line">                reply.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BinderService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(serviceConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实例三：Nativie"><a href="#实例三：Nativie" class="headerlink" title="实例三：Nativie"></a>实例三：Nativie</h1><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><ul>
<li>ClientDemo.cpp: 客户端程序</li>
<li>ServerDemo.cpp：服务端程序</li>
<li>IMyService.h：自定义的MyService服务的头文件</li>
<li>IMyService.cpp：自定义的MyService服务</li>
<li>Android.mk：源码build文件</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IMyService.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取service manager引用</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    <span class="comment">//注册名为"service.myservice"的服务到service manager</span></span><br><span class="line">    sm-&gt;addService(String16(<span class="string">"service.myservice"</span>), <span class="keyword">new</span> BnMyService());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool(); <span class="comment">//启动线程池</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool(); <span class="comment">//把主线程加入线程池</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将名为”service.myservice”的BnMyService服务添加到ServiceManager，并启动服务</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IMyService.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取service manager引用</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    <span class="comment">//获取名为"service.myservice"的binder接口</span></span><br><span class="line">    sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(<span class="string">"service.myservice"</span>));</span><br><span class="line">    <span class="comment">//将biner对象转换为强引用类型的IMyService</span></span><br><span class="line">    sp&lt;IMyService&gt; cs = interface_cast&lt;IMyService&gt;(binder);</span><br><span class="line">    <span class="comment">//利用binder引用调用远程sayHello()方法</span></span><br><span class="line">    cs-&gt;sayHello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取名为”service.myservice”的服务，再进行类型，最后调用远程方法sayHello()</p>
<h2 id="创建MyService"><a href="#创建MyService" class="headerlink" title="创建MyService"></a>创建MyService</h2><h3 id="IMyService-h"><a href="#IMyService-h" class="headerlink" title="IMyService.h"></a>IMyService.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> android</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IMyService</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DECLARE_META_INTERFACE(MyService); <span class="comment">//使用宏，申明MyService</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//定义方法</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义命令字段</span></span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        HELLO = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申明客户端BpMyService</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BpMyService</span>:</span> <span class="keyword">public</span> BpInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BpMyService(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申明服务端BnMyService</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BnMyService</span>:</span> <span class="keyword">public</span> BnInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能：</p>
<ul>
<li>申明IMyService</li>
<li>申明BpMyService（Binder客户端）</li>
<li>申明BnMyService（Binder的服务端）</li>
</ul>
<h3 id="IMyService-cpp"><a href="#IMyService-cpp" class="headerlink" title="IMyService.cpp"></a>IMyService.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IMyService.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> android</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用宏，完成MyService定义</span></span><br><span class="line">    IMPLEMENT_META_INTERFACE(MyService, <span class="string">"android.demo.IMyService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    BpMyService::BpMyService(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl) :</span><br><span class="line">            BpInterface&lt;IMyService&gt;(impl) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现客户端sayHello方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BpMyService::sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"BpMyService::sayHello\n"</span>);</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMyService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(HELLO, data, &amp;reply);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get num from BnMyService: %d\n"</span>, reply.readInt32());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端，接收远程消息，处理onTransact方法</span></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">BnMyService::onTransact</span><span class="params">(<span class="keyword">uint_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">            Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> HELLO: &#123;    <span class="comment">//收到HELLO命令的处理流程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"BnMyService:: got the client hello\n"</span>);</span><br><span class="line">            CHECK_INTERFACE(IMyService, data, reply);</span><br><span class="line">            sayHello();</span><br><span class="line">            reply-&gt;writeInt32(<span class="number">2015</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现服务端sayHello方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BnMyService::sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"BnMyService::sayHello\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="native_binder_demo.jpg" alt="native_binder_demo"></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol>
<li>编译生成：利用Android.mk编译上述代码，在Android的源码中，通过mm编译后，可生成两个可执行文件ServerDemo，ClientDemo。</li>
<li>执行：将这两个可执行文件push到手机，然后运行。</li>
</ol>
<h1 id="实例四：Framework"><a href="#实例四：Framework" class="headerlink" title="实例四：Framework"></a>实例四：Framework</h1><h2 id="源码结构-1"><a href="#源码结构-1" class="headerlink" title="源码结构"></a>源码结构</h2><p>Server端：</p>
<ul>
<li>ServerDemo.java：可执行程序</li>
<li>IMyService.java: 定义IMyService接口</li>
<li>MyService.java：定义MyService</li>
</ul>
<p>Client端：</p>
<ul>
<li>ClientDemo.java：可执行程序</li>
<li>IMyService.java: 与Server端完全一致</li>
<li>MyServiceProxy.java：定义MyServiceProxy</li>
</ul>
<p>注意：ServiceManager被@hide隐藏了，在高版本Android机型上，即使通过反射去调用ServiceManager中的方法，也会报错：<code>java.lang.SecurityException</code>。</p>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><h3 id="ServerDemo-java"><a href="#ServerDemo-java" class="headerlink" title="ServerDemo.java"></a>ServerDemo.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyService Start"</span>);</span><br><span class="line">        <span class="comment">//准备Looper循环执行</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="comment">//设置为前台优先级</span></span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        <span class="comment">//注册服务</span></span><br><span class="line">        ServiceManager.addService(<span class="string">"MyService"</span>, <span class="keyword">new</span> MyService());</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IMyService-java"><a href="#IMyService-java" class="headerlink" title="IMyService.java"></a>IMyService.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyService</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.hearing.frameworkBinder.MyServer"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> <span class="keyword">throws</span> RemoteException </span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_say = IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyService-java"><a href="#MyService-java" class="headerlink" title="MyService.java"></a>MyService.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IMyService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将MyService转换为IMyService接口 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMyService <span class="title">asInterface</span><span class="params">( IBinder obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IInterface iInterface = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (((iInterface != <span class="keyword">null</span>) &amp;&amp; (iInterface <span class="keyword">instanceof</span> IMyService)))&#123;</span><br><span class="line">            <span class="keyword">return</span> ((IMyService) iInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 服务端，接收远程消息，处理onTransact方法 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_say: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                String str = data.readString();</span><br><span class="line">                sayHello(str);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 自定义sayHello()方法 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyService:: Hello, "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><h3 id="ClientDemo-java"><a href="#ClientDemo-java" class="headerlink" title="ClientDemo.java"></a>ClientDemo.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client start"</span>);</span><br><span class="line">        IBinder binder = ServiceManager.getService(<span class="string">"MyService"</span>); <span class="comment">//获取名为"MyService"的服务</span></span><br><span class="line">        IMyService myService = <span class="keyword">new</span> MyServiceProxy(binder); <span class="comment">//创建MyServiceProxy对象</span></span><br><span class="line">        myService.sayHello(<span class="string">"binder"</span>); <span class="comment">//通过MyServiceProxy对象调用接口的方法</span></span><br><span class="line">        System.out.println(<span class="string">"Client end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IMyService-java-1"><a href="#IMyService-java-1" class="headerlink" title="IMyService.java"></a>IMyService.java</h3><p>与Server端的IMyService是一致，基本都是拷贝一份过来。</p>
<h3 id="MyServiceProxy-java"><a href="#MyServiceProxy-java" class="headerlink" title="MyServiceProxy.java"></a>MyServiceProxy.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceProxy</span> <span class="keyword">implements</span> <span class="title">IMyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IBinder mRemote;  <span class="comment">//代表BpBinder</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServiceProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 自定义的sayHello()方法 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Parcel _data = Parcel.obtain();</span><br><span class="line">        Parcel _reply = Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(str);</span><br><span class="line">            mRemote.transact(TRANSACTION_say, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h2><p><img src="MyServer_framework_binder.jpg" alt="MyServer_framework_binder"></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><h2 id="Binder概述"><a href="#Binder概述" class="headerlink" title="Binder概述"></a>Binder概述</h2><ul>
<li>从IPC角度来说：Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有；</li>
<li>从Android Driver层：Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ul>
<h2 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h2><p><img src="Binder%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png" alt="Binder进程和线程"></p>
<p>对于底层Binder驱动，通过binder_procs链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应，且每个进程有且只有一个ProcessState对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是binder_thread结构体。在binder_proc结构体中通过成员变量<code>rb_root threads</code>，来记录当前进程内所有的binder_thread。</p>
<p>Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。</p>
<h2 id="Binder传输过程"><a href="#Binder传输过程" class="headerlink" title="Binder传输过程"></a>Binder传输过程</h2><p>Binder IPC机制，就是指在进程间传输数据（binder_transaction_data），一次数据的传输，称为事务（binder_transaction）。对于多个不同进程向同一个进程发送事务时，这个同一个进程或线程的事务需要串行执行，在Binder驱动中为binder_proc和binder_thread都有todo队列。</p>
<p>也就是说对于进程间的通信，就是发送端把binder_transaction节点，插入到目标进程或其子线程的todo队列中，等目标进程或线程不断循环地从todo队列中取出数据并进行相应的操作。</p>
<p>在Binder驱动层，每个接收端进程都有一个todo队列，用于保存发送端进程发送过来的binder请求，这类请求可以由接收端进程的任意一个空闲的binder线程处理；接收端进程存在一个或多个binder线程，在每个binder线程里都有一个todo队列，也是用于保存发送端进程发送过来的binder请求，这类请求只能由当前binder线程来处理。binder线程在空闲时进入可中断的休眠状态，当自己的todo队列或所属进程的todo队列有新的请求到来时便会唤醒，如果是由所需进程唤醒的，那么进程会让其中一个线程处理响应的请求，其他线程再次进入休眠状态。</p>
<h2 id="Binder路由"><a href="#Binder路由" class="headerlink" title="Binder路由"></a>Binder路由</h2><p>先来看看Native Binder IPC的两个重量级对象：BpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来。</p>
<ul>
<li>IBinder有一个重要方法queryLocalInterface， 默认返回值为NULL；<ul>
<li>BBinder/BpBinder都没有实现，默认返回NULL；BnInterface重写该方法；</li>
<li>BinderProxy(Java)默认返回NULL；Binder(Java)重写该方法；</li>
</ul>
</li>
<li>IInterface有一个重要方法asBinder；</li>
<li>IInterface子类(服务端)会有一个方法asInterface；</li>
</ul>
<p>Native层通过宏IMPLEMENT_META_INTERFACE来完成asInterface实现和descriptor的赋值过程；</p>
<p>对于Java层跟Native一样，也有完全对应的一套对象和方法:</p>
<ul>
<li>例如ActivityManagerNative， 通过实现asInterface方法，以及其通过其构造函数调用attachInterface()，完成descriptor的赋值过程。</li>
<li>再如AIDL全自动生成asInterface和descriptor赋值过程。</li>
</ul>
<p>同一个进程，请求binder服务，不需要创建binder_ref，BpBinder等这些对象，但是是否需要经过binder call，取决于descriptor是否设置。这就涉及到Java服务在Native层使用，或许Native服务在Java层使用，需要格外注意。</p>
<p><strong>binder的路由原理</strong>：BpBinder发送端，根据handler，在当前binder_proc中，找到相应的binder_ref，由binder_ref再找到目标binder_node实体，由目标binder_node再找到目标进程binder_proc。简单地方式是直接把binder_transaction节点插入到binder_proc的todo队列中，完成传输过程。</p>
<p>对于binder驱动来说应尽可能地把binder_transaction节点插入到目标进程的某个线程的todo队列，效率更高。当binder驱动可以找到合适的线程，就会把binder_transaction节点插入到相应线程的todo队列中，如果找不到合适的线程，就把节点之间插入binder_proc的todo队列。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Android-init-zygote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/Android-init-zygote/" class="post-title-link" itemprop="url">Android-init-zygote</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-21 16:35:56" itemprop="dateCreated datePublished" datetime="2019-10-21T16:35:56+08:00">2019-10-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">原理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%8E%9F%E7%90%86/init/" itemprop="url" rel="index"><span itemprop="name">init</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>注：本文基于Android 9.0源码，为了文章的简洁性，引用源码的地方可能有所删减。</p>
<p>本文主要分析Android系统在启动之后系统服务之间的关系以及各个关键进程的启动逻辑，Android系统简要启动流程如下：</p>
<p><img src="android-boot.jpg" alt="android-boot"></p>
<h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>当电源按下时引导芯片代码会从预定义的地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。</p>
<h2 id="引导程序BootLoader"><a href="#引导程序BootLoader" class="headerlink" title="引导程序BootLoader"></a>引导程序BootLoader</h2><p>它是Android操作系统开始运行前的一个小程序，主要将操作系统OS拉起来并进行。</p>
<h2 id="Linux内核启动"><a href="#Linux内核启动" class="headerlink" title="Linux内核启动"></a>Linux内核启动</h2><p>当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。此外，还启动了Kernel的swapper进程（pid = 0）和kthreadd进程（pid = 2）：</p>
<ul>
<li>swapper进程：又称为idle进程，系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Binder Driver、Display、Camera Driver等相关工作。</li>
<li>kthreadd进程：Linux系统的内核进程，是所有内核进程的鼻祖，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。</li>
</ul>
<p>当内核完成系统设置时，它首先在系统文件中寻找init.rc文件，并启动init进程。init进程是一个由内核启动的第一个用户级进程，它的进程号是1，父进程id号是0。它的生命周期贯穿整个linux内核运行的始终，linux中所有其它的进程的共同始祖均为init进程。</p>
<p>init进程是所有用户空间的鼻祖, 它会启动servicemanager(binder服务管家，其功能为查询和注册服务), Zygote进程(Java进程的鼻祖). Zygote进程会创建 system_server进程以及各种app进程。如下图所示：</p>
<p><img src="%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="关系图"></p>
<p>Android系统的启动流程如下图：</p>
<p><img src="Android%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="Android启动流程"></p>
<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><h2 id="init-cpp"><a href="#init-cpp" class="headerlink" title="init.cpp"></a>init.cpp</h2><p>init进程的入口函数是<code>system/core/init/init.cpp</code>的main函数，它的代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：内核态</span></span><br><span class="line">    <span class="comment">// 第二阶段：用户态</span></span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (getenv(<span class="string">"INIT_SECOND_STAGE"</span>) == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        <span class="comment">// Clear the umask，与Linux系统权限有关</span></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">        <span class="comment">// on / and then we'll let the rc file figure out the rest.</span></span><br><span class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"init first stage started!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Failed to mount required partitions early ..."</span>;</span><br><span class="line">            panic();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up SELinux(Security-Enhanced Linux), loading the SELinux policy.</span></span><br><span class="line">        selinux_initialize(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We're in the kernel domain, so re-exec init to transition to the init domain now</span></span><br><span class="line">        <span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line">        <span class="comment">// 按selinux policy要求，重新设置init文件属性</span></span><br><span class="line">        <span class="keyword">if</span> (restorecon(<span class="string">"/init"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 失败的话会reboot</span></span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"restorecon failed"</span>;</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setenv(<span class="string">"INIT_SECOND_STAGE"</span>, <span class="string">"true"</span>, <span class="number">1</span>);</span><br><span class="line">        setenv(<span class="string">"INIT_STARTED_AT"</span>, StringPrintf(<span class="string">"%"</span> PRIu64, start_ms).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次调用init的main函数，启动用户态的init进程</span></span><br><span class="line">        <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>* args[] = &#123; path, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        execv(path, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">        <span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二阶段：用户态</span></span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"init second stage started!"</span>;</span><br><span class="line"></span><br><span class="line">    property_init();  <span class="comment">// 初始化属性服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行内核命令</span></span><br><span class="line">    process_kernel_dt();</span><br><span class="line">    process_kernel_cmdline();</span><br><span class="line">    export_kernel_boot_props();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    property_set(<span class="string">"ro.boottime.init"</span>, getenv(<span class="string">"INIT_STARTED_AT"</span>));</span><br><span class="line">    property_set(<span class="string">"ro.boottime.init.selinux"</span>, getenv(<span class="string">"INIT_SELINUX_TOOK"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置之前使用过的一些环境变量</span></span><br><span class="line">    unsetenv(<span class="string">"INIT_SECOND_STAGE"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_STARTED_AT"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_SELINUX_TOOK"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_AVB_VERSION"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set up SELinux for second stage.</span></span><br><span class="line">    selinux_initialize(<span class="literal">false</span>);</span><br><span class="line">    selinux_restore_context();</span><br><span class="line"></span><br><span class="line">    signal_handler_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启属性服务</span></span><br><span class="line">    start_property_service();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析init.rc</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认会休眠直到有事件唤醒</span></span><br><span class="line">        <span class="keyword">int</span> epoll_timeout_ms = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重启一些挂掉的进程，例如Zygote</span></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            restart_processes();</span><br><span class="line">            <span class="comment">// If there's a process that needs restarting, wake up in time for that.</span></span><br><span class="line">            <span class="keyword">if</span> (process_needs_restart_at != <span class="number">0</span>) &#123;</span><br><span class="line">                epoll_timeout_ms = (process_needs_restart_at - time(<span class="literal">nullptr</span>)) * <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">if</span> (epoll_timeout_ms &lt; <span class="number">0</span>) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, epoll_timeout_ms));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"epoll_wait failed"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一阶段：</p>
<ul>
<li>判断及增加环境变量</li>
<li>创建文件系统目录并挂载相关的文件系统</li>
<li>重定向输入输出/内核Log系统</li>
<li>挂载一些分区设备</li>
<li>完成SELinux相关工作</li>
<li>is_first_stage 收尾 </li>
</ul>
<p>第二阶段：</p>
<ul>
<li>初始化属性域，清空环境变量</li>
<li>完成SELinux相关工作</li>
<li>启动属性服务</li>
<li>解析配置文件，执行各个阶段的动作，创建Zygote的工作就是在其中的某个阶段完成的。</li>
<li>init进入一个无限循环，并且等待一些事情的发生。</li>
</ul>
<h2 id="rc文件语法"><a href="#rc文件语法" class="headerlink" title="rc文件语法"></a>rc文件语法</h2><p>rc文件主要包含Action、Service、Command、Options，其中对于Action和Service的名称都是唯一的，对于重复的命名视为无效。</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action：通过触发器trigger，即以on开头的语句来决定执行相应的service的时机，具体有如下时机：</p>
<ul>
<li><code>on early-init</code>：在初始化早期阶段触发；</li>
<li><code>on init</code>：在初始化阶段触发；</li>
<li><code>on late-init</code>：在初始化晚期阶段触发；</li>
<li><code>on boot/charger</code>：当系统启动/充电时触发，还包含其他情况，此处不一一列举；</li>
<li><code>on property:&lt;key&gt;=&lt;value&gt;</code>：当属性值满足条件时触发；</li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>服务Service，以service开头，由init进程启动，一般运行在init的一个子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service在启动时会通过fork方式生成子进程。</p>
<p>例如：<code>service servicemanager /system/bin/servicemanager</code>代表的是服务名为servicemanager，服务执行的路径为/system/bin/servicemanager。</p>
<h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><p>下面列举常用的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务；</span><br><span class="line">start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过；</span><br><span class="line">stop &lt;service_name&gt;： 停止正在运行的服务</span><br><span class="line">setprop &lt;name&gt; &lt;value&gt;：设置属性值</span><br><span class="line">mkdir &lt;path&gt;：创建指定目录</span><br><span class="line">symlink &lt;target&gt; &lt;sym_link&gt;： 创建连接到&lt;target&gt;的&lt;sym_link&gt;符号链接；</span><br><span class="line">write &lt;path&gt; &lt;string&gt;： 向文件path中写入字符串；</span><br><span class="line">exec： fork并执行，会阻塞init进程直到程序完毕；</span><br><span class="line">exprot &lt;name&gt; &lt;name&gt;：设定环境变量；</span><br><span class="line">loglevel &lt;level&gt;：设置log级别</span><br></pre></td></tr></table></figure>

<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>Options是Service的可选项，与service配合使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">disabled: 不随class自动启动，只有根据service名才启动；</span><br><span class="line">oneshot: service退出后不再重启；</span><br><span class="line">user/group： 设置执行服务的用户/用户组，默认都是root；</span><br><span class="line">class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default；</span><br><span class="line">onrestart:当服务重启时执行相应命令；</span><br><span class="line">socket: 创建名为/dev/socket/&lt;name&gt;的socket</span><br><span class="line">critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式</span><br><span class="line">default: 意味着disabled=false，oneshot=false，critical=false。</span><br></pre></td></tr></table></figure>

<h2 id="启动service"><a href="#启动service" class="headerlink" title="启动service"></a>启动service</h2><h3 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">on init</span><br><span class="line">on late-init</span><br><span class="line">    trigger post-fs      </span><br><span class="line">    trigger load_system_props_action</span><br><span class="line">    trigger post-fs-data  </span><br><span class="line">    trigger load_persist_props_action</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line">    trigger boot   </span><br><span class="line"></span><br><span class="line">on post-fs      //挂载文件系统</span><br><span class="line">    start logd</span><br><span class="line">    mount rootfs rootfs / ro remount</span><br><span class="line">    mount rootfs rootfs / shared rec</span><br><span class="line">    mount none /mnt/runtime/default /storage slave bind rec</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">on post-fs-data  //挂载data</span><br><span class="line">    start logd</span><br><span class="line">    start vold   //启动vold，Vold是用于管理和控制Android外部存储介质的后台进程，主要包括SD卡的插拔、挂载/卸载和格式化等。</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">on boot      //启动核心服务</span><br><span class="line">    ...</span><br><span class="line">    class_start core //启动core class</span><br></pre></td></tr></table></figure>

<h3 id="启动zygote"><a href="#启动zygote" class="headerlink" title="启动zygote"></a>启动zygote</h3><p>在init.zygote64_32.rc文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote_secondary stream 660 root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>通过init_parser.cpp完成整个service解析工作，此处就不详细展开讲解析过程，该过程主要工作是：</p>
<ul>
<li>创建一个名叫”zygote”的service结构体；</li>
<li>创建一个用于socket通信的socketinfo结构体；</li>
<li>创建一个包含4个onrestart的action结构体。</li>
</ul>
<p>Zygote服务会随着main class的启动而启动，退出后会由init重启zygote，即使多次重启也不会进入recovery模式。</p>
<p>zygote所对应的可执行文件是<code>/system/bin/app_process</code>，通过调用<code>pid = fork()</code>创建子进程，通过<code>execve(svc-&gt;args[0], (char**)svc-&gt;args, (char**) ENV)</code>，进入app_main.cpp的main()函数。故zygote是通过fork和execv共同创建的。</p>
<p>流程如下：</p>
<p><img src="zygote%E5%90%AF%E5%8A%A8.jpg" alt="zygote启动"></p>
<h3 id="重启zygote"><a href="#重启zygote" class="headerlink" title="重启zygote"></a>重启zygote</h3><p>当init子进程退出时，会产生SIGCHLD信号，并发送给init进程，通过socket套接字传递数据，调用到wait_for_one_process()方法，根据是否是oneshot，来决定是重启子进程，还是放弃启动。</p>
<p>所有的Service里面只有servicemanager，zygote，surfaceflinger这3个服务有onrestart关键字来触发其他service启动过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//zygote可触发media、netd重启</span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line"></span><br><span class="line">//servicemanager可触发healthd、zygote、media、surfaceflinger、drm重启</span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line"></span><br><span class="line">//surfaceflinger可触发zygote重启</span><br><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    onrestart restart zygote</span><br></pre></td></tr></table></figure>

<p>由上可知：</p>
<ul>
<li>zygote：触发media、netd以及子进程(包括system_server进程)重启；</li>
<li>system_server: 触发zygote重启;</li>
<li>surfaceflinger：触发zygote重启;</li>
<li>servicemanager: 触发zygote、healthd、media、surfaceflinger、drm重启</li>
</ul>
<p>所以，surfaceflinger,servicemanager,zygote自身以及system_server进程被杀都会触发Zygote重启。</p>
<h2 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h2><p>我们知道，Windows平台上有一个叫注册表的东西。注册表可以存储一些类似key/value的键值对。一般而言，系统或某些应用程序会把自己的一些属性存储在注册表中，即使下次系统重启或应用程序重启，它还能够根据之前在注册表中设置的属性，进行相应的初始化工作。</p>
<p>Android平台也提供了一个类型机制，可称之为属性服务（property service）。应用程序可通过这个属性机制，查询或设置属性。当某个进程A修改属性值后，init进程会检查访问权限，当权限满足要求后，则更改相应的属性值，属性值一旦改变则会触发相应的触发器（即rc文件中的on开头的语句)，在Android Shared Memmory（共享内存区域）中有一个_system_property_area_区域，里面记录着所有的属性值。对于进程A通过property_get（）方法，获取的也是该共享内存区域的属性值。</p>
<h3 id="属性服务初始化"><a href="#属性服务初始化" class="headerlink" title="属性服务初始化"></a>属性服务初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_property_area();<span class="comment">//初始化属性存储区域</span></span><br><span class="line">    <span class="comment">//加载default.prop文件</span></span><br><span class="line">    load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在properyty_init函数中，先调用init_property_area函数，创建一块用于存储属性的存储区域，然后加载default.prop文件中的内容。虽然属性区域是由init进程创建，但Android系统希望其他进程也能读取这块内存里的东西。为做到这一点，它便做了以下两项工作：</p>
<ul>
<li>把属性区域创建在共享内存上，而共享内存是可以跨进程的。</li>
<li>如何让其他进程知道这个共享内存呢？Android利用了gcc的constructor属性，这个属性指明了一个<strong>libc_prenit函数，当bionic libc库被加载时，将自动调用这个</strong>libc_prenit，这个函数内部就将完成共享内存到本地进程的映射工作。</li>
</ul>
<h3 id="启动属性服务器"><a href="#启动属性服务器" class="headerlink" title="启动属性服务器"></a>启动属性服务器</h3><p>init进程会启动一个属性服务器，而客户端只能通过和属性服务器交互才能设置属性。</p>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><h4 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h4><p>通过property_get和property_set方法操作，需要include cutils/properties.h，并链接libcutils库。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cutils/properties.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BootAnimation::readyToRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> decrypt[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(<span class="string">"vold.decrypt"</span>, decrypt, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android.mk</span></span><br><span class="line">LOCAL_SHARED_LIBRARIES := \</span><br><span class="line">    libcutils \</span><br></pre></td></tr></table></figure>

<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>通过SystemProperties中的API进行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> android.os.SystemProperties;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finishBooting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SystemProperties.set(<span class="string">"sys.boot_completed"</span>, <span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><ul>
<li>通过命令adb shell: getprop查看手机上所有属性状态值</li>
<li>通过setprop 和 getprop 获取和设置属性</li>
</ul>
<h1 id="zygote进程"><a href="#zygote进程" class="headerlink" title="zygote进程"></a>zygote进程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是app_main.cpp，进程名为zygote。</p>
<p>当Zygote进程启动后, 便会执行到frameworks/base/cmds/app_process/app_main.cpp文件的main()方法。整个调用流程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app_main.main</span><br><span class="line">    AndroidRuntime.start</span><br><span class="line">        AndroidRuntime.startVm</span><br><span class="line">        AndroidRuntime.startReg</span><br><span class="line">        ZygoteInit.main (首次进入Java世界)</span><br><span class="line">            registerServerSocketFromEnv</span><br><span class="line">            preload</span><br><span class="line">            forkSystemServer</span><br><span class="line">            runSelectLoop</span><br></pre></td></tr></table></figure>

<p>Zygote进程创建Java虚拟机，并注册JNI方法，真正成为Java进程的母体，用于孵化Java进程。在创建完system_server进程后，zygote功成身退，调用runSelectLoop()随时待命，当接收到创建新进程请求时立即唤醒并执行相应工作。Zygote进程共做了如下几件事：</p>
<ol>
<li>创建AppRuntime并调用其start方法，启动Zygote进程。</li>
<li>创建DVM（ART）并为DVM注册JNI。</li>
<li>通过JNI调用ZygoteInit的main函数进入Zygote的Java框架层。</li>
<li>通过registerServerSocketFromEnv函数创建服务端Socket，并通过runSelectLoop函数等待ActivityManagerService的请求来创建新的应用程序进程。</li>
<li>启动SystemServer进程。</li>
</ol>
<h2 id="app-main-cpp"><a href="#app-main-cpp" class="headerlink" title="app_main.cpp"></a>app_main.cpp</h2><p>Zygote本身是一个Native的应用程序，和驱动、内核等均无关系。Zygote是由init进程根据init.rc文件中的配置项而创建的。zygote最初的名字叫“app_process”，这个名字是在Android.mk文件中被指定的，但app_process在运行过程中，通过Linux下的pctrl系统调用将自己的名字换成了“zygote”，所以我们通过ps命令看到的进程名是“zygote”。</p>
<p>zygote的原型app_process所对应的源文件是<code>framework/base/cmds/app_process/app_main.cpp</code>，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --zygote : Start in zygote mode</span></span><br><span class="line">    <span class="comment">// --start-system-server : Start the system server.</span></span><br><span class="line">    <span class="comment">// --application : Start in application (stand alone, non zygote) mode.</span></span><br><span class="line">    <span class="comment">// --nice-name : The nice name for this process.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;  <span class="comment">// zygote64 or zygote</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We're not in zygote mode</span></span><br><span class="line">        <span class="comment">// 需要传递给RuntimeInit的唯一参数是application参数，剩余的args传递给启动类main</span></span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppRuntime类的声明和实现均在app_main.cpp中，它是从AndroidRuntime类派生出来的，上述start函数使用的是基类AndroidRuntime的start。</p>
<h2 id="AndroidRuntime-start"><a href="#AndroidRuntime-start" class="headerlink" title="AndroidRuntime.start"></a>AndroidRuntime.start</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/AndroidRuntime.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">"/system"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">"No root directory specified, and /android does not exist."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为后续Java世界用到的一些函数是采用native方式来实现的，所以必须提前注册这些函数</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将参数封装到strArray里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到ZygoteInit类的static main函数的jMethodId</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用ZygoteInit.main函数后，Zygote便进入了Java世界</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h2><p>CallStaticVoidMethod最终将调用com.android.internal.os.ZygoteInit的main函数，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">String</span> socketName = <span class="string">"zygote"</span>;</span><br><span class="line">        <span class="keyword">String</span> abiList = null;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个Zygote的Socket接口，用来和AMS等通信</span></span><br><span class="line">        zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            <span class="comment">// 预加载一些类和资源，这是导致Android系统启动慢的原因之一</span></span><br><span class="line">            <span class="comment">// 应用程序都从Zygote孵化出来，应用程序都会继承Zygote的所有内容，如果在Zygote启动的时候加载这些类和资源，</span></span><br><span class="line">            <span class="comment">// 这些孵化的应用程序就继承Zygote的类和资源，这样启动引用程序的时候就不需要加载类和资源了，启动的速度就会快很多。</span></span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">        gcAndFinalize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">            <span class="comment">// 子进程（system_server）</span></span><br><span class="line">            <span class="keyword">if</span> (r != null) &#123;</span><br><span class="line">                <span class="comment">// 调用com.android.server.SystemServer.main方法</span></span><br><span class="line">                r.<span class="built_in">run</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the command.</span></span><br><span class="line">    <span class="keyword">if</span> (caller != null) &#123;</span><br><span class="line">        caller.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有三个重要的调用：</p>
<ul>
<li>registerServerSocketFromEnv用来创建一个Zygote的Socket接口，用来和AMS等通信</li>
<li>forkSystemServer用来fork创建system_server进程；</li>
<li>runSelectLoop用来处理客户端连接与请求，包括AMS请求创建app进程。</li>
</ul>
<h1 id="system-server进程"><a href="#system-server进程" class="headerlink" title="system_server进程"></a>system_server进程</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>SyetemServer在启动时做了如下工作：</p>
<ol>
<li>启动Binder线程池，这样就可以与其他进程进行通信。</li>
<li>创建SystemServiceManager用于对系统的服务进行创建、启动和生命周期管理。</li>
<li>启动各种系统服务。AMS，PMS，以及WMS等都是运行在system_server这个进程中的线程。</li>
</ol>
<h2 id="ZygoteInit-forkSystemServer"><a href="#ZygoteInit-forkSystemServer" class="headerlink" title="ZygoteInit.forkSystemServer"></a>ZygoteInit.forkSystemServer</h2><p>在上节中，ZygoteInit.main方法首次进入Java世界，然后调用了forkSystemServer方法创建system_server进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> profileSystemServer = SystemProperties.getBoolean(</span><br><span class="line">                <span class="string">"dalvik.vm.profilesystemserver"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (profileSystemServer) &#123;</span><br><span class="line">            parsedArgs.runtimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.runtimeFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里设置了system_server进程的uid，gid和groups，nice-name等，有两个重要的调用：</p>
<ul>
<li>Zygote.forkSystemServer()函数用来fork一个新的进程，如果pid==0，表示已经进入SystemServer子进程，于是先关闭“Zygote”socket，因为系统服务进程system_server也继承了Socket，不用所以close它；</li>
<li>调用了handleSystemServerProcess()方法，返回Runnable对象到ZygoteInit.main并调用，其实是调用到了com.android.server.SystemServer.main方法。</li>
</ul>
<h2 id="Zygote-forkSystemServer"><a href="#Zygote-forkSystemServer" class="headerlink" title="Zygote.forkSystemServer"></a>Zygote.forkSystemServer</h2><p>首先看看Zygote.forkSystemServer方法，它调用的是nativeForkSystemServer方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits, jlong permittedCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                        runtime_flags, rlimits,</span><br><span class="line">                                        permittedCapabilities, effectiveCapabilities,</span><br><span class="line">                                        MOUNT_EXTERNAL_DEFAULT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">true</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ForkAndSpecializeCommon</span><span class="params">(<span class="comment">/* ... */</span>)</span> </span>&#123;</span><br><span class="line">    SetSignalHandlers();</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork(); <span class="comment">// fork子进程</span></span><br><span class="line">    UnsetChldSignalHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSignalHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig_chld</span> = &#123;</span>&#125;;</span><br><span class="line">    sig_chld.sa_handler = SigChldHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sig_chld, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error setting SIGCHLD handler: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig_hup</span> = &#123;</span>&#125;;</span><br><span class="line">    sig_hup.sa_handler = SIG_IGN;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sig_hup, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error setting SIGHUP handler: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets the SIGCHLD handler back to default behavior in zygote children.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnsetChldSignalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error unsetting SIGCHLD handler: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SigChldHandler</span><span class="params">(<span class="keyword">int</span> <span class="comment">/*signal_number*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == gSystemServerPid) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Exit zygote because system server (%d) has terminated"</span>, pid);</span><br><span class="line">            kill(getpid(), SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ForkAndSpecializeCommon中有个逻辑是如果SystemServer进程停止工作，那么首先通过getpid()来获取Zygote进程的pid，然后调用kill函数杀死它，即SystemServer停止工作之后，Zygote进程自杀，然后在Init进程的main()函数中有一个死循环，如果它的子进程Zygote停止工作，就会去重启子进程。</p>
<h2 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess"></a>handleSystemServerProcess</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">    Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">    <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行Binder驱动程序初始化的相关工作，它调用之后system_server进程就可以进行Binder进程通信</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获得com.android.server.SystemServer的main方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    Method m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** method to call */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** argument array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里可以知道ZygoteInit.main方法中的<code>Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</code>返回的r即是MethodAndArgsCaller，在子进程中调用r.run方法便是调用了com.android.server.SystemServer.main方法。</p>
<h2 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer#main"></a>SystemServer#main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先初始化SystemServer对象，再调用对象的run()方法</span></span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepareMainLooper();<span class="comment">// 准备主线程looper</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">    System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line"></span><br><span class="line">    createSystemContext(); <span class="comment">//初始化系统上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建系统服务管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    LocalServices.addService(SystemServiceManager<span class="class">.<span class="keyword">class</span>, <span class="title">mSystemServiceManager</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动各种系统服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一直循环执行</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.main</span><br><span class="line">    SystemServer.run</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        createSystemContext</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        Looper.loop();</span><br></pre></td></tr></table></figure>

<p>LocalServices通过用静态Map变量sLocalServiceObjects，来保存以服务类名为key，以具体服务对象为value的Map结构。</p>
<p>首先看看启动引导服务的方法startBootstrapServices：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞等待与installd建立socket通道</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In some cases after launching an app we need to access device identifiers,</span></span><br><span class="line">    <span class="comment">// therefore register the device identifier policy before the activity manager.</span></span><br><span class="line">    mSystemServiceManager.startService(DeviceIdentifiersPolicyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>).<span class="title">getService</span>()</span>;</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(RecoverySystemService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have the bare essentials of the OS up and running, take</span></span><br><span class="line">    <span class="comment">// note that we just booted, which might send out a rescue party if</span></span><br><span class="line">    <span class="comment">// we're stuck in a runtime restart loop.</span></span><br><span class="line">    RescueParty.noteBoot(mSystemContext);</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(LightsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Package manager isn't started yet; need to use SysProp not hardware feature</span></span><br><span class="line">    <span class="keyword">if</span> (SystemProperties.getBoolean(<span class="string">"config.enable_sidekick_graphics"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        mSystemServiceManager.startService(WEAR_SIDEKICK_SERVICE_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the default display before we can initialize the package manager.</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当设备正在加密时，仅运行core apps</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Detected encryption in progress - only parsing core apps"</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Device encrypted - only parsing core apps"</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the package manager.</span></span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    mDisplayManagerService.setupSchedulerPolicies();</span><br><span class="line">    mSystemServiceManager.startService(<span class="keyword">new</span> OverlayManagerService(mSystemContext, installer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动传感器服务</span></span><br><span class="line">    startSensorService();</span><br></pre></td></tr></table></figure>

<p>该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务等。</p>
<p>然后是启动核心服务startCoreServices：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动服务BatteryService，用于统计电池电量，需要LightService.</span></span><br><span class="line">    mSystemServiceManager.startService(BatteryService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务UsageStatsService，用于统计应用使用情况</span></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WEBVIEW)) &#123;</span><br><span class="line">        <span class="comment">// 启动服务WebViewUpdateService</span></span><br><span class="line">        mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinderCallsStatsService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务BatteryService，UsageStatsService，WebViewUpdateService等。</p>
<p>启动其它服务的startOtherServices方法比较长，主要是启动一系列的服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ServiceManager.addService(<span class="string">"sec_key_att_app_id_provider"</span>, <span class="keyword">new</span> KeyAttestationApplicationIdProviderService(context));</span><br><span class="line">    mSystemServiceManager.startService(KeyChainSystemService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ServiceManager.addService(<span class="string">"scheduling_policy"</span>, <span class="keyword">new</span> SchedulingPolicyService());</span><br><span class="line">    mSystemServiceManager.startService(TelecomLoaderService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    telephonyRegistry = <span class="keyword">new</span> TelephonyRegistry(context);</span><br><span class="line">    ServiceManager.addService(<span class="string">"telephony.registry"</span>, telephonyRegistry);</span><br><span class="line">    mEntropyMixer = <span class="keyword">new</span> EntropyMixer(context);</span><br><span class="line"></span><br><span class="line">    mContentResolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);</span><br><span class="line">    mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备好window, power, package, display服务</span></span><br><span class="line">    wm.systemReady();</span><br><span class="line">    mPowerManagerService.systemReady(...);</span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    mDisplayManagerService.systemReady(...);</span><br><span class="line">    mActivityManagerService.systemReady(...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此, System_server主线程的启动工作总算完成, 进入Looper.loop()状态，等待其他线程通过handler发送消息到主线再处理。</p>
<p>与system_server进程的Application相关的解析可见：<a href="https://ljd1996.github.io/2019/12/16/Android-Application/" target="_blank" rel="noopener">Android-Application</a>。</p>
<h1 id="app进程"><a href="#app进程" class="headerlink" title="app进程"></a>app进程</h1><h2 id="AMS发送请求"><a href="#AMS发送请求" class="headerlink" title="AMS发送请求"></a>AMS发送请求</h2><p>ActivityManagerService也是由SystemServer创建的。假设通过startActivity来启动一个新的Activity，而这个Activity附属于一个还未启动的进程，则会启动一个新的进程，调用startActivity的进程通过Binder调用到ActivityManagerService中的方法，然后经过层层调用（具体可见<a href="https://ljd1996.github.io/2020/03/18/Android-Activity%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Android-Activity启动原理</a>），会调用到Process.start()方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">            runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">            abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的参数processClass为“android.app.ActivityThread”，它是传进去的第一个参数，也就是程序初始化进程时要加载的主文件Java类。当应用进程启动之后，会把这个类加载到进程，调用它的main()方法作为应用程序进程的入口。Process类的start()直接调用了ZygoteProcess类的start()方法，该start()方法调用了ZygoteProcess类的startViaZygote()方法，下面看看该方法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">Process</span>.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> <span class="keyword">String</span> processClass, <span class="keyword">final</span> <span class="keyword">String</span> niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid, <span class="keyword">final</span> <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> targetSdkVersion, <span class="keyword">String</span> seInfo, <span class="keyword">String</span> abi, <span class="keyword">String</span> instructionSet,<span class="keyword">String</span> appDataDir, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">String</span> invokeWith, <span class="keyword">String</span>[] extraArgs)</span> throws ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    ArrayList&lt;<span class="keyword">String</span>&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">    argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">    argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">    argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    synchronized(mLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先给它设置值，包括uid、gid等。接着调用openZygoteSocketIfNeeded()方法来连接“zygote”Socket，链接Socket成功之后，就会调用zygoteSendArgsAndGetResult()方法来进一步处理。</p>
<p>先来看看openZygoteSocketIfNeeded()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中的mSocket的值是“zygote”，通过connect()方法去连接“zygote”Socket。接着看看zygoteSendArgsAndGetResult()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Socket写入流writer把前面传过来的那些参数写进去，Socket即ZygoteServer类的runSelectLoop()方法监听。写入这些数据之后，ZygoteServer类的runSelectLoop()方法就能被监听到。</p>
<h2 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForkChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mIsForkChild = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ZygoteConnection connection = peers.get(i);</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="comment">// 通过mIsForkChild变量控制父进程接着死循环/子进程返回command</span></span><br><span class="line">                    <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                        <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> command;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                            connection.closeSocket();</span><br><span class="line">                            peers.remove(i);</span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mIsForkChild) &#123;</span><br><span class="line">                        ZygoteConnection conn = peers.remove(i);</span><br><span class="line">                        conn.closeSocket();</span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入ZygoteConnection类的processOneCommand()方法后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">            parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">            parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,</span><br><span class="line">            parsedArgs.appDataDir);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            zygoteServer.setForkChild();</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此处通过Zygote.forkAndSpecialize()来fork新的应用进程，而启动systemserver进程是通过Zygote.forkSystemServer()来fork SystemServer进程。</li>
<li>此处通过handleChildProc()方法处理，而之前是用handleSystemServerProcess()来处理。</li>
</ul>
<p>通过fork新的应用程序进程之后，返回pid等于0就表示进入子进程，于是调用handleChildProc()方法进一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors,FileDescriptor pipeFd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ZygoteInit.zygoteInit中会创建Binder线程池，</span></span><br><span class="line">    <span class="comment">// 也就是说每个进程无论是否包含任何activity等组件，一定至少会包含一个Binder线程</span></span><br><span class="line">    <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,<span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此处，后面便和上面一样的了，唯一不同的是，SystemServer进程启动之后进入的是主类SystemServer.java的main()函数，而这里应用程序启动起来后进入的是主类是ActivityThread.java的main()函数，进入ActivityThread.main()方法后，会创建Application实例，具体可见：<a href="https://ljd1996.github.io/2019/12/16/Android-Application/" target="_blank" rel="noopener">Android-Application</a>。</p>
<p>接下来就只剩下forkAndSpecialize方法的解析了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] fdsToIgnore, <span class="keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于提升fork效率），</span></span><br><span class="line">    <span class="comment">// 并等待这些线程的停止，初始化gc堆的工作</span></span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    <span class="comment">// Resets nice priority for zygote process.</span></span><br><span class="line">    resetNicePriority();</span><br><span class="line">    <span class="comment">// 调用fork()创建新进程，设置新进程的主线程id，重置gc性能数据，设置信号处理函数</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">                uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">                fdsToIgnore, startChildZygote, instructionSet, appDataDir);</span><br><span class="line">    <span class="comment">// 在fork新进程后，启动Zygote的4个Daemon线程，java堆整理等。</span></span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeForkAndSpecialize()方法是一个Native方法，最终调用的是frameworks/base/core/jni/com_android_internal_os_Zygote.cpp#com_android_internal_os_Zygote_nativeForkAndSpecialize()方法，该方法又调用的是ForkAndSpecializeCommon方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> kZygoteClassName[] = <span class="string">"com/android/internal/os/Zygote"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_Zygote</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    gZygoteClass = MakeGlobalRefOrDie(env, FindClassOrDie(env, kZygoteClassName));</span><br><span class="line">    gCallPostForkChildHooks = GetStaticMethodIDOrDie(env, gZygoteClass, <span class="string">"callPostForkChildHooks"</span>, <span class="string">"(IZZLjava/lang/String;)V"</span>);</span><br><span class="line">    <span class="keyword">return</span> RegisterMethodsOrDie(env, <span class="string">"com/android/internal/os/Zygote"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSignalHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig_chld</span> = &#123;</span>&#125;;</span><br><span class="line">    sig_chld.sa_handler = SigChldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets the SIGCHLD handler back to default behavior in zygote children.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnsetChldSignalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = SIG_DFL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SigChldHandler</span><span class="params">(<span class="keyword">int</span> <span class="comment">/*signal_number*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If the just-crashed process is the system_server, bring down zygote</span></span><br><span class="line">        <span class="comment">// so that it is restarted by init and system server will be restarted</span></span><br><span class="line">        <span class="comment">// from there.</span></span><br><span class="line">        <span class="keyword">if</span> (pid == gSystemServerPid) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Exit zygote because system server (%d) has terminated"</span>, pid);</span><br><span class="line">            kill(getpid(), SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray javaGids, jint runtime_flags, </span></span></span><br><span class="line"><span class="function"><span class="params">    jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">    jint mount_external, jstring java_se_info, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> is_system_server, jintArray fdsToClose, jintArray fdsToIgnore,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> is_child_zygote, jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置子进程的signal信号处理函数</span></span><br><span class="line">    SetSignalHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        PreApplicationInit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理所有必须立即关闭的描述符</span></span><br><span class="line">        <span class="keyword">if</span> (!DetachDescriptors(env, fdsToClose, &amp;error_msg)) &#123;</span><br><span class="line">            fail_fn(error_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Re-open all remaining open file descriptors so that they aren't shared</span></span><br><span class="line">        <span class="comment">// with the zygote across a fork.</span></span><br><span class="line">        <span class="keyword">if</span> (!gOpenFdTable-&gt;ReopenOrDetach(&amp;error_msg)) &#123;</span><br><span class="line">            fail_fn(error_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        MountEmulatedStorage(uid, mount_external, use_native_bridge, &amp;error_msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this zygote isn't root, it won't be able to create a process group,</span></span><br><span class="line">        <span class="comment">// since the directory is owned by root.</span></span><br><span class="line">        <span class="keyword">if</span> (!is_system_server &amp;&amp; getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// selinux上下文</span></span><br><span class="line">        rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (se_name_c_str == <span class="literal">NULL</span> &amp;&amp; is_system_server) &#123;</span><br><span class="line">            se_name_c_str = <span class="string">"system_server"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (se_name_c_str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            SetThreadName(se_name_c_str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unset the SIGCHLD handler, but keep ignoring SIGHUP (rationale in SetSignalHandlers).</span></span><br><span class="line">        UnsetChldSignalHandler();</span><br><span class="line">        <span class="comment">// 等价于调用zygote.callPostForkChildHooks()</span></span><br><span class="line">        env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                                is_system_server, is_child_zygote, instructionSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入zygote.callPostForkChildHooks()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callPostForkChildHooks</span><span class="params">(<span class="keyword">int</span> runtimeFlags, <span class="keyword">boolean</span> isSystemServer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isZygote, String instructionSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用ZygoteHooks.postForkChild()</span></span><br><span class="line">    VM_HOOKS.postForkChild(runtimeFlags, isSystemServer, isZygote, instructionSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZygoteHooks.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkChild</span><span class="params">(<span class="keyword">int</span> runtimeFlags, <span class="keyword">boolean</span> isSystemServer, <span class="keyword">boolean</span> isZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instructionSet)</span> </span>&#123;</span><br><span class="line">    nativePostForkChild(token, runtimeFlags, isSystemServer, isZygote, instructionSet);</span><br><span class="line">    <span class="comment">// 设置了新进程Random随机数种子为当前系统时间，也就是在进程创建的那一刻就决定了未来随机数的情况，也就是伪随机。</span></span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativePostForkChild通过JNI最终调用调用如下方法：art/runtime/native/dalvik_system_ZygoteHooks.cc#ZygoteHooks_nativePostForkChild()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZygoteHooks_nativePostForkChild</span><span class="params">(JNIEnv* env, jclass, jlong token, jint debug_flags, jstring instruction_set)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处token记录着当前线程</span></span><br><span class="line">    Thread* thread = <span class="keyword">reinterpret_cast</span>&lt;Thread*&gt;(token);</span><br><span class="line">    <span class="comment">// 设置新进程的主线程id</span></span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    <span class="keyword">if</span> (instruction_set != <span class="literal">nullptr</span> &amp;&amp; !is_system_server) &#123;</span><br><span class="line">        <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instruction_set)</span></span>;</span><br><span class="line">        InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">        Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">        <span class="keyword">if</span> (isa != InstructionSet::kNone &amp;&amp; isa != kRuntimeISA) &#123;</span><br><span class="line">            action = Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime::Current()-&gt;InitNonZygoteOrPostFork(env, is_system_server, action, isa_string.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Runtime::Current()-&gt;InitNonZygoteOrPostFork(env, is_system_server,</span><br><span class="line">            Runtime::NativeBridgeAction::kUnload, <span class="literal">nullptr</span>, profile_system_server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用了art/runtime/runtime.cc#InitNonZygoteOrPostFork方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Runtime::InitNonZygoteOrPostFork</span><span class="params">(JNIEnv* env, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">    NativeBridgeAction action, <span class="keyword">const</span> <span class="keyword">char</span>* isa, <span class="keyword">bool</span> profile_system_server)</span> </span>&#123;</span><br><span class="line">    is_zygote_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_native_bridge_loaded_) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> NativeBridgeAction::kUnload:</span><br><span class="line">                UnloadNativeBridge(); <span class="comment">// 卸载用于跨平台的桥连库</span></span><br><span class="line">                is_native_bridge_loaded_ = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> NativeBridgeAction::kInitialize:</span><br><span class="line">                InitializeNativeBridge(env, isa); <span class="comment">// 初始化用于跨平台的桥连库</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Java堆处理的线程池</span></span><br><span class="line">    heap_-&gt;CreateThreadPool();</span><br><span class="line">    <span class="comment">// 重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span></span><br><span class="line">    heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!safe_mode_ &amp;&amp; (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &amp;&amp; jit_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建JIT</span></span><br><span class="line">        CreateJit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    StartSignalCatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>init进程(pid=1)是Linux系统中用户空间的第一个进程，主要工作如下：</p>
<ul>
<li>分析和运行所有的init.rc文件;</li>
<li>生成设备驱动节点;（通过rc文件创建）</li>
<li>处理子进程的终止(signal方式);</li>
<li>创建一块共享的内存空间用于属性服务器，并启动相应属性服务进程;</li>
<li>进入无限循环状态，执行如下流程：<ul>
<li>检查是否需要重启的进程，若有则将其重新启动;</li>
<li>进入epoll_wait等待状态，直到系统属性变化事件(property_set改变属性值)，或者收到子进程的信号SIGCHLD，再或者keychord 键盘输入事件，则会退出等待状态，执行相应的回调函数。</li>
</ul>
</li>
</ul>
<p>可见init进程在开机之后的核心工作就是响应property变化事件和回收僵尸进程以及重启进程。</p>
<ul>
<li>当某个进程调用property_set来改变一个系统属性值时，系统会通过socket向init进程发送一个property变化的事件通知，那么property fd会变成可读，init进程采用epoll机制监听该fd则会触发回调handle_property_set_fd()方法。</li>
<li>回收僵尸进程，在Linux内核中，如父进程不等待子进程的结束直接退出，会导致子进程在结束后变成僵尸进程，占用系统资源。为此，init进程专门安装了SIGCHLD信号接收器，当某些子进程退出时发现其父进程已经退出，则会向init进程发送SIGCHLD信号，init进程调用回调方法handle_signal()来回收僵尸子进程。</li>
</ul>
<p>Zygote启动过程的调用流程：</p>
<ul>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</li>
<li>registerServerSocketFromEnv()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；</li>
<li>zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</li>
</ul>
<p>Zygote进程为了启动SystemServer和启动应用程序进程主要做了两件事，一是初始化Binder驱动用来进行进程间通信，二是通过反射进入main()方法。</p>
<p>将整个流程总结为下图：</p>
<p><img src="init-zygote.jpg" alt="init-zygote总结"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
