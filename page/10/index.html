<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">EventBus 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:13:30" itemprop="dateCreated datePublished" datetime="2020-05-31T11:13:30+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>EventBus是一个Android端优化的publish／subscribe消息总线，简化了应用程序内各组件内、组件与后台线程间的通信，比如请求网络，等网络返回时，通过Handler、Broadcast更新UI等。它有很多优点：简化应用组件间的通信；解耦事件的发送者和接收者。<br><img src="https://upload-images.jianshu.io/upload_images/2169292-9d0c216714804720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EventBus-Publish-Subscribe.png"></p>
<h5 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h5><p>注册： EventBus.getDefault().register(this);<br>解注册：EventBus.getDefault().unregister(this);<br>事件Event： 事件可以是任意普通的Java对象，没有任何特殊的要求<br>发送消息： EventBus.getDefault().post(new MessageEvent(“Hello EventBus!”));</p>
<h5 id="三、线程模式"><a href="#三、线程模式" class="headerlink" title="三、线程模式"></a>三、线程模式</h5><p>EventBus支持订阅者方法在不同于发布事件所在线程的线程中被调用。你可以使用线程模式来指定调用订阅者方法的线程。EventBus总共支持5种线程模式：</p>
<ul>
<li><p>ThreadMode.POSTING 订阅者方法将在发布事件所在的线程中被调用。这是 默认的线程模式。事件的传递是同步的，一旦发布事件，所有该模式的订阅者方法都将被调用。这种线程模式意味着最少的性能开销，因为它避免了线程的切换。因此，对于不要求是主线程并且耗时很短的简单任务推荐使用该模式。使用该模式的订阅者方法应该快速返回，以避免阻塞发布事件的线程，这可能是主线程。</p>
</li>
<li><p>ThreadMode.MAIN 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.MAIN_ORDERED 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。事件将先进入队列然后才发送给订阅者，所以发布事件的调用将立即返回。这使得事件的处理保持严格的串行顺序。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.BACKGROUND 订阅者方法将在后台线程中被调用。如果发布事件的线程不是主线程，那么订阅者方法将直接在该线程中被调用。如果发布事件的线程是主线程，那么将使用一个单独的后台线程，该线程将按顺序发送所有的事件。使用该模式的订阅者方法应该快速返回，以避免阻塞后台线程。</p>
</li>
<li><p>ThreadMode.ASYNC 订阅者方法将在一个单独的线程中被调用。因此，发布事件的调用将立即返回。如果订阅者方法的执行需要一些时间，例如网络访问，那么就应该使用该模式。避免触发大量的长时间运行的订阅者方法，以限制并发线程的数量。EventBus使用了一个线程池来有效地重用已经完成调用订阅者方法的线程。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.POSTING)</span><br><span class="line">    public void onMessageEventPosting(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventPosting(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN)</span><br><span class="line">public void onMessageEventMain(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMain(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN_ORDERED)</span><br><span class="line">public void onMessageEventMainOrdered(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMainOrdered(), current thread is &quot;</span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.BACKGROUND)</span><br><span class="line">public void onMessageEventBackground(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventBackground(), current thread is &quot; </span><br><span class="line">         + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.ASYNC)</span><br><span class="line">public void onMessageEventAsync(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventAsync(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、粘性事件"><a href="#四、粘性事件" class="headerlink" title="四、粘性事件"></a>四、粘性事件</h5><p>发布一个粘性事件之后，EventBus将在内存中缓存该粘性事件。当有订阅者订阅了该粘性事件，订阅者将接收到该事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发布粘性事件</span><br><span class="line">EventBus.getDefault().postSticky(new MessageEvent(&quot;Hello EventBus!&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅粘性事件</span><br><span class="line">@Subscribe(sticky &#x3D; true)</span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、源码解析"><a href="#五、源码解析" class="headerlink" title="五、源码解析"></a>五、源码解析</h5><ol>
<li>从EventBus.getDefault()方法开始说起。主要是获取EventBus对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 典型的双重校验锁的单例模式</span><br><span class="line">static volatile EventBus defaultInstance;</span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">    if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                defaultInstance &#x3D; new EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final EventBusBuilder DEFAULT_BUILDER &#x3D; new EventBusBuilder();</span><br><span class="line">&#x2F;&#x2F; 支持直接通过new创建EventBus</span><br><span class="line">public EventBus() &#123;</span><br><span class="line">    this(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; key 为订阅事件类型，value为订阅该事件的所有订阅者集合</span><br><span class="line">&#x2F;&#x2F; Subscription则是一个封装了订阅者和方法体的一个类</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">&#x2F;&#x2F; key为订阅者，value为订阅的所有事件类型</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">&#x2F;&#x2F; key 为eventType, value为事件集合</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; &#x2F;&#x2F;粘性事件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化成员变量</span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadPoster &#x3D; new HandlerPoster(this, Looper.getMainLooper(), 10);</span><br><span class="line">    backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">    asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">    &#x2F;&#x2F;一系列的builder赋值</span><br><span class="line">    subscriberMethodFinder &#x3D; new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    eventInheritance &#x3D; builder.eventInheritance; &#x2F;&#x2F; 默认支持继承</span><br><span class="line">    executorService &#x3D; builder.executorService;   &#x2F;&#x2F; Executors.newCachedThreadPool();</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">2. 消息注册register(this)函数</span><br></pre></td></tr></table></figure>
public void register(Object subscriber) {<br> Class&lt;?&gt; subscriberClass = subscriber.getClass();<br> // 从订阅类中获取所有的订阅方法信息<br> List<SubscriberMethod> subscriberMethods = subscriberMethodFinder<pre><code>.findSubscriberMethods(subscriberClass);</code></pre> synchronized (this) {<pre><code>for (SubscriberMethod subscriberMethod : subscriberMethods) {
    subscribe(subscriber, subscriberMethod);
}</code></pre> }<br>}</li>
</ol>
<p>private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {<br>    Class&lt;?&gt; eventType = subscriberMethod.eventType;</p>
<pre><code>/**
 ** (1) 将订阅者和订阅方法封装为Subscription对象
 ** (2) 将eventType和List&lt;Subscription&gt;集合添加到subscriptionsByEventType
 ** (3) 根据优先级排序List&lt;Subscription&gt;
 */
Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
if (subscriptions == null) {
    subscriptions = new CopyOnWriteArrayList&lt;&gt;();
    subscriptionsByEventType.put(eventType, subscriptions);
} else {
    if (subscriptions.contains(newSubscription)) {
        throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                + eventType);
    }
}

// 根据优先级排序，找到待插入位置
int size = subscriptions.size();
for (int i = 0; i &lt;= size; i++) {
    if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {
        subscriptions.add(i, newSubscription);
        break;
    }
}

/**
 ** (1) 将eventType事件类型添加subscriber所订阅的事件类型集合中
 */
List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
if (subscribedEvents == null) {
    subscribedEvents = new ArrayList&lt;&gt;();
    typesBySubscriber.put(subscriber, subscribedEvents);
}
subscribedEvents.add(eventType);
if (subscriberMethod.sticky) {
    if (eventInheritance) { // 默认为true
        Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
        for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
            Class&lt;?&gt; candidateEventType = entry.getKey();
            if (eventType.isAssignableFrom(candidateEventType)) {
                Object stickyEvent = entry.getValue();
                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
            }
        }
    } else {
        Object stickyEvent = stickyEvents.get(eventType);
        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
    }
}</code></pre><p>}</p>
<p>List<SubscriberMethod> findSubscriberMethods(Class&lt;?&gt; subscriberClass) {<br>    // 首先从缓存中读取<br>    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);<br>    if (subscriberMethods != null) {<br>        return subscriberMethods;<br>    }<br>    // 默认是false<br>    if (ignoreGeneratedIndex) {<br>        // 利用反射来获取订阅方法中的信息<br>        subscriberMethods = findUsingReflection(subscriberClass);<br>    } else {<br>        // 从注解器获取的类中获得订阅方法信息<br>        subscriberMethods = findUsingInfo(subscriberClass);<br>    }<br>    if (subscriberMethods.isEmpty()) {<br>        throw new EventBusException(“Subscriber “ + subscriberClass<br>                + “ and its super classes have no public methods with “<br>                +” the @Subscribe annotation”);<br>    } else {<br>        // 保存在缓存中<br>        METHOD_CACHE.put(subscriberClass, subscriberMethods);<br>        return subscriberMethods;<br>    }<br>}</p>
<p>private List<SubscriberMethod> findUsingInfo(Class&lt;?&gt; subscriberClass) {<br>    // 准备一个FindState，该FindState保存了订阅者类的信息<br>    FindState findState = prepareFindState();<br>    //对FindState初始化<br>    findState.initForSubscriber(subscriberClass);<br>    while (findState.clazz != null) {<br>        findState.subscriberInfo = getSubscriberInfo(findState);<br>        //获得订阅者的信息，一开始会返回null<br>        if (findState.subscriberInfo != null) {<br>            SubscriberMethod[] array = findState.subscriberInfo<br>                                       .getSubscriberMethods();<br>            for (SubscriberMethod subscriberMethod : array) {<br>                if (findState.checkAdd(subscriberMethod.method<br>                    , subscriberMethod.eventType)) {<br>                    findState.subscriberMethods.add(subscriberMethod);<br>                }<br>            }<br>        } else {<br>            findUsingReflectionInSingleClass(findState);<br>        }<br>        findState.moveToSuperclass();<br>    }<br>    return getMethodsAndRelease(findState);<br>}</p>
<p>private void findUsingReflectionInSingleClass(FindState findState) {<br>    Method[] methods;<br>    try {<br>        methods = findState.clazz.getDeclaredMethods();<br>    } catch (Throwable th) {<br>        methods = findState.clazz.getMethods();<br>        findState.skipSuperClasses = true;<br>    }<br>    for (Method method : methods) {<br>        int modifiers = method.getModifiers();<br>        if ((modifiers &amp; Modifier.PUBLIC) != 0<br>            &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {<br>            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method
                                               .getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    Class<?> eventType = parameterTypes[0];<br>                    if (findState.checkAdd(method, eventType)) {<br>                        ThreadMode threadMode = subscribeAnnotation.threadMode();<br>                        findState.subscriberMethods.add(new SubscriberMethod(method<br>                        , eventType, threadMode,subscribeAnnotation.priority()<br>                        , subscribeAnnotation.sticky()));<br>                    }<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>                   String methodName = method.getDeclaringClass().getName()<br>                                    + “.” + method.getName();<br>                    throw new EventBusException(“@Subscribe method “ + methodName +<br>                 “must have exactly 1 parameter but has “ + parameterTypes.length);<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>            String methodName = method.getDeclaringClass().getName() + “.”<br>                                + method.getName();<br>            throw new EventBusException(methodName +<br>                        “ is a illegal @Subscribe method: must be public “<br>                        + “, non-static, and non-abstract”);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3. 发送消息源码</span><br></pre></td></tr></table></figure>

<p>// 粘性事件<br>public void postSticky(Object event) {<br>    synchronized (stickyEvents) {<br>        stickyEvents.put(event.getClass(), event);<br>    }<br>    post(event);<br>}</p>
<p>// 普通事件<br>public void post(Object event) {<br>    PostingThreadState postingState = currentPostingThreadState.get();<br>    List<Object> eventQueue = postingState.eventQueue;<br>    eventQueue.add(event);<br>    // 如果没有正在发送，则发送消息<br>    if (!postingState.isPosting) {<br>        postingState.isMainThread = isMainThread();<br>        postingState.isPosting = true;<br>        if (postingState.canceled) {<br>          throw new EventBusException(“Internal error. Abort state was not reset”);<br>        }<br>        try {<br>            while (!eventQueue.isEmpty()) {<br>                // 发送消息<br>                postSingleEvent(eventQueue.remove(0), postingState);<br>             }<br>        } finally {<br>            postingState.isPosting = false;<br>            postingState.isMainThread = false;<br>        }<br>    }<br>}</p>
<p>private void postSingleEvent(Object event, PostingThreadState postingState)<br>throws Error {<br>    Class<?> eventClass = event.getClass();
    boolean subscriptionFound = false;
    if (eventInheritance) {
        List<Class<?>&gt; eventTypes = lookupAllEventTypes(eventClass);<br>        int countTypes = eventTypes.size();<br>        for (int h = 0; h &lt; countTypes; h++) {<br>            Class&lt;?&gt; clazz = eventTypes.get(h);<br>            subscriptionFound |= postSingleEventForEventType(event<br>                                 , postingState, clazz);<br>        }<br>     } else {<br>        subscriptionFound = postSingleEventForEventType(event, postingState<br>                                                        , eventClass);<br>     }<br>     if (!subscriptionFound) {<br>        if (logNoSubscriberMessages) {<br>            logger.log(Level.FINE, “No subscribers registered for event “<br>                       + eventClass);<br>        }<br>        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class<br>            &amp;&amp; eventClass != SubscriberExceptionEvent.class) {<br>            post(new NoSubscriberEvent(this, event));<br>        }<br>    }<br>}</p>
<p>private boolean postSingleEventForEventType(Object event<br>                          , PostingThreadState postingState, Class&lt;?&gt; eventClass) {<br>    CopyOnWriteArrayList<Subscription> subscriptions;<br>    synchronized (this) {<br>        // 根据事件类型获取所有的订者<br>        subscriptions = subscriptionsByEventType.get(eventClass);<br>    }<br>    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {<br>        for (Subscription subscription : subscriptions) {<br>            postingState.event = event;<br>            postingState.subscription = subscription;<br>            boolean aborted = false;<br>            try {<br>                postToSubscription(subscription, event, postingState.isMainThread);<br>                aborted = postingState.canceled;<br>            } finally {<br>                postingState.event = null;<br>                postingState.subscription = null;<br>                postingState.canceled = false;<br>            }<br>            if (aborted) {<br>                break;<br>            }<br>        }<br>        return true;<br>    }<br>    return false;<br>}</p>
<p>private void postToSubscription(Subscription subscription, Object event<br>                                , boolean isMainThread) {<br>    switch (subscription.subscriberMethod.threadMode) {<br>        case POSTING:<br>            invokeSubscriber(subscription, event);<br>            break;<br>        case MAIN:<br>            if (isMainThread) {<br>                invokeSubscriber(subscription, event);<br>            } else {<br>                mainThreadPoster.enqueue(subscription, event);<br>            }<br>            break;<br>        case MAIN_ORDERED:<br>            if (mainThreadPoster != null) {<br>                mainThreadPoster.enqueue(subscription, event);<br>            } else {<br>                // temporary: technically not correct as poster not decoupled<br>                // from subscriber<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case BACKGROUND:<br>            if (isMainThread) {<br>                backgroundPoster.enqueue(subscription, event);<br>            } else {<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case ASYNC:<br>            asyncPoster.enqueue(subscription, event);<br>            break;<br>        default:<br>            throw new IllegalStateException(“Unknown thread mode: “<br>                                       + subscription.subscriberMethod.threadMode);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4. 取消注册源码分析</span><br></pre></td></tr></table></figure>
<p>public synchronized void unregister(Object subscriber) {<br>    List&lt;Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class<?> eventType : subscribedTypes) {<br>            unsubscribeByEventType(subscriber, eventType);<br>        }<br>        typesBySubscriber.remove(subscriber);<br>    } else {<br>        logger.log(Level.WARNING, “Subscriber to unregister was not<br>                   “+registered before: “ + subscriber.getClass());<br>    }<br>}</p>
<p>private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {<br>    // 获取事件类型的所有订阅者<br>    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);<br>    if (subscriptions != null) {<br>        int size = subscriptions.size();<br>        // 遍历订阅者集合将解除的订阅者移除<br>        for (int i = 0; i &lt; size; i++) {<br>            Subscription subscription = subscriptions.get(i);<br>            if (subscription.subscriber == subscriber) {<br>                subscription.active = false;<br>                subscriptions.remove(i);<br>                i–;<br>                size–;<br>            }<br>        }<br>    }<br>}</p>
<pre><code>简单的进行总结一下，主要就是注册和发送过程比较重要。

注册：

1. 通过反射或者注解获取所有的订阅方法 
2. 将当前订阅者添加到EventBus总的事件订阅者集合中subscriptionsByEventType 
3. 将当前订阅者所有订阅的事件类型添加到typesBySubscriber，方便解注册

发送：
1. 得到要发送的事件类型 
2. 根据事件类型获取订阅者，并循环向每个订阅者发送

解注册：
1. 通过typesBySubscriber获取当前订阅者所有的订阅事件类型
2. 循环遍历每一个事件类型，并删除当前订阅者的订阅的方法</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">RxJava 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:10:57" itemprop="dateCreated datePublished" datetime="2020-05-31T11:10:57+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、RxJava-简介"><a href="#一、RxJava-简介" class="headerlink" title="一、RxJava 简介"></a>一、RxJava 简介</h5><p>RxJava是一种基于观察者模式的响应式编程框架，其定义的角色有Observable事件流、ObservableOnSubscribe事件源头、Observer是事件订阅者。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">12 系统启动并解析Manifest的流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Manifest%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">Manifest解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近有同学问我关于Manifest何时被系统解析的问题，正好也分析到这一块了，索性这一章就讲解一下android系统何时解析Manifest吧，这里的Manifest指的是android安装文件apk中的androidManifest.xml文件是何时被解析的。<br>大家应该都知道，Android系统启动之后，我们就可以在一个应用中打开另一个从未打开过的应用，或者是在一个应用中发送广播，如果另外一个应用设置了这个广播的接收器，那么这个应用进程就会被启动并接收该广播并作出相应的处理，这样的例子很多，我们可以猜测到Android系统在启动的时候就会抓取到了系统中所有安装的应用信息（应该是解析apk文件的Manifest信息），即在Android系统的启动过程中就已经解析了系统中安装应用的androidManifest.xml文件并保存起来了，那么这个过程具体是如何的呢?</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/11%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/11%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">11 应用进程启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">应用启动流程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每一个android应用默认都是在他自己的linux进程中运行。android操作系统会在这个android应用中的组件需要被执行的时候启动这个应用进程，并且会在这个应用进程没有任何组件执行或者是系统需要为其他应用申请更多内存的时候杀死这个应用进程。所以当我们需要启动这个应用的四大组件之一的时候如果这个应用的进程还没有启动，那么就会先启动这个应用程序进程。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/30/11%20%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/10%20Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/10%20Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">10 Launcher启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Launcher启动流程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Launcher程序就是我们平时看到的桌面程序，它其实也是一个android应用程序，只不过这个应用程序是系统默认第一个启动的应用程序，这里我们就简单的分析一下Launcher应用的启动流程。</p>
<p>不同的手机厂商定制android操作系统的时候都会更改Launcher的源代码，我们这里以android23的源码为例大致的分析一下Launcher的启动流程。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/30/10%20Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/9%20SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/9%20SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">9 SystemServer进程启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/SystemServer/" itemprop="url" rel="index"><span itemprop="name">SystemServer</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上面一文中我们讲过android系统中比较重要的几个进程：init进程，Zygote进程，SystemServer进程已经各种应用进程，其中Zygote进程是整个android系统的根进程，包含SystemServer进程已经各种应用进程在内的进程都是通过Zygote进程fork出来的，那么SystemServer进程是做什么用的呢？</p>
<p>其实SystemServer进程主要的作用是在这个进程中启动各种系统服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务，以及各种系统性的服务其实都是在SystemServer进程中启动的，而当我们的应用需要使用各种系统服务的时候其实也是通过与SystemServer进程通讯获取各种服务对象的句柄的。</p>
<p>由上一篇文章我们知道SystemServer进程其实也是有Zygote进程fork出来的，并且执行其main方法，那么这里我们以android23的源码为例，看一下SystemServer的main方法的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里比较简单，只是new出一个SystemServer对象并执行其run方法，查看SystemServer类的定义我们知道其实final类型的，所以我们一般不能重写或者继承。</p>
<p>然后我们查看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private void run() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1、首先判断系统当前时间，为防止一些和时间相关的初始化出错，若当前时间小于1970年1月1日，设置系统当前时间为该时间点。    </span><br><span class="line">    if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);</span><br><span class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2、设置系统的语言环境等 </span><br><span class="line">    if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) &#123;</span><br><span class="line">        final String languageTag &#x3D; Locale.getDefault().toLanguageTag();</span><br><span class="line">        SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag);</span><br><span class="line">        SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;);</span><br><span class="line">        SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;);</span><br><span class="line">        SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3、设置当前虚拟机的运行库路径</span><br><span class="line">    SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">    VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; The system server has to run all of the time, so it needs to be</span><br><span class="line">        &#x2F;&#x2F; as efficient as possible with its memory usage.</span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 5、设置线程优先级</span><br><span class="line">    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(false);</span><br><span class="line">    &#x2F;&#x2F; 6、初始化Looper</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    &#x2F;&#x2F; 7、装载libandroid_servers.so库</span><br><span class="line">    System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line"></span><br><span class="line">    performPendingShutdown();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 8、创建System的context</span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 9、 创建SystemServiceManager，负责服务的启动</span><br><span class="line">    mSystemServiceManager &#x3D; new SystemServiceManager(mSystemContext);</span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 10、Start services. 真正的开启服务了</span><br><span class="line">    try &#123;</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 11、 进入Loop循环，处理消息循环</span><br><span class="line">    Looper.loop();</span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用createSystemContext()方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private void createSystemContext() &#123;</span><br><span class="line">    ActivityThread activityThread &#x3D; ActivityThread.systemMain();</span><br><span class="line">    mSystemContext &#x3D; activityThread.getSystemContext();</span><br><span class="line">    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">    </span><br><span class="line">    final Context systemUiContext &#x3D; activityThread.getSystemUiContext();</span><br><span class="line">    systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityThread.java]</span><br><span class="line">public static ActivityThread systemMain() &#123;</span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">    if (!system) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果是个应用，走这里</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;,</span><br><span class="line">            UserHandle.myUserId());</span><br><span class="line">        try &#123;</span><br><span class="line">            mInstrumentation &#x3D; new Instrumentation();</span><br><span class="line">            mInstrumentation.basicInit(this);</span><br><span class="line">            &#x2F;&#x2F; mPackageInfo是一个LoadedApk对象</span><br><span class="line">            ContextImpl context &#x3D; ContextImpl.createAppContext(</span><br><span class="line">                    this, getSystemContext().mPackageInfo);</span><br><span class="line">            mInitialApplication &#x3D; context.mPackageInfo.makeApplication(true, null);</span><br><span class="line">            mInitialApplication.onCreate();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate Application():&quot; + e.toString(), e);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ContextImpl getSystemContext() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mSystemContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mSystemContext &#x3D; ContextImpl.createSystemContext(this);</span><br><span class="line">        &#125;</span><br><span class="line">        return mSystemContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ContextImpl createSystemContext(ActivityThread mainThread) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建LoadedApk</span><br><span class="line">    LoadedApk packageInfo &#x3D; new LoadedApk(mainThread);</span><br><span class="line">    ContextImpl context &#x3D; new ContextImpl(null, mainThread, packageInfo, null, null, null, 0, null);</span><br><span class="line">    context.setResources(packageInfo.getResources());</span><br><span class="line">    context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(),</span><br><span class="line">        context.mResourcesManager.getDisplayMetrics());</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[LoadedApk.java]</span><br><span class="line">LoadedApk(ActivityThread activityThread) &#123;</span><br><span class="line">    mActivityThread &#x3D; activityThread;</span><br><span class="line">    mApplicationInfo &#x3D; new ApplicationInfo();</span><br><span class="line">    mApplicationInfo.packageName &#x3D; &quot;android&quot;;</span><br><span class="line">    mPackageName &#x3D; &quot;android&quot;;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; LoadedAPK对象使用来保存一个apk文件的信息，这个构造方法中会将使用的包名指定为”android”，</span><br><span class="line">&#x2F;&#x2F; 而framework-res.apk的包名正是”android”。意味着getSystemContext中创建的mSystemContext对象对应的apk文件是framework-res.apk。</span><br><span class="line">&#x2F;&#x2F; framework-res.apk文件位于&#x2F;system&#x2F;framework文件夹中，里面有着系统大部分的图片，包括图标，弹出对话框的样式，动作特效，界面布局。</span><br></pre></td></tr></table></figure>
<p>可以看到在SystemServer进程中也存在着Context对象，并且是通过ActivityThread.systemMain方法创建context的，这一部分的逻辑以后会通过介绍Activity的启动流程来介绍，这里就不在扩展，只知道在SystemServer进程中也需要创建Context对象。<br>然后通过SystemServiceManager的构造方法创建了一个新的SystemServiceManager对象，我们知道SystemServer进程主要是用来构建系统各种service服务的，而SystemServiceManager就是这些服务的管理对象。<br>然后调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br></pre></td></tr></table></figure>
<p>是将SystemServiceManager对象保存SystemServer进程中的一个数据结构中。</p>
<p>最后开始执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Start services.</span><br><span class="line">try &#123;</span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">&#125; catch (Throwable ex) &#123;</span><br><span class="line">    Slog.e(&quot;System&quot;, &quot;******************************************&quot;);</span><br><span class="line">    Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);</span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面主要涉及了是三个方法：<br>startBootstrapServices() 主要用于启动系统Boot级服务<br>startCoreServices() 主要用于启动系统核心的服务<br>startOtherServices() 主要用于启动一些非紧要或者是非需要及时启动的服务</p>
<p>下面我们重点介绍这三个启动服务的方法，包括启动那些系统服务已经如何启动系统服务等。</p>
<p>首先看一下startBootstrapServices方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void startBootstrapServices() &#123;</span><br><span class="line">    Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">        ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">    </span><br><span class="line">    mDisplayManagerService &#x3D; mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">    mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Installer installer &#x3D; mSystemServiceManager.startService(Installer.class);</span><br></pre></td></tr></table></figure>
<p>mSystemServiceManager是系统服务管理对象，在main方法中已经创建完成，这里我们看一下其startService方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123;</span><br><span class="line">    final String name &#x3D; serviceClass.getName();</span><br><span class="line">    Slog.i(TAG, &quot;Starting &quot; + name);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create the service.</span><br><span class="line">    if (!SystemService.class.isAssignableFrom(serviceClass)) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failed to create &quot; + name</span><br><span class="line">            + &quot;: service must extend &quot; + SystemService.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    final T service;</span><br><span class="line">    try &#123;</span><br><span class="line">        Constructor&lt;T&gt; constructor &#x3D; serviceClass.getConstructor(Context.class);</span><br><span class="line">        service &#x3D; constructor.newInstance(mContext);</span><br><span class="line">    &#125; catch (InstantiationException ex) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">            + &quot;: service could not be instantiated&quot;, ex);</span><br><span class="line">    &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">            + &quot;: service must have a public constructor with a Context argument&quot;, ex);</span><br><span class="line">    &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">            + &quot;: service must have a public constructor with a Context argument&quot;, ex);</span><br><span class="line">    &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failed to create service &quot; + name</span><br><span class="line">             + &quot;: service constructor threw an exception&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Register it.</span><br><span class="line">    mServices.add(service);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Start it.</span><br><span class="line">    try &#123;</span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failed to start service &quot; + name</span><br><span class="line">            + &quot;: onStart threw an exception&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们通过反射器构造方法创建出服务类，然后添加到SystemServiceManager的服务列表数据中，最后调用了service.onStart()方法，因为我们传递的是Installer.class，我们这里我们查看一下Installer的onStart方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStart() &#123;</span><br><span class="line">    Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;);</span><br><span class="line">    mInstaller.waitForConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单就是执行了mInstaller的waitForConnection方法，这里简单介绍一下Installer类，该类是系统安装apk时的一个服务类，继承SystemService（系统服务的一个抽象接口），我们需要在启动完成Installer服务之后才能启动其他的系统服务。<br>然后查看waitForConnection（）方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void waitForConnection() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (execute(&quot;ping&quot;) &gt;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.w(TAG, &quot;installd not ready&quot;);</span><br><span class="line">        SystemClock.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过追踪代码可以发现，其在不断的通过ping命令连接Zygote进程（SystemServer和Zygote进程通过socket方式通讯，其他进程通过Binder方式通讯）；</p>
<p><strong>总结：</strong><br>在开始执行启动服务之前总是会先尝试通过socket方式连接Zygote进程，在成功连接之后才会开始启动其他服务。</p>
<p>继续来看startBootstrapServices方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Activity manager runs the show.</span><br><span class="line">mActivityManagerService &#x3D; mSystemServiceManager.startService(</span><br><span class="line">    ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">mActivityManagerService.setInstaller(installer);</span><br></pre></td></tr></table></figure>
<p>这段代码主要是用于启动ActivityManagerService服务，并为其设置SysServiceManager和Installer。ActivityManagerService是系统中一个非常重要的服务，Activity，service，Broadcast，contentProvider都需要通过其余系统交互。</p>
<p>首先看一下Lifecycle类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static final class Lifecycle extends SystemService &#123;</span><br><span class="line">    private final ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">    public Lifecycle(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        mService &#x3D; new ActivityManagerService(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    ublic void onStart() &#123;</span><br><span class="line">        mService.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ActivityManagerService getService() &#123;</span><br><span class="line">        return mService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实ActivityManagerService的一个静态内部类，在其构造方法中会创建一个ActivityManagerService，通过刚刚对Installer服务的分析我们知道，SystemServiceManager的startService方法会调用服务的onStart()方法，而在Lifecycle类的定义中我们看到其onStart（）方法直接调用了mService.start()方法，mService是Lifecycle类中对ActivityManagerService的引用，所以我们可以看一下ActivityManagerService的start方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void start() &#123;</span><br><span class="line">    Process.removeAllProcessGroups();</span><br><span class="line">    mProcessCpuThread.start();</span><br><span class="line"></span><br><span class="line">    mBatteryStatsService.publish(mContext);</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    Slog.d(&quot;AppOps&quot;, &quot;AppOpsService published&quot;);</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于ActivityManagerService的创建过程比较复杂这里不做过多的分析了，主要是在其构造方法中初始化了一些变量。</p>
<p>然后是启动PowerManagerService服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPowerManagerService &#x3D; mSystemServiceManager.startService(PowerManagerService.class);</span><br></pre></td></tr></table></figure>
<p>启动方式跟上面的ActivityManagerService服务相似都会调用其构造方法和onStart方法，PowerManagerService主要用于计算系统中和Power相关的计算，然后决策系统应该如何反应。同时协调Power如何与系统其它模块的交互，比如没有用户活动时，屏幕变暗等等。</p>
<p>然后是启动LightsService服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSystemServiceManager.startService(LightsService.class);</span><br></pre></td></tr></table></figure>
<p>主要是手机中关于闪光灯，LED等相关的服务；也是会调用LightsService的构造方法和onStart方法；</p>
<p>然后是启动DisplayManagerService服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDisplayManagerService &#x3D; mSystemServiceManager.startService(DisplayManagerService.class);</span><br></pre></td></tr></table></figure>
<p>主要是手机显示方面的服务；</p>
<p>然后是启动PackageManagerService，该服务也是android系统中一个比较重要的服务，包括多apk文件的安装，解析，删除，卸载等等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Slog.i(TAG, &quot;Package Manager&quot;);</span><br><span class="line">mPackageManagerService &#x3D; PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">    mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">mFirstBoot &#x3D; mPackageManagerService.isFirstBoot();</span><br><span class="line">mPackageManager &#x3D; mSystemContext.getPackageManager();</span><br></pre></td></tr></table></figure>
<p>可以看到PackageManagerService服务的启动方式与其他服务的启动方式有一些区别，直接调用了PackageManagerService的静态main方法，这里我们看一下其main方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">    boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    PackageManagerService m &#x3D; new PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore);</span><br><span class="line">    ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到也是直接使用new的方式创建了一个PackageManagerService对象，并在其构造方法中初始化相关变量，最后调用了ServiceManager.addService方法，主要是通过Binder机制与JNI层交互，这里不再扩展。</p>
<p>然后启动UserManagerService和SensorService，至此startBootstrapServices方法执行完成。</p>
<p>然后查看startCoreServices方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">    LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line">    mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里启动了BatteryService（电池相关服务），UsageStatsService，WebViewUpdateService服务等。</p>
<p>最后看一下startOtherServices方法，主要用于启动系统中其他的服务，代码很多，这里就不贴代码了，启动的流程和ActivityManagerService的流程类似，会调用服务的构造方法与onStart方法初始化变量。</p>
<p>总结：</p>
<ul>
<li>SystemServer进程是android中一个很重要的进程由Zygote进程启动</li>
<li>SystemServer进程主要用于启动系统中的服务</li>
<li>SystemServer进程启动服务的启动函数为main函数</li>
<li>SystemServer在执行过程中首先会初始化一些系统变量，加载类库，创建Context对象，创建SystemServiceManager对象等之后才开始启动系统服务</li>
<li>SystemServer进程将系统服务分为三类：boot服务，core服务和other服务，并逐步启动</li>
<li>SertemServer进程在尝试启动服务之前会首先尝试与Zygote建立socket通讯，只有通讯成功之后才会开始尝试启动服务</li>
<li>创建的系统服务过程中主要通过SystemServiceManager对象来管理，通过调用服务对象的构造方法和onStart方法初始化服务的相关变量</li>
<li>服务对象都有自己的异步消息对象，并运行在单独的线程中</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/8%20Init-Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/8%20Init-Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">8 Init-Zygote进程启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Zygote/" itemprop="url" rel="index"><span itemprop="name">Zygote</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Android系统的启动过程"><a href="#Android系统的启动过程" class="headerlink" title="Android系统的启动过程"></a>Android系统的启动过程</h4><p>Android系统简要启动流程如下：</p>
<img src="/2020/05/30/8%20Init-Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/android-boot.jpg" class="" title="[android-boot]">

<p>当电源按下时引导芯片代码会从预定义的地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。BootLoader是Android操作系统开始运行前的一个小程序，主要将操作系统OS拉起来并进行。</p>
<p>当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。此外，还启动了Kernel的swapper进程（pid = 0）和kthreadd进程（pid = 2）：</p>
<ul>
<li>swapper进程：又称为idle进程，系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Binder Driver、Display、Camera Driver等相关工作。</li>
<li>kthreadd进程：Linux系统的内核进程，是所有内核进程的鼻祖，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。</li>
</ul>
<p>当内核完成系统设置时，它首先在系统文件中寻找init.rc文件，并启动init进程。init进程是一个由内核启动的第一个用户级进程，它的进程号是1，父进程id号是0。它的生命周期贯穿整个linux内核运行的始终，linux中所有其它的进程的共同始祖均为init进程。</p>
<p>init进程是所有用户空间的鼻祖, 它会启动servicemanager(binder服务管家，其功能为查询和注册服务), Zygote进程(Java进程的鼻祖). Zygote进程会创建 system_server进程以及各种app进程。如下图所示：</p>
<img src="/2020/05/30/8%20Init-Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" class="" title="[关系图]">

<p>Android系统的启动流程如下图：</p>
<img src="/2020/05/30/8%20Init-Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Android%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" class="" title="[Android启动流程]">

<h4 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h4><h5 id="init-cpp"><a href="#init-cpp" class="headerlink" title="init.cpp"></a>init.cpp</h5><p>init进程的入口函数是<code>system/core/init/init.cpp</code>的main函数，它的代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：内核态</span></span><br><span class="line">    <span class="comment">// 第二阶段：用户态</span></span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (getenv(<span class="string">"INIT_SECOND_STAGE"</span>) == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        <span class="comment">// Clear the umask，与Linux系统权限有关</span></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">        <span class="comment">// on / and then we'll let the rc file figure out the rest.</span></span><br><span class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"init first stage started!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Failed to mount required partitions early ..."</span>;</span><br><span class="line">            panic();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up SELinux(Security-Enhanced Linux), loading the SELinux policy.</span></span><br><span class="line">        selinux_initialize(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We're in the kernel domain, so re-exec init to transition to the init domain now</span></span><br><span class="line">        <span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line">        <span class="comment">// 按selinux policy要求，重新设置init文件属性</span></span><br><span class="line">        <span class="keyword">if</span> (restorecon(<span class="string">"/init"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 失败的话会reboot</span></span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"restorecon failed"</span>;</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setenv(<span class="string">"INIT_SECOND_STAGE"</span>, <span class="string">"true"</span>, <span class="number">1</span>);</span><br><span class="line">        setenv(<span class="string">"INIT_STARTED_AT"</span>, StringPrintf(<span class="string">"%"</span> PRIu64, start_ms).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次调用init的main函数，启动用户态的init进程</span></span><br><span class="line">        <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>* args[] = &#123; path, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        execv(path, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">        <span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二阶段：用户态</span></span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"init second stage started!"</span>;</span><br><span class="line"></span><br><span class="line">    property_init();  <span class="comment">// 初始化属性服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行内核命令</span></span><br><span class="line">    process_kernel_dt();</span><br><span class="line">    process_kernel_cmdline();</span><br><span class="line">    export_kernel_boot_props();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    property_set(<span class="string">"ro.boottime.init"</span>, getenv(<span class="string">"INIT_STARTED_AT"</span>));</span><br><span class="line">    property_set(<span class="string">"ro.boottime.init.selinux"</span>, getenv(<span class="string">"INIT_SELINUX_TOOK"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置之前使用过的一些环境变量</span></span><br><span class="line">    unsetenv(<span class="string">"INIT_SECOND_STAGE"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_STARTED_AT"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_SELINUX_TOOK"</span>);</span><br><span class="line">    unsetenv(<span class="string">"INIT_AVB_VERSION"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set up SELinux for second stage.</span></span><br><span class="line">    selinux_initialize(<span class="literal">false</span>);</span><br><span class="line">    selinux_restore_context();</span><br><span class="line"></span><br><span class="line">    signal_handler_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启属性服务</span></span><br><span class="line">    start_property_service();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析init.rc</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认会休眠直到有事件唤醒</span></span><br><span class="line">        <span class="keyword">int</span> epoll_timeout_ms = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重启一些挂掉的进程，例如Zygote</span></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            restart_processes();</span><br><span class="line">            <span class="comment">// If there's a process that needs restarting, wake up in time for that.</span></span><br><span class="line">            <span class="keyword">if</span> (process_needs_restart_at != <span class="number">0</span>) &#123;</span><br><span class="line">                epoll_timeout_ms = (process_needs_restart_at - time(<span class="literal">nullptr</span>)) * <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">if</span> (epoll_timeout_ms &lt; <span class="number">0</span>) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, epoll_timeout_ms));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"epoll_wait failed"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一阶段：</p>
<ul>
<li>判断及增加环境变量</li>
<li>创建文件系统目录并挂载相关的文件系统</li>
<li>重定向输入输出/内核Log系统</li>
<li>挂载一些分区设备</li>
<li>完成SELinux相关工作</li>
<li>is_first_stage 收尾 </li>
</ul>
<p>第二阶段：</p>
<ul>
<li>初始化属性域，清空环境变量</li>
<li>完成SELinux相关工作</li>
<li>启动属性服务</li>
<li>解析配置文件，执行各个阶段的动作，创建Zygote的工作就是在其中的某个阶段完成的。</li>
<li>init进入一个无限循环，并且等待一些事情的发生。</li>
</ul>
<h5 id="rc文件语法"><a href="#rc文件语法" class="headerlink" title="rc文件语法"></a>rc文件语法</h5><p>rc文件主要包含Action、Service、Command、Options，其中对于Action和Service的名称都是唯一的，对于重复的命名视为无效。</p>
<h5 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h5><p>Action：通过触发器trigger，即以on开头的语句来决定执行相应的service的时机，具体有如下时机：</p>
<ul>
<li><code>on early-init</code>：在初始化早期阶段触发；</li>
<li><code>on init</code>：在初始化阶段触发；</li>
<li><code>on late-init</code>：在初始化晚期阶段触发；</li>
<li><code>on boot/charger</code>：当系统启动/充电时触发，还包含其他情况，此处不一一列举；</li>
<li><code>on property:&lt;key&gt;=&lt;value&gt;</code>：当属性值满足条件时触发；</li>
</ul>
<h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>服务Service，以service开头，由init进程启动，一般运行在init的一个子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service在启动时会通过fork方式生成子进程。</p>
<p>例如：<code>service servicemanager /system/bin/servicemanager</code>代表的是服务名为servicemanager，服务执行的路径为/system/bin/servicemanager。</p>
<h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><p>下面列举常用的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务；</span><br><span class="line">start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过；</span><br><span class="line">stop &lt;service_name&gt;： 停止正在运行的服务</span><br><span class="line">setprop &lt;name&gt; &lt;value&gt;：设置属性值</span><br><span class="line">mkdir &lt;path&gt;：创建指定目录</span><br><span class="line">symlink &lt;target&gt; &lt;sym_link&gt;： 创建连接到&lt;target&gt;的&lt;sym_link&gt;符号链接；</span><br><span class="line">write &lt;path&gt; &lt;string&gt;： 向文件path中写入字符串；</span><br><span class="line">exec： fork并执行，会阻塞init进程直到程序完毕；</span><br><span class="line">exprot &lt;name&gt; &lt;name&gt;：设定环境变量；</span><br><span class="line">loglevel &lt;level&gt;：设置log级别</span><br></pre></td></tr></table></figure>

<h5 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h5><p>Options是Service的可选项，与service配合使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">disabled: 不随class自动启动，只有根据service名才启动；</span><br><span class="line">oneshot: service退出后不再重启；</span><br><span class="line">user/group： 设置执行服务的用户/用户组，默认都是root；</span><br><span class="line">class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default；</span><br><span class="line">onrestart:当服务重启时执行相应命令；</span><br><span class="line">socket: 创建名为/dev/socket/&lt;name&gt;的socket</span><br><span class="line">critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式</span><br><span class="line">default: 意味着disabled=false，oneshot=false，critical=false。</span><br></pre></td></tr></table></figure>

<h4 id="启动service"><a href="#启动service" class="headerlink" title="启动service"></a>启动service</h4><h5 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">on init</span><br><span class="line">on late-init</span><br><span class="line">    trigger post-fs      </span><br><span class="line">    trigger load_system_props_action</span><br><span class="line">    trigger post-fs-data  </span><br><span class="line">    trigger load_persist_props_action</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line">    trigger boot   </span><br><span class="line"></span><br><span class="line">on post-fs      //挂载文件系统</span><br><span class="line">    start logd</span><br><span class="line">    mount rootfs rootfs / ro remount</span><br><span class="line">    mount rootfs rootfs / shared rec</span><br><span class="line">    mount none /mnt/runtime/default /storage slave bind rec</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">on post-fs-data  //挂载data</span><br><span class="line">    start logd</span><br><span class="line">    start vold   //启动vold，Vold是用于管理和控制Android外部存储介质的后台进程，主要包括SD卡的插拔、挂载/卸载和格式化等。</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">on boot      //启动核心服务</span><br><span class="line">    ...</span><br><span class="line">    class_start core //启动core class</span><br></pre></td></tr></table></figure>

<h5 id="启动zygote"><a href="#启动zygote" class="headerlink" title="启动zygote"></a>启动zygote</h5><p>在init.zygote64_32.rc文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote_secondary stream 660 root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>通过init_parser.cpp完成整个service解析工作，此处就不详细展开讲解析过程，该过程主要工作是：</p>
<ul>
<li>创建一个名叫”zygote”的service结构体；</li>
<li>创建一个用于socket通信的socketinfo结构体；</li>
<li>创建一个包含4个onrestart的action结构体。</li>
</ul>
<p>Zygote服务会随着main class的启动而启动，退出后会由init重启zygote，即使多次重启也不会进入recovery模式。</p>
<p>zygote所对应的可执行文件是<code>/system/bin/app_process</code>，通过调用<code>pid = fork()</code>创建子进程，通过<code>execve(svc-&gt;args[0], (char**)svc-&gt;args, (char**) ENV)</code>，进入app_main.cpp的main()函数。故zygote是通过fork和execv共同创建的。</p>
<p>流程如下：</p>
<p><img src="zygote%E5%90%AF%E5%8A%A8.jpg" alt="zygote启动"></p>
<h5 id="重启zygote"><a href="#重启zygote" class="headerlink" title="重启zygote"></a>重启zygote</h5><p>当init子进程退出时，会产生SIGCHLD信号，并发送给init进程，通过socket套接字传递数据，调用到wait_for_one_process()方法，根据是否是oneshot，来决定是重启子进程，还是放弃启动。</p>
<p>所有的Service里面只有servicemanager，zygote，surfaceflinger这3个服务有onrestart关键字来触发其他service启动过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//zygote可触发media、netd重启</span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line"></span><br><span class="line">//servicemanager可触发healthd、zygote、media、surfaceflinger、drm重启</span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line"></span><br><span class="line">//surfaceflinger可触发zygote重启</span><br><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    onrestart restart zygote</span><br></pre></td></tr></table></figure>

<p>由上可知：</p>
<ul>
<li>zygote：触发media、netd以及子进程(包括system_server进程)重启；</li>
<li>system_server: 触发zygote重启;</li>
<li>surfaceflinger：触发zygote重启;</li>
<li>servicemanager: 触发zygote、healthd、media、surfaceflinger、drm重启</li>
</ul>
<p>所以，surfaceflinger,servicemanager,zygote自身以及system_server进程被杀都会触发Zygote重启。</p>
<h5 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h5><p>我们知道，Windows平台上有一个叫注册表的东西。注册表可以存储一些类似key/value的键值对。一般而言，系统或某些应用程序会把自己的一些属性存储在注册表中，即使下次系统重启或应用程序重启，它还能够根据之前在注册表中设置的属性，进行相应的初始化工作。</p>
<p>Android平台也提供了一个类型机制，可称之为属性服务（property service）。应用程序可通过这个属性机制，查询或设置属性。当某个进程A修改属性值后，init进程会检查访问权限，当权限满足要求后，则更改相应的属性值，属性值一旦改变则会触发相应的触发器（即rc文件中的on开头的语句)，在Android Shared Memmory（共享内存区域）中有一个_system_property_area_区域，里面记录着所有的属性值。对于进程A通过property_get（）方法，获取的也是该共享内存区域的属性值。</p>
<h5 id="属性服务初始化"><a href="#属性服务初始化" class="headerlink" title="属性服务初始化"></a>属性服务初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_property_area();<span class="comment">//初始化属性存储区域</span></span><br><span class="line">    <span class="comment">//加载default.prop文件</span></span><br><span class="line">    load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在properyty_init函数中，先调用init_property_area函数，创建一块用于存储属性的存储区域，然后加载default.prop文件中的内容。虽然属性区域是由init进程创建，但Android系统希望其他进程也能读取这块内存里的东西。为做到这一点，它便做了以下两项工作：</p>
<ul>
<li>把属性区域创建在共享内存上，而共享内存是可以跨进程的。</li>
<li>如何让其他进程知道这个共享内存呢？Android利用了gcc的constructor属性，这个属性指明了一个<strong>libc_prenit函数，当bionic libc库被加载时，将自动调用这个</strong>libc_prenit，这个函数内部就将完成共享内存到本地进程的映射工作。</li>
</ul>
<h5 id="启动属性服务器"><a href="#启动属性服务器" class="headerlink" title="启动属性服务器"></a>启动属性服务器</h5><p>init进程会启动一个属性服务器，而客户端只能通过和属性服务器交互才能设置属性。</p>
<h5 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h5><h5 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h5><p>通过property_get和property_set方法操作，需要include cutils/properties.h，并链接libcutils库。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cutils/properties.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BootAnimation::readyToRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> decrypt[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(<span class="string">"vold.decrypt"</span>, decrypt, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Android.mk</span></span><br><span class="line">LOCAL_SHARED_LIBRARIES := \</span><br><span class="line">    libcutils \</span><br></pre></td></tr></table></figure>

<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><p>通过SystemProperties中的API进行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> android.os.SystemProperties;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finishBooting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SystemProperties.set(<span class="string">"sys.boot_completed"</span>, <span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><ul>
<li>通过命令adb shell: getprop查看手机上所有属性状态值</li>
<li>通过setprop 和 getprop 获取和设置属性</li>
</ul>
<h4 id="zygote进程"><a href="#zygote进程" class="headerlink" title="zygote进程"></a>zygote进程</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是app_main.cpp，进程名为zygote。</p>
<p>当Zygote进程启动后, 便会执行到frameworks/base/cmds/app_process/app_main.cpp文件的main()方法。整个调用流程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app_main.main</span><br><span class="line">    AndroidRuntime.start</span><br><span class="line">        AndroidRuntime.startVm</span><br><span class="line">        AndroidRuntime.startReg</span><br><span class="line">        ZygoteInit.main (首次进入Java世界)</span><br><span class="line">            registerServerSocketFromEnv</span><br><span class="line">            preload</span><br><span class="line">            forkSystemServer</span><br><span class="line">            runSelectLoop</span><br></pre></td></tr></table></figure>

<p>Zygote本身是一个Native的应用程序，和驱动、内核等均无关系。Zygote是由init进程根据init.rc文件中的配置项而创建的。zygote最初的名字叫“app_process”，这个名字是在Android.mk文件中被指定的，但app_process在运行过程中，通过Linux下的pctrl系统调用将自己的名字换成了“zygote”，所以我们通过ps命令看到的进程名是“zygote”。</p>
<p>zygote的原型app_process所对应的源文件是framework/base/cmds/app_process/app_main.cpp，代码如下所示：</p>
<p><strong>app_main.cpp、AndroidRuntime.cpp</strong></p>
<p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/cmds/app_process/app_main.cpp" target="_blank" rel="noopener">app_main.cpp</a><br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/AndroidRuntime.cpp" target="_blank" rel="noopener">AndroidRuntime.cpp</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建Binder线程池</span><br><span class="line">virtual void onZygoteInit() &#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    ALOGV(&quot;App process: starting thread pool.\n&quot;);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* const argv[]) &#123;</span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    &#x2F;&#x2F; 解析init.rc参数</span><br><span class="line">    while (i &lt; argc) &#123;</span><br><span class="line">        const char* arg &#x3D; argv[i++];</span><br><span class="line">        if (strcmp(arg, &quot;--zygote&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 启动Zygote进程</span><br><span class="line">            zygote &#x3D; true;</span><br><span class="line">            niceName &#x3D; ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 启动system-server进程</span><br><span class="line">            startSystemServer &#x3D; true;</span><br><span class="line">        &#125; else if (strcmp(arg, &quot;--application&quot;) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            application &#x3D; true;</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--nice-name&#x3D;&quot;, 12) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            niceName.setTo(arg + 12);</span><br><span class="line">        &#125; else if (strncmp(arg, &quot;--&quot;, 2) !&#x3D; 0) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            --i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置一个“好听的名字” zygote，之前的名称是app_process</span><br><span class="line">    if (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string(), true &#x2F;* setProcName *&#x2F;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建虚拟机</span><br><span class="line">    if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) !&#x3D; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line">    &#x2F;&#x2F; 注册JNI函数</span><br><span class="line">    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;Unable to register all android natives\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; JNI调用Java函数, ZygoteInit类的static main函数</span><br><span class="line">    env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int register_com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env) &#123;</span><br><span class="line">    const JNINativeMethod methods[] &#x3D; &#123;</span><br><span class="line">        &#123; &quot;nativeZygoteInit&quot;, &quot;()V&quot;,</span><br><span class="line">            (void*) com_android_internal_os_ZygoteInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    return jniRegisterNativeMethods(env, &quot;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit&quot;,</span><br><span class="line">        methods, NELEM(methods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz) &#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init进程在启动Zygote进程时一般都会调用ZygoteInit类的main方法，因此我们这里看一下该方法的具体实现(基于android23源码)；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String argv[]) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; DDMS 的全称是Dalvik Debug Monitor Service，是 Android 开发环境中的Dalvik虚拟机调试监控服务</span><br><span class="line">        RuntimeInit.enableDdms();</span><br><span class="line"></span><br><span class="line">        boolean startSystemServer &#x3D; false;</span><br><span class="line">        String socketName &#x3D; &quot;zygote&quot;;</span><br><span class="line">        String abiList &#x3D; null;</span><br><span class="line">		&#x2F;&#x2F; 解析app_main.cpp传来的参数</span><br><span class="line">        for (int i &#x3D; 1; i &lt; argv.length; i++) &#123;</span><br><span class="line">            if (&quot;start-system-server&quot;.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer &#x3D; true;</span><br><span class="line">            &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList &#x3D; argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName &#x3D; argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (abiList &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;No ABI list supplied.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 注册zygote的socket监听端口</span><br><span class="line">        registerZygoteSocket(socketName);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 预加载系统资源</span><br><span class="line">        preload();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Do an initial gc to clean up after startup</span><br><span class="line">        gcAndFinalize();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; fork SystemServer子进程</span><br><span class="line">        if (startSystemServer) &#123;</span><br><span class="line">            startSystemServer(abiList, socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 进入监听和接受消息的循环</span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line"></span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; catch (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, &quot;Zygote died with exception&quot;, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行主要是调用enableDdms()，设置DDMS可用，可以发现DDMS启动的时机还是比较早的，在整个Zygote进程刚刚开始要启动额时候就设置可用了。</p>
</li>
<li><p>下面的循环主要是解析main方法的参数获取是否需要启动SystemService进程，获取abi列表，获取scoket连接名称<br>（这里需要注意的是：<strong>android系统中进程之间通讯的方式是Binder</strong>，但是有一个例外是<strong>SystemService进程与Zygote进程之间是通过Socket的方式</strong>进行通讯的）</p>
</li>
<li><p>然后调用registerZygoteSocket（String socketName）为Zygote进程注册socket：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void registerZygoteSocket(String socketName) &#123;</span><br><span class="line">    if (sServerSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">        int fileDesc;</span><br><span class="line">        final String fullSocketName &#x3D; ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">        try &#123;</span><br><span class="line">            String env &#x3D; System.getenv(fullSocketName);</span><br><span class="line">            fileDesc &#x3D; Integer.parseInt(env);</span><br><span class="line">        &#125; catch (RuntimeException ex) &#123;</span><br><span class="line">            throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 创建LocalServerSocket关联FileDescriptor</span><br><span class="line">        try &#123;</span><br><span class="line">            FileDescriptor fd &#x3D; new FileDescriptor();</span><br><span class="line">            fd.setInt$(fileDesc);</span><br><span class="line">            sServerSocket &#x3D; new LocalServerSocket(fd);</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Error binding to local socket&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接着调用系统方法preLoad()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">static void preload() &#123;</span><br><span class="line">    preloadClasses(); &#x2F;&#x2F; 加载系统类</span><br><span class="line">    preloadResources(); &#x2F;&#x2F; 加载系统资源</span><br><span class="line">    preloadOpenGL();    &#x2F;&#x2F; 加载OpenGL</span><br><span class="line">    preloadSharedLibraries(); &#x2F;&#x2F; 加载共享库</span><br><span class="line">    preloadTextResources();</span><br><span class="line">    WebViewFactory.prepareWebViewInZygote(); &#x2F;&#x2F; 加载WebView资源</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final String PRELOADED_CLASSES &#x3D; &quot;&#x2F;system&#x2F;etc&#x2F;preloaded-classes&quot;; </span><br><span class="line">private static void preloadClasses() &#123;</span><br><span class="line">    InputStream is;</span><br><span class="line">    try &#123;</span><br><span class="line">        is &#x3D; new FileInputStream(PRELOADED_CLASSES);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        BufferedReader br&#x3D; new BufferedReader(new InputStreamReader(is), 256);</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        String line;</span><br><span class="line">        while ((line &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            line &#x3D; line.trim();</span><br><span class="line">            if (line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;          </span><br><span class="line">                &#x2F;&#x2F;装载Java类信息</span><br><span class="line">                Class.forName(line, true, null);</span><br><span class="line">                count++;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void preloadResources() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        mResources &#x3D; Resources.getSystem();</span><br><span class="line">        mResources.startPreloading();</span><br><span class="line">        if (PRELOAD_RESOURCES) &#123;</span><br><span class="line">           	&#x2F;&#x2F;加载系统Drawable资源</span><br><span class="line">            TypedArray ar &#x3D; mResources.obtainTypedArray(com.android.internal.R.array.preloaded_drawables);</span><br><span class="line">            int N &#x3D; preloadDrawables(ar);</span><br><span class="line">            ar.recycle();</span><br><span class="line">            &#x2F;&#x2F;加载系统颜色资源</span><br><span class="line">            ar &#x3D; mResources.obtainTypedArray(com.android.internal.R.array.preloaded_color_state_lists);</span><br><span class="line">            N &#x3D; preloadColorStateLists(ar);</span><br><span class="line">            ar.recycle();    </span><br><span class="line">        &#125;</span><br><span class="line">        mResources.finishPreloading();</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void preloadSharedLibraries() &#123;</span><br><span class="line">    Log.i(TAG, &quot;Preloading shared libraries...&quot;);</span><br><span class="line">    System.loadLibrary(&quot;android&quot;);</span><br><span class="line">    System.loadLibrary(&quot;compiler_rt&quot;);</span><br><span class="line">    System.loadLibrary(&quot;jnigraphics&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中：</p>
<ol>
<li>preloadClasses()用于初始化Zygote中需要的class类；</li>
<li>preloadResources()用于初始化系统资源；</li>
<li>preloadOpenGL()用于初始化OpenGL；</li>
<li>preloadSharedLibraries()用于初始化系统libraries；</li>
<li>preloadTextResources()用于初始化文字资源；</li>
<li>prepareWebViewInZygote()用于初始化webview;</li>
</ol>
<ul>
<li>然后调用startSystemServer(abiList, socket);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">private static boolean startSystemServer(String abiList, String socketName)</span><br><span class="line">                        throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">    long capabilities &#x3D; posixCapabilitiesAsBits(</span><br><span class="line">        OsConstants.CAP_BLOCK_SUSPEND,</span><br><span class="line">        OsConstants.CAP_KILL,</span><br><span class="line">        OsConstants.CAP_NET_ADMIN,</span><br><span class="line">        OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">        OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">        OsConstants.CAP_NET_RAW,</span><br><span class="line">        OsConstants.CAP_SYS_MODULE,</span><br><span class="line">        OsConstants.CAP_SYS_NICE,</span><br><span class="line">        OsConstants.CAP_SYS_RESOURCE,</span><br><span class="line">        OsConstants.CAP_SYS_TIME,</span><br><span class="line">        OsConstants.CAP_SYS_TTY_CONFIG</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    String args[] &#x3D; &#123;</span><br><span class="line">        &quot;--setuid&#x3D;1000&quot;,</span><br><span class="line">        &quot;--setgid&#x3D;1000&quot;,</span><br><span class="line">        &quot;--setgroups&#x3D;1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;,</span><br><span class="line">        &quot;--capabilities&#x3D;&quot; + capabilities + &quot;,&quot; + capabilities,</span><br><span class="line">        &quot;--nice-name&#x3D;system_server&quot;,</span><br><span class="line">        &quot;--runtime-args&quot;,</span><br><span class="line">        &quot;com.android.server.SystemServer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs &#x3D; null;</span><br><span class="line">    int pid;</span><br><span class="line">    try &#123;</span><br><span class="line">        parsedArgs &#x3D; new ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; fork创建新的进程</span><br><span class="line">        pid &#x3D; Zygote.forkSystemServer(</span><br><span class="line">            parsedArgs.uid, </span><br><span class="line">            parsedArgs.gid,</span><br><span class="line">            parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags,</span><br><span class="line">            null,</span><br><span class="line">            parsedArgs.permittedCapabilities,</span><br><span class="line">            parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* For child process *&#x2F;</span><br><span class="line">    if (pid &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这段逻辑的执行逻辑就是通过Zygote fork出SystemServer进程。</p>
<img src="/2020/05/30/8%20Init-Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/20180420192323479.png" class="" title="[Android应用进程共享内存图]">


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static void handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">	&#x2F;&#x2F;关闭zygote的socket</span><br><span class="line">    closeServerSocket();</span><br><span class="line">	&#x2F;&#x2F;设置umask为0077；只有SystemServer进程可以访问；</span><br><span class="line">    &#x2F;&#x2F; set umask to 0077 so new files and directories will default to owner-only permissions.</span><br><span class="line">    Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line">	&#x2F;&#x2F;由3.1可以看出nice-name&#x3D;system_server，设置进程的名称为system_server；</span><br><span class="line">    if (parsedArgs.niceName !&#x3D; null) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String systemServerClasspath &#x3D; Os.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);</span><br><span class="line">    if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;由3.1可以看出invokeWith为null;</span><br><span class="line">    if (parsedArgs.invokeWith !&#x3D; null) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ClassLoader cl &#x3D; null;</span><br><span class="line">        if (systemServerClasspath !&#x3D; null) &#123;</span><br><span class="line">            cl &#x3D; createSystemServerClassLoader(systemServerClasspath,</span><br><span class="line">                                               parsedArgs.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);  &#x2F;&#x2F;最终会调用  -&gt; ZygoteInit.nativeZygoteInit();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds &#x3D; new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers &#x3D; new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        StructPollfd[] pollFds &#x3D; new StructPollfd[fds.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] &#x3D; new StructPollfd();</span><br><span class="line">            pollFds[i].fd &#x3D; fds.get(i);</span><br><span class="line">            pollFds[i].events &#x3D; (short) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Os.poll(pollFds, -1);</span><br><span class="line">        &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; pollFds.length - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            if ((pollFds[i].revents &amp; POLLIN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">			&#x2F;&#x2F;4.1）接受连接请求</span><br><span class="line">            if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                ZygoteConnection newPeer &#x3D; acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">			&#x2F;&#x2F;4.2) 接受消息</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                boolean done &#x3D; peers.get(i).runOnce();</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>init进程(pid=1)是Linux系统中用户空间的第一个进程，主要工作如下：</p>
<ul>
<li>分析和运行所有的init.rc文件;</li>
<li>生成设备驱动节点;（通过rc文件创建）</li>
<li>处理子进程的终止(signal方式);</li>
<li>创建一块共享的内存空间用于属性服务器，并启动相应属性服务进程;</li>
<li>进入无限循环状态，执行如下流程：<ul>
<li>检查是否需要重启的进程，若有则将其重新启动;</li>
<li>进入epoll_wait等待状态，直到系统属性变化事件(property_set改变属性值)，或者收到子进程的信号SIGCHLD，再或者keychord 键盘输入事件，则会退出等待状态，执行相应的回调函数。</li>
</ul>
</li>
</ul>
<p>可见init进程在开机之后的核心工作就是响应property变化事件和回收僵尸进程以及重启进程。</p>
<ul>
<li>当某个进程调用property_set来改变一个系统属性值时，系统会通过socket向init进程发送一个property变化的事件通知，那么property fd会变成可读，init进程采用epoll机制监听该fd则会触发回调handle_property_set_fd()方法。</li>
<li>回收僵尸进程，在Linux内核中，如父进程不等待子进程的结束直接退出，会导致子进程在结束后变成僵尸进程，占用系统资源。为此，init进程专门安装了SIGCHLD信号接收器，当某些子进程退出时发现其父进程已经退出，则会向init进程发送SIGCHLD信号，init进程调用回调方法handle_signal()来回收僵尸子进程。</li>
</ul>
<p>Zygote启动过程的调用流程：</p>
<ul>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</li>
<li>registerServerSocketFromEnv()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；</li>
<li>zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</li>
</ul>
<p>Zygote进程为了启动SystemServer和启动应用程序进程主要做了两件事，一是初始化Binder驱动用来进行进程间通信，二是通过反射进入main()方法。</p>
<p>将整个流程总结为下图：</p>
<p><img src="init-zygote.jpg" alt="init-zygote总结"></p>
<h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p><strong>Binder线程池</strong></p>
<p>Binder线程创建与其所在进程的创建中产生，Java层进程的创建都是通过Process.start()方法，向Zygote进程发出创建进程的socket消息，Zygote收到消息后会调用Zygote.forkAndSpecialize()来fork出新进程，在新进程中会调用到RuntimeInit.nativeZygoteInit方法，该方法经过jni映射，最终会调用到app_main.cpp中的onZygoteInit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建Binder线程池</span><br><span class="line">virtual void onZygoteInit() &#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc &#x3D; ProcessState::self();</span><br><span class="line">    ALOGV(&quot;App process: starting thread pool.\n&quot;);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()。</p>
<p>[-&gt; ProcessState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void ProcessState::startThreadPool() &#123;</span><br><span class="line">    &#x2F;&#x2F;多线程同步</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    if (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted &#x3D; true;</span><br><span class="line">        spawnPooledThread(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ProcessState::spawnPooledThread(bool isMain) &#123;</span><br><span class="line">    if (mThreadPoolStarted) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取Binder线程名</span><br><span class="line">        String8 name &#x3D; makeBinderThreadName();</span><br><span class="line">        &#x2F;&#x2F;此处isMain&#x3D;true</span><br><span class="line">        sp&lt;Thread&gt; t &#x3D; new PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String8 ProcessState::makeBinderThreadName() &#123;</span><br><span class="line">    int32_t s &#x3D; android_atomic_add(1, &amp;mThreadPoolSeq);</span><br><span class="line">    String8 name;</span><br><span class="line">    name.appendFormat(&quot;Binder_%X&quot;, s);</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PoolThread : public Thread</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    PoolThread(bool isMain)</span><br><span class="line">        : mIsMain(isMain)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">protected:</span><br><span class="line">    virtual bool threadLoop()</span><br><span class="line">    &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    const bool mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[-&gt; IPCThreadState.cpp]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void IPCThreadState::joinThreadPool(bool isMain) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建Binder线程</span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">    set_sched_policy(mMyThreadId, SP_FOREGROUND); &#x2F;&#x2F;设置前台调度策略</span><br><span class="line"> </span><br><span class="line">    status_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        processPendingDerefs(); &#x2F;&#x2F;清除队列的引用</span><br><span class="line">        result &#x3D; getAndExecuteCommand(); &#x2F;&#x2F;处理下一条指令</span><br><span class="line"> </span><br><span class="line">        if (result &lt; NO_ERROR &amp;&amp; result !&#x3D; TIMED_OUT</span><br><span class="line">                &amp;&amp; result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF) &#123;</span><br><span class="line">            abort();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if(result &#x3D;&#x3D; TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            break; &#x2F;&#x2F;&#x2F;&#x2F;非主线程出现timeout则线程退出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (result !&#x3D; -ECONNREFUSED &amp;&amp; result !&#x3D; -EBADF);</span><br><span class="line"> </span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);  &#x2F;&#x2F; 线程退出循环</span><br><span class="line">    talkWithDriver(false); &#x2F;&#x2F;false代表bwr数据的read_buffer为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于isMain=true的情况下， command为BC_ENTER_LOOPER，代表的是Binder主线程，不会退出的线程；</li>
<li>对于isMain=false的情况下，command为BC_REGISTER_LOOPER，表示是由binder驱动创建的线程。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/7%20android%E4%B9%8BLruCache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/7%20android%E4%B9%8BLruCache/" class="post-title-link" itemprop="url">7 android之LruCache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/LruCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">LruCache源码解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>android开发过程中经常会用到缓存，现在主流的app中图片等资源的缓存策略一般是分两级，一个是内存级别的缓存，一个是磁盘级别的缓存。</p>
<h4 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h4><p>作为android系统的维护者google也开源了其缓存方案，LruCache和DiskLruCache。从android3.1开始LruCache已经作为android源码的一部分维护在android系统中，为了兼容以前的版本android的support-v4包也提供了LruCache的维护，如果App需要兼容到android3.1之前的版本就需要使用support-v4包中的LruCache，如果不需要兼容到android3.1则直接使用android源码中的LruCache即可，这里需要注意的是DiskLruCache并不是android源码的一部分。</p>
<p>在LruCache的源码中，关于LruCache有这样的一段介绍：</p>
<blockquote>
<p>A cache that holds strong references to a limited number of values. Each time a value is accessed, it is moved to the head of a queue. When a value is added to a full cache, the value at the end of that queue is evicted and may become eligible for garbage collection.</p>
</blockquote>
<p>cache对象通过一个强引用来访问内容。每次当一个item被访问到的时候，这个item就会被移动到一个队列的队首。当一个item被添加到已经满了的队列时，这个队列的队尾的item就会被移除。</p>
<p>其实这个实现的过程就是LruCache的缓存策略，即Lru–&gt;(Least recent used)最少最近使用算法。</p>
<p>下面我们具体看一下LruCache的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">public class LruCache&lt;K, V&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 内部采用有序链表LinkedHashMap</span><br><span class="line">    private final LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line">    private int size;</span><br><span class="line">    private int maxSize;</span><br><span class="line"></span><br><span class="line">    private int putCount;</span><br><span class="line">    private int createCount;</span><br><span class="line">    private int evictionCount;</span><br><span class="line">    private int hitCount;</span><br><span class="line">    private int missCount;</span><br><span class="line"></span><br><span class="line">    public LruCache(int maxSize) &#123;</span><br><span class="line">        if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        this.map &#x3D; new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void resize(int maxSize) &#123;</span><br><span class="line">        if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            this.maxSize &#x3D; maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    public final V get(K key) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V mapValue;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mapValue &#x3D; map.get(key);</span><br><span class="line">            if (mapValue !&#x3D; null) &#123;</span><br><span class="line">                hitCount++;</span><br><span class="line">                return mapValue;</span><br><span class="line">            &#125;</span><br><span class="line">            missCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V createdValue &#x3D; create(key);</span><br><span class="line">        if (createdValue &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            createCount++;</span><br><span class="line">            mapValue &#x3D; map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">            if (mapValue !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; There was a conflict so undo that last put</span><br><span class="line">                map.put(key, mapValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                size +&#x3D; safeSizeOf(key, createdValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            trimToSize(maxSize);</span><br><span class="line">            return createdValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V put(K key, V value) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key &#x3D;&#x3D; null || value &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            putCount++;</span><br><span class="line">			&#x2F;&#x2F; 添加节点将size + 1</span><br><span class="line">            size +&#x3D; safeSizeOf(key, value);</span><br><span class="line">            previous &#x3D; map.put(key, value);</span><br><span class="line">			&#x2F;&#x2F; 如果该节点已经存在链表中，则覆盖原先的值，同时将size -  1还原链表大小</span><br><span class="line">            if (previous !&#x3D; null) &#123;</span><br><span class="line">                size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            entryRemoved(false, key, previous, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return previous;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F; 调整LinkedHashMap的大小</span><br><span class="line">    public void trimToSize(int maxSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 死循环，直到链表的size &lt;&#x3D; maxSize</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size !&#x3D; 0)) &#123;</span><br><span class="line">                    throw new IllegalStateException(getClass().getName()</span><br><span class="line">                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (size &lt;&#x3D; maxSize) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 删除尾节点</span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict &#x3D; map.eldest();</span><br><span class="line">                if (toEvict &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                key &#x3D; toEvict.getKey();</span><br><span class="line">                value &#x3D; toEvict.getValue();</span><br><span class="line">                map.remove(key);</span><br><span class="line">                size -&#x3D; safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(true, key, value, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 删除节点</span><br><span class="line">    public final V remove(K key) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            previous &#x3D; map.remove(key);</span><br><span class="line">            &#x2F;&#x2F; 如果找到删除的节点，则size - 1</span><br><span class="line">            if (previous !&#x3D; null) &#123;</span><br><span class="line">                size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            entryRemoved(false, key, previous, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    protected V create(K key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int safeSizeOf(K key, V value) &#123;</span><br><span class="line">        int result &#x3D; sizeOf(key, value);</span><br><span class="line">        if (result &lt; 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;&#x3D;&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected int sizeOf(K key, V value) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void evictAll() &#123;</span><br><span class="line">        trimToSize(-1); &#x2F;&#x2F; -1 will evict 0-sized elements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到LruCache初始化的时候需要使用泛型，一般的我们这样初始化LruCache对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取应用程序最大可用内存  </span><br><span class="line">int maxMemory &#x3D; (int) Runtime.getRuntime().maxMemory();  </span><br><span class="line">int cacheSize &#x3D; maxMemory &#x2F; 8;  </span><br><span class="line">&#x2F;&#x2F; 设置图片缓存大小为程序最大可用内存的1&#x2F;8  </span><br><span class="line">mMemoryCache &#x3D; new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected int sizeOf(String key, Bitmap bitmap) &#123;  </span><br><span class="line">        return bitmap.getByteCount();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们假设通过String作为key保存bitmap对象，同时需要传递一个int型的maxSize数值，主要用于设置LruCache链表的最大值。</p>
<p>查看其构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public LruCache(int maxSize) &#123;</span><br><span class="line">    if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxSize &#x3D; maxSize;</span><br><span class="line">    this.map &#x3D; new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashMap的初始化大小，会返回一个2的整数次幂的大小，并不一定是我们指定的大小</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其主要的是初始化了maxSize和map链表对象。需要注意的是HashMap初始化的时候默认大小为16也就是2的4次方。如果我们指定的大小不是2的整数次幂，会自动寻找一个最接近的符合条件的大小。</p>
<p>然后查看<strong>put方法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final V put(K key, V value) &#123;</span><br><span class="line">	&#x2F;&#x2F; 不能存放null</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null || value &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        putCount++;</span><br><span class="line">        size +&#x3D; safeSizeOf(key, value);</span><br><span class="line">        previous &#x3D; map.put(key, value);</span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (previous !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要传递两个参数：K和V，首先做了一下参数的判断，然后定义一个保存前一个Value值得临时变量，让putCount（put执行的次数）自增，让map的size大小自增。<br>需要注意的是这里的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previous &#x3D; map.put(key, value);</span><br></pre></td></tr></table></figure>
<p>我们看一下这里的map.put（）的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override </span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">	if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return putValueForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int hash &#x3D; Collections.secondaryHash(key);</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] tab &#x3D; table;</span><br><span class="line">    int index &#x3D; hash &amp; (tab.length - 1);</span><br><span class="line">    for (HashMapEntry&lt;K, V&gt; e &#x3D; tab[index]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">            preModify(e);</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No entry for (non-null) key is present; create one</span><br><span class="line">    modCount++;</span><br><span class="line">    if (size++ &gt; threshold) &#123;</span><br><span class="line">        tab &#x3D; doubleCapacity();</span><br><span class="line">        index &#x3D; hash &amp; (tab.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    addNewEntry(key, value, hash, index);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将Key与Value的值压入Map中，这里判断了一下如果map中已经存在该key，value键值对，则不再压入map，并将Value值返回，否则将该键值对压入Map中，并返回null；</p>
<p>返回继续put方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">previous &#x3D; map.put(key, value);</span><br><span class="line">if (previous !&#x3D; null) &#123;</span><br><span class="line">    size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里我们判断map.put方法的返回值是否为空，如果不为空的话，则说明我们刚刚并没有将我么你的键值对压入Map中，所以这里的size需要自减；</p>
<p>然后下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (previous !&#x3D; null) &#123;</span><br><span class="line">    entryRemoved(false, key, previous, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断previous是否为空，如果不为空的话，调用了一个空的实现方法entryRemoved()，也就是说我们可以实现自己的LruCache并在添加缓存的时候若存在该缓存可以重写这个方法；</p>
<p>下面调用了trimToSize(maxSize)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize(int maxSize) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size !&#x3D; 0)) &#123;</span><br><span class="line">                throw new IllegalStateException(getClass().getName()</span><br><span class="line">                  + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (size &lt;&#x3D; maxSize) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict &#x3D; map.eldest();</span><br><span class="line">            if (toEvict &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key &#x3D; toEvict.getKey();</span><br><span class="line">            value &#x3D; toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -&#x3D; safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entryRemoved(true, key, value, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是判断该Map的大小是否已经达到阙值，若达到，则将Map队尾的元素（最不常使用的元素）remove掉。</p>
<p><strong>总结：</strong><br>LruCache put方法，将键值对压入Map数据结构中，若这是Map的大小已经大于LruCache中定义的最大值，则将Map中最早压入的元素remove掉；</p>
<p>查看get方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public final V get(K key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mapValue &#x3D; map.get(key);</span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V createdValue &#x3D; create(key);</span><br><span class="line">    if (createdValue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue &#x3D; map.put(key, createdValue);</span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            size +&#x3D; safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mapValue !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">        return mapValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到参数值为Key，简单的理解就是通过key值从map中取出Value值。<br>具体来说，判断map中是否含有key值value值，若存在，则hitCount（击中元素数量）自增，并返回Value值，若没有击中，则执行create(key)方法，这里看到create方法是一个空的实现方法，返回值为null，所以我们可以重写该方法，在调用get（key）的时候若没有找到value值，则自动创建一个value值并压入map中。</p>
<h4 id="精简版LruCache"><a href="#精简版LruCache" class="headerlink" title="精简版LruCache"></a>精简版LruCache</h4><p>Java已经为我们提供了这种形式的数据结构-LinkedHashMap！它甚至提供可覆盖回收策略的方法。唯一需要我们注意的事情是，改链表的顺序是插入的顺序，而不是访问的顺序。但是，有一个构造函数提供了一个选项，可以使用访问的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public LRUCache extends LinkedHashMap &#123;</span><br><span class="line">  private int cacheSize;</span><br><span class="line"></span><br><span class="line">  public LRUCache(int cacheSize) &#123;</span><br><span class="line">    &#x2F;&#x2F;true for access-order, false for insertion-order</span><br><span class="line">    super(16, 0.75, true);</span><br><span class="line">    this.cacheSize &#x3D; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">    return size() &gt;&#x3D; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>LruCache，内部使用Map保存内存级别的缓存</li>
<li>LruCache使用泛型可以设配各种类型</li>
<li>LruCache使用了Lru算法保存数据</li>
<li>LruCache只用使用put和get方法添加和查找数据</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/6%20android%E4%B9%8BLog%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/6%20android%E4%B9%8BLog%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">6 android之Log日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Log%E6%97%A5%E5%BF%97/" itemprop="url" rel="index"><span itemprop="name">Log日志</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Log类解析"><a href="#Log类解析" class="headerlink" title="Log类解析"></a>Log类解析</h4><p>我们今天需要介绍的Log对象，它位于android framework层utils包下，是一个final class类：查看其具体定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public final class Log &#123;</span><br><span class="line">    public static final int VERBOSE &#x3D; 2;</span><br><span class="line">    public static final int DEBUG &#x3D; 3;</span><br><span class="line">    public static final int INFO &#x3D; 4;</span><br><span class="line">    public static final int WARN &#x3D; 5;</span><br><span class="line">    public static final int ERROR &#x3D; 6；</span><br><span class="line">    public static final int ASSERT &#x3D; 7;</span><br><span class="line"></span><br><span class="line">    private Log() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static int v(String tag, String msg) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, VERBOSE, tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int v(String tag, String msg, Throwable tr) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, VERBOSE, tag, msg + &#39;\n&#39; + getStackTraceString(tr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int d(String tag, String msg) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, DEBUG, tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int d(String tag, String msg, Throwable tr) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, DEBUG, tag, msg + &#39;\n&#39; + getStackTraceString(tr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int i(String tag, String msg) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, INFO, tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int i(String tag, String msg, Throwable tr) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, INFO, tag, msg + &#39;\n&#39; + getStackTraceString(tr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int w(String tag, String msg) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, WARN, tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int w(String tag, String msg, Throwable tr) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, WARN, tag, msg + &#39;\n&#39; + getStackTraceString(tr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int w(String tag, Throwable tr) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int e(String tag, String msg) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, ERROR, tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int e(String tag, String msg, Throwable tr) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, ERROR, tag, msg + &#39;\n&#39; + getStackTraceString(tr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getStackTraceString(Throwable tr) &#123;</span><br><span class="line">        if (tr &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Throwable t &#x3D; tr;</span><br><span class="line">        while (t !&#x3D; null) &#123;</span><br><span class="line">            if (t instanceof UnknownHostException) &#123;</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            t &#x3D; t.getCause();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringWriter sw &#x3D; new StringWriter();</span><br><span class="line">        PrintWriter pw &#x3D; new PrintWriter(sw);</span><br><span class="line">        tr.printStackTrace(pw);</span><br><span class="line">        pw.flush();</span><br><span class="line">        return sw.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int println(int priority, String tag, String msg) &#123;</span><br><span class="line">        return println(LOG_ID_MAIN, priority, tag, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** @hide *&#x2F; public static final int LOG_ID_MAIN &#x3D; 0;</span><br><span class="line">    &#x2F;** @hide *&#x2F; public static final int LOG_ID_RADIO &#x3D; 1;</span><br><span class="line">    &#x2F;** @hide *&#x2F; public static final int LOG_ID_EVENTS &#x3D; 2;</span><br><span class="line">    &#x2F;** @hide *&#x2F; public static final int LOG_ID_SYSTEM &#x3D; 3;</span><br><span class="line">    &#x2F;** @hide *&#x2F; public static final int LOG_ID_CRASH &#x3D; 4;</span><br><span class="line"></span><br><span class="line">    &#x2F;** @hide *&#x2F; @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    public static int println(int bufID, int priority, String tag, String msg) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其实final类，所以我们不能通过继承Log类的方式实现自身的日志工具类，一般的我们可以通过定义Log成员变量的方式，封装Log工具方法；</p>
<p>在Log类中我们定义了六种日志级别，分别是：VERBOSE、DEBUG、INFO、WARN、ERROR、ASSERT等六种级别，但是我们平时使用的只有前五种，即VERBOSE,DEBUG,INFO,WARN,ERROR。</p>
<p>通过查看源代码我们发现Log类中所有的静态日志方法Log.v()，Log.d()，Log.i()，Log.w()，Log.e()等方法都是底层都是调用了println方法，然后在github的源码中查看，其实其内部调用的是println_native方法，也就是通过JNI调用底层的c++输出日志；</p>
<p>我们暂时只是分析到这里，至于底层的c++日志输出的具体实现不作分析，总结一下：</p>
<ul>
<li><p>Log.java是一个final类，所以我们不可以继承Log类来实现自己的日志框架，但是可以通过关联（保存Log成员变量）的方式实现自己的Log工具类；</p>
</li>
<li><p>Log.java中定义了六种日志级别，但是我们通常只是使用其中的五种日志级别，分别对应着VERBOSE、DEBUG、INFO、WARN、ERROR。</p>
</li>
</ul>
<h4 id="Logger框架解析"><a href="#Logger框架解析" class="headerlink" title="Logger框架解析"></a>Logger框架解析</h4><p>Simple, pretty and powerful logger for android。简单，功能强大日志框架，专为Android。其打印出来出来的日志如下图：</p>
<img src="/2020/05/30/6%20android%E4%B9%8BLog%E6%97%A5%E5%BF%97/logger_output.png" class="" title="[Logger日志图]">

<p>Logger的整体框架原理也比较简单：</p>
<img src="/2020/05/30/6%20android%E4%B9%8BLog%E6%97%A5%E5%BF%97/how_it_works.png" class="" title="[Logger框架原理图]">

<p>Logger总共也就13个类，其UML图：</p>
<img src="/2020/05/30/6%20android%E4%B9%8BLog%E6%97%A5%E5%BF%97/Logger.png" class="" title="[Logger类图]">

<p><strong>Logger</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class Logger &#123;</span><br><span class="line">	&#x2F;&#x2F; Printer接口, LoggerPrinter才是具体实现类</span><br><span class="line">	private static Printer printer &#x3D; new LoggerPrinter();</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; LogAdapter接口,一般实现类为AndroidLogAdapter</span><br><span class="line">	public static void addLogAdapter(@NonNull LogAdapter adapter) &#123;</span><br><span class="line">		printer.addAdapter(checkNotNull(adapter));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 调用Logger.d()最终也是调用printer.d</span><br><span class="line">	public static void d(@NonNull String message, @Nullable Object... args) &#123;</span><br><span class="line">		printer.d(message, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Printer、LoggerPrinter</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public interface Printer &#123;</span><br><span class="line">	void addAdapter(@NonNull LogAdapter adapter);</span><br><span class="line">	void d(@NonNull String message, @Nullable Object... args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LoggerPrinter implements Printer &#123;</span><br><span class="line">	private final List&lt;LogAdapter&gt; logAdapters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	@Override </span><br><span class="line">	public void d(@NonNull String message, @Nullable Object... args) &#123;</span><br><span class="line">		log(DEBUG, null, message, args);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private synchronized void log(int priority,</span><br><span class="line">                                @Nullable Throwable throwable,</span><br><span class="line">                                @NonNull String msg,</span><br><span class="line">                                @Nullable Object... args) &#123;</span><br><span class="line">		checkNotNull(msg);</span><br><span class="line">		String tag &#x3D; getTag();</span><br><span class="line">		String message &#x3D; createMessage(msg, args);</span><br><span class="line">		log(priority, tag, message, throwable);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private String createMessage(@NonNull String message, @Nullable Object... args) &#123;</span><br><span class="line">		return args &#x3D;&#x3D; null || args.length &#x3D;&#x3D; 0 ? message : String.format(message, args);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override </span><br><span class="line">	public synchronized void log(int priority,</span><br><span class="line">                                         @Nullable String tag,</span><br><span class="line">                                         @Nullable String message,</span><br><span class="line">                                         @Nullable Throwable throwable) &#123;</span><br><span class="line">		if (throwable !&#x3D; null &amp;&amp; message !&#x3D; null) &#123;</span><br><span class="line">		  message +&#x3D; &quot; : &quot; + Utils.getStackTraceString(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">		if (throwable !&#x3D; null &amp;&amp; message &#x3D;&#x3D; null) &#123;</span><br><span class="line">		  message &#x3D; Utils.getStackTraceString(throwable);</span><br><span class="line">		&#125;</span><br><span class="line">		if (Utils.isEmpty(message)) &#123;</span><br><span class="line">		  message &#x3D; &quot;Empty&#x2F;NULL log message&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 最终还是通过LogAdapter的具体实现类来完成日志打印</span><br><span class="line">		for (LogAdapter adapter : logAdapters) &#123;</span><br><span class="line">		  if (adapter.isLoggable(priority, tag)) &#123;</span><br><span class="line">			adapter.log(priority, tag, message);</span><br><span class="line">		  &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override </span><br><span class="line">	public void clearLogAdapters() &#123;</span><br><span class="line">		logAdapters.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override </span><br><span class="line">	public void addAdapter(@NonNull LogAdapter adapter) &#123;</span><br><span class="line">		logAdapters.add(checkNotNull(adapter));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LogAdapter、AndroidLogAdapter</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface LogAdapter &#123;</span><br><span class="line">	boolean isLoggable(int priority, @Nullable String tag);</span><br><span class="line">	void log(int priority, @Nullable String tag, @NonNull String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AndroidLogAdapter implements LogAdapter &#123;</span><br><span class="line">	private final FormatStrategy formatStrategy;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 默认采用LogcatLogStrategy</span><br><span class="line">	public AndroidLogAdapter() &#123;</span><br><span class="line">		this.formatStrategy &#x3D; PrettyFormatStrategy.newBuilder().build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public AndroidLogAdapter(@NonNull FormatStrategy formatStrategy) &#123;</span><br><span class="line">		this.formatStrategy &#x3D; checkNotNull(formatStrategy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override </span><br><span class="line">	public boolean isLoggable(int priority, @Nullable String tag) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void log(int priority, @Nullable String tag, @NonNull String message) &#123;</span><br><span class="line">		formatStrategy.log(priority, tag, message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FormatStrategy、LogcatLogStrategy、PrettyFormatStrategy</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public interface FormatStrategy &#123;</span><br><span class="line">	void log(int priority, @Nullable String tag, @NonNull String message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LogcatLogStrategy implements LogStrategy &#123;</span><br><span class="line">	&#x2F;&#x2F; 其实就是调用android.util.Log</span><br><span class="line">	public void log(int priority, @Nullable String tag, @NonNull String message) &#123;</span><br><span class="line">		Log.println(priority, tag, message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PrettyFormatStrategy implements FormatStrategy &#123;</span><br><span class="line">	@Override </span><br><span class="line">	public void log(int priority, @Nullable String onceOnlyTag, @NonNull String message) &#123;</span><br><span class="line">		checkNotNull(message);</span><br><span class="line">		String tag &#x3D; formatTag(onceOnlyTag);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 绘制顶部的分割线</span><br><span class="line">		logTopBorder(priority, tag);</span><br><span class="line">		logHeaderContent(priority, tag, methodCount);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;get bytes of message with system&#39;s default charset (which is UTF-8 for Android)</span><br><span class="line">		byte[] bytes &#x3D; message.getBytes();</span><br><span class="line">		int length &#x3D; bytes.length;</span><br><span class="line">		if (length &lt;&#x3D; CHUNK_SIZE) &#123;</span><br><span class="line">		  if (methodCount &gt; 0) &#123;</span><br><span class="line">			logDivider(priority, tag);</span><br><span class="line">		  &#125;</span><br><span class="line">		  logContent(priority, tag, message);</span><br><span class="line">		  logBottomBorder(priority, tag);</span><br><span class="line">		  return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (methodCount &gt; 0) &#123;</span><br><span class="line">		  logDivider(priority, tag);</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; length; i +&#x3D; CHUNK_SIZE) &#123;</span><br><span class="line">		  int count &#x3D; Math.min(length - i, CHUNK_SIZE);</span><br><span class="line">		  &#x2F;&#x2F;create a new String with system&#39;s default charset (which is UTF-8 for Android)</span><br><span class="line">		  logContent(priority, tag, new String(bytes, i, count));</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 绘制底部的分割线</span><br><span class="line">		logBottomBorder(priority, tag);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/5%20android%E4%B9%8BIntentService/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/5%20android%E4%B9%8BIntentService/" class="post-title-link" itemprop="url">5 android之IntentService</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/IntentService%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">IntentService源码解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么是IntentService？简单来说IntentService就是一个含有自身消息循环的Service，首先它是一个service，所以service相关具有的特性他都有，同时他还有一些自身的属性，其内部封装了一个消息队列和一个HandlerThread，在其具体的抽象方法：onHandleIntent方法是运行在其消息队列线程中，废话不多说，我们来看其简单的使用方法：</p>
<ul>
<li>定义一个IntentService</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MIntentService extends IntentService&#123;</span><br><span class="line">    public MIntentService() &#123;</span><br><span class="line">        super(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onHandleIntent(Intent intent) &#123;</span><br><span class="line">        Log.i(&quot;tag&quot;, intent.getStringExtra(&quot;params&quot;) + &quot;  &quot; + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在androidManifest.xml中定义service</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name&#x3D;&quot;.MIntentService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动这个service</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Intent intent &#x3D; new Intent(MainActivity.this, MIntentService.class);</span><br><span class="line">        intent.putExtra(&quot;params&quot;, &quot;ceshi&quot;);</span><br><span class="line">        startService(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以发现当点击title组件的时候，service接收到了消息并打印出了传递过去的intent参数，同时显示onHandlerIntent方法执行的线程ID并非主线程，这是为什么呢？</p>
<p>下面我们来看一下service的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IntentService extends Service &#123;</span><br><span class="line">    private volatile Looper mServiceLooper;</span><br><span class="line">    private volatile ServiceHandler mServiceHandler;</span><br><span class="line">    private String mName;</span><br><span class="line">    private boolean mRedelivery;</span><br><span class="line"></span><br><span class="line">    private final class ServiceHandler extends Handler &#123;</span><br><span class="line">        public ServiceHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public IntentService(String name) &#123;</span><br><span class="line">        super();</span><br><span class="line">        mName &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setIntentRedelivery(boolean enabled) &#123;</span><br><span class="line">        mRedelivery &#x3D; enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        HandlerThread thread &#x3D; new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper &#x3D; thread.getLooper();</span><br><span class="line">        mServiceHandler &#x3D; new ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart(Intent intent, int startId) &#123;</span><br><span class="line">        Message msg &#x3D; mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 &#x3D; startId;</span><br><span class="line">        msg.obj &#x3D; intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @WorkerThread</span><br><span class="line">    protected abstract void onHandleIntent(Intent intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么样，代码还是相当的简洁的，首先通过定义我们可以知道IntentService是一个Service，并且是一个抽象类，所以我们在继承IntentService的时候需要实现其抽象方法：onHandlerIntent。</p>
<p>下面看一下其onCreate方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    HandlerThread thread &#x3D; new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    mServiceLooper &#x3D; thread.getLooper();</span><br><span class="line">    mServiceHandler &#x3D; new ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现其内部定义一个HandlerIThread（本质上是一个含有消息队列的线程）然后用成员变量维护其Looper和Handler，由于其Handler关联着这个HandlerThread的Looper对象，所以Handler的handMessage方法在HandlerThread线程中执行。</p>
<p>然后我们发现其onStartCommand方法就是调用的其onStart方法，具体看一下其onStart方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStart(Intent intent, int startId) &#123;</span><br><span class="line">    Message msg &#x3D; mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 &#x3D; startId;</span><br><span class="line">    msg.obj &#x3D; intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单就是就是讲startId和启动时接受到的intent对象传递到消息队列中处理，那么我们具体看一下其消息队列的处理逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">    public ServiceHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">		&#x2F;&#x2F; IntentService在首次启动的时候，AMS会传入一个startId</span><br><span class="line">		&#x2F;&#x2F; 参数startId跟最后启动该service时生成的ID相等时才会执行停止服务</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到起handleMessage方法内部执行了两个逻辑一个是调用了其onHandlerIntent抽象方法，通过分析其onCreate方法handler对象的创建过程我们知道其handler对象是依附于HandlerThread线程的，所以其handeMessage方法也是在HandlerThread线程中执行的，从而证实了我们刚刚例子中的一个结论，onHandlerIntent在子线程中执行。<br>然后调用了stopSelf(int id)方法，这里需要注意的是stopSelf方法传递了msg.arg1参数，从刚刚的onStart方法我们可以知道我们传递了startId，参考其他文章我们知道，由于service可以启动N次，可以传递N次消息，当IntentService的消息队列中含有消息时调用stopSelf(startId)并不会立即stop自己，<strong>只有当消息队列中最后一个消息被执行完成时才会真正的stop自身</strong>。<br>而<strong>stopSelf()则是直接停止服务</strong>.</p>
<p>通过上面的例子与相关说明，我们可以知道：</p>
<ul>
<li>IntentService是一个service，也是一个抽象类</li>
<li>继承IntentService需要实现其onHandlerIntent抽象方法</li>
<li>onHandlerIntent在子线程中执行</li>
<li>IntentService内部保存着一个HandlerThread、Looper与Handler等成员变量，维护这自身的消息队列</li>
<li>每次IntentService后台任务执行完成之后都会尝试关闭自身，但是当且仅当IntentService消息队列中最后一个消息被执行完成之后才会真正的stop自身</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
