<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Java基础之ThreadLocal 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:44:43" itemprop="dateCreated datePublished" datetime="2020-05-31T11:44:43+08:00">2020-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/ThreadLocal%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">ThreadLocal原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ThreadLocal-概述"><a href="#ThreadLocal-概述" class="headerlink" title="ThreadLocal 概述"></a>ThreadLocal 概述</h4><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而且只有在指定的线程里才能获取到存储的数据，对于其他线程来说是获取不到的。ThreadLocal适用于变量在线程间隔离而在方法或类间共享的场景。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/Java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Volley源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:26:01" itemprop="dateCreated datePublished" datetime="2020-05-31T11:26:01+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>本文基于Volley 1.1.1版本的源码。</p>
<p>Volley是Google官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持HttpClient、HttpUrlConnection，甚至支持OkHttp。Volley不适用于下载大量内容的操作或流式传输操作，因为在解析过程中，Volley会将所有响应存储在内存中，因此Volley不适合上传和下载大文件。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">Kotlin 实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:19:43" itemprop="dateCreated datePublished" datetime="2020-05-31T11:19:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Kotlin-引入-Android-项目"><a href="#Kotlin-引入-Android-项目" class="headerlink" title="Kotlin 引入 Android 项目"></a>Kotlin 引入 Android 项目</h4><p>Kotlin是基于JVM新的编程语言，由 JetBrains 开发，可以编译成java字节码，也可以编译成JavaScript。而JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，也在 Apache 许可下已经开源其Kotlin 编程语言。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/Kotlin%20%E5%AE%9E%E6%88%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Glide%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Glide 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:17:43" itemprop="dateCreated datePublished" datetime="2020-05-31T11:17:43+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>
<p>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。</p>
<h3 id="Glide-源码剖析"><a href="#Glide-源码剖析" class="headerlink" title="Glide 源码剖析"></a>Glide 源码剖析</h3><p><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">Glide</a>是Google出品的一款性能优异的图片加载框架。</p>
<p>依赖库导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">  google()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;</span><br><span class="line">  annotationProcessor &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(myFragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .centerCrop()</span><br><span class="line">    .placeholder(R.drawable.loading_spinner)</span><br><span class="line">    .into(myImageView);</span><br></pre></td></tr></table></figure>

<p>下面我们将会带着以下一些问题深入的剖析源码，去寻找答案。</p>
<ul>
<li>Glide的with方法是如何绑定Activity/Fragment生命周期的？</li>
<li>Glide的网络请求是怎样发出的？</li>
<li>Glide请求完成之后，图片是如何展示的？</li>
<li>Glide的缓存策略是什么样的？</li>
<li>Glide编解码逻辑是怎么样的？</li>
<li>Glide的OOM解决办法？</li>
</ul>
<h5 id="1-with-Context-方法，返回RequestManager"><a href="#1-with-Context-方法，返回RequestManager" class="headerlink" title="1. with(Context)方法，返回RequestManager"></a>1. with(Context)方法，返回RequestManager</h5><p><strong>Glide.java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">public class Glide implements ComponentCallbacks2 &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 各种注册器集合(modelLoaderRegistry、encoderRegistry、decoderRegistry、transcoderRegistry)</span><br><span class="line">    private final Registry registry;</span><br><span class="line">    private final RequestManagerRetriever requestManagerRetriever;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 构造函数</span><br><span class="line">    Glide(...) &#123;</span><br><span class="line">        registry &#x3D; new Registry();</span><br><span class="line">        &#x2F;&#x2F; ModelLoader</span><br><span class="line">        registry.append(String.class, InputStream.class, new DataUrlLoader.StreamFactory&lt;String&gt;())</span><br><span class="line">        registry.append(String.class, InputStream.class, new StringLoader.StreamFactory())</span><br><span class="line">        registry.append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())</span><br><span class="line">        registry.append(String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())</span><br><span class="line">        ...</span><br><span class="line">        registry.append(Uri.class, InputStream.class, new DataUrlLoader.StreamFactory&lt;Uri&gt;())</span><br><span class="line">        registry.append(Uri.class, InputStream.class, new HttpUriLoader.Factory()) &#x2F;&#x2F; -&gt; HttpUriLoader</span><br><span class="line">        registry.append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets()))</span><br><span class="line">        registry.append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context))</span><br><span class="line">        registry.append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context));</span><br><span class="line">        registry.append(Uri.class, InputStream.class, new UrlUriLoader.StreamFactory()) &#x2F;&#x2F; 1</span><br><span class="line">        registry.append(Uri.class, InputStream.class, new UriLoader.StreamFactory(contentResolver)) &#x2F;&#x2F; 2</span><br><span class="line">        </span><br><span class="line">        .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory()) &#x2F;&#x2F;最终</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        </span><br><span class="line">        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder)</span><br><span class="line">        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;* Transcoders *&#x2F;</span><br><span class="line">        .register(Bitmap.class, BitmapDrawable.class, new BitmapDrawableTranscoder(resources))</span><br><span class="line">        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder)</span><br><span class="line">        .register(</span><br><span class="line">            Drawable.class,</span><br><span class="line">            byte[].class,</span><br><span class="line">            new DrawableBytesTranscoder(</span><br><span class="line">                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder))</span><br><span class="line">        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static RequestManager with(@NonNull Context context) &#123;</span><br><span class="line">        return getRetriever(context).get(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RequestManager with(@NonNull Activity activity) &#123;</span><br><span class="line">        return getRetriever(activity).get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public static RequestManager with(@NonNull FragmentActivity activity) &#123;</span><br><span class="line">        return getRetriever(activity).get(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static RequestManager with(@NonNull Fragment fragment) &#123;</span><br><span class="line">        return getRetriever(fragment.getContext()).get(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static RequestManager with(@NonNull android.app.Fragment fragment) &#123;</span><br><span class="line">        return getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    private static RequestManagerRetriever getRetriever(@Nullable Context context) &#123;</span><br><span class="line">        return Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Glide get(@NonNull Context context) &#123;</span><br><span class="line">        if (glide &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 注解自定义GlideModule</span><br><span class="line">        &#x2F;&#x2F; 反射newInstance生成com.bumptech.glide.GeneratedAppGlideModuleImpl</span><br><span class="line">        GeneratedAppGlideModule annotationGeneratedModule &#x3D;</span><br><span class="line">          getAnnotationGeneratedGlideModules(context.getApplicationContext());</span><br><span class="line">        synchronized (Glide.class) &#123;</span><br><span class="line">            if (glide &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 初始化Glide</span><br><span class="line">                &#x2F;&#x2F; 0. 处理Manifest方式生成的GlideModule(ApplicationInfo.metaData解析，反射生成GlideModule)</span><br><span class="line">                &#x2F;&#x2F; 1. excluded某些GlideModule</span><br><span class="line">                &#x2F;&#x2F; 2. GlideBuilder.build构建Glide(初始化diskCacheExecutor、sourceExecutor、bitmapPool、memoryCache、engine)</span><br><span class="line">                checkAndInitializeGlide(context, annotationGeneratedModule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return glide;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**with()**方法重载了5个方法</span><br><span class="line"></span><br><span class="line">RequestManagerRetriever.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManagerRetriever implements Handler.Callback {</p>
<pre><code>// Application相关联RequestManager
private volatile RequestManager applicationManager;

public RequestManagerRetriever(@Nullable RequestManagerFactory factory) {
    this.factory = factory != null ? factory : DEFAULT_FACTORY;
    handler = new Handler(Looper.getMainLooper(), this /* Callback */);
}

public RequestManager get(Context context) {
    if (context == null) {
        throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);
    } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {
        if (context instanceof FragmentActivity) {
            return get((FragmentActivity) context);
        } else if (context instanceof Activity) {
            return get((Activity) context);
        } else if (context instanceof ContextWrapper) {
            return get(((ContextWrapper) context).getBaseContext());
        }
    }

    return getApplicationManager(context);
}

// 生命周期和Application相关连
private RequestManager getApplicationManager(Context context) {
    if (applicationManager == null) {
        synchronized (this) {
            if (applicationManager == null) {
                Glide glide = Glide.get(context.getApplicationContext());
                applicationManager = factory.build(glide, new ApplicationLifecycle(), 
                    new EmptyRequestManagerTreeNode(), context.getApplicationContext());
            }
        }
    }
    return applicationManager;
}

// activity.getSupportFragmentManager(),会创建SupportRequestManagerFragment
public RequestManager get(FragmentActivity activity) {
    if (Util.isOnBackgroundThread()) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        FragmentManager fm = activity.getSupportFragmentManager();
        return supportFragmentGet(activity, fm);
    }
}

RequestManager supportFragmentGet(Context context, FragmentManager fm) {
    SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm);
    // 内部新建ActivityFragmentLifecycle对象
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        // 将SupportRequestManagerFragment的LifeCycle注入到RequestManager
        Glide glide = Glide.get(context);
        requestManager = factory.build(glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); 
        // 将current.getLifecycle()与 requestManager进行了绑定
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) {
    SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        current = pendingSupportRequestManagerFragments.get(fm);
        if (current == null) {
            current = new SupportRequestManagerFragment();
            pendingSupportRequestManagerFragments.put(fm, current);
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}

// activity.getFragmentManager会创建RequestManagerFragment
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public RequestManager get(Activity activity) {
    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) {
        return get(activity.getApplicationContext());
    } else {
        assertNotDestroyed(activity);
        android.app.FragmentManager fm = activity.getFragmentManager();
        return fragmentGet(activity, fm);
    }
}

@TargetApi(Build.VERSION_CODES.HONEYCOMB)
RequestManager fragmentGet(Context context, android.app.FragmentManager fm) {
    RequestManagerFragment current = getRequestManagerFragment(fm);
    RequestManager requestManager = current.getRequestManager();
    if (requestManager == null) {
        Glide glide = Glide.get(context);
        requestManager = factory.build(glide, current.getGlideLifecycle(), 
            current.getRequestManagerTreeNode(), context);
        current.setRequestManager(requestManager);
    }
    return requestManager;
}

@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
RequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {
    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        // 思考一下，为什么要使用pendingRequestManagerFragments缓存？
        current = pendingRequestManagerFragments.get(fm);
        if (current == null) {
            current = new RequestManagerFragment();
            pendingRequestManagerFragments.put(fm, current);
            // commit之前缓存fragment
            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
            // 发送Handler消息清除缓存
            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
        }
    }
    return current;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根据Context如果是Application，则创建全局applicationManager,其生命周期为ApplicationLifecycle,只有addListener</span><br><span class="line">否则创建SupportRequestManagerFragment或者RequestManagerFragment将其GlideLifecycle和requestManager绑定</span><br><span class="line"></span><br><span class="line">SupportRequestManagerFragment.java</span><br></pre></td></tr></table></figure>
<p>public class SupportRequestManagerFragment extends Fragment {<br>    private RequestManager requestManager;<br>    private final ActivityFragmentLifecycle lifecycle;</p>
<pre><code>@Override
public void onStart() {
    super.onStart();
    lifecycle.onStart();
}

@Override
public void onStop() {
    super.onStop();
    lifecycle.onStop();
}

@Override
public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这样SupportRequestManagerFragment就和ActivityFragmentLifecycle进行了绑定管理者Fragment的生命周期</span><br><span class="line">在RequestManager的构造函数中会调用lifecycle.addListener(RequestManager.this);进行绑定。至此整个生命周期的传递过程就形成了。</span><br><span class="line">SupportRequestManagerFragment -&gt; ActivityFragmentLifecycle -&gt; RequestManager -&gt; requestTracker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 2. load()方法,返回RequestBuilder&lt;TranscodeType&gt;</span><br><span class="line"></span><br><span class="line">RequestManager.java</span><br></pre></td></tr></table></figure>
<p>public class RequestManager implements LifecycleListener {<br>    private final Lifecycle lifecycle;<br>    private final RequestTracker requestTracker;<br>    private final Handler mainHandler = new Handler(Looper.getMainLooper());<br>    private final Runnable addSelfToLifecycle =<br>        new Runnable() {<br>            @Override<br>            public void run() {<br>                lifecycle.addListener(RequestManager.this);<br>            }<br>        };</p>
<pre><code>RequestManager(Context context, final Lifecycle lifecycle, ...) {
    ...
    if (Util.isOnBackgroundThread()) {
        mainHandler.post(addSelfToLifecycle);
    } else {
        lifecycle.addListener(this);
    }
    ...
}

public RequestBuilder&lt;Drawable&gt; load(@Nullable String string) {
    return asDrawable().load(string);
}

public RequestBuilder&lt;Drawable&gt; asDrawable() {
    return as(Drawable.class);
}

public &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as(
    @NonNull Class&lt;ResourceType&gt; resourceClass) {
    return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);
}

@Override
public void onStart() {
    resumeRequests();
}

@Override
public void onStop() {
    pauseRequests();
}

@Override
public void onDestroy() {
    requestTracker.clearRequests();
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestManager初始化的时候，将自己注册到Fragment.lifecycle监听器集合中。待Fragment的生命周期发生变化的时候，会回调onStart、onStop、onDestroy。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">** RequestBuilder.java**</span><br></pre></td></tr></table></figure>
<p>public class RequestBuilder<TranscodeType> extends BaseRequestOptions&lt;RequestBuilder<TranscodeType>&gt;<br>    implements Cloneable, ModelTypes&lt;RequestBuilder<TranscodeType>&gt; {</p>
<pre><code>public RequestBuilder&lt;TranscodeType&gt; load(@Nullable String string) {
    return loadGeneric(string);
}

private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) {
    this.model = model; // url、file、uri等类型
    isModelSet = true;
    return this;
}

public ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) {
    Util.assertMainThread();
    Preconditions.checkNotNull(view);

    BaseRequestOptions&lt;?&gt; requestOptions = this;
    if (!requestOptions.isTransformationSet()
        &amp;&amp; requestOptions.isTransformationAllowed()
        &amp;&amp; view.getScaleType() != null) {
      switch (view.getScaleType()) {
        case CENTER_CROP:
          requestOptions = requestOptions.clone().optionalCenterCrop();
          break;
        case CENTER_INSIDE:
          requestOptions = requestOptions.clone().optionalCenterInside();
          break;
        case FIT_CENTER:
        case FIT_START:
        case FIT_END:
          requestOptions = requestOptions.clone().optionalFitCenter();
          break;
        case FIT_XY:
          requestOptions = requestOptions.clone().optionalCenterInside();
          break;
        case CENTER:
        case MATRIX:
        default:
          // Do nothing.
      }
    }

    // transcodeClass 标识Bitmap、Drawable
    return into(
        glideContext.buildImageViewTarget(view, transcodeClass), // 绑定Target,最终生成BitmapImageViewTarget、DrawableImageViewTarget
        /*targetListener=*/ null,
        requestOptions,
        Executors.mainThreadExecutor());
}

private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(
      @NonNull Y target,
      @Nullable RequestListener&lt;TranscodeType&gt; targetListener,
      BaseRequestOptions&lt;?&gt; options,
      Executor callbackExecutor) {
    Preconditions.checkNotNull(target);
    if (!isModelSet) {
      throw new IllegalArgumentException(&quot;You must call #load() before calling #into()&quot;);
    }

    // 最终返回SingleRequest
    Request request = buildRequest(target, targetListener, options, callbackExecutor);

    Request previous = target.getRequest(); // 原理就是获取View.getTag、setTag将Requet保存起来
    if (request.isEquivalentTo(previous)
        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
      // 如果请求已经完成，则重新进行请求，确保重新得到请求结果
      if (!Preconditions.checkNotNull(previous).isRunning()) {
        // 复用之前的Request
        previous.begin();
      }
      return target;
    }

    requestManager.clear(target);
    target.setRequest(request);
    requestManager.track(target, request);

    return target;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">into()返回Target对象且创建SingleRequest通过View.setTag绑定。最后交给requestManager的track方法： requestTracker.runRequest(request)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 资源请求(三级缓存)</span><br><span class="line"></span><br><span class="line">RequestTracker.java (Request集合, 负责Request的执行，暂停，取消等等关于图片请求的操作)</span><br></pre></td></tr></table></figure>
<p>public class RequestTracker {<br>    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap&lt;Request, Boolean&gt;());<br>    private final List<Request> pendingRequests = new ArrayList<Request>();<br>    private boolean isPaused;</p>
<pre><code>public void runRequest(Request request) {
    requests.add(request);
    if (!isPaused) {
        request.begin();
    } else {
        request.clear();
        pendingRequests.add(request);
    }
}

public void pauseRequests() {
    isPaused = true;
    for (Request request : Util.getSnapshot(requests)) {
        if (request.isRunning()) {
            request.pause();
            pendingRequests.add(request);
        }
    }
}

public void resumeRequests() {
    isPaused = false;
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled() &amp;&amp; !request.isRunning()) {
            request.begin();
        }
    }
    pendingRequests.clear();
}

public void restartRequests() {
    for (Request request : Util.getSnapshot(requests)) {
        if (!request.isComplete() &amp;&amp; !request.isCancelled()) {
            // Ensure the request will be restarted in onResume.
            request.pause();
            if (!isPaused) {
                request.begin();
            } else {
                pendingRequests.add(request);
            }
        }
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SingleRequest.java</span><br></pre></td></tr></table></figure>
<p>public final class SingleRequest<R> implements Request, SizeReadyCallback,<br>        ResourceCallback {</p>
<pre><code>@Override
public void begin() {
    synchronized (requestLock) {
        .. // 校验model!=null
        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this); // 获取target的width、height
        }
        if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
                &amp;&amp; canNotifyStatusChanged()) {
           // 设置placeholder
           target.onLoadStarted(getPlaceholderDrawable());
        }
    }
}    

@Override
public void onSizeReady(int width, int height) {
    synchronized (requestLock) {
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;

        float sizeMultiplier = requestOptions.getSizeMultiplier(); // 默认1f
        this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
        this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
        loadStatus =
          engine.load(
              glideContext,
              model,
              requestOptions.getSignature(),
              this.width,
              this.height,
              requestOptions.getResourceClass(),
              transcodeClass,
              priority,
              requestOptions.getDiskCacheStrategy(),
              requestOptions.getTransformations(),
              requestOptions.isTransformationRequired(),
              requestOptions.isScaleOnlyOrNoTransform(),
              requestOptions.getOptions(),
              requestOptions.isMemoryCacheable(),
              requestOptions.getUseUnlimitedSourceGeneratorsPool(),
              requestOptions.getUseAnimationPool(),
              requestOptions.getOnlyRetrieveFromCache(),
              this,
              callbackExecutor);

            if (status != Status.RUNNING) {
                loadStatus = null;
            }  
    }
}

private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {
    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SingleRequest的begin方法首先需要获取到target的宽高，最终都会走到onSizeReady方法中，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Engine.java**</span><br></pre></td></tr></table></figure>
<p>public class Engine implements EngineJobListener,<br>        MemoryCache.ResourceRemovedListener,<br>        EngineResource.ResourceListener {</p>
<pre><code>private final MemoryCache cache; // 对应LruResourceCache
private final ActiveResources activeResources; // 内部采用WeakReference保存资源

public &lt;R&gt; LoadStatus load(GlideContext glideContext,
  Object model,
  Key signature,
  int width,
  int height,
  Class&lt;?&gt; resourceClass,
  Class&lt;R&gt; transcodeClass,
  Priority priority,
  DiskCacheStrategy diskCacheStrategy,
  Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,
  boolean isTransformationRequired,
  boolean isScaleOnlyOrNoTransform,
  Options options,
  boolean isMemoryCacheable,
  boolean useUnlimitedSourceExecutorPool,
  boolean useAnimationPool,
  boolean onlyRetrieveFromCache,
  ResourceCallback cb,
  Executor callbackExecutor) {

    // 根据请求key以及width、height一起构成了一个EngineKey, 如果width、height改变了，
    // 则会认为是一个新的Key，会重新缓存。
    EngineKey key = keyFactory.buildKey(
        model,signature,width,height,transformations,
        resourceClass,transcodeClass,options);

    EngineResource&lt;?&gt; memoryResource;
    synchronized (this) {
        memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);
        if (memoryResource == null) {
            return waitForExistingOrStartNewJob(
                    glideContext,
                    model,
                    signature,
                    width,
                    height,
                    resourceClass,
                    transcodeClass,
                    priority,
                    diskCacheStrategy,
                    transformations,
                    isTransformationRequired,
                    isScaleOnlyOrNoTransform,
                    options,
                    isMemoryCacheable,
                    useUnlimitedSourceExecutorPool,
                    useAnimationPool,
                    onlyRetrieveFromCache,
                    cb,
                    callbackExecutor,
                    key,
                    startTime);
        }
    }

    cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);
    return null;
}

private EngineResource&lt;?&gt; loadFromMemory(
    EngineKey key, boolean isMemoryCacheable, long startTime) {
    // 如果设置skipMemoryCache(true)内存缓存不可用，磁盘缓存可用
    if (!isMemoryCacheable) {
        return null;
    }
    // 1. ActiveResources缓存中获取
    EngineResource&lt;?&gt; active = loadFromActiveResources(key);
    if (active != null) {
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);
      }
      return active;
    }
    // 2. MemoryCache缓存，采用LRU算法
    EngineResource&lt;?&gt; cached = loadFromCache(key);
    if (cached != null) {
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);
      }
      return cached;
    }
    return null;
}

private EngineResource&lt;?&gt; loadFromActiveResources(Key key) {
    EngineResource&lt;?&gt; active = activeResources.get(key);
    if (active != null) {
        active.acquire(); // 计数器+1
    }

    return active;
}

private EngineResource&lt;?&gt; loadFromCache(Key key) {
    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);
    if (cached != null) {
        cached.acquire();
        activeResources.activate(key, cached);
    }
    return cached;
}

private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) {
    Resource&lt;?&gt; cached = cache.remove(key);
    final EngineResource&lt;?&gt; result;
    if (cached == null) {
      result = null;
    } else if (cached instanceof EngineResource) {
      // Save an object allocation if we&apos;ve cached an EngineResource (the typical case).
      result = (EngineResource&lt;?&gt;) cached;
    } else {
      result =
          new EngineResource&lt;&gt;(
              cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);
    }
    return result;
}

private &lt;R&gt; LoadStatus waitForExistingOrStartNewJob()
    EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);
    if (current != null) {
        current.addCallback(cb, callbackExecutor);
        return new LoadStatus(cb, current);
    }

    EngineJob&lt;R&gt; engineJob = engineJobFactory.build(
        key,
        isMemoryCacheable,
        useUnlimitedSourceExecutorPool,
        useAnimationPool,
        onlyRetrieveFromCache);

    DecodeJob&lt;R&gt; decodeJob = decodeJobFactory.build(
        glideContext,
        model,
        key,
        signature,
        width,
        height,
        resourceClass,
        transcodeClass,
        priority,
        diskCacheStrategy,
        transformations,
        isTransformationRequired,
        isScaleOnlyOrNoTransform,
        onlyRetrieveFromCache,
        options,
        engineJob);

    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    engineJob.start(decodeJob); // 选择合适的线程池运行decodeJob
    return new LoadStatus(cb, engineJob);
}</code></pre><p>}            </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**DecodeJob.java**</span><br></pre></td></tr></table></figure>
<p>class DecodeJob<R><br>    implements DataFetcherGenerator.FetcherReadyCallback,<br>        Runnable,<br>        Comparable&lt;DecodeJob&lt;?&gt;&gt;,<br>        Poolable {</p>
<pre><code>public void run() {
    runWrapped();
}

private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        currentGenerator = getNextGenerator();
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException(&quot;Unrecognized run reason: &quot; + runReason);
    }
}

private DataFetcherGenerator getNextGenerator() {
    switch (stage) {
      case RESOURCE_CACHE:
        return new ResourceCacheGenerator(decodeHelper, this); //处理之后的数据缓存
      case DATA_CACHE:
        return new DataCacheGenerator(decodeHelper, this); //原始数据缓存
      case SOURCE:
        return new SourceGenerator(decodeHelper, this); // 网络缓存
      case FINISHED:
        return null;
      default:
        throw new IllegalStateException(&quot;Unrecognized stage: &quot; + stage);
    }
}

private void runGenerators() {
    currentThread = Thread.currentThread();
    startFetchTime = LogTime.getLogTime();
    boolean isStarted = false;
    // 循环调用Generator的startNext方法，如果失败返回false则getNextGenerator下一个继续
    while (!isCancelled
        &amp;&amp; currentGenerator != null
        &amp;&amp; !(isStarted = currentGenerator.startNext())) {
      stage = getNextStage(stage);
      currentGenerator = getNextGenerator();

      if (stage == Stage.SOURCE) {
        // 如果是SOURCE，则选择getActiveSourceExecutor线程池运行
        reschedule();
        return;
      }
    }
    // We&apos;ve run out of stages and generators, give up.
    if ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) {
      notifyFailed();
    }
}

private Stage getNextStage(Stage current) {
    switch (current) {
      case INITIALIZE:
        return diskCacheStrategy.decodeCachedResource()
            ? Stage.RESOURCE_CACHE
            : getNextStage(Stage.RESOURCE_CACHE);
      case RESOURCE_CACHE:
        return diskCacheStrategy.decodeCachedData()
            ? Stage.DATA_CACHE
            : getNextStage(Stage.DATA_CACHE);
      case DATA_CACHE:
        // Skip loading from source if the user opted to only retrieve the resource from cache.
        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
      case SOURCE:
      case FINISHED:
        return Stage.FINISHED;
      default:
        throw new IllegalArgumentException(&quot;Unrecognized stage: &quot; + current);
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DecodeJob的run方法根据state状态依次选择ResourceCacheGenerator、DataCacheGenerator进行磁盘缓存查找，最后如果没找到SourceGenerator进行网络请求。（其中涉及到ModelLoad加载）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**HttpUrlFetcher**</span><br></pre></td></tr></table></figure>
<p>public class HttpUrlFetcher implements DataFetcher<InputStream> {</p>
<pre><code>private HttpURLConnection urlConnection;
private InputStream stream;

@Override
public InputStream loadData(Priority priority) throws Exception {
    return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
}

private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map&lt;String, String&gt; headers)
        throws IOException {
    ...
    urlConnection = connectionFactory.build(url);
    for (Map.Entry&lt;String, String&gt; headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(2500);
    urlConnection.setReadTimeout(2500);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) { // 200 OK
        return getStreamForSuccessfulRequest(urlConnection);
    } else if (statusCode / 100 == 3) { // 3XX 重定向
        String redirectUrlString = urlConnection.getHeaderField(&quot;Location&quot;);
        if (TextUtils.isEmpty(redirectUrlString)) {
            throw new IOException(&quot;Received empty or null redirect url&quot;);
        }
        URL redirectUrl = new URL(url, redirectUrlString);
        return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    }
    ...
}

private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection) throws IOException {
    ...
    stream = urlConnection.getInputStream();
    return stream;
}    </code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">至此Glide的整个网络数据请求流程就结束了，接下来看看Glide是如何编解码图片。</span><br></pre></td></tr></table></figure>
<p>class DecodeJob<R> implements DataFetcherGenerator.FetcherReadyCallback,<br>        Runnable,<br>        Comparable&lt;DecodeJob&lt;?&gt;&gt;,<br>        Poolable {</p>
<pre><code>public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey) {
    this.currentSourceKey = sourceKey;
    this.currentData = data;
    this.currentFetcher = fetcher;
    this.currentDataSource = dataSource;
    this.currentAttemptingKey = attemptedKey;
    if (Thread.currentThread() != currentThread) {
      runReason = RunReason.DECODE_DATA;
      callback.reschedule(this);
    } else {
      GlideTrace.beginSection(&quot;DecodeJob.decodeFromRetrievedData&quot;);
      try {
        // 开始解码
        decodeFromRetrievedData();
      } finally {
        GlideTrace.endSection();
      }
    }
}

private void decodeFromRetrievedData() {
    Resource&lt;R&gt; resource = null;
    try {
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    } catch (GlideException e) {
      throwables.add(e);
    }
    if (resource != null) {
      // 向上回调
      notifyEncodeAndRelease(resource, currentDataSource);
    } else {
      runGenerators();
    }
}</code></pre><p>  private <Data> Resource<R> decodeFromData(<br>      DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource) throws GlideException {<br>    try {<br>      if (data == null) {<br>        return null;<br>      }<br>      long startTime = LogTime.getLogTime();<br>      Resource<R> result = decodeFromFetcher(data, dataSource);<br>      if (Log.isLoggable(TAG, Log.VERBOSE)) {<br>        logWithTimeAndKey(“Decoded result “ + result, startTime);<br>      }<br>      return result;<br>    } finally {<br>      fetcher.cleanup();<br>    }<br>  }</p>
<p>  private <Data> Resource<R> decodeFromFetcher(Data data, DataSource dataSource)<br>      throws GlideException {<br>    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class<Data>) data.getClass());<br>    return runLoadPath(data, dataSource, path);<br>  }</p>
<p>  private &lt;Data, ResourceType&gt; Resource<R> runLoadPath(<br>      Data data, DataSource dataSource, LoadPath&lt;Data, ResourceType, R&gt; path)<br>      throws GlideException {<br>    Options options = getOptionsWithHardwareConfig(dataSource);<br>    DataRewinder<Data> rewinder = glideContext.getRegistry().getRewinder(data);<br>    try {<br>      // ResourceType in DecodeCallback below is required for compilation to work with gradle.<br>      return path.load(<br>          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));<br>    } finally {<br>      rewinder.cleanup();<br>    }<br>  }  </p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>  public Resource<Transcode> load(<br>      DataRewinder<Data> rewinder,<br>      @NonNull Options options,<br>      int width,<br>      int height,<br>      DecodePath.DecodeCallback<ResourceType> decodeCallback)<br>      throws GlideException {<br>    List<Throwable> throwables = Preconditions.checkNotNull(listPool.acquire());<br>    try {<br>      return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);<br>    } finally {<br>      listPool.release(throwables);<br>    }<br>  }</p>
<p>  private Resource<Transcode> loadWithExceptionList(<br>      DataRewinder<Data> rewinder,<br>      @NonNull Options options,<br>      int width,<br>      int height,<br>      DecodePath.DecodeCallback<ResourceType> decodeCallback,<br>      List<Throwable> exceptions)<br>      throws GlideException {<br>    Resource<Transcode> result = null;<br>    for (int i = 0, size = decodePaths.size(); i &lt; size; i++) {<br>      DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);<br>      try {<br>        result = path.decode(rewinder, width, height, options, decodeCallback);<br>      } catch (GlideException e) {<br>        exceptions.add(e);<br>      }<br>      if (result != null) {<br>        break;<br>      }<br>    }</p>
<pre><code>if (result == null) {
  throw new GlideException(failureMessage, new ArrayList&lt;&gt;(exceptions));
}

return result;</code></pre><p>  }</p>
<p>}  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  public Resource<Transcode> decode(<br>      DataRewinder<DataType> rewinder,<br>      int width,<br>      int height,<br>      @NonNull Options options,<br>      DecodeCallback<ResourceType> callback)<br>      throws GlideException {<br>    Resource<ResourceType> decoded = decodeResource(rewinder, width, height, options);<br>    Resource<ResourceType> transformed = callback.onResourceDecoded(decoded);<br>    return transcoder.transcode(transformed, options);<br>  }</p>
<p>  @NonNull<br>  private Resource<ResourceType> decodeResource(<br>      DataRewinder<DataType> rewinder, int width, int height, @NonNull Options options)<br>      throws GlideException {<br>    List<Throwable> exceptions = Preconditions.checkNotNull(listPool.acquire());<br>    try {<br>      return decodeResourceWithList(rewinder, width, height, options, exceptions);<br>    } finally {<br>      listPool.release(exceptions);<br>    }<br>  }</p>
<p>  private Resource<ResourceType> decodeResourceWithList(<br>      DataRewinder<DataType> rewinder,<br>      int width,<br>      int height,<br>      @NonNull Options options,<br>      List<Throwable> exceptions)<br>      throws GlideException {<br>    Resource<ResourceType> result = null;<br>    //noinspection ForLoopReplaceableByForEach to improve perf<br>    for (int i = 0, size = decoders.size(); i &lt; size; i++) {<br>      ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);<br>      try {<br>        DataType data = rewinder.rewindAndGet();<br>        if (decoder.handles(data, options)) {<br>          data = rewinder.rewindAndGet();<br>          result = decoder.decode(data, width, height, options);<br>        }<br>        // Some decoders throw unexpectedly. If they do, we shouldn’t fail the entire load path, but<br>        // instead log and continue. See #2406 for an example.<br>      } catch (IOException | RuntimeException | OutOfMemoryError e) {<br>        if (Log.isLoggable(TAG, Log.VERBOSE)) {<br>          Log.v(TAG, “Failed to decode data for “ + decoder, e);<br>        }<br>        exceptions.add(e);<br>      }</p>
<pre><code>  if (result != null) {
    break;
  }
}

return result;</code></pre><p>  }  </p>
<p>```</p>
<p><img src="https://img-blog.csdn.net/20170515074139121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRXRoYW5Dbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Glide 执行过程"></p>
<h4 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h4><p><a href="https://blog.csdn.net/u011733020/article/details/52446902" target="_blank" rel="noopener">1. Glide（图片异步加载缓存库）发起request获取resource</a></p>
<p><a href="https://juejin.im/post/5e2109e25188254c257c40c6#heading-42" target="_blank" rel="noopener">2. Android主流三方库源码分析（三、深入理解Glide源码）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Picasso 源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:16:36" itemprop="dateCreated datePublished" datetime="2020-05-31T11:16:36+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="Picasso简介"><a href="#Picasso简介" class="headerlink" title="Picasso简介"></a>Picasso简介</h5><p>Picasso是鼎鼎有名的Square公司的一个开源项目，该公司同时开源了许多知名的项目，比如Okhttp，Retrofit，Otto等。Picasso继承了Okhttp的链式调用风格，使得它使用起来非常简单和方便，并且它的设计和实现也很轻量简单，使得整个库的接口数量和体积都很小，因此被很多开发者使用在项目中。下面我们来看一下Picasso的总体设计：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/Picasso%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">OkHttp 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:15:34" itemprop="dateCreated datePublished" datetime="2020-05-31T11:15:34+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、OkHttp-简介"><a href="#一、OkHttp-简介" class="headerlink" title="一、OkHttp 简介"></a>一、OkHttp 简介</h5><p>HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/OkHttp%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">Retrofit2 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:14:46" itemprop="dateCreated datePublished" datetime="2020-05-31T11:14:46+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、Retrofit2-简介"><a href="#一、Retrofit2-简介" class="headerlink" title="一、Retrofit2 简介"></a>一、Retrofit2 简介</h5><p>Retrofit是一个遵循RESTful设计的进行HTTP网络请求框架，底层网络请求基于OkHttp框架</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/Retrofit2%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/EventBus%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">EventBus 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:13:30" itemprop="dateCreated datePublished" datetime="2020-05-31T11:13:30+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>EventBus是一个Android端优化的publish／subscribe消息总线，简化了应用程序内各组件内、组件与后台线程间的通信，比如请求网络，等网络返回时，通过Handler、Broadcast更新UI等。它有很多优点：简化应用组件间的通信；解耦事件的发送者和接收者。<br><img src="https://upload-images.jianshu.io/upload_images/2169292-9d0c216714804720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EventBus-Publish-Subscribe.png"></p>
<h5 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h5><p>注册： EventBus.getDefault().register(this);<br>解注册：EventBus.getDefault().unregister(this);<br>事件Event： 事件可以是任意普通的Java对象，没有任何特殊的要求<br>发送消息： EventBus.getDefault().post(new MessageEvent(“Hello EventBus!”));</p>
<h5 id="三、线程模式"><a href="#三、线程模式" class="headerlink" title="三、线程模式"></a>三、线程模式</h5><p>EventBus支持订阅者方法在不同于发布事件所在线程的线程中被调用。你可以使用线程模式来指定调用订阅者方法的线程。EventBus总共支持5种线程模式：</p>
<ul>
<li><p>ThreadMode.POSTING 订阅者方法将在发布事件所在的线程中被调用。这是 默认的线程模式。事件的传递是同步的，一旦发布事件，所有该模式的订阅者方法都将被调用。这种线程模式意味着最少的性能开销，因为它避免了线程的切换。因此，对于不要求是主线程并且耗时很短的简单任务推荐使用该模式。使用该模式的订阅者方法应该快速返回，以避免阻塞发布事件的线程，这可能是主线程。</p>
</li>
<li><p>ThreadMode.MAIN 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.MAIN_ORDERED 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。事件将先进入队列然后才发送给订阅者，所以发布事件的调用将立即返回。这使得事件的处理保持严格的串行顺序。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。</p>
</li>
<li><p>ThreadMode.BACKGROUND 订阅者方法将在后台线程中被调用。如果发布事件的线程不是主线程，那么订阅者方法将直接在该线程中被调用。如果发布事件的线程是主线程，那么将使用一个单独的后台线程，该线程将按顺序发送所有的事件。使用该模式的订阅者方法应该快速返回，以避免阻塞后台线程。</p>
</li>
<li><p>ThreadMode.ASYNC 订阅者方法将在一个单独的线程中被调用。因此，发布事件的调用将立即返回。如果订阅者方法的执行需要一些时间，例如网络访问，那么就应该使用该模式。避免触发大量的长时间运行的订阅者方法，以限制并发线程的数量。EventBus使用了一个线程池来有效地重用已经完成调用订阅者方法的线程。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.POSTING)</span><br><span class="line">    public void onMessageEventPosting(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventPosting(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN)</span><br><span class="line">public void onMessageEventMain(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMain(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.MAIN_ORDERED)</span><br><span class="line">public void onMessageEventMainOrdered(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventMainOrdered(), current thread is &quot;</span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.BACKGROUND)</span><br><span class="line">public void onMessageEventBackground(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventBackground(), current thread is &quot; </span><br><span class="line">         + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Subscribe(threadMode &#x3D; ThreadMode.ASYNC)</span><br><span class="line">public void onMessageEventAsync(MessageEvent event) &#123;</span><br><span class="line">    Log.i(TAG, &quot;onMessageEventAsync(), current thread is &quot; </span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、粘性事件"><a href="#四、粘性事件" class="headerlink" title="四、粘性事件"></a>四、粘性事件</h5><p>发布一个粘性事件之后，EventBus将在内存中缓存该粘性事件。当有订阅者订阅了该粘性事件，订阅者将接收到该事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 发布粘性事件</span><br><span class="line">EventBus.getDefault().postSticky(new MessageEvent(&quot;Hello EventBus!&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 订阅粘性事件</span><br><span class="line">@Subscribe(sticky &#x3D; true)</span><br><span class="line">public void onMessageEvent(MessageEvent event) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、源码解析"><a href="#五、源码解析" class="headerlink" title="五、源码解析"></a>五、源码解析</h5><ol>
<li>从EventBus.getDefault()方法开始说起。主要是获取EventBus对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 典型的双重校验锁的单例模式</span><br><span class="line">static volatile EventBus defaultInstance;</span><br><span class="line">public static EventBus getDefault() &#123;</span><br><span class="line">    if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            if (defaultInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                defaultInstance &#x3D; new EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final EventBusBuilder DEFAULT_BUILDER &#x3D; new EventBusBuilder();</span><br><span class="line">&#x2F;&#x2F; 支持直接通过new创建EventBus</span><br><span class="line">public EventBus() &#123;</span><br><span class="line">    this(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; key 为订阅事件类型，value为订阅该事件的所有订阅者集合</span><br><span class="line">&#x2F;&#x2F; Subscription则是一个封装了订阅者和方法体的一个类</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line">&#x2F;&#x2F; key为订阅者，value为订阅的所有事件类型</span><br><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line">&#x2F;&#x2F; key 为eventType, value为事件集合</span><br><span class="line">private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; &#x2F;&#x2F;粘性事件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化成员变量</span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    typesBySubscriber &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    mainThreadPoster &#x3D; new HandlerPoster(this, Looper.getMainLooper(), 10);</span><br><span class="line">    backgroundPoster &#x3D; new BackgroundPoster(this);</span><br><span class="line">    asyncPoster &#x3D; new AsyncPoster(this);</span><br><span class="line">    &#x2F;&#x2F;一系列的builder赋值</span><br><span class="line">    subscriberMethodFinder &#x3D; new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    eventInheritance &#x3D; builder.eventInheritance; &#x2F;&#x2F; 默认支持继承</span><br><span class="line">    executorService &#x3D; builder.executorService;   &#x2F;&#x2F; Executors.newCachedThreadPool();</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">2. 消息注册register(this)函数</span><br></pre></td></tr></table></figure>
public void register(Object subscriber) {<br> Class&lt;?&gt; subscriberClass = subscriber.getClass();<br> // 从订阅类中获取所有的订阅方法信息<br> List<SubscriberMethod> subscriberMethods = subscriberMethodFinder<pre><code>.findSubscriberMethods(subscriberClass);</code></pre> synchronized (this) {<pre><code>for (SubscriberMethod subscriberMethod : subscriberMethods) {
    subscribe(subscriber, subscriberMethod);
}</code></pre> }<br>}</li>
</ol>
<p>private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {<br>    Class&lt;?&gt; eventType = subscriberMethod.eventType;</p>
<pre><code>/**
 ** (1) 将订阅者和订阅方法封装为Subscription对象
 ** (2) 将eventType和List&lt;Subscription&gt;集合添加到subscriptionsByEventType
 ** (3) 根据优先级排序List&lt;Subscription&gt;
 */
Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
if (subscriptions == null) {
    subscriptions = new CopyOnWriteArrayList&lt;&gt;();
    subscriptionsByEventType.put(eventType, subscriptions);
} else {
    if (subscriptions.contains(newSubscription)) {
        throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                + eventType);
    }
}

// 根据优先级排序，找到待插入位置
int size = subscriptions.size();
for (int i = 0; i &lt;= size; i++) {
    if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {
        subscriptions.add(i, newSubscription);
        break;
    }
}

/**
 ** (1) 将eventType事件类型添加subscriber所订阅的事件类型集合中
 */
List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
if (subscribedEvents == null) {
    subscribedEvents = new ArrayList&lt;&gt;();
    typesBySubscriber.put(subscriber, subscribedEvents);
}
subscribedEvents.add(eventType);
if (subscriberMethod.sticky) {
    if (eventInheritance) { // 默认为true
        Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
        for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
            Class&lt;?&gt; candidateEventType = entry.getKey();
            if (eventType.isAssignableFrom(candidateEventType)) {
                Object stickyEvent = entry.getValue();
                checkPostStickyEventToSubscription(newSubscription, stickyEvent);
            }
        }
    } else {
        Object stickyEvent = stickyEvents.get(eventType);
        checkPostStickyEventToSubscription(newSubscription, stickyEvent);
    }
}</code></pre><p>}</p>
<p>List<SubscriberMethod> findSubscriberMethods(Class&lt;?&gt; subscriberClass) {<br>    // 首先从缓存中读取<br>    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);<br>    if (subscriberMethods != null) {<br>        return subscriberMethods;<br>    }<br>    // 默认是false<br>    if (ignoreGeneratedIndex) {<br>        // 利用反射来获取订阅方法中的信息<br>        subscriberMethods = findUsingReflection(subscriberClass);<br>    } else {<br>        // 从注解器获取的类中获得订阅方法信息<br>        subscriberMethods = findUsingInfo(subscriberClass);<br>    }<br>    if (subscriberMethods.isEmpty()) {<br>        throw new EventBusException(“Subscriber “ + subscriberClass<br>                + “ and its super classes have no public methods with “<br>                +” the @Subscribe annotation”);<br>    } else {<br>        // 保存在缓存中<br>        METHOD_CACHE.put(subscriberClass, subscriberMethods);<br>        return subscriberMethods;<br>    }<br>}</p>
<p>private List<SubscriberMethod> findUsingInfo(Class&lt;?&gt; subscriberClass) {<br>    // 准备一个FindState，该FindState保存了订阅者类的信息<br>    FindState findState = prepareFindState();<br>    //对FindState初始化<br>    findState.initForSubscriber(subscriberClass);<br>    while (findState.clazz != null) {<br>        findState.subscriberInfo = getSubscriberInfo(findState);<br>        //获得订阅者的信息，一开始会返回null<br>        if (findState.subscriberInfo != null) {<br>            SubscriberMethod[] array = findState.subscriberInfo<br>                                       .getSubscriberMethods();<br>            for (SubscriberMethod subscriberMethod : array) {<br>                if (findState.checkAdd(subscriberMethod.method<br>                    , subscriberMethod.eventType)) {<br>                    findState.subscriberMethods.add(subscriberMethod);<br>                }<br>            }<br>        } else {<br>            findUsingReflectionInSingleClass(findState);<br>        }<br>        findState.moveToSuperclass();<br>    }<br>    return getMethodsAndRelease(findState);<br>}</p>
<p>private void findUsingReflectionInSingleClass(FindState findState) {<br>    Method[] methods;<br>    try {<br>        methods = findState.clazz.getDeclaredMethods();<br>    } catch (Throwable th) {<br>        methods = findState.clazz.getMethods();<br>        findState.skipSuperClasses = true;<br>    }<br>    for (Method method : methods) {<br>        int modifiers = method.getModifiers();<br>        if ((modifiers &amp; Modifier.PUBLIC) != 0<br>            &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {<br>            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method
                                               .getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    Class<?> eventType = parameterTypes[0];<br>                    if (findState.checkAdd(method, eventType)) {<br>                        ThreadMode threadMode = subscribeAnnotation.threadMode();<br>                        findState.subscriberMethods.add(new SubscriberMethod(method<br>                        , eventType, threadMode,subscribeAnnotation.priority()<br>                        , subscribeAnnotation.sticky()));<br>                    }<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>                   String methodName = method.getDeclaringClass().getName()<br>                                    + “.” + method.getName();<br>                    throw new EventBusException(“@Subscribe method “ + methodName +<br>                 “must have exactly 1 parameter but has “ + parameterTypes.length);<br>                }<br>            } else if (strictMethodVerification<br>                       &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {<br>            String methodName = method.getDeclaringClass().getName() + “.”<br>                                + method.getName();<br>            throw new EventBusException(methodName +<br>                        “ is a illegal @Subscribe method: must be public “<br>                        + “, non-static, and non-abstract”);<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3. 发送消息源码</span><br></pre></td></tr></table></figure>

<p>// 粘性事件<br>public void postSticky(Object event) {<br>    synchronized (stickyEvents) {<br>        stickyEvents.put(event.getClass(), event);<br>    }<br>    post(event);<br>}</p>
<p>// 普通事件<br>public void post(Object event) {<br>    PostingThreadState postingState = currentPostingThreadState.get();<br>    List<Object> eventQueue = postingState.eventQueue;<br>    eventQueue.add(event);<br>    // 如果没有正在发送，则发送消息<br>    if (!postingState.isPosting) {<br>        postingState.isMainThread = isMainThread();<br>        postingState.isPosting = true;<br>        if (postingState.canceled) {<br>          throw new EventBusException(“Internal error. Abort state was not reset”);<br>        }<br>        try {<br>            while (!eventQueue.isEmpty()) {<br>                // 发送消息<br>                postSingleEvent(eventQueue.remove(0), postingState);<br>             }<br>        } finally {<br>            postingState.isPosting = false;<br>            postingState.isMainThread = false;<br>        }<br>    }<br>}</p>
<p>private void postSingleEvent(Object event, PostingThreadState postingState)<br>throws Error {<br>    Class<?> eventClass = event.getClass();
    boolean subscriptionFound = false;
    if (eventInheritance) {
        List<Class<?>&gt; eventTypes = lookupAllEventTypes(eventClass);<br>        int countTypes = eventTypes.size();<br>        for (int h = 0; h &lt; countTypes; h++) {<br>            Class&lt;?&gt; clazz = eventTypes.get(h);<br>            subscriptionFound |= postSingleEventForEventType(event<br>                                 , postingState, clazz);<br>        }<br>     } else {<br>        subscriptionFound = postSingleEventForEventType(event, postingState<br>                                                        , eventClass);<br>     }<br>     if (!subscriptionFound) {<br>        if (logNoSubscriberMessages) {<br>            logger.log(Level.FINE, “No subscribers registered for event “<br>                       + eventClass);<br>        }<br>        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class<br>            &amp;&amp; eventClass != SubscriberExceptionEvent.class) {<br>            post(new NoSubscriberEvent(this, event));<br>        }<br>    }<br>}</p>
<p>private boolean postSingleEventForEventType(Object event<br>                          , PostingThreadState postingState, Class&lt;?&gt; eventClass) {<br>    CopyOnWriteArrayList<Subscription> subscriptions;<br>    synchronized (this) {<br>        // 根据事件类型获取所有的订者<br>        subscriptions = subscriptionsByEventType.get(eventClass);<br>    }<br>    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {<br>        for (Subscription subscription : subscriptions) {<br>            postingState.event = event;<br>            postingState.subscription = subscription;<br>            boolean aborted = false;<br>            try {<br>                postToSubscription(subscription, event, postingState.isMainThread);<br>                aborted = postingState.canceled;<br>            } finally {<br>                postingState.event = null;<br>                postingState.subscription = null;<br>                postingState.canceled = false;<br>            }<br>            if (aborted) {<br>                break;<br>            }<br>        }<br>        return true;<br>    }<br>    return false;<br>}</p>
<p>private void postToSubscription(Subscription subscription, Object event<br>                                , boolean isMainThread) {<br>    switch (subscription.subscriberMethod.threadMode) {<br>        case POSTING:<br>            invokeSubscriber(subscription, event);<br>            break;<br>        case MAIN:<br>            if (isMainThread) {<br>                invokeSubscriber(subscription, event);<br>            } else {<br>                mainThreadPoster.enqueue(subscription, event);<br>            }<br>            break;<br>        case MAIN_ORDERED:<br>            if (mainThreadPoster != null) {<br>                mainThreadPoster.enqueue(subscription, event);<br>            } else {<br>                // temporary: technically not correct as poster not decoupled<br>                // from subscriber<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case BACKGROUND:<br>            if (isMainThread) {<br>                backgroundPoster.enqueue(subscription, event);<br>            } else {<br>                invokeSubscriber(subscription, event);<br>            }<br>            break;<br>        case ASYNC:<br>            asyncPoster.enqueue(subscription, event);<br>            break;<br>        default:<br>            throw new IllegalStateException(“Unknown thread mode: “<br>                                       + subscription.subscriberMethod.threadMode);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4. 取消注册源码分析</span><br></pre></td></tr></table></figure>
<p>public synchronized void unregister(Object subscriber) {<br>    List&lt;Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class<?> eventType : subscribedTypes) {<br>            unsubscribeByEventType(subscriber, eventType);<br>        }<br>        typesBySubscriber.remove(subscriber);<br>    } else {<br>        logger.log(Level.WARNING, “Subscriber to unregister was not<br>                   “+registered before: “ + subscriber.getClass());<br>    }<br>}</p>
<p>private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {<br>    // 获取事件类型的所有订阅者<br>    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);<br>    if (subscriptions != null) {<br>        int size = subscriptions.size();<br>        // 遍历订阅者集合将解除的订阅者移除<br>        for (int i = 0; i &lt; size; i++) {<br>            Subscription subscription = subscriptions.get(i);<br>            if (subscription.subscriber == subscriber) {<br>                subscription.active = false;<br>                subscriptions.remove(i);<br>                i–;<br>                size–;<br>            }<br>        }<br>    }<br>}</p>
<pre><code>简单的进行总结一下，主要就是注册和发送过程比较重要。

注册：

1. 通过反射或者注解获取所有的订阅方法 
2. 将当前订阅者添加到EventBus总的事件订阅者集合中subscriptionsByEventType 
3. 将当前订阅者所有订阅的事件类型添加到typesBySubscriber，方便解注册

发送：
1. 得到要发送的事件类型 
2. 根据事件类型获取订阅者，并循环向每个订阅者发送

解注册：
1. 通过typesBySubscriber获取当前订阅者所有的订阅事件类型
2. 循环遍历每一个事件类型，并删除当前订阅者的订阅的方法</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">RxJava 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:10:57" itemprop="dateCreated datePublished" datetime="2020-05-31T11:10:57+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="一、RxJava-简介"><a href="#一、RxJava-简介" class="headerlink" title="一、RxJava 简介"></a>一、RxJava 简介</h5><p>RxJava是一种基于观察者模式的响应式编程框架，其定义的角色有Observable事件流、ObservableOnSubscribe事件源头、Observer是事件订阅者。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/31/RxJava%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">12 系统启动并解析Manifest的流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Manifest%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">Manifest解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近有同学问我关于Manifest何时被系统解析的问题，正好也分析到这一块了，索性这一章就讲解一下android系统何时解析Manifest吧，这里的Manifest指的是android安装文件apk中的androidManifest.xml文件是何时被解析的。<br>大家应该都知道，Android系统启动之后，我们就可以在一个应用中打开另一个从未打开过的应用，或者是在一个应用中发送广播，如果另外一个应用设置了这个广播的接收器，那么这个应用进程就会被启动并接收该广播并作出相应的处理，这样的例子很多，我们可以猜测到Android系统在启动的时候就会抓取到了系统中所有安装的应用信息（应该是解析apk文件的Manifest信息），即在Android系统的启动过程中就已经解析了系统中安装应用的androidManifest.xml文件并保存起来了，那么这个过程具体是如何的呢?</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/05/30/12%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
