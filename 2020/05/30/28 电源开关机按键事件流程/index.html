<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。 和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇">
<meta property="og:type" content="article">
<meta property="og:title" content="28 电源开关机按键事件流程">
<meta property="og:url" content="http://yoursite.com/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。 和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.blog.csdn.net/20160524153125405">
<meta property="og:image" content="http://img.blog.csdn.net/20160525144307466">
<meta property="article:published_time" content="2020-05-29T16:29:04.811Z">
<meta property="article:modified_time" content="2020-05-31T03:02:48.614Z">
<meta property="article:author" content="yudesong">
<meta property="article:tag" content="Android系统层">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.blog.csdn.net/20160524153125405">

<link rel="canonical" href="http://yoursite.com/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>28 电源开关机按键事件流程 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/28%20%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          28 电源开关机按键事件流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。</p>
<p>和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。</p>
<p>下面首先看一下dispatchUnhandledKey方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                if (DEBUG_INPUT) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;Fallback: keyCode&#x3D;&quot; + fallbackAction.keyCode</span><br><span class="line">                            + &quot; metaState&#x3D;&quot; + Integer.toHexString(fallbackAction.metaState));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过前面两篇文章的分析<br>（<a href="http://blog.csdn.net/qq_23547831/article/details/51474288" target="_blank" rel="noopener"> android源码解析（二十六）–&gt;截屏事件流程</a>&nbsp;&nbsp;<br><a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）<br>我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">            case KeyEvent.KEYCODE_POWER: &#123;</span><br><span class="line">                result &amp;&#x3D; ~ACTION_PASS_TO_USER;</span><br><span class="line">                isWakeKey &#x3D; false; &#x2F;&#x2F; wake-up will be handled separately</span><br><span class="line">                if (down) &#123;</span><br><span class="line">                    interceptPowerKeyDown(event, interactive);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    interceptPowerKeyUp(event, interactive, canceled);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private void interceptPowerKeyDown(KeyEvent event, boolean interactive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Latch power key state to detect screenshot chord.</span><br><span class="line">        if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mScreenshotChordPowerKeyTriggered &#x3D; true;</span><br><span class="line">            mScreenshotChordPowerKeyTime &#x3D; event.getDownTime();</span><br><span class="line">            interceptScreenshotChord();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Stop ringing or end call if configured to do so when power is pressed.</span><br><span class="line">        TelecomManager telecomManager &#x3D; getTelecommService();</span><br><span class="line">        boolean hungUp &#x3D; false;</span><br><span class="line">        if (telecomManager !&#x3D; null) &#123;</span><br><span class="line">            if (telecomManager.isRinging()) &#123;</span><br><span class="line">                &#x2F;&#x2F; Pressing Power while there&#39;s a ringing incoming</span><br><span class="line">                &#x2F;&#x2F; call should silence the ringer.</span><br><span class="line">                telecomManager.silenceRinger();</span><br><span class="line">            &#125; else if ((mIncallPowerBehavior</span><br><span class="line">                    &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) !&#x3D; 0</span><br><span class="line">                    &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; Otherwise, if &quot;Power button ends call&quot; is enabled,</span><br><span class="line">                &#x2F;&#x2F; the Power button will hang up any current active call.</span><br><span class="line">                hungUp &#x3D; telecomManager.endCall();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the power key has still not yet been handled, then detect short</span><br><span class="line">        &#x2F;&#x2F; press, long press, or multi press and decide what to do.</span><br><span class="line">        mPowerKeyHandled &#x3D; hungUp || mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                || mScreenshotChordVolumeUpKeyTriggered;</span><br><span class="line">        if (!mPowerKeyHandled) &#123;</span><br><span class="line">            if (interactive) &#123;</span><br><span class="line">                &#x2F;&#x2F; When interactive, we&#39;re already awake.</span><br><span class="line">                &#x2F;&#x2F; Wait for a long press or for the button to be released to decide what to do.</span><br><span class="line">                if (hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                wakeUpFromPowerKey(event.getDownTime());</span><br><span class="line"></span><br><span class="line">                if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) &#123;</span><br><span class="line">                    Message msg &#x3D; mHandler.obtainMessage(MSG_POWER_LONG_PRESS);</span><br><span class="line">                    msg.setAsynchronous(true);</span><br><span class="line">                    mHandler.sendMessageDelayed(msg,</span><br><span class="line">                            ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">                    mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int maxCount &#x3D; getMaxMultiPressPowerCount();</span><br><span class="line"></span><br><span class="line">                    if (maxCount &lt;&#x3D; 1) &#123;</span><br><span class="line">                        mPowerKeyHandled &#x3D; true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBeganFromNonInteractive &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case MSG_POWER_LONG_PRESS:</span><br><span class="line">                    powerLongPress();</span><br><span class="line">                    break;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void powerLongPress() &#123;</span><br><span class="line">        final int behavior &#x3D; getResolvedLongPressOnPowerBehavior();</span><br><span class="line">        switch (behavior) &#123;</span><br><span class="line">        case LONG_PRESS_POWER_NOTHING:</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_GLOBAL_ACTIONS:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) &#123;</span><br><span class="line">                performAuditoryFeedbackForAccessibilityIfNeed();</span><br><span class="line">            &#125;</span><br><span class="line">            showGlobalActionsInternal();</span><br><span class="line">            break;</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF:</span><br><span class="line">        case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM:</span><br><span class="line">            mPowerKeyHandled &#x3D; true;</span><br><span class="line">            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);</span><br><span class="line">            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">            mWindowManagerFuncs.shutdown(behavior &#x3D;&#x3D; LONG_PRESS_POWER_SHUT_OFF);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面：<br><img src="http://img.blog.csdn.net/20160524153125405" alt="这里写图片描述"></p>
<p>然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void showGlobalActionsInternal() &#123;</span><br><span class="line">        sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);</span><br><span class="line">        if (mGlobalActions &#x3D;&#x3D; null) &#123;</span><br><span class="line">            mGlobalActions &#x3D; new GlobalActions(mContext, mWindowManagerFuncs);</span><br><span class="line">        &#125;</span><br><span class="line">        final boolean keyguardShowing &#x3D; isKeyguardShowingAndNotOccluded();</span><br><span class="line">        mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned());</span><br><span class="line">        if (keyguardShowing) &#123;</span><br><span class="line">            &#x2F;&#x2F; since it took two seconds of long press to bring this up,</span><br><span class="line">            &#x2F;&#x2F; poke the wake lock so they have some time to see the dialog.</span><br><span class="line">            mPowerManager.userActivity(SystemClock.uptimeMillis(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（<a href="http://blog.csdn.net/qq_23547831/article/details/51475929" target="_blank" rel="noopener">android源码解析（二十七）–&gt;HOME事件流程</a>）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">        mContext &#x3D; context;</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">        mAudioManager &#x3D; (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">        mDreamManager &#x3D; IDreamManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(DreamService.DREAM_SERVICE));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; receive broadcasts</span><br><span class="line">        IntentFilter filter &#x3D; new IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);</span><br><span class="line">        filter.addAction(Intent.ACTION_SCREEN_OFF);</span><br><span class="line">        filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);</span><br><span class="line">        context.registerReceiver(mBroadcastReceiver, filter);</span><br><span class="line"></span><br><span class="line">        ConnectivityManager cm &#x3D; (ConnectivityManager)</span><br><span class="line">                context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">        mHasTelephony &#x3D; cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; get notified of phone state changes</span><br><span class="line">        TelephonyManager telephonyManager &#x3D;</span><br><span class="line">                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">        telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE);</span><br><span class="line">        mContext.getContentResolver().registerContentObserver(</span><br><span class="line">                Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true,</span><br><span class="line">                mAirplaneModeObserver);</span><br><span class="line">        Vibrator vibrator &#x3D; (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);</span><br><span class="line">        mHasVibrator &#x3D; vibrator !&#x3D; null &amp;&amp; vibrator.hasVibrator();</span><br><span class="line"></span><br><span class="line">        mShowSilentToggle &#x3D; SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_useFixedVolume);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) &#123;</span><br><span class="line">        mKeyguardShowing &#x3D; keyguardShowing;</span><br><span class="line">        mDeviceProvisioned &#x3D; isDeviceProvisioned;</span><br><span class="line">        if (mDialog !&#x3D; null) &#123;</span><br><span class="line">            mDialog.dismiss();</span><br><span class="line">            mDialog &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; Show delayed, so that the dismiss of the previous dialog completes</span><br><span class="line">            mHandler.sendEmptyMessage(MESSAGE_SHOW);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handleShow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void handleShow() &#123;</span><br><span class="line">        awakenIfNecessary();</span><br><span class="line">        mDialog &#x3D; createDialog();</span><br><span class="line">        prepareDialog();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we only have 1 item and it&#39;s a simple press action, just do this action.</span><br><span class="line">        if (mAdapter.getCount() &#x3D;&#x3D; 1</span><br><span class="line">                &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction</span><br><span class="line">                &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) &#123;</span><br><span class="line">            ((SinglePressAction) mAdapter.getItem(0)).onPress();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            WindowManager.LayoutParams attrs &#x3D; mDialog.getWindow().getAttributes();</span><br><span class="line">            attrs.setTitle(&quot;GlobalActions&quot;);</span><br><span class="line">            mDialog.getWindow().setAttributes(attrs);</span><br><span class="line">            mDialog.show();</span><br><span class="line">            mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">private GlobalActionsDialog createDialog() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mAirplaneModeOn &#x3D; new ToggleAction(</span><br><span class="line">                R.drawable.ic_lock_airplane_mode,</span><br><span class="line">                R.drawable.ic_lock_airplane_mode_off,</span><br><span class="line">                R.string.global_actions_toggle_airplane_mode,</span><br><span class="line">                R.string.global_actions_airplane_mode_on_status,</span><br><span class="line">                R.string.global_actions_airplane_mode_off_status) &#123;</span><br><span class="line"></span><br><span class="line">            void onToggle(boolean on) &#123;</span><br><span class="line">                if (mHasTelephony &amp;&amp; Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) &#123;</span><br><span class="line">                    mIsWaitingForEcmExit &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; Launch ECM exit dialog</span><br><span class="line">                    Intent ecmDialogIntent &#x3D;</span><br><span class="line">                            new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);</span><br><span class="line">                    ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                    mContext.startActivity(ecmDialogIntent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    changeAirplaneModeSystemSetting(on);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected void changeStateFromPress(boolean buttonOn) &#123;</span><br><span class="line">                if (!mHasTelephony) return;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; In ECM mode airplane state cannot be changed</span><br><span class="line">                if (!(Boolean.parseBoolean(</span><br><span class="line">                        SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) &#123;</span><br><span class="line">                    mState &#x3D; buttonOn ? State.TurningOn : State.TurningOff;</span><br><span class="line">                    mAirplaneState &#x3D; mState;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showDuringKeyguard() &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public boolean showBeforeProvisioning() &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        onAirplaneModeChanged();</span><br><span class="line"></span><br><span class="line">        mItems &#x3D; new ArrayList&lt;Action&gt;();</span><br><span class="line">        String[] defaultActions &#x3D; mContext.getResources().getStringArray(</span><br><span class="line">                com.android.internal.R.array.config_globalActionsList);</span><br><span class="line"></span><br><span class="line">        ArraySet&lt;String&gt; addedKeys &#x3D; new ArraySet&lt;String&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; defaultActions.length; i++) &#123;</span><br><span class="line">            String actionKey &#x3D; defaultActions[i];</span><br><span class="line">            if (addedKeys.contains(actionKey)) &#123;</span><br><span class="line">                &#x2F;&#x2F; If we already have added this, don&#39;t add it again.</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(new PowerAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(mAirplaneModeOn);</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) &#123;</span><br><span class="line">                if (Settings.Global.getInt(mContext.getContentResolver(),</span><br><span class="line">                        Settings.Global.BUGREPORT_IN_POWER_MENU, 0) !&#x3D; 0 &amp;&amp; isCurrentUserOwner()) &#123;</span><br><span class="line">                    mItems.add(getBugReportAction());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) &#123;</span><br><span class="line">                if (mShowSilentToggle) &#123;</span><br><span class="line">                    mItems.add(mSilentModeAction);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) &#123;</span><br><span class="line">                if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) &#123;</span><br><span class="line">                    addUsersToMenu(mItems);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getSettingsAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getLockdownAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getVoiceAssistAction());</span><br><span class="line">            &#125; else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) &#123;</span><br><span class="line">                mItems.add(getAssistAction());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Log.e(TAG, &quot;Invalid global action key &quot; + actionKey);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Add here so we don&#39;t add more than one.</span><br><span class="line">            addedKeys.add(actionKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdapter &#x3D; new MyAdapter();</span><br><span class="line"></span><br><span class="line">        AlertParams params &#x3D; new AlertParams(mContext);</span><br><span class="line">        params.mAdapter &#x3D; mAdapter;</span><br><span class="line">        params.mOnClickListener &#x3D; this;</span><br><span class="line">        params.mForceInverseBackground &#x3D; true;</span><br><span class="line"></span><br><span class="line">        GlobalActionsDialog dialog &#x3D; new GlobalActionsDialog(mContext, params);</span><br><span class="line">        dialog.setCanceledOnTouchOutside(false); &#x2F;&#x2F; Handled by the custom class.</span><br><span class="line"></span><br><span class="line">        dialog.getListView().setItemsCanFocus(true);</span><br><span class="line">        dialog.getListView().setLongClickable(true);</span><br><span class="line">        dialog.getListView().setOnItemLongClickListener(</span><br><span class="line">                new AdapterView.OnItemLongClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position,</span><br><span class="line">                            long id) &#123;</span><br><span class="line">                        final Action action &#x3D; mAdapter.getItem(position);</span><br><span class="line">                        if (action instanceof LongPressAction) &#123;</span><br><span class="line">                            return ((LongPressAction) action).onLongPress();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        dialog.setOnDismissListener(this);</span><br><span class="line"></span><br><span class="line">        return dialog;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面：<br><img src="http://img.blog.csdn.net/20160525144307466" alt="这里写图片描述"></p>
<p>好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mItems.add(new PowerAction());</span><br></pre></td></tr></table></figure>
<p>这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final class PowerAction extends SinglePressAction implements LongPressAction &#123;</span><br><span class="line">        private PowerAction() &#123;</span><br><span class="line">            super(com.android.internal.R.drawable.ic_lock_power_off,</span><br><span class="line">                R.string.global_action_power_off);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onLongPress() &#123;</span><br><span class="line">            UserManager um &#x3D; (UserManager) mContext.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) &#123;</span><br><span class="line">                mWindowManagerFuncs.rebootSafeMode(true);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showDuringKeyguard() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean showBeforeProvisioning() &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onPress() &#123;</span><br><span class="line">            &#x2F;&#x2F; shutdown by making sure radio and power are handled accordingly.</span><br><span class="line">            mWindowManagerFuncs.shutdown(false &#x2F;* confirm *&#x2F;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) &#123;</span><br><span class="line">		...</span><br><span class="line">        mWindowManagerFuncs &#x3D; windowManagerFuncs;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。</p>
<p>经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void initPolicy() &#123;</span><br><span class="line">        UiThread.getHandler().runWithScissors(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line"></span><br><span class="line">                mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。</p>
<p>然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false /* confirm */);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void shutdown(boolean confirm) &#123;</span><br><span class="line">        ShutdownThread.shutdown(mContext, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void shutdown(final Context context, boolean confirm) &#123;</span><br><span class="line">        mReboot &#x3D; false;</span><br><span class="line">        mRebootSafeMode &#x3D; false;</span><br><span class="line">        shutdownInner(context, confirm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void shutdownInner(final Context context, boolean confirm) &#123;</span><br><span class="line">        &#x2F;&#x2F; ensure that only one thread is trying to power down.</span><br><span class="line">        &#x2F;&#x2F; any additional calls are just returned</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int longPressBehavior &#x3D; context.getResources().getInteger(</span><br><span class="line">                        com.android.internal.R.integer.config_longPressOnPowerBehavior);</span><br><span class="line">        final int resourceId &#x3D; mRebootSafeMode</span><br><span class="line">                ? com.android.internal.R.string.reboot_safemode_confirm</span><br><span class="line">                : (longPressBehavior &#x3D;&#x3D; 2</span><br><span class="line">                        ? com.android.internal.R.string.shutdown_confirm_question</span><br><span class="line">                        : com.android.internal.R.string.shutdown_confirm);</span><br><span class="line"></span><br><span class="line">        Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior&#x3D;&quot; + longPressBehavior);</span><br><span class="line"></span><br><span class="line">        if (confirm) &#123;</span><br><span class="line">            final CloseDialogReceiver closer &#x3D; new CloseDialogReceiver(context);</span><br><span class="line">            if (sConfirmDialog !&#x3D; null) &#123;</span><br><span class="line">                sConfirmDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">            sConfirmDialog &#x3D; new AlertDialog.Builder(context)</span><br><span class="line">                    .setTitle(mRebootSafeMode</span><br><span class="line">                            ? com.android.internal.R.string.reboot_safemode_title</span><br><span class="line">                            : com.android.internal.R.string.power_off)</span><br><span class="line">                    .setMessage(resourceId)</span><br><span class="line">                    .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">                        public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                            beginShutdownSequence(context);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .setNegativeButton(com.android.internal.R.string.no, null)</span><br><span class="line">                    .create();</span><br><span class="line">            closer.dialog &#x3D; sConfirmDialog;</span><br><span class="line">            sConfirmDialog.setOnDismissListener(closer);</span><br><span class="line">            sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line">            sConfirmDialog.show();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            beginShutdownSequence(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">private static void beginShutdownSequence(Context context) &#123;</span><br><span class="line">        synchronized (sIsStartedGuard) &#123;</span><br><span class="line">            if (sIsStarted) &#123;</span><br><span class="line">                Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            sIsStarted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">        if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) &#123;</span><br><span class="line">            mRebootUpdate &#x3D; new File(UNCRYPT_PACKAGE_FILE).exists();</span><br><span class="line">            if (mRebootUpdate) &#123;</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_update_prepare));</span><br><span class="line">                pd.setMax(100);</span><br><span class="line">                pd.setProgressNumberFormat(null);</span><br><span class="line">                pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">                pd.setProgress(0);</span><br><span class="line">                pd.setIndeterminate(false);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Factory reset path. Set the dialog message accordingly.</span><br><span class="line">                pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));</span><br><span class="line">                pd.setMessage(context.getText(</span><br><span class="line">                        com.android.internal.R.string.reboot_to_reset_message));</span><br><span class="line">                pd.setIndeterminate(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pd.setTitle(context.getText(com.android.internal.R.string.power_off));</span><br><span class="line">            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));</span><br><span class="line">            pd.setIndeterminate(true);</span><br><span class="line">        &#125;</span><br><span class="line">        pd.setCancelable(false);</span><br><span class="line">        pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);</span><br><span class="line"></span><br><span class="line">        pd.show();</span><br><span class="line"></span><br><span class="line">        sInstance.mProgressDialog &#x3D; pd;</span><br><span class="line">        sInstance.mContext &#x3D; context;</span><br><span class="line">        sInstance.mPowerManager &#x3D; (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; make sure we never fall asleep again</span><br><span class="line">        sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                    PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;);</span><br><span class="line">            sInstance.mCpuWakeLock.setReferenceCounted(false);</span><br><span class="line">            sInstance.mCpuWakeLock.acquire();</span><br><span class="line">        &#125; catch (SecurityException e) &#123;</span><br><span class="line">            Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">            sInstance.mCpuWakeLock &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; also make sure the screen stays on for better user experience</span><br><span class="line">        sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">        if (sInstance.mPowerManager.isScreenOn()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; sInstance.mPowerManager.newWakeLock(</span><br><span class="line">                        PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;);</span><br><span class="line">                sInstance.mScreenWakeLock.setReferenceCounted(false);</span><br><span class="line">                sInstance.mScreenWakeLock.acquire();</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e);</span><br><span class="line">                sInstance.mScreenWakeLock &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; start the thread that initiates shutdown</span><br><span class="line">        sInstance.mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        sInstance.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。</p>
<p>总结：</p>
<ul>
<li><p>电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中；</p>
</li>
<li><p>在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等；</p>
</li>
<li><p>当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法；</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E7%B3%BB%E7%BB%9F%E5%B1%82/" rel="tag"># Android系统层</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/30/27%20HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" rel="prev" title="27 HOME事件流程">
      <i class="fa fa-chevron-left"></i> 27 HOME事件流程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/30/29%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" rel="next" title="29 应用程序返回按键执行流程">
      29 应用程序返回按键执行流程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
