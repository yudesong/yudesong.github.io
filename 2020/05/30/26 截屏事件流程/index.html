<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。 我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里">
<meta property="og:type" content="article">
<meta property="og:title" content="26 截屏事件流程">
<meta property="og:url" content="http://yoursite.com/2020/05/30/26%20%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。 我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-29T16:29:04.775Z">
<meta property="article:modified_time" content="2020-05-31T03:03:02.472Z">
<meta property="article:author" content="yudesong">
<meta property="article:tag" content="Android系统层">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/05/30/26%20%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>26 截屏事件流程 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/26%20%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          26 截屏事件流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。</p>
<p>我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。</p>
<p>在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** &#123;@inheritDoc&#125; *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        ...</span><br><span class="line">        KeyEvent fallbackEvent &#x3D; null;</span><br><span class="line">        if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final KeyCharacterMap kcm &#x3D; event.getKeyCharacterMap();</span><br><span class="line">            final int keyCode &#x3D; event.getKeyCode();</span><br><span class="line">            final int metaState &#x3D; event.getMetaState();</span><br><span class="line">            final boolean initialDown &#x3D; event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_DOWN</span><br><span class="line">                    &amp;&amp; event.getRepeatCount() &#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for fallback actions specified by the key character map.</span><br><span class="line">            final FallbackAction fallbackAction;</span><br><span class="line">            if (initialDown) &#123;</span><br><span class="line">                fallbackAction &#x3D; kcm.getFallbackAction(keyCode, metaState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fallbackAction &#x3D; mFallbackActions.get(keyCode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (fallbackAction !&#x3D; null) &#123;</span><br><span class="line">                ...</span><br><span class="line">                final int flags &#x3D; event.getFlags() | KeyEvent.FLAG_FALLBACK;</span><br><span class="line">                fallbackEvent &#x3D; KeyEvent.obtain(</span><br><span class="line">                        event.getDownTime(), event.getEventTime(),</span><br><span class="line">                        event.getAction(), fallbackAction.keyCode,</span><br><span class="line">                        event.getRepeatCount(), fallbackAction.metaState,</span><br><span class="line">                        event.getDeviceId(), event.getScanCode(),</span><br><span class="line">                        flags, event.getSource(), null);</span><br><span class="line"></span><br><span class="line">                if (!interceptFallback(win, fallbackEvent, policyFlags)) &#123;</span><br><span class="line">                    fallbackEvent.recycle();</span><br><span class="line">                    fallbackEvent &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (initialDown) &#123;</span><br><span class="line">                    mFallbackActions.put(keyCode, fallbackAction);</span><br><span class="line">                &#125; else if (event.getAction() &#x3D;&#x3D; KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                    mFallbackActions.remove(keyCode);</span><br><span class="line">                    fallbackAction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        return fallbackEvent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) &#123;</span><br><span class="line">        int actions &#x3D; interceptKeyBeforeQueueing(fallbackEvent, policyFlags);</span><br><span class="line">        if ((actions &amp; ACTION_PASS_TO_USER) !&#x3D; 0) &#123;</span><br><span class="line">            long delayMillis &#x3D; interceptKeyBeforeDispatching(</span><br><span class="line">                    win, fallbackEvent, policyFlags);</span><br><span class="line">            if (delayMillis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) &#123;</span><br><span class="line">        if (!mSystemBooted) &#123;</span><br><span class="line">            &#x2F;&#x2F; If we have not yet booted, don&#39;t let key events do anything.</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; Handle special keys.</span><br><span class="line">        switch (keyCode) &#123;</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_DOWN:</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_UP:</span><br><span class="line">            case KeyEvent.KEYCODE_VOLUME_MUTE: &#123;</span><br><span class="line">                if (mUseTvRouting) &#123;</span><br><span class="line">                    &#x2F;&#x2F; On TVs volume keys never go to the foreground app</span><br><span class="line">                    result &amp;&#x3D; ~ACTION_PASS_TO_USER;</span><br><span class="line">                &#125;</span><br><span class="line">                if (keyCode &#x3D;&#x3D; KeyEvent.KEYCODE_VOLUME_DOWN) &#123;</span><br><span class="line">                    if (down) &#123;</span><br><span class="line">                        if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered &#x3D; true;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime &#x3D; event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed &#x3D; false;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mScreenshotChordVolumeDownKeyTriggered &#x3D; false;</span><br><span class="line">                        cancelPendingScreenshotChordAction();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里首先判断当前系统是否已经boot完毕，若尚未启动完毕，则所有的按键操作都将失效，若启动完成，则执行后续的操作，这里我们只是关注音量减少按键和电源按键组合的处理事件。另外这里多说一句想安卓系统的HOME按键事件，MENU按键事件，进程列表按键事件等等都是在这里实现的，后续中我们会陆续介绍这方面的内容。</p>
<p>回到我们的interceptKeyBeforeQueueing方法，当我用按下音量减少按键的时候回进入到：case KeyEvent.KEYCODE_VOLUME_MUTE分支并执行相应的逻辑，然后同时判断用户是否按下了电源键，若同时按下了电源键，则执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered</span><br><span class="line">                                &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTriggered &#x3D; true;</span><br><span class="line">                            mScreenshotChordVolumeDownKeyTime &#x3D; event.getDownTime();</span><br><span class="line">                            mScreenshotChordVolumeDownKeyConsumed &#x3D; false;</span><br><span class="line">                            cancelPendingPowerKeyAction();</span><br><span class="line">                            interceptScreenshotChord();</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里的interceptScreenshotChrod方法就是系统准备开始执行截屏操作的开始，我们继续看一下interceptcreenshotChord方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void interceptScreenshotChord() &#123;</span><br><span class="line">        if (mScreenshotChordEnabled</span><br><span class="line">                &amp;&amp; mScreenshotChordVolumeDownKeyTriggered &amp;&amp; mScreenshotChordPowerKeyTriggered</span><br><span class="line">                &amp;&amp; !mScreenshotChordVolumeUpKeyTriggered) &#123;</span><br><span class="line">            final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            if (now &lt;&#x3D; mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS</span><br><span class="line">                    &amp;&amp; now &lt;&#x3D; mScreenshotChordPowerKeyTime</span><br><span class="line">                            + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) &#123;</span><br><span class="line">                mScreenshotChordVolumeDownKeyConsumed &#x3D; true;</span><br><span class="line">                cancelPendingPowerKeyAction();</span><br><span class="line"></span><br><span class="line">                mHandler.postDelayed(mScreenshotRunnable, getScreenshotChordLongPressDelay());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中我们最终会执行发送一个延迟的异步消息，请求执行截屏的操作而这里的延时时间，若当前输入框是打开状态，则延时时间为输入框关闭时间加上系统配置的按键超时时间，若当前输入框没有打开则直接是系统配置的按键超时处理时间，可看一下getScreenshotChordLongPressDelay方法的具体实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private long getScreenshotChordLongPressDelay() &#123;</span><br><span class="line">        if (mKeyguardDelegate.isShowing()) &#123;</span><br><span class="line">            &#x2F;&#x2F; Double the time it takes to take a screenshot from the keyguard</span><br><span class="line">            return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER *</span><br><span class="line">                    ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());</span><br><span class="line">        &#125;</span><br><span class="line">        return ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>回到我们的interceptScreenshotChord方法，发送了异步消息之后系统最终会被我们发送的Runnable对象的run方法执行，这里关于异步消息的逻辑可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/50751687" target="_blank" rel="noopener">android源码解析之（二）–&gt;异步消息机制</a></p>
<p>这样我们看一下Runnable类型的mScreenshotRunnable的run方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable mScreenshotRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            takeScreenshot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体中并未执行其他操作，直接就是调用了takeScreenshot方法，这样我们继续看一下takeScreenshot方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void takeScreenshot() &#123;</span><br><span class="line">        synchronized (mScreenshotLock) &#123;</span><br><span class="line">            if (mScreenshotConnection !&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ComponentName cn &#x3D; new ComponentName(&quot;com.android.systemui&quot;,</span><br><span class="line">                    &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;);</span><br><span class="line">            Intent intent &#x3D; new Intent();</span><br><span class="line">            intent.setComponent(cn);</span><br><span class="line">            ServiceConnection conn &#x3D; new ServiceConnection() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">                    synchronized (mScreenshotLock) &#123;</span><br><span class="line">                        if (mScreenshotConnection !&#x3D; this) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Messenger messenger &#x3D; new Messenger(service);</span><br><span class="line">                        Message msg &#x3D; Message.obtain(null, 1);</span><br><span class="line">                        final ServiceConnection myConn &#x3D; this;</span><br><span class="line">                        Handler h &#x3D; new Handler(mHandler.getLooper()) &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void handleMessage(Message msg) &#123;</span><br><span class="line">                                synchronized (mScreenshotLock) &#123;</span><br><span class="line">                                    if (mScreenshotConnection &#x3D;&#x3D; myConn) &#123;</span><br><span class="line">                                        mContext.unbindService(mScreenshotConnection);</span><br><span class="line">                                        mScreenshotConnection &#x3D; null;</span><br><span class="line">                                        mHandler.removeCallbacks(mScreenshotTimeout);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        msg.replyTo &#x3D; new Messenger(h);</span><br><span class="line">                        msg.arg1 &#x3D; msg.arg2 &#x3D; 0;</span><br><span class="line">                        if (mStatusBar !&#x3D; null &amp;&amp; mStatusBar.isVisibleLw())</span><br><span class="line">                            msg.arg1 &#x3D; 1;</span><br><span class="line">                        if (mNavigationBar !&#x3D; null &amp;&amp; mNavigationBar.isVisibleLw())</span><br><span class="line">                            msg.arg2 &#x3D; 1;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            messenger.send(msg);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void onServiceDisconnected(ComponentName name) &#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            if (mContext.bindServiceAsUser(</span><br><span class="line">                    intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) &#123;</span><br><span class="line">                mScreenshotConnection &#x3D; conn;</span><br><span class="line">                mHandler.postDelayed(mScreenshotTimeout, 10000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里通过反射机制创建了一个TakeScreenshotService对象然后调用了bindServiceAsUser，这样就创建了TakeScreenshotService服务并在服务创建之后发送了一个异步消息。好了，我们看一下TakeScreenshotService的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TakeScreenshotService extends Service &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;TakeScreenshotService&quot;;</span><br><span class="line"></span><br><span class="line">    private static GlobalScreenshot mScreenshot;</span><br><span class="line"></span><br><span class="line">    private Handler mHandler &#x3D; new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    final Messenger callback &#x3D; msg.replyTo;</span><br><span class="line">                    if (mScreenshot &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        mScreenshot &#x3D; new GlobalScreenshot(TakeScreenshotService.this);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mScreenshot.takeScreenshot(new Runnable() &#123;</span><br><span class="line">                        @Override public void run() &#123;</span><br><span class="line">                            Message reply &#x3D; Message.obtain(null, 1);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                callback.send(reply);</span><br><span class="line">                            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, msg.arg1 &gt; 0, msg.arg2 &gt; 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new Messenger(mHandler).getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在在TakeScreenshotService类的定义中有一个Handler成员变量，而我们在启动TakeScreentshowService的时候回发送一个异步消息，这样就会执行mHandler的handleMessage方法，然后在handleMessage方法中我们创建了一个GlobalScreenshow对象，然后执行了takeScreenshot方法，好吧，继续看一下takeScreentshot方法的执行逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Takes a screenshot of the current display and shows an animation.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to orient the screenshot correctly (and the Surface api seems to take screenshots</span><br><span class="line">        &#x2F;&#x2F; only in the natural orientation of the device :!)</span><br><span class="line">        mDisplay.getRealMetrics(mDisplayMetrics);</span><br><span class="line">        float[] dims &#x3D; &#123;mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels&#125;;</span><br><span class="line">        float degrees &#x3D; getDegreesForRotation(mDisplay.getRotation());</span><br><span class="line">        boolean requiresRotation &#x3D; (degrees &gt; 0);</span><br><span class="line">        if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Get the dimensions of the device in its native orientation</span><br><span class="line">            mDisplayMatrix.reset();</span><br><span class="line">            mDisplayMatrix.preRotate(-degrees);</span><br><span class="line">            mDisplayMatrix.mapPoints(dims);</span><br><span class="line">            dims[0] &#x3D; Math.abs(dims[0]);</span><br><span class="line">            dims[1] &#x3D; Math.abs(dims[1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Take the screenshot</span><br><span class="line">        mScreenBitmap &#x3D; SurfaceControl.screenshot((int) dims[0], (int) dims[1]);</span><br><span class="line">        if (mScreenBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">            notifyScreenshotError(mContext, mNotificationManager);</span><br><span class="line">            finisher.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rotate the screenshot to the current orientation</span><br><span class="line">            Bitmap ss &#x3D; Bitmap.createBitmap(mDisplayMetrics.widthPixels,</span><br><span class="line">                    mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">            Canvas c &#x3D; new Canvas(ss);</span><br><span class="line">            c.translate(ss.getWidth() &#x2F; 2, ss.getHeight() &#x2F; 2);</span><br><span class="line">            c.rotate(degrees);</span><br><span class="line">            c.translate(-dims[0] &#x2F; 2, -dims[1] &#x2F; 2);</span><br><span class="line">            c.drawBitmap(mScreenBitmap, 0, 0, null);</span><br><span class="line">            c.setBitmap(null);</span><br><span class="line">            &#x2F;&#x2F; Recycle the previous bitmap</span><br><span class="line">            mScreenBitmap.recycle();</span><br><span class="line">            mScreenBitmap &#x3D; ss;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Optimizations</span><br><span class="line">        mScreenBitmap.setHasAlpha(false);</span><br><span class="line">        mScreenBitmap.prepareToDraw();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Start the post-screenshot animation</span><br><span class="line">        startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里后两个参数：statusBarVisible，navBarVisible是否可见，而这两个参数在我们PhoneWindowManager.takeScreenshot方法传递的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (mStatusBar !&#x3D; null &amp;&amp; mStatusBar.isVisibleLw())</span><br><span class="line">                            msg.arg1 &#x3D; 1;</span><br><span class="line">                        if (mNavigationBar !&#x3D; null &amp;&amp; mNavigationBar.isVisibleLw())</span><br><span class="line">                            msg.arg2 &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>可见若果mStatusBar可见，则传递的statusBarVisible为true，若mNavigationBar可见，则传递的navBarVisible为true。然后我们在截屏的时候判断nStatusBar是否可见，mNavigationBar是否可见，若可见的时候则截屏同样将其截屏出来。继续回到我们的takeScreenshot方法，然后调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Take the screenshot</span><br><span class="line">mScreenBitmap &#x3D; SurfaceControl.screenshot((int) dims[0], (int) dims[1]);</span><br></pre></td></tr></table></figure>
<p>方法，看注释，这里就是执行截屏事件的具体操作了，然后我看一下SurfaceControl.screenshot方法的具体实现，另外这里需要注意的是，截屏之后返回的是一个Bitmap对象，其实熟悉android绘制机制的童鞋应该知道android中所有显示能够显示的东西，在内存中表现都是Bitmap对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap screenshot(int width, int height) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: should take the display as a parameter</span><br><span class="line">        IBinder displayToken &#x3D; SurfaceControl.getBuiltInDisplay(</span><br><span class="line">                SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN);</span><br><span class="line">        return nativeScreenshot(displayToken, new Rect(), width, height, 0, 0, true,</span><br><span class="line">                false, Surface.ROTATION_0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里调用的是nativeScreenshot方法，它是一个native方法，具体的实现在JNI层，这里就不做过多的介绍了。继续回到我们的takeScreenshot方法，在调用了截屏方法screentshot之后，判断是否截屏成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (mScreenBitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">            notifyScreenshotError(mContext, mNotificationManager);</span><br><span class="line">            finisher.run();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>若截屏之后，截屏的bitmap对象为空，这里判断截屏失败，调用了notifyScreenshotError方法，发送截屏失败的notification通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void notifyScreenshotError(Context context, NotificationManager nManager) &#123;</span><br><span class="line">        Resources r &#x3D; context.getResources();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Clear all existing notification, compose the new notification and show it</span><br><span class="line">        Notification.Builder b &#x3D; new Notification.Builder(context)</span><br><span class="line">            .setTicker(r.getString(R.string.screenshot_failed_title))</span><br><span class="line">            .setContentTitle(r.getString(R.string.screenshot_failed_title))</span><br><span class="line">            .setContentText(r.getString(R.string.screenshot_failed_text))</span><br><span class="line">            .setSmallIcon(R.drawable.stat_notify_image_error)</span><br><span class="line">            .setWhen(System.currentTimeMillis())</span><br><span class="line">            .setVisibility(Notification.VISIBILITY_PUBLIC) &#x2F;&#x2F; ok to show outside lockscreen</span><br><span class="line">            .setCategory(Notification.CATEGORY_ERROR)</span><br><span class="line">            .setAutoCancel(true)</span><br><span class="line">            .setColor(context.getColor(</span><br><span class="line">                        com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line">        Notification n &#x3D;</span><br><span class="line">            new Notification.BigTextStyle(b)</span><br><span class="line">                .bigText(r.getString(R.string.screenshot_failed_text))</span><br><span class="line">                .build();</span><br><span class="line">        nManager.notify(R.id.notification_screenshot, n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后继续看takeScreenshot方法，判断截屏的图像是否需要旋转，若需要的话，则旋转图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (requiresRotation) &#123;</span><br><span class="line">            &#x2F;&#x2F; Rotate the screenshot to the current orientation</span><br><span class="line">            Bitmap ss &#x3D; Bitmap.createBitmap(mDisplayMetrics.widthPixels,</span><br><span class="line">                    mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">            Canvas c &#x3D; new Canvas(ss);</span><br><span class="line">            c.translate(ss.getWidth() &#x2F; 2, ss.getHeight() &#x2F; 2);</span><br><span class="line">            c.rotate(degrees);</span><br><span class="line">            c.translate(-dims[0] &#x2F; 2, -dims[1] &#x2F; 2);</span><br><span class="line">            c.drawBitmap(mScreenBitmap, 0, 0, null);</span><br><span class="line">            c.setBitmap(null);</span><br><span class="line">            &#x2F;&#x2F; Recycle the previous bitmap</span><br><span class="line">            mScreenBitmap.recycle();</span><br><span class="line">            mScreenBitmap &#x3D; ss;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在takeScreenshot方法的最后若截屏成功，我们调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Start the post-screenshot animation</span><br><span class="line">        startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br></pre></td></tr></table></figure>
<p>开始截屏的动画，好吧，看一下动画效果的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Starts the animation after taking the screenshot</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible,</span><br><span class="line">            boolean navBarVisible) &#123;</span><br><span class="line">        &#x2F;&#x2F; Add the view for the animation</span><br><span class="line">        mScreenshotView.setImageBitmap(mScreenBitmap);</span><br><span class="line">        mScreenshotLayout.requestFocus();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Setup the animation with the screenshot just taken</span><br><span class="line">        if (mScreenshotAnimation !&#x3D; null) &#123;</span><br><span class="line">            mScreenshotAnimation.end();</span><br><span class="line">            mScreenshotAnimation.removeAllListeners();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams);</span><br><span class="line">        ValueAnimator screenshotDropInAnim &#x3D; createScreenshotDropInAnimation();</span><br><span class="line">        ValueAnimator screenshotFadeOutAnim &#x3D; createScreenshotDropOutAnimation(w, h,</span><br><span class="line">                statusBarVisible, navBarVisible);</span><br><span class="line">        mScreenshotAnimation &#x3D; new AnimatorSet();</span><br><span class="line">        mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim);</span><br><span class="line">        mScreenshotAnimation.addListener(new AnimatorListenerAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAnimationEnd(Animator animation) &#123;</span><br><span class="line">                &#x2F;&#x2F; Save the screenshot once we have a bit of time now</span><br><span class="line">                saveScreenshotInWorkerThread(finisher);</span><br><span class="line">                mWindowManager.removeView(mScreenshotLayout);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Clear any references to the bitmap</span><br><span class="line">                mScreenBitmap &#x3D; null;</span><br><span class="line">                mScreenshotView.setImageBitmap(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mScreenshotLayout.post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; Play the shutter sound to notify that we&#39;ve taken a screenshot</span><br><span class="line">                mCameraSound.play(MediaActionSound.SHUTTER_CLICK);</span><br><span class="line"></span><br><span class="line">                mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null);</span><br><span class="line">                mScreenshotView.buildLayer();</span><br><span class="line">                mScreenshotAnimation.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，经过着一些列的操作之后我们实现了截屏之后的动画效果了，这里暂时不分析动画效果，我们看一下动画效果之后做了哪些？还记不记的一般情况下我们截屏之后都会收到一个截屏的notification通知？这里应该也是在其AnimatorListenerAdapter的onAnimationEnd方法中实现的，也就是动画执行完成之后，我们看一下其saveScreenshotInWorkerThread方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Creates a new worker thread and saves the screenshot to the media store.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void saveScreenshotInWorkerThread(Runnable finisher) &#123;</span><br><span class="line">        SaveImageInBackgroundData data &#x3D; new SaveImageInBackgroundData();</span><br><span class="line">        data.context &#x3D; mContext;</span><br><span class="line">        data.image &#x3D; mScreenBitmap;</span><br><span class="line">        data.iconSize &#x3D; mNotificationIconSize;</span><br><span class="line">        data.finisher &#x3D; finisher;</span><br><span class="line">        data.previewWidth &#x3D; mPreviewWidth;</span><br><span class="line">        data.previewheight &#x3D; mPreviewHeight;</span><br><span class="line">        if (mSaveInBgTask !&#x3D; null) &#123;</span><br><span class="line">            mSaveInBgTask.cancel(false);</span><br><span class="line">        &#125;</span><br><span class="line">        mSaveInBgTask &#x3D; new SaveImageInBackgroundTask(mContext, data, mNotificationManager,</span><br><span class="line">                R.id.notification_screenshot).execute(data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，这里主要逻辑就是构造了一个SaveImageInBackgroundTask对象，看样子发送截屏成功的通知应该是在这里实现的，我们看一下SaveImageInBackgroundTask构造方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data,</span><br><span class="line">            NotificationManager nManager, int nId) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Show the intermediate notification</span><br><span class="line">        mTickerAddSpace &#x3D; !mTickerAddSpace;</span><br><span class="line">        mNotificationId &#x3D; nId;</span><br><span class="line">        mNotificationManager &#x3D; nManager;</span><br><span class="line">        final long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        mNotificationBuilder &#x3D; new Notification.Builder(context)</span><br><span class="line">            .setTicker(r.getString(R.string.screenshot_saving_ticker)</span><br><span class="line">                    + (mTickerAddSpace ? &quot; &quot; : &quot;&quot;))</span><br><span class="line">            .setContentTitle(r.getString(R.string.screenshot_saving_title))</span><br><span class="line">            .setContentText(r.getString(R.string.screenshot_saving_text))</span><br><span class="line">            .setSmallIcon(R.drawable.stat_notify_image)</span><br><span class="line">            .setWhen(now)</span><br><span class="line">            .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line"></span><br><span class="line">        mNotificationStyle &#x3D; new Notification.BigPictureStyle()</span><br><span class="line">            .bigPicture(picture.createAshmemBitmap());</span><br><span class="line">        mNotificationBuilder.setStyle(mNotificationStyle);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; For &quot;public&quot; situations we want to show all the same info but</span><br><span class="line">        &#x2F;&#x2F; omit the actual screenshot image.</span><br><span class="line">        mPublicNotificationBuilder &#x3D; new Notification.Builder(context)</span><br><span class="line">                .setContentTitle(r.getString(R.string.screenshot_saving_title))</span><br><span class="line">                .setContentText(r.getString(R.string.screenshot_saving_text))</span><br><span class="line">                .setSmallIcon(R.drawable.stat_notify_image)</span><br><span class="line">                .setCategory(Notification.CATEGORY_PROGRESS)</span><br><span class="line">                .setWhen(now)</span><br><span class="line">                .setColor(r.getColor(</span><br><span class="line">                        com.android.internal.R.color.system_notification_accent_color));</span><br><span class="line"></span><br><span class="line">        mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build());</span><br><span class="line"></span><br><span class="line">        Notification n &#x3D; mNotificationBuilder.build();</span><br><span class="line">        n.flags |&#x3D; Notification.FLAG_NO_CLEAR;</span><br><span class="line">        mNotificationManager.notify(nId, n);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; On the tablet, the large icon makes the notification appear as if it is clickable (and</span><br><span class="line">        &#x2F;&#x2F; on small devices, the large icon is not shown) so defer showing the large icon until</span><br><span class="line">        &#x2F;&#x2F; we compose the final post-save notification below.</span><br><span class="line">        mNotificationBuilder.setLargeIcon(icon.createAshmemBitmap());</span><br><span class="line">        &#x2F;&#x2F; But we still don&#39;t set it for the expanded view, allowing the smallIcon to show here.</span><br><span class="line">        mNotificationStyle.bigLargeIcon((Bitmap) null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在构造方法的后面狗仔了一个NotificationBuilder对象，然后发送了一个截屏成功的Notification，这样我们在截屏动画之后就收到了Notification的通知了。</p>
<p>总结：</p>
<ul>
<li><p>在PhoneWindowManager的dispatchUnhandledKey方法中处理App无法处理的按键事件，当然也包括音量减少键和电源按键的组合按键</p>
</li>
<li><p>通过一系列的调用启动TakeScreenshotService服务，并通过其执行截屏的操作。</p>
</li>
<li><p>具体的截屏代码是在native层实现的。</p>
</li>
<li><p>截屏操作时候，若截屏失败则直接发送截屏失败的notification通知。</p>
</li>
<li><p>截屏之后，若截屏成功，则先执行截屏的动画，并在动画效果执行完毕之后，发送截屏成功的notification的通知。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E7%B3%BB%E7%BB%9F%E5%B1%82/" rel="tag"># Android系统层</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/30/25%20onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" rel="prev" title="25 onLowMemory执行流程">
      <i class="fa fa-chevron-left"></i> 25 onLowMemory执行流程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/30/27%20HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/" rel="next" title="27 HOME事件流程">
      27 HOME事件流程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
