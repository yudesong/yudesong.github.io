<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="这篇文章是承接上一篇文章(Android布局加载流程：android源码解析（十七）–&gt;Activity布局加载流程)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Act">
<meta property="og:type" content="article">
<meta property="og:title" content="18 Activity布局绘制流程">
<meta property="og:url" content="http://yoursite.com/2020/05/30/18%20Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="这篇文章是承接上一篇文章(Android布局加载流程：android源码解析（十七）–&gt;Activity布局加载流程)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Act">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-29T16:29:04.561Z">
<meta property="article:modified_time" content="2020-05-31T03:01:46.329Z">
<meta property="article:author" content="yudesong">
<meta property="article:tag" content="Android系统层">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/05/30/18%20Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>18 Activity布局绘制流程 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/18%20Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          18 Activity布局绘制流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章是承接上一篇文章(Android布局加载流程：<a href="http://blog.csdn.net/qq_23547831/article/details/51284556" target="_blank" rel="noopener">android源码解析（十七）–&gt;Activity布局加载流程</a>)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Activity对象也就可以说是一个窗口对象，而Window只是控制着界面布局文件的加载过程，那么界面布局文件的绘制流程是如何的呢？这篇文章主要就是顺着上篇文章的思路，看一下在android系统中Activity的布局文件是如何绘制的。</p>
<p>顺便在这里多说几句，android中所有能显示的东西都是通过Window对象实现了，无论Activity，Dialog，PopupWindow，Toast等。后期我可能也会讲一下Dialog，PopupWindow，Toast等组件的显示过程。</p>
<p>前面有一篇文章中我们介绍过Activity的启动流程，可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">android源码解析之（十四）–&gt;Activity启动流程</a><br>在执行ActivityThread的handleLauncherActivity方法中通过Window对象控制了布局文件的加载流程，而Android体系在执行Activity的onResume方法之前会回调ActivityThread的handleResumeActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide, boolean isForward, boolean reallyResume) &#123;</span><br><span class="line">            ...</span><br><span class="line">            if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window &#x3D; r.activity.getWindow();</span><br><span class="line">                View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                a.mDecor &#x3D; decor;</span><br><span class="line">                l.type &#x3D; WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |&#x3D; forwardBit;</span><br><span class="line">                if (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded &#x3D; true;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the window has already been added, but during resume</span><br><span class="line">            &#x2F;&#x2F; we started another activity, then don&#39;t yet make the</span><br><span class="line">            &#x2F;&#x2F; window visible.</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; The window is now visible if it has been added, we are not</span><br><span class="line">            &#x2F;&#x2F; simply finishing, and we are not starting another activity.</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor !&#x3D; null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                if (r.newConfig !&#x3D; null) &#123;</span><br><span class="line">                    r.tmpConfig.setTo(r.newConfig);</span><br><span class="line">                    if (r.overrideConfig !&#x3D; null) &#123;</span><br><span class="line">                        r.tmpConfig.updateFrom(r.overrideConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                            + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);</span><br><span class="line">                    performConfigurationChanged(r.activity, r.tmpConfig);</span><br><span class="line">                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</span><br><span class="line">                    r.newConfig &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward&#x3D;&quot;</span><br><span class="line">                        + isForward);</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                if ((l.softInputMode</span><br><span class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                        !&#x3D; forwardBit) &#123;</span><br><span class="line">                    l.softInputMode &#x3D; (l.softInputMode</span><br><span class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                            | forwardBit;</span><br><span class="line">                    if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                        ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                        View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                        wm.updateViewLayout(decor, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mVisibleFromServer &#x3D; true;</span><br><span class="line">                mNumVisibleActivities++;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!r.onlyLocalRequest) &#123;</span><br><span class="line">                r.nextIdle &#x3D; mNewActivities;</span><br><span class="line">                mNewActivities &#x3D; r;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">                Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">            &#125;</span><br><span class="line">            r.onlyLocalRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have resumed.</span><br><span class="line">            if (reallyResume) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在在获取了Activity的Window相关参数之后执行了r.activity.makeVisible()方法，看样子这个就是Activity的显示方法，这里我们来具体看一下makeVisible方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void makeVisible() &#123;</span><br><span class="line">        if (!mWindowAdded) &#123;</span><br><span class="line">            ViewManager wm &#x3D; getWindowManager();</span><br><span class="line">            wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">            mWindowAdded &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断成员变量mWindowAdded是否为true，可以发现mWindowAdded成员变量只有在执行之后才能赋值为true，所以这里的代码的主要逻辑是该if分支只能执行一次。</p>
<p>这里的ViewManager对象是通过getWindowManager()方法获取的，我们来看一下getWindowManager()方法的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManager getWindowManager() &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，原来就是返回的Activity的mWindowManager的成员变量，那么这个mWindowManager的成员变量是什么时候赋值的呢？上一篇文章我们在Activity的attach方法方法中初始化了Activity的相关成员变量，这里也包括了mWindowManager，我们来看一下mWindowManager的赋值过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindowManager &#x3D; mWindow.getWindowManager();</span><br></pre></td></tr></table></figure>
<p>好吧，这里的Window.getWindowManager()方法是具体如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManager getWindowManager() &#123;</span><br><span class="line">        return mWindowManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么这里的Window对象的mWindowManager成员变量是具体如何赋值的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void setWindowManager(WindowManager wm, IBinder appToken, String appName,</span><br><span class="line">            boolean hardwareAccelerated) &#123;</span><br><span class="line">        mAppToken &#x3D; appToken;</span><br><span class="line">        mAppName &#x3D; appName;</span><br><span class="line">        mHardwareAccelerated &#x3D; hardwareAccelerated</span><br><span class="line">                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);</span><br><span class="line">        if (wm &#x3D;&#x3D; null) &#123;</span><br><span class="line">            wm &#x3D; (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager &#x3D; ((WindowManagerImpl)wm).createLocalWindowManager(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，可以发现mWindowManager = ((WindowManagerImpl)vm).createLocalWindowManager(this)原来是在这里赋值的，所以一个Activity对应这一个新的Window，而这个Window对象内部会对应着一个新的WindowManager对象，我们接着往下看，那么createLoclWindowManager方法是如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123;</span><br><span class="line">        return new WindowManagerImpl(mDisplay, parentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，原来是new出了一个WindowManagerImpl对象，所以回到我们的Activity的makeVisible方法，ViewManager获取的是一个WindowManagerImpl对象，所以Window对象内部的WindowManager对象其实都是一个WindowManagerImpl的实例，都是而且从继承关系上可以看到：</p>
<p>WindowManagerImpl –&gt; WindowManager –&gt; ViewManager;</p>
<p>继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wm.addView(mDecor, getWindow().getAttributes());</span><br></pre></td></tr></table></figure>
<p>这里的mDector成员变量，通过上一篇文章的介绍，我们知道，它是Activity的界面根View，而getWindow.getAttrbutes方法是windowManager中定义的Params内部类，该内部类定义了许多的Window类型，由于这里的vm是WindowManagerImpl的实例，我们来看一下这里的addView的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们具体看一下mGlobal.addView方法，这里的mGlobal是一个WindowManagerGlobal的单例对象，WindowManagerGlobal是Window处理的工具类，那么WindowManagerGlobal的addView具体是如何实现的呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">            Display display, Window parentWindow) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        View panelParentView &#x3D; null;</span><br><span class="line"></span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            &#x2F;&#x2F; Start watching for system property changes.</span><br><span class="line">            if (mSystemPropertyUpdater &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mSystemPropertyUpdater &#x3D; new Runnable() &#123;</span><br><span class="line">                    @Override public void run() &#123;</span><br><span class="line">                        synchronized (mLock) &#123;</span><br><span class="line">                            for (int i &#x3D; mRoots.size() - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">                                mRoots.get(i).loadSystemProperties();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int index &#x3D; findViewLocked(view, false);</span><br><span class="line">            if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                if (mDyingViews.contains(view)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue.</span><br><span class="line">                    mRoots.get(index).doDie();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;View &quot; + view</span><br><span class="line">                            + &quot; has already been added to the window manager.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; The previous removeView() had not completed executing. Now it has.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If this is a panel window, then find the window it is being</span><br><span class="line">            &#x2F;&#x2F; attached to for future reference.</span><br><span class="line">            if (wparams.type &gt;&#x3D; WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                    wparams.type &lt;&#x3D; WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">                final int count &#x3D; mViews.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">                    if (mRoots.get(i).mWindow.asBinder() &#x3D;&#x3D; wparams.token) &#123;</span><br><span class="line">                        panelParentView &#x3D; mViews.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root &#x3D; new ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; do this last because it fires off messages to start doing things</span><br><span class="line">        try &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">            synchronized (mLock) &#123;</span><br><span class="line">                final int index &#x3D; findViewLocked(view, false);</span><br><span class="line">                if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">                    removeViewLocked(index, true);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在WindowManagerGlobal中存在着三个数据列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;View&gt; mViews &#x3D; new ArrayList&lt;View&gt;();</span><br><span class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots &#x3D; new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line">private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams &#x3D;</span><br><span class="line">            new ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br></pre></td></tr></table></figure>
<p>其中mViews主要用于保存Activity的mDector也就是Activity的根View，而mRoots主要用于保存ViewRootImpl，mParams主要用于保存Window的LayoutParams，WindowManagerGlobal主要作为WindowManagerImpl的辅助方法类，用于操作View组件。</p>
<p>最后我们调用了root.setView方法，这个方法很重要我们就是在这里实现了我们的root与ViewRootImpl的关联的，除了实现了mDector与ViewRootImpl的相互关联，我们还调用了requestLayout方法，这里我们看一下setView方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        ...</span><br><span class="line">        requestLayout();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在方法体中又调用了requestLayout方法，这个方法其实就是调用执行重绘的请求，我们来看一下这个requestLayout方法具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void requestLayout() &#123;</span><br><span class="line">        if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested &#x3D; true;</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里有一个checkThread方法，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">        if (mThread !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new CalledFromWrongThreadException(</span><br><span class="line">                    &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相信大家平时在编程的过程中肯定会遇到过这个错误，ViewRootImpl是具体更新View的管理类，所有关于View的更新操作都是在这里执行的，自然而然的对于更新线程的检测是在这个类中添加的，一般在更新UI的时候都会调用这个方法用于检测当前执行更新UI的线程是否是UI线程，否则就会抛出这个异常。</p>
<p>继续回到我们的requestLayout方法，这里又调用了scheduleTraversales方法，我们来看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">        if (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; true;</span><br><span class="line">            mTraversalBarrier &#x3D; mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">            if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里mChoreographer.postCallback，内部会调用一个异步消息，用于执行mTraversalRunnable的run方法，这个mTraversalRunnable是一个Runnable对象，我们来看一下mTraversalRunnable类的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在TraversalRunnable类的run方法中调用了doTraversal方法，我们来看一下这个方法的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void doTraversal() &#123;</span><br><span class="line">        if (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; false;</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            if (mProfile) &#123;</span><br><span class="line">                Debug.startMethodTracing(&quot;ViewAncestor&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            performTraversals();</span><br><span class="line"></span><br><span class="line">            if (mProfile) &#123;</span><br><span class="line">                Debug.stopMethodTracing();</span><br><span class="line">                mProfile &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，其内部又回调了方法performTraversals方法，这个方法就是整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作之后就可以展示在界面中了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 执行View组件的onMeasure方法，主要用于测量View</span><br><span class="line">            if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">                boolean focusChangedDueToTouchMode &#x3D; ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) !&#x3D; 0);</span><br><span class="line">                if (focusChangedDueToTouchMode || mWidth !&#x3D; host.getMeasuredWidth()</span><br><span class="line">                        || mHeight !&#x3D; host.getMeasuredHeight() || contentInsetsChanged) &#123;</span><br><span class="line">                    int childWidthMeasureSpec &#x3D; getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    int childHeightMeasureSpec &#x3D; getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed!  mWidth&#x3D;&quot;</span><br><span class="line">                            + mWidth + &quot; measuredWidth&#x3D;&quot; + host.getMeasuredWidth()</span><br><span class="line">                            + &quot; mHeight&#x3D;&quot; + mHeight</span><br><span class="line">                            + &quot; measuredHeight&#x3D;&quot; + host.getMeasuredHeight()</span><br><span class="line">                            + &quot; coveredInsetsChanged&#x3D;&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                     &#x2F;&#x2F; Ask host how big it wants to be</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Implementation of weights from WindowManager.LayoutParams</span><br><span class="line">                    &#x2F;&#x2F; We just grow the dimensions as needed and re-measure if</span><br><span class="line">                    &#x2F;&#x2F; needs be</span><br><span class="line">                    int width &#x3D; host.getMeasuredWidth();</span><br><span class="line">                    int height &#x3D; host.getMeasuredHeight();</span><br><span class="line">                    boolean measureAgain &#x3D; false;</span><br><span class="line"></span><br><span class="line">                    if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        width +&#x3D; (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                        childWidthMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        height +&#x3D; (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                        childHeightMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (measureAgain) &#123;</span><br><span class="line">                        if (DEBUG_LAYOUT) Log.v(TAG,</span><br><span class="line">                                &quot;And hey let&#39;s measure once more: width&#x3D;&quot; + width</span><br><span class="line">                                + &quot; height&#x3D;&quot; + height);</span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">		&#x2F;&#x2F; 主要用于测量View组件的位置</span><br><span class="line">		...</span><br><span class="line">        final boolean didLayout &#x3D; layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener &#x3D; didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">            performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; By this point all views have been sized and positioned</span><br><span class="line">            &#x2F;&#x2F; We can compute the transparent area</span><br><span class="line"></span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; start out transparent</span><br><span class="line">                &#x2F;&#x2F; TODO: AVOID THAT CALL BY CACHING THE RESULT?</span><br><span class="line">                host.getLocationInWindow(mTmpLocation);</span><br><span class="line">                mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                        mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                        mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">                host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">                if (mTranslator !&#x3D; null) &#123;</span><br><span class="line">                    mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                    mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                    mFullRedrawNeeded &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F; reconfigure window manager</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DBG) &#123;</span><br><span class="line">                System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">                System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">                host.debug();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 主要用于View的绘制过程</span><br><span class="line">        ...</span><br><span class="line">        if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            if (!skipDraw || mReportNextDraw) &#123;</span><br><span class="line">                if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                        mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingTransitions.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                performDraw();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (viewVisibility &#x3D;&#x3D; View.VISIBLE) &#123;</span><br><span class="line">                &#x2F;&#x2F; Try again</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">            &#125; else if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsInTraversal &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法performTraversals方法，我们调用了performMeasure，performLayout，performDraw三个方法，这几个方法主要用于测量View组件的大小，测量View组件的位置，绘制View组件；</p>
<p>即：测量大小 –&gt; 测量位置 –&gt; 绘制组件</p>
<p>好吧，这里我们调用了performMeasure方法，我们先看一下performMeasure方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在performMeasure方法中我们又调用了mView的measure方法，这里的mView就是我们一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        ...</span><br><span class="line">        onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在View的measure方法中，又调用了onMeasure方法，由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">        final boolean measureMatchParentChildren &#x3D;</span><br><span class="line">                MeasureSpec.getMode(widthMeasureSpec) !&#x3D; MeasureSpec.EXACTLY ||</span><br><span class="line">                MeasureSpec.getMode(heightMeasureSpec) !&#x3D; MeasureSpec.EXACTLY;</span><br><span class="line">        mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">        int maxHeight &#x3D; 0;</span><br><span class="line">        int maxWidth &#x3D; 0;</span><br><span class="line">        int childState &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child &#x3D; getChildAt(i);</span><br><span class="line">            if (mMeasureAllChildren || child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">                final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line">                maxWidth &#x3D; Math.max(maxWidth,</span><br><span class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">                maxHeight &#x3D; Math.max(maxHeight,</span><br><span class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                childState &#x3D; combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">                if (measureMatchParentChildren) &#123;</span><br><span class="line">                    if (lp.width &#x3D;&#x3D; LayoutParams.MATCH_PARENT ||</span><br><span class="line">                            lp.height &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                        mMatchParentChildren.add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Account for padding too</span><br><span class="line">        maxWidth +&#x3D; getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">        maxHeight +&#x3D; getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check against our minimum height and width</span><br><span class="line">        maxHeight &#x3D; Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">        maxWidth &#x3D; Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check against our foreground&#39;s minimum height and width</span><br><span class="line">        final Drawable drawable &#x3D; getForeground();</span><br><span class="line">        if (drawable !&#x3D; null) &#123;</span><br><span class="line">            maxHeight &#x3D; Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">            maxWidth &#x3D; Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">        count &#x3D; mMatchParentChildren.size();</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">                final View child &#x3D; mMatchParentChildren.get(i);</span><br><span class="line">                final MarginLayoutParams lp &#x3D; (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                final int childWidthMeasureSpec;</span><br><span class="line">                if (lp.width &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    final int width &#x3D; Math.max(0, getMeasuredWidth()</span><br><span class="line">                            - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                            - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                    childWidthMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            width, MeasureSpec.EXACTLY);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    childWidthMeasureSpec &#x3D; getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                            getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                            lp.leftMargin + lp.rightMargin,</span><br><span class="line">                            lp.width);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int childHeightMeasureSpec;</span><br><span class="line">                if (lp.height &#x3D;&#x3D; LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    final int height &#x3D; Math.max(0, getMeasuredHeight()</span><br><span class="line">                            - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                            - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                    childHeightMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(</span><br><span class="line">                            height, MeasureSpec.EXACTLY);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    childHeightMeasureSpec &#x3D; getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                            getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                            lp.topMargin + lp.bottomMargin,</span><br><span class="line">                            lp.height);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法，这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法，我们来看一下View的onMeasure方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法中调用了setMeasuredDimension方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        boolean optical &#x3D; isLayoutModeOptical(this);</span><br><span class="line">        if (optical !&#x3D; isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            Insets insets &#x3D; getOpticalInsets();</span><br><span class="line">            int opticalWidth  &#x3D; insets.left + insets.right;</span><br><span class="line">            int opticalHeight &#x3D; insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">            measuredWidth  +&#x3D; optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">            measuredHeight +&#x3D; optical ? opticalHeight : -opticalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，方法体里面又调用了setMeasuredDimensionRaw方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">        mMeasuredWidth &#x3D; measuredWidth;</span><br><span class="line">        mMeasuredHeight &#x3D; measuredHeight;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |&#x3D; PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中。</p>
<p>继续回到我们的performTransles方法，然后我们继续看performLayout方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">            int desiredWindowHeight) &#123;</span><br><span class="line">        mLayoutRequested &#x3D; false;</span><br><span class="line">        mScrollMayChange &#x3D; true;</span><br><span class="line">        mInLayout &#x3D; true;</span><br><span class="line"></span><br><span class="line">        final View host &#x3D; mView;</span><br><span class="line">        if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">            Log.v(TAG, &quot;Laying out &quot; + host + &quot; to (&quot; +</span><br><span class="line">                    host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">            mInLayout &#x3D; false;</span><br><span class="line">            int numViewsRequestingLayout &#x3D; mLayoutRequesters.size();</span><br><span class="line">            if (numViewsRequestingLayout &gt; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; requestLayout() was called during layout.</span><br><span class="line">                &#x2F;&#x2F; If no layout-request flags are set on the requesting views, there is no problem.</span><br><span class="line">                &#x2F;&#x2F; If some requests are still pending, then we need to clear those flags and do</span><br><span class="line">                &#x2F;&#x2F; a full request&#x2F;measure&#x2F;layout pass to handle this situation.</span><br><span class="line">                ArrayList&lt;View&gt; validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                        false);</span><br><span class="line">                if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Set this flag to indicate that any further requests are happening during</span><br><span class="line">                    &#x2F;&#x2F; the second pass, which may result in posting those requests to the next</span><br><span class="line">                    &#x2F;&#x2F; frame instead</span><br><span class="line">                    mHandlingLayoutInLayoutRequest &#x3D; true;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Process fresh layout requests, then measure and layout</span><br><span class="line">                    int numValidRequests &#x3D; validLayoutRequesters.size();</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                        final View view &#x3D; validLayoutRequesters.get(i);</span><br><span class="line">                        Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                                &quot; during layout: running second layout pass&quot;);</span><br><span class="line">                        view.requestLayout();</span><br><span class="line">                    &#125;</span><br><span class="line">                    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                    mInLayout &#x3D; true;</span><br><span class="line">                    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                    mHandlingLayoutInLayoutRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Check the valid requests again, this time without checking&#x2F;clearing the</span><br><span class="line">                    &#x2F;&#x2F; layout flags, since requests happening during the second pass get noop&#39;d</span><br><span class="line">                    validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters, true);</span><br><span class="line">                    if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                        final ArrayList&lt;View&gt; finalRequesters &#x3D; validLayoutRequesters;</span><br><span class="line">                        &#x2F;&#x2F; Post second-pass requests to the next frame</span><br><span class="line">                        getRunQueue().post(new Runnable() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void run() &#123;</span><br><span class="line">                                int numValidRequests &#x3D; finalRequesters.size();</span><br><span class="line">                                for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                    final View view &#x3D; finalRequesters.get(i);</span><br><span class="line">                                    Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                                            &quot; during second layout pass: posting in next frame&quot;);</span><br><span class="line">                                    view.requestLayout();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        mInLayout &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在方法体中，我们看到该方法执行了layout方法，我们看一下该layout方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL &#x3D; mLeft;</span><br><span class="line">        int oldT &#x3D; mTop;</span><br><span class="line">        int oldB &#x3D; mBottom;</span><br><span class="line">        int oldR &#x3D; mRight;</span><br><span class="line"></span><br><span class="line">        boolean changed &#x3D; isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">            if (li !&#x3D; null &amp;&amp; li.mOnLayoutChangeListeners !&#x3D; null) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy &#x3D;</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners &#x3D; listenersCopy.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |&#x3D; PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法体中执行了onLayout方法，这个方法就是具体执行测量位置的方法了，由于我们的mDector是一个FrameLayout，所以跟measure类似的，我们看一下FrameLayout的onLayout方法的实现：</p>
<p>我们看到我们定义了一个循环逻辑，获取所有的validLayoutRequesters也就是需要执行Layout方法的View的集合，通过循环执行view的requestLayout方法。这里我们来看一下requestLayout方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">        layoutChildren(left, top, right, bottom, false &#x2F;* no force left gravity *&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了layoutChildren方法，让我们来看一下layoutChildren方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void layoutChildren(int left, int top, int right, int bottom,</span><br><span class="line">                                  boolean forceLeftGravity) &#123;</span><br><span class="line">        final int count &#x3D; getChildCount();</span><br><span class="line"></span><br><span class="line">        final int parentLeft &#x3D; getPaddingLeftWithForeground();</span><br><span class="line">        final int parentRight &#x3D; right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">        final int parentTop &#x3D; getPaddingTopWithForeground();</span><br><span class="line">        final int parentBottom &#x3D; bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child &#x3D; getChildAt(i);</span><br><span class="line">            if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">                final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">                final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                int childLeft;</span><br><span class="line">                int childTop;</span><br><span class="line"></span><br><span class="line">                int gravity &#x3D; lp.gravity;</span><br><span class="line">                if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                    gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">                final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                        lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.RIGHT:</span><br><span class="line">                        if (!forceLeftGravity) &#123;</span><br><span class="line">                            childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    case Gravity.LEFT:</span><br><span class="line">                    default:</span><br><span class="line">                        childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                switch (verticalGravity) &#123;</span><br><span class="line">                    case Gravity.TOP:</span><br><span class="line">                        childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.CENTER_VERTICAL:</span><br><span class="line">                        childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    case Gravity.BOTTOM:</span><br><span class="line">                        childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跟measure类似的，这里也是遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法，好吧，我们看一下View的layout的具体实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) !&#x3D; 0) &#123;</span><br><span class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;&#x3D; ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int oldL &#x3D; mLeft;</span><br><span class="line">        int oldT &#x3D; mTop;</span><br><span class="line">        int oldB &#x3D; mBottom;</span><br><span class="line">        int oldR &#x3D; mRight;</span><br><span class="line"></span><br><span class="line">        boolean changed &#x3D; isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) &#x3D;&#x3D; PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">            onLayout(changed, l, t, r, b);</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">            ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">            if (li !&#x3D; null &amp;&amp; li.mOnLayoutChangeListeners !&#x3D; null) &#123;</span><br><span class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy &#x3D;</span><br><span class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">                int numListeners &#x3D; listenersCopy.size();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                    listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;&#x3D; ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">        mPrivateFlags3 |&#x3D; PFLAG3_IS_LAID_OUT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中。</p>
<p>好吧，经过了测量大小与测量位置的逻辑之后，我们最后看一下performTraversals方法中的performDraw方法，这个方法的作用就是执行View组件的绘制逻辑了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void performDraw() &#123;</span><br><span class="line">        ...</span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了ViewRootImpl的draw方法，然后我们看一下draw方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">			...</span><br><span class="line">            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">               return;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里又调用了drawSoftware方法，看名字这里应该就是调用执行绘制的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">            boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        ...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了mView的draw方法，这里的mView是我们的mDector，好吧，看一下draw方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">        final int privateFlags &#x3D; mPrivateFlags;</span><br><span class="line">        final boolean dirtyOpaque &#x3D; (privateFlags &amp; PFLAG_DIRTY_MASK) &#x3D;&#x3D; PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo &#x3D;&#x3D; null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        mPrivateFlags &#x3D; (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">         * in the appropriate order:</span><br><span class="line">         *</span><br><span class="line">         *      1. Draw the background</span><br><span class="line">         *      2. If necessary, save the canvas&#39; layers to prepare for fading</span><br><span class="line">         *      3. Draw view&#39;s content</span><br><span class="line">         *      4. Draw children</span><br><span class="line">         *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">         *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 1, draw the background, if needed</span><br><span class="line">        int saveCount;</span><br><span class="line"></span><br><span class="line">        if (!dirtyOpaque) &#123;</span><br><span class="line">            drawBackground(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; skip step 2 &amp; 5 if possible (common case)</span><br><span class="line">        final int viewFlags &#x3D; mViewFlags;</span><br><span class="line">        boolean horizontalEdges &#x3D; (viewFlags &amp; FADING_EDGE_HORIZONTAL) !&#x3D; 0;</span><br><span class="line">        boolean verticalEdges &#x3D; (viewFlags &amp; FADING_EDGE_VERTICAL) !&#x3D; 0;</span><br><span class="line">        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            &#x2F;&#x2F; Step 3, draw the content</span><br><span class="line">            if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Step 4, draw the children</span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Overlay is part of the content and draws beneath Foreground</span><br><span class="line">            if (mOverlay !&#x3D; null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">            onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; we&#39;re done...</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Here we do the full fledged routine...</span><br><span class="line">         * (this is an uncommon case where speed matters less,</span><br><span class="line">         * this is why we repeat some of the tests that have been</span><br><span class="line">         * done above)</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        boolean drawTop &#x3D; false;</span><br><span class="line">        boolean drawBottom &#x3D; false;</span><br><span class="line">        boolean drawLeft &#x3D; false;</span><br><span class="line">        boolean drawRight &#x3D; false;</span><br><span class="line"></span><br><span class="line">        float topFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float bottomFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float leftFadeStrength &#x3D; 0.0f;</span><br><span class="line">        float rightFadeStrength &#x3D; 0.0f;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 2, save the canvas&#39; layers</span><br><span class="line">        int paddingLeft &#x3D; mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        final boolean offsetRequired &#x3D; isPaddingOffsetRequired();</span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            paddingLeft +&#x3D; getLeftPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left &#x3D; mScrollX + paddingLeft;</span><br><span class="line">        int right &#x3D; left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">        int top &#x3D; mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">        int bottom &#x3D; top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">        if (offsetRequired) &#123;</span><br><span class="line">            right +&#x3D; getRightPaddingOffset();</span><br><span class="line">            bottom +&#x3D; getBottomPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ScrollabilityCache scrollabilityCache &#x3D; mScrollCache;</span><br><span class="line">        final float fadeHeight &#x3D; scrollabilityCache.fadingEdgeLength;</span><br><span class="line">        int length &#x3D; (int) fadeHeight;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; clip the fade length if top and bottom fades overlap</span><br><span class="line">        &#x2F;&#x2F; overlapping fades produce odd-looking artifacts</span><br><span class="line">        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">            length &#x3D; (bottom - top) &#x2F; 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; also clip horizontal fades if necessary</span><br><span class="line">        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">            length &#x3D; (right - left) &#x2F; 2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (verticalEdges) &#123;</span><br><span class="line">            topFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</span><br><span class="line">            drawTop &#x3D; topFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            bottomFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</span><br><span class="line">            drawBottom &#x3D; bottomFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (horizontalEdges) &#123;</span><br><span class="line">            leftFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</span><br><span class="line">            drawLeft &#x3D; leftFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">            rightFadeStrength &#x3D; Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</span><br><span class="line">            drawRight &#x3D; rightFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        saveCount &#x3D; canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">        int solidColor &#x3D; getSolidColor();</span><br><span class="line">        if (solidColor &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            final int flags &#x3D; Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">            if (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawBottom) &#123;</span><br><span class="line">                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawLeft) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, left + length, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (drawRight) &#123;</span><br><span class="line">                canvas.saveLayer(right - length, top, right, bottom, null, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 3, draw the content</span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 5, draw the fade effect and restore layers</span><br><span class="line">        final Paint p &#x3D; scrollabilityCache.paint;</span><br><span class="line">        final Matrix matrix &#x3D; scrollabilityCache.matrix;</span><br><span class="line">        final Shader fade &#x3D; scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">        if (drawTop) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * topFadeStrength);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawBottom) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * bottomFadeStrength);</span><br><span class="line">            matrix.postRotate(180);</span><br><span class="line">            matrix.postTranslate(left, bottom);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawLeft) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * leftFadeStrength);</span><br><span class="line">            matrix.postRotate(-90);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawRight) &#123;</span><br><span class="line">            matrix.setScale(1, fadeHeight * rightFadeStrength);</span><br><span class="line">            matrix.postRotate(90);</span><br><span class="line">            matrix.postTranslate(right, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            p.setShader(fade);</span><br><span class="line">            canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Overlay is part of the content and draws beneath Foreground</span><br><span class="line">        if (mOverlay !&#x3D; null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整个View的绘制流程还是比较清楚的，整个执行逻辑还有相应的注释，一共大概需要六步，并且在执行draw方法的过程中，如果包含子View，那么也会执行子View的draw方法，好吧，经过这样一系列的执行逻辑之后，mDector以及子View就被绘制出来了。</p>
<p>总结：</p>
<ul>
<li><p>Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。</p>
</li>
<li><p>View的绘制流程包含了测量大小，测量位置，绘制三个流程；</p>
</li>
<li><p>Activty的界面绘制是从mDector即根View开始的，也就是从mDector的测量大小，测量位置，绘制三个流程；</p>
</li>
<li><p>View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的；</p>
</li>
<li><p>View的测量大小流程:performMeasure –&gt; measure –&gt; onMeasure等方法;</p>
</li>
<li><p>View的测量位置流程：performLayout –&gt; layout –&gt; onLayout等方法；</p>
</li>
<li><p>View的绘制流程：onDraw等方法；</p>
</li>
<li><p>View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑；</p>
</li>
<li><p>Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）；</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E7%B3%BB%E7%BB%9F%E5%B1%82/" rel="tag"># Android系统层</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/30/17%20Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/" rel="prev" title="17 Activity布局加载流程">
      <i class="fa fa-chevron-left"></i> 17 Activity布局加载流程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/30/19%20Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" rel="next" title="19 Dialog加载绘制流程">
      19 Dialog加载绘制流程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
