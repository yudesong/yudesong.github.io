<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等， 首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍：  An activity represents a single scree">
<meta property="og:type" content="article">
<meta property="og:title" content="14 activity启动流程">
<meta property="og:url" content="http://yoursite.com/2020/05/30/14%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等， 首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍：  An activity represents a single scree">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.blog.csdn.net/20160423105932970">
<meta property="article:published_time" content="2020-05-29T16:29:04.461Z">
<meta property="article:modified_time" content="2020-05-31T02:05:14.547Z">
<meta property="article:author" content="yudesong">
<meta property="article:tag" content="Android系统层">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.blog.csdn.net/20160423105932970">

<link rel="canonical" href="http://yoursite.com/2020/05/30/14%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>14 activity启动流程 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/14%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          14 activity启动流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:04" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:04+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等，</p>
<p>首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍：</p>
<blockquote>
<p>An activity represents a single screen with a user interface. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. Although the activities work together to form a cohesive user experience in the email application, each one is independent of the others. As such, a different application can start any one of these activities (if the email application allows it). For example, a camera application can start the activity in the email application that composes new mail, in order for the user to share a picture.</p>
</blockquote>
<p>英文不太好，这里就不献丑了，这里介绍的Activity的大概意思就是说，activity在Android系统中代表的就是一个屏幕，一个App就是由许多个不同的Acitivty组成的，并且不同进程之间的Activity是可以相互调用的。</p>
<p>在介绍Activity的启动流程之前，我们先介绍几个概念：</p>
<ul>
<li>Activity的生命周期</li>
</ul>
<blockquote>
<p>protected void onCreate(Bundle savedInstanceState);<br>protected void onRestart();<br>protected void onStart();<br>protected void onResume();<br>protected void onPause();<br>protected void onStop();<br>protected void onDestory();<br>以上为Activity生命周期中的各个时期的回调方法，在不同的方法中我们可以执行不同的逻辑。<br>关于Activity生命周期的详细介绍可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/41693807" target="_blank" rel="noopener"> Android activity的生命周期</a></p>
</blockquote>
<ul>
<li>Activity的启动模式</li>
</ul>
<blockquote>
<p>activity启动时可以设置不同的启动模式，主要是：standrand，singleTop，singleTask，instance等四种启动模式，不同的启动模式在启动Activity时会执行不同的逻辑，系统会按不同的启动模式将Activity存放到不同的activity栈中。<br>关于Activity启动模式的详细介绍，可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/46534693" target="_blank" rel="noopener"> Android任务和返回栈完全解析</a></p>
</blockquote>
<ul>
<li>Activity的启动进程</li>
</ul>
<blockquote>
<p>在Manifest.xml中定义Activity的时候，Activity默认是属于进程名称为包名的进程的，当然这时候是可以指定Activity的启动进程，所以在Activity启动时首先会检测当前Activity所属的进程是否已经启动，若进程没有启动，则首先会启动该进程，并在该进程启动之后才会执行Activity的启动过程。</p>
</blockquote>
<ul>
<li><p>Intent启动Activity的方式</p>
<blockquote>
<p>Intent启动Activity分为两种，显示启动和隐士启动，显示启动就是在初始化Intent对象的时候直接引用需要启动的Activity的字节码，显示引用的好处就是可以直接告诉Intent对象启动的Activity对象不需要执行intent filter索引需要启动哪一个Activity，但是显示引用不能启动其他进程的Activity对象，因为无法获取其他进程的Activity对象的字节码，而隐式启动则可以通过配置Intent Filter启动其他进程的Activity对象，因此在应用内，我们一般都是使用显示启动的方式启动Activity，而如果需要启动其他应用的Activity时，一般使用隐式启动的方式。</p>
</blockquote>
</li>
<li><p>Android Framework层的CS模式<br>通过前几篇文章的介绍我们知道android系统在启动过程中会执行这样的逻辑：</p>
<pre><code>Zygote进程 --&gt; SystemServer进程 --&gt; 各种系统服务 --&gt; 应用进程</code></pre><p>在Actvity启动过程中，其实是应用进程与SystemServer进程相互配合启动Activity的过程，其中应用进程主要用于执行具体的Activity的启动过程，回调生命周期方法等操作，而SystemServer进程则主要是调用其中的各种服务，将Activity保存在栈中，协调各种系统资源等操作。</p>
</li>
<li><p>Android系统进程间通讯Binder机制<br>Android系统存了Zygote进程和SystemServer进程以及各种应用进程等，为了能够实现各种进程之间的通讯，Android系统采用了自己的进程间通讯方式Binder机制。其中主要涉及到了四种角色：Binder Client，Binder Server，Binder Manager， Binder driver。各种角色之间的关系可以参考下面这张图的介绍：<br><img src="http://img.blog.csdn.net/20160423105932970" alt="这里写图片描述"></p>
</li>
</ul>
<p>好吧，前面我们介绍了一些Activity启动过程中需要的相关知识点，下面我们开始Activity启动流程的讲解。。。。</p>
<p>还记得前面我们讲过的Launcher启动流程么？可以参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51112031" target="_blank" rel="noopener">android源码解析之（十）–&gt;Launcher启动流程</a><br>在这篇文章中我们说Launcher启动之后会将各个应用包名和icon与app name保存起来，然后执行icon的点击事件的时候调用startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">        Intent intent &#x3D; intentForPosition(position);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected Intent intentForPosition(int position) &#123;</span><br><span class="line">        ActivityAdapter adapter &#x3D; (ActivityAdapter) mAdapter;</span><br><span class="line">        return adapter.intentForPosition(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public Intent intentForPosition(int position) &#123;</span><br><span class="line">            if (mActivitiesList &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Intent intent &#x3D; new Intent(mIntent);</span><br><span class="line">            ListItem item &#x3D; mActivitiesList.get(position);</span><br><span class="line">            intent.setClassName(item.packageName, item.className);</span><br><span class="line">            if (item.extras !&#x3D; null) &#123;</span><br><span class="line">                intent.putExtras(item.extras);</span><br><span class="line">            &#125;</span><br><span class="line">            return intent;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，我们在启动Activity的时候，执行的逻辑就是创建一个Intent对象，然后初始化Intent对象，使用隐式启动的方式启动该Acvitity，这里为什么不能使用显示启动的方式呢？</p>
<p>这是因为Launcher程序启动的Activity一般都是启动一个新的应用进程，该进程与Launcher进程不是在同一个进程中，所以也就无法引用到启动的Activity字节码，自然也就无法启动该Activity了。</p>
<p>继续，我们查看startActivity方法的具体实现：</p>
<p></br><strong><font size="6" >一:开始请求执行启动Activity</font><strong></p>
<blockquote>
<font color="red">
MyActivity.startActivity()
Activity.startActivity()
Activity.startActivityForResult
Instrumentation.execStartActivty
ActivityManagerNative.getDefault().startActivityAsUser()
</font>
</blockquote>
<p>在我们的Activity中调用startActivity方法，会执行Activity中的startActivity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        this.startActivity(intent, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在Activity中的startActivity方法体里调用了startActivity的重载方法，这里我们看一下其重载方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void startActivity(Intent intent, @Nullable Bundle options) &#123;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            startActivityForResult(intent, -1, options);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Note we want to go through this call for compatibility with</span><br><span class="line">            &#x2F;&#x2F; applications that may have overridden the method.</span><br><span class="line">            startActivityForResult(intent, -1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于在上一步骤中我们传递的Bunde对象为空，所以这里我们执行的是else分支的逻辑，所以这里调用了startActivityForResult方法，并且传递的参数为intent和-1.</p>
<p><font color="#A52A2A"><strong>注意：</strong>通过这里的代码我们可以发现，其实我们在Activity中调用startActivity的内部也是调用的startActivityForResult的。那么为什么调用startActivityForResult可以在Activity中回调onActivityResult而调用startActivity则不可以呢？可以发现其主要的区别是调用startActivity内部调用startActivityForResult传递的传输requestCode值为-1，也就是说我们在Activity调用startActivityForResult的时候传递的requestCode值为-1的话，那么onActivityResult是不起作用的。<br>实际上，经测试requestCode的值小于0的时候都是不起作用的，所以当我们调用startActivityForResult的时候需要注意这一点。</font></p>
<p>好吧，我们继续往下看，startActivityForResult方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123;</span><br><span class="line">        if (mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar &#x3D;</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    this, mMainThread.getApplicationThread(), mToken, this,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            if (ar !&#x3D; null) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">            if (requestCode &gt;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; If this start is requesting a result, we can avoid making</span><br><span class="line">                &#x2F;&#x2F; the activity visible until the result is received.  Setting</span><br><span class="line">                &#x2F;&#x2F; this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span><br><span class="line">                &#x2F;&#x2F; activity hidden during this time, to avoid flickering.</span><br><span class="line">                &#x2F;&#x2F; This can only be done when a result is requested because</span><br><span class="line">                &#x2F;&#x2F; that guarantees we will get information back when the</span><br><span class="line">                &#x2F;&#x2F; activity is finished, no matter what happens to it.</span><br><span class="line">                mStartedActivity &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelInputsAndStartExitTransition(options);</span><br><span class="line">            &#x2F;&#x2F; TODO Consider clearing&#x2F;flushing other event sources and events for child windows.</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (options !&#x3D; null) &#123;</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode, options);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Note we want to go through this method for compatibility with</span><br><span class="line">                &#x2F;&#x2F; existing applications that may have overridden it.</span><br><span class="line">                mParent.startActivityFromChild(this, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现由于我们是第一次启动Activity，所以这里的mParent为空，所以会执行if分之，然后调用mInstrumentation.execStartActivity方法，并且这里需要注意的是，有一个判断逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (requestCode &gt;&#x3D; 0) &#123;</span><br><span class="line">	mStartedActivity &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释也验证了我们刚刚的说法即，调用startActivityForResult的时候只有requestCode的值大于等于0，onActivityResult才会被回调。</p>
<p>然后我们看一下mInstrumentation.execStartActivity方法的实现。在查看execStartActivity方法之前，我们需要对mInstrumentation对象有一个了解？什么是Instrumentation？Instrumentation是android系统中启动Activity的一个实际操作类，也就是说Activity在应用进程端的启动实际上就是Instrumentation执行的，那么为什么说是在应用进程端的启动呢？实际上acitivty的启动分为应用进程端的启动和SystemServer服务进程端的启动的，多个应用进程相互配合最终完成了Activity在系统中的启动的，而在应用进程端的启动实际的操作类就是Intrumentation来执行的，可能还是有点绕口，没关系，随着我们慢慢的解析大家就会对Instrumentation的认识逐渐加深的。</p>
<p>可以发现execStartActivity方法传递的几个参数：<br>this，为启动Activity的对象；<br>contextThread，为Binder对象，是主进程的context对象；<br>token，也是一个Binder对象，指向了服务端一个ActivityRecord对象；<br>target，为启动的Activity；<br>intent，启动的Intent对象；<br>requestCode，请求码；<br>options，参数；</p>
<p>这样就调用了Imstrument.execStartActivity方法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">            int result &#x3D; ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在这个方法中主要调用ActivityManagerNative.getDefault().startActivity方法，那么ActivityManagerNative又是个什么鬼呢？查看一下getDefault()对象的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager getDefault() &#123;</span><br><span class="line">        return gDefault.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，相当之简单直接返回的是gDefault.get()，那么gDefault又是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault &#x3D; new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        protected IActivityManager create() &#123;</span><br><span class="line">            IBinder b &#x3D; ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder &#x3D; &quot; + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am &#x3D; asInterface(b);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service &#x3D; &quot; + am);</span><br><span class="line">            &#125;</span><br><span class="line">            return am;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager in &#x3D;</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，最后直接返回一个ActivityManagerProxy对象，而ActivityManagerProxy继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的ActivityManagerProxy和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示：<br>Binder接口 –&gt; ActivityManagerNative/ActivityManagerProxy –&gt; ActivityManagerService；</p>
<p>这样，ActivityManagerNative与ActivityManagerProxy相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不同等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。</p>
<p>好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。</p>
<p>继续往下卡，我们调用的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int result &#x3D; ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target !&#x3D; null ? target.mEmbeddedID : null,</span><br><span class="line">                        requestCode, 0, null, options);</span><br></pre></td></tr></table></figure>
<p>这里通过我们刚刚的分析，ActivityManagerNative.getDefault()方法会返回一个ActivityManagerProxy对象，那么我们看一下ActivityManagerProxy对象的startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">            String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123;</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(caller !&#x3D; null ? caller.asBinder() : null);</span><br><span class="line">        data.writeString(callingPackage);</span><br><span class="line">        intent.writeToParcel(data, 0);</span><br><span class="line">        data.writeString(resolvedType);</span><br><span class="line">        data.writeStrongBinder(resultTo);</span><br><span class="line">        data.writeString(resultWho);</span><br><span class="line">        data.writeInt(requestCode);</span><br><span class="line">        data.writeInt(startFlags);</span><br><span class="line">        if (profilerInfo !&#x3D; null) &#123;</span><br><span class="line">            data.writeInt(1);</span><br><span class="line">            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (options !&#x3D; null) &#123;</span><br><span class="line">            data.writeInt(1);</span><br><span class="line">            options.writeToParcel(data, 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.readException();</span><br><span class="line">        int result &#x3D; reply.readInt();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。</p>
<p>以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。</p>
<p><br/><strong><font size="6">二：ActivityManagerService接收启动Activity的请求</font></strong></p>
<blockquote>
<font color="red">
ActivityManagerService.startActivity() 
ActvityiManagerService.startActivityAsUser() 
ActivityStackSupervisor.startActivityMayWait() 
ActivityStackSupervisor.startActivityLocked() 
ActivityStackSupervisor.startActivityUncheckedLocked() 
ActivityStackSupervisor.startActivityLocked() 
ActivityStackSupervisor.resumeTopActivitiesLocked()
ActivityStackSupervisor.resumeTopActivityInnerLocked() 
</font>
</blockquote>
<p>好吧，代码量比较大，慢慢看，首先看一下ActivityManagerService.startActivity的具体实现；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123;</span><br><span class="line">        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, options,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，该方法并没有实现什么逻辑，直接调用了startActivityAsUser方法，我们继续看一下startActivityAsUser方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123;</span><br><span class="line">        enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">        userId &#x3D; handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,</span><br><span class="line">                false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);</span><br><span class="line">        &#x2F;&#x2F; TODO: Switch to user app stacks here.</span><br><span class="line">        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">                profilerInfo, null, null, options, false, userId, null, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，下面我们来看一下这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">            String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,</span><br><span class="line">            Bundle options, boolean ignoreTargetSecurity, int userId,</span><br><span class="line">            IActivityContainer iContainer, TaskRecord inTask) &#123;</span><br><span class="line">		    ...</span><br><span class="line"></span><br><span class="line">            int res &#x3D; startActivityLocked(caller, intent, resolvedType, aInfo,</span><br><span class="line">                    voiceSession, voiceInteractor, resultTo, resultWho,</span><br><span class="line">                    requestCode, callingPid, callingUid, callingPackage,</span><br><span class="line">                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,</span><br><span class="line">                    componentSpecified, null, container, inTask);</span><br><span class="line">		    ...</span><br><span class="line">            return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityLocked(IApplicationThread caller,</span><br><span class="line">            Intent intent, String resolvedType, ActivityInfo aInfo,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int callingPid, int callingUid, String callingPackage,</span><br><span class="line">            int realCallingPid, int realCallingUid, int startFlags, Bundle options,</span><br><span class="line">            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">            ActivityContainer container, TaskRecord inTask) &#123;</span><br><span class="line">        int err &#x3D; ActivityManager.START_SUCCESS;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        err &#x3D; startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, true, options, inTask);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,</span><br><span class="line">            boolean doResume, Bundle options, TaskRecord inTask) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task);</span><br><span class="line">        targetStack.mLastPausedActivity &#x3D; null;</span><br><span class="line">        targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);</span><br><span class="line">        if (!launchTaskBehind) &#123;</span><br><span class="line">            &#x2F;&#x2F; Don&#39;t set focus on an activity that&#39;s going to the back.</span><br><span class="line">            mService.setFocusedActivityLocked(r, &quot;startedActivity&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return ActivityManager.START_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>startActivityUncheckedLocked方法中只要执行了不同启动模式不同栈的处理，并最后调用了startActivityLocked的重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void startActivityLocked(ActivityRecord r, boolean newTask,</span><br><span class="line">            boolean doResume, boolean keepCurTransition, Bundle options) &#123;</span><br><span class="line">		...</span><br><span class="line">        if (doResume) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个startActivityLocked方法主要执行初始化了windowManager服务，然后调用resumeTopActivitiesLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,</span><br><span class="line">            Bundle targetOptions) &#123;</span><br><span class="line">        if (targetStack &#x3D;&#x3D; null) &#123;</span><br><span class="line">            targetStack &#x3D; mFocusedStack;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Do targetStack first.</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        if (isFrontStack(targetStack)) &#123;</span><br><span class="line">            result &#x3D; targetStack.resumeTopActivityLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int displayNdx &#x3D; mActivityDisplays.size() - 1; displayNdx &gt;&#x3D; 0; --displayNdx) &#123;</span><br><span class="line">            final ArrayList&lt;ActivityStack&gt; stacks &#x3D; mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">            for (int stackNdx &#x3D; stacks.size() - 1; stackNdx &gt;&#x3D; 0; --stackNdx) &#123;</span><br><span class="line">                final ActivityStack stack &#x3D; stacks.get(stackNdx);</span><br><span class="line">                if (stack &#x3D;&#x3D; targetStack) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Already started above.</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isFrontStack(stack)) &#123;</span><br><span class="line">                    stack.resumeTopActivityLocked(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现经过循环逻辑判断之后，最终调用了resumeTopActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev) &#123;</span><br><span class="line">        return resumeTopActivityLocked(prev, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line">        if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">            &#x2F;&#x2F; Don&#39;t even start recursing.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Protect against recursion.</span><br><span class="line">            mStackSupervisor.inResumeTopActivity &#x3D; true;</span><br><span class="line">            if (mService.mLockScreenShown &#x3D;&#x3D; ActivityManagerService.LOCK_SCREEN_LEAVING) &#123;</span><br><span class="line">                mService.mLockScreenShown &#x3D; ActivityManagerService.LOCK_SCREEN_HIDDEN;</span><br><span class="line">                mService.updateSleepIfNeededLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mStackSupervisor.inResumeTopActivity &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续调用resumeTopActivityInnerLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">		if (mResumedActivity !&#x3D; null) &#123;</span><br><span class="line">            if (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                    &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);</span><br><span class="line">            pausing |&#x3D; startPausingLocked(userLeaving, false, true, dontWaitForPause);</span><br><span class="line">        &#125;        ...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。</p>
<p><br><strong><font size="6">三：执行栈顶Activity的onPause方法</p>
<blockquote>
<font color="red">
ActivityStack.startPausingLocked()
IApplicationThread.schudulePauseActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage();
ActivityThread.H.handleMessage()
ActivityThread.handlePauseActivity()
ActivityThread.performPauseActivity()
Activity.performPause()
Activity.onPause()
ActivityManagerNative.getDefault().activityPaused(token)
ActivityManagerService.activityPaused()
ActivityStack.activityPausedLocked()
ActivityStack.completePauseLocked()
ActivityStack.resumeTopActivitiesLocked()
ActivityStack.resumeTopActivityLocked()
ActivityStack.resumeTopActivityInnerLocked()
ActivityStack.startSpecificActivityLocked
</font>
</blockquote>
<p>好吧，方法比较多也比较乱，首先来看startPausingLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming,</span><br><span class="line">            boolean dontWait) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (prev.app !&#x3D; null &amp;&amp; prev.app.thread !&#x3D; null) &#123;</span><br><span class="line">            if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev);</span><br><span class="line">            try &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,</span><br><span class="line">                        prev.userId, System.identityHashCode(prev),</span><br><span class="line">                        prev.shortComponentName);</span><br><span class="line">                mService.updateUsageStats(prev, false);</span><br><span class="line">                prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                        userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore exception, if process died other code will cleanup.</span><br><span class="line">                Slog.w(TAG, &quot;Exception thrown during pause&quot;, e);</span><br><span class="line">                mPausingActivity &#x3D; null;</span><br><span class="line">                mLastPausedActivity &#x3D; null;</span><br><span class="line">                mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mPausingActivity &#x3D; null;</span><br><span class="line">            mLastPausedActivity &#x3D; null;</span><br><span class="line">            mLastNoHistoryActivity &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。</p>
<p><font color="red">这里的ApplicationThread可以和ActivityManagerNative对于一下：<br>通过ActivityManagerNative –&gt;   ActivityManagerService实现了应用进程与SystemServer进程的通讯<br>通过AppicationThread          &lt;–    IApplicationThread实现了SystemServer进程与应用进程的通讯</font></p>
<p>然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished,</span><br><span class="line">                boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">            sendMessage(</span><br><span class="line">                    finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">                    token,</span><br><span class="line">                    (userLeaving ? 1 : 0) | (dontReport ? 2 : 0),</span><br><span class="line">                    configChanges);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>发送了PAUSE_ACTIVITY_FINISHING消息，然后看一下sendMessage的实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2) &#123;</span><br><span class="line">        sendMessage(what, obj, arg1, arg2, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用了其重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">        if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">            TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">            + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">        Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.what &#x3D; what;</span><br><span class="line">        msg.obj &#x3D; obj;</span><br><span class="line">        msg.arg1 &#x3D; arg1;</span><br><span class="line">        msg.arg2 &#x3D; arg2;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            msg.setAsynchronous(true);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                ...</span><br><span class="line">                case PAUSE_ACTIVITY_FINISHING:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);</span><br><span class="line">                    handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) !&#x3D; 0, msg.arg2,</span><br><span class="line">                            (msg.arg1&amp;1) !&#x3D; 0);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    break;</span><br><span class="line">				...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其调用了handlePauseActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;Slog.v(TAG, &quot;userLeaving&#x3D;&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br><span class="line">            if (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |&#x3D; configChanges;</span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Make sure any pending writes are now committed.</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        return r !&#x3D; null ? performPauseActivity(r, finished, saveState) : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用其重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final Bundle performPauseActivity(ActivityClientRecord r, boolean finished,</span><br><span class="line">            boolean saveState) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return !r.activity.mFinished &amp;&amp; saveState ? r.state : null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样回到了mInstrumentation的callActivityOnPuase方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnPause(Activity activity) &#123;</span><br><span class="line">        activity.performPause();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>呵呵，原来最终回调到了Activity的performPause方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final void performPause() &#123;</span><br><span class="line">        mDoReportFullyDrawn &#x3D; false;</span><br><span class="line">        mFragments.dispatchPause();</span><br><span class="line">        mCalled &#x3D; false;</span><br><span class="line">        onPause();</span><br><span class="line">        mResumed &#x3D; false;</span><br><span class="line">        if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;&#x3D; android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">            throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onPause()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mResumed &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。</p>
<p>然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityPaused(IBinder token) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                stack.activityPausedLocked(token, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，继续看一下activityPausedLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void activityPausedLocked(IBinder token, boolean timeout) &#123;</span><br><span class="line">	        ...</span><br><span class="line">                if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r</span><br><span class="line">                        + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;));</span><br><span class="line">                completePauseLocked(true);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行了completePauseLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void completePauseLocked(boolean resumeNext) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        if (resumeNext) &#123;</span><br><span class="line">            final ActivityStack topStack &#x3D; mStackSupervisor.getFocusedStack();</span><br><span class="line">            if (!mService.isSleepingOrShuttingDown()) &#123;</span><br><span class="line">                mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line">                ActivityRecord top &#x3D; topStack.topRunningActivityLocked(null);</span><br><span class="line">                if (top &#x3D;&#x3D; null || (prev !&#x3D; null &amp;&amp; top !&#x3D; prev)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; If there are no more activities available to run,</span><br><span class="line">                    &#x2F;&#x2F; do resume anyway to start something.  Also if the top</span><br><span class="line">                    &#x2F;&#x2F; activity on the stack is not the just paused activity,</span><br><span class="line">                    &#x2F;&#x2F; we need to go ahead and resume it to ensure we complete</span><br><span class="line">                    &#x2F;&#x2F; an in-flight app switch.</span><br><span class="line">                    mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第二步中解析的方法中了，这样经过<br>resumeTopActivitiesLocked –&gt;<br>ActivityStack.resumeTopActivityLocked() –&gt;<br>resumeTopActivityInnerLocked –&gt;<br>startSpecificActivityLocked<br>好吧，我们看一下startSpecificActivityLocked的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">            boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">        &#x2F;&#x2F; Is this activity&#39;s application already running?</span><br><span class="line">        ProcessRecord app &#x3D; mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">        r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) &#x3D;&#x3D; 0</span><br><span class="line">                        || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Don&#39;t add this if it is a platform component that is marked</span><br><span class="line">                    &#x2F;&#x2F; to run in multiple processes, because this is actually</span><br><span class="line">                    &#x2F;&#x2F; part of the framework so doesn&#39;t make sense to track as a</span><br><span class="line">                    &#x2F;&#x2F; separate apk in the process.</span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If a dead object exception was thrown -- fall through to</span><br><span class="line">            &#x2F;&#x2F; restart the application.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。<br>这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause<br>方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。</p>
<p><br/><strong><font size="6">四：启动Activity所属的应用进程</font></strong></p>
<p>关于如何启动应用进程，前面的一篇文章已经做了介绍，可参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51119333" target="_blank" rel="noopener"> android源码解析之（十一）–&gt;应用进程启动流程</a> 这里在简单的介绍一下</p>
<blockquote>
<font color="red">
ActivityManagerService.startProcessLocked()
Process.start()
ActivityThread.main()
ActivityThread.attach()
ActivityManagerNative.getDefault().attachApplication()
ActivityManagerService.attachApplication()
</font>
</blockquote>
<p>好吧，首先看一下startProcessLocked()方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app,</span><br><span class="line">            String hostingType, String hostingNameStr) &#123;</span><br><span class="line">        startProcessLocked(app, hostingType, hostingNameStr, null &#x2F;* abiOverride *&#x2F;,</span><br><span class="line">                null &#x2F;* entryPoint *&#x2F;, null &#x2F;* entryPointArgs *&#x2F;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后回调了其重载的startProcessLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app, String hostingType,</span><br><span class="line">            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123;</span><br><span class="line">            ...</span><br><span class="line">            boolean isActivityProcess &#x3D; (entryPoint &#x3D;&#x3D; null);</span><br><span class="line">            if (entryPoint &#x3D;&#x3D; null) entryPoint &#x3D; &quot;android.app.ActivityThread&quot;;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; +</span><br><span class="line">                    app.processName);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">            Process.ProcessStartResult startResult &#x3D; Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名“android.app.ActivityThread”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static final ProcessStartResult start(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  int uid, int gid, int[] gids,</span><br><span class="line">                                  int debugFlags, int mountExternal,</span><br><span class="line">                                  int targetSdkVersion,</span><br><span class="line">                                  String seInfo,</span><br><span class="line">                                  String abi,</span><br><span class="line">                                  String instructionSet,</span><br><span class="line">                                  String appDataDir,</span><br><span class="line">                                  String[] zygoteArgs) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">        &#125; catch (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            Log.e(LOG_TAG,</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;);</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Starting VM process through Zygote failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用了startViaZygote方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult startViaZygote(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  final int uid, final int gid,</span><br><span class="line">                                  final int[] gids,</span><br><span class="line">                                  int debugFlags, int mountExternal,</span><br><span class="line">                                  int targetSdkVersion,</span><br><span class="line">                                  String seInfo,</span><br><span class="line">                                  String abi,</span><br><span class="line">                                  String instructionSet,</span><br><span class="line">                                  String appDataDir,</span><br><span class="line">                                  String[] extraArgs)</span><br><span class="line">                                  throws ZygoteStartFailedEx &#123;</span><br><span class="line">        synchronized(Process.class) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续查看一下zygoteSendArgsAndGetResult方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private static ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">            ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">            throws ZygoteStartFailedEx &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * See com.android.internal.os.ZygoteInit.readArgumentList()</span><br><span class="line">             * Presently the wire format to the zygote process is:</span><br><span class="line">             * a) a count of arguments (argc, in essence)</span><br><span class="line">             * b) a number of newline-separated argument strings equal to count</span><br><span class="line">             *</span><br><span class="line">             * After the zygote process reads these it will write the pid of</span><br><span class="line">             * the child or -1 on failure, followed by boolean to</span><br><span class="line">             * indicate whether a wrapper process was used.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            final BufferedWriter writer &#x3D; zygoteState.writer;</span><br><span class="line">            final DataInputStream inputStream &#x3D; zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">            writer.write(Integer.toString(args.size()));</span><br><span class="line">            writer.newLine();</span><br><span class="line"></span><br><span class="line">            int sz &#x3D; args.size();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; sz; i++) &#123;</span><br><span class="line">                String arg &#x3D; args.get(i);</span><br><span class="line">                if (arg.indexOf(&#39;\n&#39;) &gt;&#x3D; 0) &#123;</span><br><span class="line">                    throw new ZygoteStartFailedEx(</span><br><span class="line">                            &quot;embedded newlines not allowed&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                writer.write(arg);</span><br><span class="line">                writer.newLine();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Should there be a timeout on this?</span><br><span class="line">            ProcessStartResult result &#x3D; new ProcessStartResult();</span><br><span class="line">            result.pid &#x3D; inputStream.readInt();</span><br><span class="line">            if (result.pid &lt; 0) &#123;</span><br><span class="line">                throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            result.usingWrapper &#x3D; inputStream.readBoolean();</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            zygoteState.close();</span><br><span class="line">            throw new ZygoteStartFailedEx(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。</p>
<p>为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。</p>
<p>好了，这时候我们看一下ActivityThread的main方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (false) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(new</span><br><span class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; End of event ActivityThreadMain.</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？<br>然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void attach(boolean system) &#123;</span><br><span class="line">	...</span><br><span class="line">	final IActivityManager mgr &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#x2F;&#x2F; Ignore</span><br><span class="line">            &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚刚我们已经分析过ActivityManagerNative是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void attachApplication(IApplicationThread thread) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">            final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其回调了attachApplicationLocked方法，我们看一下这个方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">            int pid) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; See if the top visible activity is waiting to run in this process...</span><br><span class="line">        if (normalMode) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                    didSomething &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">                badApp &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法执行了一系列的初始化操作，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了，O(∩_∩)O哈哈~</p>
<p><br/><strong><font size="6">五：执行启动Acitivity</font></strong></p>
<blockquote>
<font color="red">
ActivityStackSupervisor.attachApplicationLocked()
ActivityStackSupervisor.realStartActivityLocked()
IApplicationThread.scheduleLauncherActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handleLauncherActivity()
ActivityThread.performLauncherActivity()
Instrumentation.callActivityOnCreate()
Activity.onCreate()
ActivityThread.handleResumeActivity()
ActivityThread.performResumeActivity()
Activity.performResume()
Instrumentation.callActivityOnResume()
Activity.onResume()
ActivityManagerNative.getDefault().activityResumed(token)
</font>
</blockquote>
<p>首先看一下attachApplicationLocked方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line">        final String processName &#x3D; app.processName;</span><br><span class="line">        boolean didSomething &#x3D; false;</span><br><span class="line">        for (int displayNdx &#x3D; mActivityDisplays.size() - 1; displayNdx &gt;&#x3D; 0; --displayNdx) &#123;</span><br><span class="line">            ArrayList&lt;ActivityStack&gt; stacks &#x3D; mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">            for (int stackNdx &#x3D; stacks.size() - 1; stackNdx &gt;&#x3D; 0; --stackNdx) &#123;</span><br><span class="line">                final ActivityStack stack &#x3D; stacks.get(stackNdx);</span><br><span class="line">                if (!isFrontStack(stack)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ActivityRecord hr &#x3D; stack.topRunningActivityLocked(null);</span><br><span class="line">                if (hr !&#x3D; null) &#123;</span><br><span class="line">                    if (hr.app &#x3D;&#x3D; null &amp;&amp; app.uid &#x3D;&#x3D; hr.info.applicationInfo.uid</span><br><span class="line">                            &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if (realStartActivityLocked(hr, app, true, true)) &#123;</span><br><span class="line">                                didSomething &#x3D; true;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                            Slog.w(TAG, &quot;Exception in new application when starting activity &quot;</span><br><span class="line">                                  + hr.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                            throw e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!didSomething) &#123;</span><br><span class="line">            ensureActivitiesVisibleLocked(null, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return didSomething;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final boolean realStartActivityLocked(ActivityRecord r,</span><br><span class="line">            ProcessRecord app, boolean andResume, boolean checkConfig)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">            app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),</span><br><span class="line">                    new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">		...</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现与第三步执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLauncherActivity方法，所以真正执行的是ActivityThread中的scheduleLauncherActivity，所以我们看一下ActivityThread中的scheduleLauncherActivity的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">                int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(procState, false);</span><br><span class="line"></span><br><span class="line">            ActivityClientRecord r &#x3D; new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">            r.token &#x3D; token;</span><br><span class="line">            r.ident &#x3D; ident;</span><br><span class="line">            r.intent &#x3D; intent;</span><br><span class="line">            r.referrer &#x3D; referrer;</span><br><span class="line">            r.voiceInteractor &#x3D; voiceInteractor;</span><br><span class="line">            r.activityInfo &#x3D; info;</span><br><span class="line">            r.compatInfo &#x3D; compatInfo;</span><br><span class="line">            r.state &#x3D; state;</span><br><span class="line">            r.persistentState &#x3D; persistentState;</span><br><span class="line"></span><br><span class="line">            r.pendingResults &#x3D; pendingResults;</span><br><span class="line">            r.pendingIntents &#x3D; pendingNewIntents;</span><br><span class="line"></span><br><span class="line">            r.startsNotResumed &#x3D; notResumed;</span><br><span class="line">            r.isForward &#x3D; isForward;</span><br><span class="line"></span><br><span class="line">            r.profilerInfo &#x3D; profilerInfo;</span><br><span class="line"></span><br><span class="line">            r.overrideConfig &#x3D; overrideConfig;</span><br><span class="line">            updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">            sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，还是那套逻辑，ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">        Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">        if (a !&#x3D; null) &#123;</span><br><span class="line">            r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState &#x3D; r.state;</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">Activity activity &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl &#x3D; r.packageInfo.getClassLoader();</span><br><span class="line">            activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            if (r.state !&#x3D; null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        activity.mCalled &#x3D; false;</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">           mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">		if (!r.activity.mFinished) &#123;</span><br><span class="line">                    activity.performStart();</span><br><span class="line">                    r.stopped &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">        ...</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现这里我们需要的Activity对象终于是创建出来了，而且他是以反射的机制创建的，现在还不太清楚为啥google要以反射的方式创建Activity，先不看这些，然后在代码中其调用Instrumentation的callActivityOnCreate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle,</span><br><span class="line">            PersistableBundle persistentState) &#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行activity的performCreate方法。。。。好吧，都转晕了。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">        mActivityTransitionState.readState(icicle);</span><br><span class="line">        performCreateCommon();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，第二个生命周期方法出来了，onCreate方法。。。。</p>
<p>在回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart();方法，好吧，看一下他的实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final void performStart() &#123;</span><br><span class="line">        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">        mFragments.noteStateNotSaved();</span><br><span class="line">        mCalled &#x3D; false;</span><br><span class="line">        mFragments.execPendingActions();</span><br><span class="line">        mInstrumentation.callActivityOnStart(this);</span><br><span class="line">        if (!mCalled) &#123;</span><br><span class="line">            throw new SuperNotCalledException(</span><br><span class="line">                &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                &quot; did not call through to super.onStart()&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mFragments.dispatchStart();</span><br><span class="line">        mFragments.reportLoaderStart();</span><br><span class="line">        mActivityTransitionState.enterReady(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，还是通过Instrumentation调用callActivityOnStart方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnStart(Activity activity) &#123;</span><br><span class="line">        activity.onStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O哈哈~</p>
<p>还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide, boolean isForward, boolean reallyResume) &#123;</span><br><span class="line">        &#x2F;&#x2F; If we are getting ready to gc after going to the background, well</span><br><span class="line">        &#x2F;&#x2F; we are back active so skip it.</span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line">        mSomeActivitiesChanged &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; TODO Push resumeArgs into the activity for consideration</span><br><span class="line">        ActivityClientRecord r &#x3D; performResumeActivity(token, clearHide);</span><br><span class="line"></span><br><span class="line">        if (r !&#x3D; null) &#123;</span><br><span class="line">            final Activity a &#x3D; r.activity;</span><br><span class="line"></span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</span><br><span class="line">                a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</span><br><span class="line">                + &quot;, finished: &quot; + a.mFinished);</span><br><span class="line"></span><br><span class="line">            final int forwardBit &#x3D; isForward ?</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the window hasn&#39;t yet been added to the window manager,</span><br><span class="line">            &#x2F;&#x2F; and this guy didn&#39;t finish itself or start another activity,</span><br><span class="line">            &#x2F;&#x2F; then go ahead and add the window.</span><br><span class="line">            boolean willBeVisible &#x3D; !a.mStartedActivity;</span><br><span class="line">            if (!willBeVisible) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    willBeVisible &#x3D; ActivityManagerNative.getDefault().willActivityBeVisible(</span><br><span class="line">                            a.getActivityToken());</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (r.window &#x3D;&#x3D; null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window &#x3D; r.activity.getWindow();</span><br><span class="line">                View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                a.mDecor &#x3D; decor;</span><br><span class="line">                l.type &#x3D; WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |&#x3D; forwardBit;</span><br><span class="line">                if (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded &#x3D; true;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If the window has already been added, but during resume</span><br><span class="line">            &#x2F;&#x2F; we started another activity, then don&#39;t yet make the</span><br><span class="line">            &#x2F;&#x2F; window visible.</span><br><span class="line">            &#125; else if (!willBeVisible) &#123;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">                r.hideForNow &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Get rid of anything left hanging around.</span><br><span class="line">            cleanUpPendingRemoveWindows(r);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; The window is now visible if it has been added, we are not</span><br><span class="line">            &#x2F;&#x2F; simply finishing, and we are not starting another activity.</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                    &amp;&amp; r.activity.mDecor !&#x3D; null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                if (r.newConfig !&#x3D; null) &#123;</span><br><span class="line">                    r.tmpConfig.setTo(r.newConfig);</span><br><span class="line">                    if (r.overrideConfig !&#x3D; null) &#123;</span><br><span class="line">                        r.tmpConfig.updateFrom(r.overrideConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;</span><br><span class="line">                            + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);</span><br><span class="line">                    performConfigurationChanged(r.activity, r.tmpConfig);</span><br><span class="line">                    freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));</span><br><span class="line">                    r.newConfig &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward&#x3D;&quot;</span><br><span class="line">                        + isForward);</span><br><span class="line">                WindowManager.LayoutParams l &#x3D; r.window.getAttributes();</span><br><span class="line">                if ((l.softInputMode</span><br><span class="line">                        &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                        !&#x3D; forwardBit) &#123;</span><br><span class="line">                    l.softInputMode &#x3D; (l.softInputMode</span><br><span class="line">                            &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                            | forwardBit;</span><br><span class="line">                    if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                        ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">                        View decor &#x3D; r.window.getDecorView();</span><br><span class="line">                        wm.updateViewLayout(decor, l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.mVisibleFromServer &#x3D; true;</span><br><span class="line">                mNumVisibleActivities++;</span><br><span class="line">                if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    r.activity.makeVisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!r.onlyLocalRequest) &#123;</span><br><span class="line">                r.nextIdle &#x3D; mNewActivities;</span><br><span class="line">                mNewActivities &#x3D; r;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Scheduling idle handler for &quot; + r);</span><br><span class="line">                Looper.myQueue().addIdleHandler(new Idler());</span><br><span class="line">            &#125;</span><br><span class="line">            r.onlyLocalRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Tell the activity manager we have resumed.</span><br><span class="line">            if (reallyResume) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; If an exception was thrown when trying to resume, then</span><br><span class="line">            &#x2F;&#x2F; just end this activity.</span><br><span class="line">            try &#123;</span><br><span class="line">                ActivityManagerNative.getDefault()</span><br><span class="line">                    .finishActivity(token, Activity.RESULT_CANCELED, null, false);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final ActivityClientRecord performResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide) &#123;</span><br><span class="line">        ActivityClientRecord r &#x3D; mActivities.get(token);</span><br><span class="line">        if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r</span><br><span class="line">                + &quot; finished&#x3D;&quot; + r.activity.mFinished);</span><br><span class="line">        if (r !&#x3D; null &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">            if (clearHide) &#123;</span><br><span class="line">                r.hideForNow &#x3D; false;</span><br><span class="line">                r.activity.mStartedActivity &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                r.activity.onStateNotSaved();</span><br><span class="line">                r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">                if (r.pendingIntents !&#x3D; null) &#123;</span><br><span class="line">                    deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">                    r.pendingIntents &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                if (r.pendingResults !&#x3D; null) &#123;</span><br><span class="line">                    deliverResults(r, r.pendingResults);</span><br><span class="line">                    r.pendingResults &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity.performResume();</span><br><span class="line"></span><br><span class="line">                EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED,</span><br><span class="line">                        UserHandle.myUserId(), r.activity.getComponentName().getClassName());</span><br><span class="line"></span><br><span class="line">                r.paused &#x3D; false;</span><br><span class="line">                r.stopped &#x3D; false;</span><br><span class="line">                r.state &#x3D; null;</span><br><span class="line">                r.persistentState &#x3D; null;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    throw new RuntimeException(</span><br><span class="line">                        &quot;Unable to resume activity &quot;</span><br><span class="line">                        + r.intent.getComponent().toShortString()</span><br><span class="line">                        + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在方法体中，最终调用了r.activity.performResume();方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void performResume() &#123;</span><br><span class="line">        ...</span><br><span class="line">        mInstrumentation.callActivityOnResume(this);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnResume(Activity activity) &#123;</span><br><span class="line">        activity.mResumed &#x3D; true;</span><br><span class="line">        activity.onResume();</span><br><span class="line">        </span><br><span class="line">        if (mActivityMonitors !&#x3D; null) &#123;</span><br><span class="line">            synchronized (mSync) &#123;</span><br><span class="line">                final int N &#x3D; mActivityMonitors.size();</span><br><span class="line">                for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                    final ActivityMonitor am &#x3D; mActivityMonitors.get(i);</span><br><span class="line">                    am.match(activity, activity, activity.getIntent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，第四个生命周期方法出现了，onResume方法。。。</p>
<p>终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有，哈哈，别着急。</p>
<p>有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？<br>你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，咦？对了onStop方法还没回调呢，O(∩_∩)O哈哈~，对了缺少的就是对onStop方法的回调啊。</p>
<p>好吧，具体的逻辑我们下一步再说</p>
<p><br><strong><font size="6">六：栈顶Activity执行onStop方法</p>
<blockquote>
<font color="red">
Looper.myQueue().addIdleHandler(new Idler())
Idler.queueIdle()
ActivityManagerNative.getDefault().activityIdle()
ActivityManagerService.activityIdle()
ActivityStackSupervisor.activityIdleInternalLocked()
ActivityStack.stopActivityLocked()
IApplicationThread.scheduleStopActivity()
ActivityThread.scheduleStopActivity()
ActivityThread.sendMessage()
ActivityThread.H.sendMessage()
ActivityThread.H.handleMessage()
ActivityThread.handleStopActivity()
ActivityThread.performStopActivityInner()
ActivityThread.callCallActivityOnSaveInstanceState()
Instrumentation.callActivityOnSaveInstanceState()
Activity.performSaveInstanceState()
Activity.onSaveInstanceState()
Activity.performStop()
Instrumentation.callActivityOnStop()
Activity.onStop()
</font>
</blockquote>
<p>回到我们的handleResumeActivity方法，在方法体最后有这样的一代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(new Idler());</span><br></pre></td></tr></table></figure>

<p>这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean queueIdle() &#123;</span><br><span class="line">            ActivityClientRecord a &#x3D; mNewActivities;</span><br><span class="line">            boolean stopProfiling &#x3D; false;</span><br><span class="line">            if (mBoundApplication !&#x3D; null &amp;&amp; mProfiler.profileFd !&#x3D; null</span><br><span class="line">                    &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">                stopProfiling &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a !&#x3D; null) &#123;</span><br><span class="line">                mNewActivities &#x3D; null;</span><br><span class="line">                IActivityManager am &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">                ActivityClientRecord prev;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (localLOGV) Slog.v(</span><br><span class="line">                        TAG, &quot;Reporting idle of &quot; + a +</span><br><span class="line">                        &quot; finished&#x3D;&quot; +</span><br><span class="line">                        (a.activity !&#x3D; null &amp;&amp; a.activity.mFinished));</span><br><span class="line">                    if (a.activity !&#x3D; null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                            a.createdConfig &#x3D; null;</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Ignore</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev &#x3D; a;</span><br><span class="line">                    a &#x3D; a.nextIdle;</span><br><span class="line">                    prev.nextIdle &#x3D; null;</span><br><span class="line">                &#125; while (a !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">            if (stopProfiling) &#123;</span><br><span class="line">                mProfiler.stopProfiling();</span><br><span class="line">            &#125;</span><br><span class="line">            ensureJitEnabled();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123;</span><br><span class="line">        final long origId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ActivityStack stack &#x3D; ActivityRecord.getStackLocked(token);</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                ActivityRecord r &#x3D;</span><br><span class="line">                        mStackSupervisor.activityIdleInternalLocked(token, false, config);</span><br><span class="line">                if (stopProfiling) &#123;</span><br><span class="line">                    if ((mProfileProc &#x3D;&#x3D; r.app) &amp;&amp; (mProfileFd !&#x3D; null)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            mProfileFd.close();</span><br><span class="line">                        &#125; catch (IOException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        clearProfilerLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,</span><br><span class="line">            Configuration config) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Stop any activities that are scheduled to do so but have been</span><br><span class="line">        &#x2F;&#x2F; waiting for the next one to start.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; NS; i++) &#123;</span><br><span class="line">            r &#x3D; stops.get(i);</span><br><span class="line">            final ActivityStack stack &#x3D; r.task.stack;</span><br><span class="line">            if (stack !&#x3D; null) &#123;</span><br><span class="line">                if (r.finishing) &#123;</span><br><span class="line">                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    stack.stopActivityLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现在其中又调用了ActivityStack.stopActivityLocked方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final void stopActivityLocked(ActivityRecord r) &#123;</span><br><span class="line">        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, &quot;Stopping: &quot; + r);</span><br><span class="line">        if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) !&#x3D; 0</span><br><span class="line">                || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) !&#x3D; 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">                r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags);</span><br><span class="line">             ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleStopActivity(IBinder token, boolean showWindow,</span><br><span class="line">                int configChanges) &#123;</span><br><span class="line">           sendMessage(</span><br><span class="line">                showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE,</span><br><span class="line">                token, 0, configChanges);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void handleStopActivity(IBinder token, boolean show, int configChanges) &#123;</span><br><span class="line">        ...</span><br><span class="line">        performStopActivityInner(r, info, show, true);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看一下performStopActivityInner的实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void performStopActivityInner(ActivityClientRecord r,</span><br><span class="line">            StopInfo info, boolean keepShown, boolean saveState) &#123;</span><br><span class="line">	        ...</span><br><span class="line">            &#x2F;&#x2F; Next have the activity save its current state and managed dialogs...</span><br><span class="line">            if (!r.activity.mFinished &amp;&amp; saveState) &#123;</span><br><span class="line">                if (r.state &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    callCallActivityOnSaveInstanceState(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!keepShown) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; Now we are idle.</span><br><span class="line">                    r.activity.performStop();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    if (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                        throw new RuntimeException(</span><br><span class="line">                                &quot;Unable to stop activity &quot;</span><br><span class="line">                                + r.intent.getComponent().toShortString()</span><br><span class="line">                                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.stopped &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，看样子在这个方法中执行了两个逻辑，一个是执行Activity的onSaveInstance方法一个是执行Activity的onStop方法，我们先看一下callCallActivityOnSaveInstanceState的执行逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) &#123;</span><br><span class="line">        r.state &#x3D; new Bundle();</span><br><span class="line">        r.state.setAllowFds(false);</span><br><span class="line">        if (r.isPersistable()) &#123;</span><br><span class="line">            r.persistentState &#x3D; new PersistableBundle();</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>好吧，又是通过Instrumentation来执行。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnSaveInstanceState(Activity activity, Bundle outState,</span><br><span class="line">            PersistableBundle outPersistentState) &#123;</span><br><span class="line">        activity.performSaveInstanceState(outState, outPersistentState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>又间接调用了Activity的performSaveInstanceState方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void performSaveInstanceState(Bundle outState) &#123;</span><br><span class="line">        onSaveInstanceState(outState);</span><br><span class="line">        saveManagedDialogs(outState);</span><br><span class="line">        mActivityTransitionState.saveState(outState);</span><br><span class="line">        if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>呵呵，这里调用到了，我们以前经常会重写的onSaveInstanceState方法。</p>
<p>然后我们看一下performStopActivityInner中调用到的Activity方法的performStop方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">final void performStop() &#123;</span><br><span class="line">        mDoReportFullyDrawn &#x3D; false;</span><br><span class="line">        mFragments.doLoaderStop(mChangingConfigurations &#x2F;*retain*&#x2F;);</span><br><span class="line"></span><br><span class="line">        if (!mStopped) &#123;</span><br><span class="line">            if (mWindow !&#x3D; null) &#123;</span><br><span class="line">                mWindow.closeAllPanels();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mToken !&#x3D; null &amp;&amp; mParent &#x3D;&#x3D; null) &#123;</span><br><span class="line">                WindowManagerGlobal.getInstance().setStoppedState(mToken, true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mFragments.dispatchStop();</span><br><span class="line"></span><br><span class="line">            mCalled &#x3D; false;</span><br><span class="line">            mInstrumentation.callActivityOnStop(this);</span><br><span class="line">            if (!mCalled) &#123;</span><br><span class="line">                throw new SuperNotCalledException(</span><br><span class="line">                    &quot;Activity &quot; + mComponent.toShortString() +</span><br><span class="line">                    &quot; did not call through to super.onStop()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            synchronized (mManagedCursors) &#123;</span><br><span class="line">                final int N &#x3D; mManagedCursors.size();</span><br><span class="line">                for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                    ManagedCursor mc &#x3D; mManagedCursors.get(i);</span><br><span class="line">                    if (!mc.mReleased) &#123;</span><br><span class="line">                        mc.mCursor.deactivate();</span><br><span class="line">                        mc.mReleased &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mStopped &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        mResumed &#x3D; false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void callActivityOnStop(Activity activity) &#123;</span><br><span class="line">        activity.onStop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>O(∩_∩)O哈哈~，最后一个生命周期方法终于出来了，onStop()…..</p>
<p><br><br><br><font size="5">总结：</font></p>
<ul>
<li><p>Activity的启动流程一般是通过调用startActivity或者是startActivityForResult来开始的</p>
</li>
<li><p>startActivity内部也是通过调用startActivityForResult来启动Activity，只不过传递的requestCode小于0</p>
</li>
<li><p>Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯</p>
</li>
<li><p>ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。</p>
</li>
<li><p>ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。</p>
</li>
<li><p>ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法；</p>
</li>
<li><p>ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发；</p>
</li>
<li><p>ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作；</p>
</li>
<li><p>ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程；</p>
</li>
<li><p>ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法；</p>
</li>
<li><p>在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作；</p>
</li>
<li><p>ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作；</p>
</li>
<li><p>ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法；</p>
</li>
<li><p>ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法；</p>
</li>
<li><p>ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread；</p>
</li>
<li><p>ActivityThread执行真正的onStop方法；</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E7%B3%BB%E7%BB%9F%E5%B1%82/" rel="tag"># Android系统层</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/30/13%20apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/" rel="prev" title="13 apk安装流程">
      <i class="fa fa-chevron-left"></i> 13 apk安装流程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/30/15%20activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/" rel="next" title="15 activity销毁流程">
      15 activity销毁流程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
