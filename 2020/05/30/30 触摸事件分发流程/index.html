<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起">
<meta property="og:type" content="article">
<meta property="og:title" content="30 触摸事件分发流程">
<meta property="og:url" content="http://yoursite.com/2020/05/30/30%20%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-29T16:29:03.953Z">
<meta property="article:modified_time" content="2020-06-01T12:07:54.813Z">
<meta property="article:author" content="yudesong">
<meta property="article:tag" content="Android系统层">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/05/30/30%20%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>30 触摸事件分发流程 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/30/30%20%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          30 触摸事件分发流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:29:03" itemprop="dateCreated datePublished" datetime="2020-05-30T00:29:03+08:00">2020-05-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起返回按键的时候默认都是销毁当前Activity。而本文中我们主要介绍触摸事件的分发流程，从Native层到Activity层触摸事件的分发了流程和按键的分发事件都是类似的，这里我们可以根据异常堆栈信息看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">at com.example.aaron.helloworld.MainActivity.dispatchTouchEvent(MainActivity.java:103)</span><br><span class="line">at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2359)</span><br><span class="line">at android.view.View.dispatchPointerEvent(View.java:8698)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4530)</span><br><span class="line">at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4388)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4053)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)</span><br><span class="line">at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4110)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)</span><br><span class="line">at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)</span><br><span class="line">at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6345)</span><br><span class="line">at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6301)</span><br><span class="line">at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6254)</span><br><span class="line">at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6507)</span><br><span class="line">at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185)</span><br></pre></td></tr></table></figure>
<p>这样经过一系列的方法调用之后最终调用了Activity的dispatchTouchEvent方法，而我们也是从Activiyt的dispatchTouchEvent方法开始对触摸事件的分发进行分析。</p>
<p>在具体查看Activity的dispatchTouchEvent方法之前我们先简单介绍一下触摸事件，触摸事件是由一个触摸按下事件、N个触摸滑动事件和一个触摸抬起事件组成的，通常的一个触摸事件中只能存在一个触摸按下和一个触摸抬起事件，但是触摸滑动事件可以有零个或者多个。好了，知道这个概念以后，下面我们就具体看一下Activity中的dispatchTouchEvent的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在看一下dispatchTouchEvent方法之前我们首先需要解释一下MotionEvent的概念。MotionEvent是一个触摸动作的封装，里面包含了触摸动作的类型，以及操作等属性，我们具体的可以看一下MotionEvent的说明：</p>
<blockquote>
<p>Object used to report movement (mouse, pen, finger, trackball) events. Motion events may hold either absolute or relative movements and other data, depending on the type of device.</p>
</blockquote>
<p>然后在dispatchTouchEvent方法中，会首先判断MotionEvent的动作类型，也就是我们的触目动作的类型，判断其是否是“按下”操作，若是的湖泽，则执行onUserInteraction方法，这个方法又是实现了什么逻辑呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void onUserInteraction() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现其在Activity中只是一个简单的空实现方法，同样的我们可以看一下该方法的介绍：</p>
<blockquote>
<p>Called whenever a key, touch, or trackball event is dispatched to the activity.  Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and {@link #onUserLeaveHint} are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication.</p>
</blockquote>
<p>理解上就是用户在触屏点击，按home，back，menu键都会触发此方法。</p>
<p>回到Activity的dispatchTouchEvent方法中，我们调用了getWindow().suerDispatchTouchEvent()方法，我们分析过Activity的加载绘制流程，而这里的getWindow()就是返回Activity中的mWindow对象，而我们知道Activity中的mWindow对象就是一个PhoneWindow的实例。并且这里的window.superDispatchTouchEvent若返回值为ture，则直接返回true，否则的话会执行Activity的onTouchEvent方法，继续我们看一下PhoneWindow的superDispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在PhoneWindow中的superDispatchTouchEvent方法中调用的是mDecor.superDispatchTouchEvent方法，而这里的mDecor是我们Activity显示的ViewTree的根View，并且mDecor是一个FrameLayout的子类，所以这里我们看一下mDecor的superDispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final class DecorView extends FrameLayout implements RootViewSurfaceTaker&#123;</span><br><span class="line">	...</span><br><span class="line">	public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return super.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DecorView的superDispatchTouchEvent方法中我们调用了super.dispatchTouchEvent方法，而我们的DecorView继承于FrameLayout，但是经过查看之后我们知道FrameLayout中并没有实现dispatchTouchEvent方法，而由于我们的FrameLayout继承于ViewGroup，所以这里的dispatchTouchEvent方法应该就是ViewGroup的dispatchTouchEvent方法。</p>
<p>好了，这里先暂时说一下Acitivty中的事件分发流程</p>
<ul>
<li><p>ViewRootImpl层的事件分发会首先调用Activity的dispatchTouchEvent方法；</p>
</li>
<li><p>Activity的dispatchTouchEvent方法中会通过Window.superDispatchTouchEvent方法将事件传递给DecorView即ViewGroup。</p>
</li>
<li><p>若window的superDispatchTouchEvent方法返回true，则事件分发完成，Activity的dispatchTouchEvent直接返回为true，否则的话调用Activity的onTouchEvent方法，并且Acitivty的dispatchTouchEvent返回值与Activity的onTouchEvent返回值一致。</p>
</li>
</ul>
<p>下面我们在继续看一下ViewGroup的dispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (mInputEventConsistencyVerifier !&#x3D; null) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the event targets the accessibility focused view and this is it, start</span><br><span class="line">        &#x2F;&#x2F; normal event dispatch. Maybe a descendant is what will handle the click.</span><br><span class="line">        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean handled &#x3D; false;</span><br><span class="line">        if (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">            final int action &#x3D; ev.getAction();</span><br><span class="line">            final int actionMasked &#x3D; action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Handle an initial down.</span><br><span class="line">            if (actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                &#x2F;&#x2F; Throw away all previous state when starting a new touch gesture.</span><br><span class="line">                &#x2F;&#x2F; The framework may have dropped the up or cancel event for the previous gesture</span><br><span class="line">                &#x2F;&#x2F; due to an app switch, ANR, or some other state change.</span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for interception.</span><br><span class="line">            final boolean intercepted;</span><br><span class="line">            if (actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN</span><br><span class="line">                    || mFirstTouchTarget !&#x3D; null) &#123;</span><br><span class="line">                final boolean disallowIntercept &#x3D; (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) !&#x3D; 0;</span><br><span class="line">                if (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted &#x3D; onInterceptTouchEvent(ev);</span><br><span class="line">                    ev.setAction(action); &#x2F;&#x2F; restore action in case it was changed</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    intercepted &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; There are no touch targets and this action is not an initial down</span><br><span class="line">                &#x2F;&#x2F; so this view group continues to intercept touches.</span><br><span class="line">                intercepted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If intercepted, start normal event dispatch. Also if there is already</span><br><span class="line">            &#x2F;&#x2F; a view that is handling the gesture, do normal event dispatch.</span><br><span class="line">            if (intercepted || mFirstTouchTarget !&#x3D; null) &#123;</span><br><span class="line">                ev.setTargetAccessibilityFocus(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check for cancelation.</span><br><span class="line">            final boolean canceled &#x3D; resetCancelNextUpFlag(this)</span><br><span class="line">                    || actionMasked &#x3D;&#x3D; MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Update list of touch targets for pointer down, if needed.</span><br><span class="line">            final boolean split &#x3D; (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) !&#x3D; 0;</span><br><span class="line">            TouchTarget newTouchTarget &#x3D; null;</span><br><span class="line">            boolean alreadyDispatchedToNewTouchTarget &#x3D; false;</span><br><span class="line">            if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; If the event is targeting accessiiblity focus we give it to the</span><br><span class="line">                &#x2F;&#x2F; view that has accessibility focus and if it does not handle it</span><br><span class="line">                &#x2F;&#x2F; we clear the flag and dispatch the event to all children as usual.</span><br><span class="line">                &#x2F;&#x2F; We are looking up the accessibility focused host to avoid keeping</span><br><span class="line">                &#x2F;&#x2F; state since these events are very rare.</span><br><span class="line">                View childWithAccessibilityFocus &#x3D; ev.isTargetAccessibilityFocus()</span><br><span class="line">                        ? findChildWithAccessibilityFocus() : null;</span><br><span class="line"></span><br><span class="line">                if (actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN</span><br><span class="line">                        || (split &amp;&amp; actionMasked &#x3D;&#x3D; MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                        || actionMasked &#x3D;&#x3D; MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                    final int actionIndex &#x3D; ev.getActionIndex(); &#x2F;&#x2F; always 0 for down</span><br><span class="line">                    final int idBitsToAssign &#x3D; split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                            : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Clean up earlier touch targets for this pointer id in case they</span><br><span class="line">                    &#x2F;&#x2F; have become out of sync.</span><br><span class="line">                    removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                    final int childrenCount &#x3D; mChildrenCount;</span><br><span class="line">                    if (newTouchTarget &#x3D;&#x3D; null &amp;&amp; childrenCount !&#x3D; 0) &#123;</span><br><span class="line">                        final float x &#x3D; ev.getX(actionIndex);</span><br><span class="line">                        final float y &#x3D; ev.getY(actionIndex);</span><br><span class="line">                        &#x2F;&#x2F; Find a child that can receive the event.</span><br><span class="line">                        &#x2F;&#x2F; Scan children from front to back.</span><br><span class="line">                        final ArrayList&lt;View&gt; preorderedList &#x3D; buildOrderedChildList();</span><br><span class="line">                        final boolean customOrder &#x3D; preorderedList &#x3D;&#x3D; null</span><br><span class="line">                                &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                        final View[] children &#x3D; mChildren;</span><br><span class="line">                        for (int i &#x3D; childrenCount - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                            final int childIndex &#x3D; customOrder</span><br><span class="line">                                    ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                            final View child &#x3D; (preorderedList &#x3D;&#x3D; null)</span><br><span class="line">                                    ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; If there is a view that has accessibility focus we want it</span><br><span class="line">                            &#x2F;&#x2F; to get the event first and if not handled we will perform a</span><br><span class="line">                            &#x2F;&#x2F; normal dispatch. We may do a double iteration but this is</span><br><span class="line">                            &#x2F;&#x2F; safer given the timeframe.</span><br><span class="line">                            if (childWithAccessibilityFocus !&#x3D; null) &#123;</span><br><span class="line">                                if (childWithAccessibilityFocus !&#x3D; child) &#123;</span><br><span class="line">                                    continue;</span><br><span class="line">                                &#125;</span><br><span class="line">                                childWithAccessibilityFocus &#x3D; null;</span><br><span class="line">                                i &#x3D; childrenCount - 1;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            if (!canViewReceivePointerEvents(child)</span><br><span class="line">                                    || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class="line">                                ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            newTouchTarget &#x3D; getTouchTarget(child);</span><br><span class="line">                            if (newTouchTarget !&#x3D; null) &#123;</span><br><span class="line">                                &#x2F;&#x2F; Child is already receiving touch within its bounds.</span><br><span class="line">                                &#x2F;&#x2F; Give it the new pointer in addition to the ones it is handling.</span><br><span class="line">                                newTouchTarget.pointerIdBits |&#x3D; idBitsToAssign;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            resetCancelNextUpFlag(child);</span><br><span class="line">                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                                &#x2F;&#x2F; Child wants to receive touch within its bounds.</span><br><span class="line">                                mLastTouchDownTime &#x3D; ev.getDownTime();</span><br><span class="line">                                if (preorderedList !&#x3D; null) &#123;</span><br><span class="line">                                    &#x2F;&#x2F; childIndex points into presorted list, find original index</span><br><span class="line">                                    for (int j &#x3D; 0; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                        if (children[childIndex] &#x3D;&#x3D; mChildren[j]) &#123;</span><br><span class="line">                                            mLastTouchDownIndex &#x3D; j;</span><br><span class="line">                                            break;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    mLastTouchDownIndex &#x3D; childIndex;</span><br><span class="line">                                &#125;</span><br><span class="line">                                mLastTouchDownX &#x3D; ev.getX();</span><br><span class="line">                                mLastTouchDownY &#x3D; ev.getY();</span><br><span class="line">                                newTouchTarget &#x3D; addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                                alreadyDispatchedToNewTouchTarget &#x3D; true;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; The accessibility focus didn&#39;t handle the event, so clear</span><br><span class="line">                            &#x2F;&#x2F; the flag and do a normal dispatch to all children.</span><br><span class="line">                            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (preorderedList !&#x3D; null) preorderedList.clear();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (newTouchTarget &#x3D;&#x3D; null &amp;&amp; mFirstTouchTarget !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Did not find a child to receive the event.</span><br><span class="line">                        &#x2F;&#x2F; Assign the pointer to the least recently added target.</span><br><span class="line">                        newTouchTarget &#x3D; mFirstTouchTarget;</span><br><span class="line">                        while (newTouchTarget.next !&#x3D; null) &#123;</span><br><span class="line">                            newTouchTarget &#x3D; newTouchTarget.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTouchTarget.pointerIdBits |&#x3D; idBitsToAssign;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Dispatch to touch targets.</span><br><span class="line">            if (mFirstTouchTarget &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; No touch targets so treat this as an ordinary view.</span><br><span class="line">                handled &#x3D; dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; Dispatch to touch targets, excluding the new touch target if we already</span><br><span class="line">                &#x2F;&#x2F; dispatched to it.  Cancel touch targets if necessary.</span><br><span class="line">                TouchTarget predecessor &#x3D; null;</span><br><span class="line">                TouchTarget target &#x3D; mFirstTouchTarget;</span><br><span class="line">                while (target !&#x3D; null) &#123;</span><br><span class="line">                    final TouchTarget next &#x3D; target.next;</span><br><span class="line">                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target &#x3D;&#x3D; newTouchTarget) &#123;</span><br><span class="line">                        handled &#x3D; true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        final boolean cancelChild &#x3D; resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;</span><br><span class="line">                        if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                                target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                            handled &#x3D; true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (cancelChild) &#123;</span><br><span class="line">                            if (predecessor &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                mFirstTouchTarget &#x3D; next;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                predecessor.next &#x3D; next;</span><br><span class="line">                            &#125;</span><br><span class="line">                            target.recycle();</span><br><span class="line">                            target &#x3D; next;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    predecessor &#x3D; target;</span><br><span class="line">                    target &#x3D; next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Update list of touch targets for pointer up or cancel, if needed.</span><br><span class="line">            if (canceled</span><br><span class="line">                    || actionMasked &#x3D;&#x3D; MotionEvent.ACTION_UP</span><br><span class="line">                    || actionMasked &#x3D;&#x3D; MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                resetTouchState();</span><br><span class="line">            &#125; else if (split &amp;&amp; actionMasked &#x3D;&#x3D; MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">                final int actionIndex &#x3D; ev.getActionIndex();</span><br><span class="line">                final int idBitsToRemove &#x3D; 1 &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">                removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!handled &amp;&amp; mInputEventConsistencyVerifier !&#x3D; null) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>前面我们知道触摸事件是由一个触摸按下事件，一个触摸抬起事件和N个触摸滑动事件组成的，而这里的触摸按下事件就是这里的ACTION_DOWN，同时友谊ACTION_DOWN是一系列事件的开端，所以我们在ACTION_DOWN时进行一些初始化操作，从上面源码中注释也可以看出来，清除以往的Touch状态然后开始新的手势。并在在cancelAndClearTouchTargets(ev)方法中将mFirstTouchTarget设置为了null，接着在resetTouchState()方法中重置Touch状态标识。</p>
<p>然后标记ViewGroup是否拦截Touch事件的传递，if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)这一条判断语句说明当事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立，否则if不成立，然后将intercepted设置为true，也即拦截事件。这里说明一下ViewGroup中的onInterceptTouchEvent方法是ViewGroup中特有的方法用于表示是否拦截触摸事件，返回为true的话则表示拦截事件，事件不在向子View中分发，若范围为false的话，则表示不拦截事件，继续分发事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一般的我们可以在自定义的ViewGroup中重写该方法，用于拦截事件的分发。而当我们在父ViewGroup重写该方法返回为true执行事件拦截的逻辑的时候，可以在子View中通过调用requestDisallowInterceptTouchEvent方法，重新设置父ViewGroup的onInterceptTouchEvent方法为false，不拦截对事件的分发逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept &#x3D;&#x3D; ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) !&#x3D; 0)) &#123;</span><br><span class="line">            &#x2F;&#x2F; We&#39;re already in this state, assume our ancestors are too</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (disallowIntercept) &#123;</span><br><span class="line">            mGroupFlags |&#x3D; FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mGroupFlags &amp;&#x3D; ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Pass it up to our parent</span><br><span class="line">        if (mParent !&#x3D; null) &#123;</span><br><span class="line">            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>比如常见的向我们的ViewPager中由于需要处理左右滑动事件从而在其onInterceptTouchEvent方法中重写了返回值，返回为true，拦截对事件的处理逻辑，但是若这时候ViewPager中嵌套了ListView，则listView也需要处理触摸事件的逻辑，但是ViewPager中已经重写了onInterceptTouchEvent方法，这时候怎么办呢？幸运的是ListView也在内部的实现中调用了requestDisallowInterceptTouchEvent方法，保证自身获得对触摸事件的处理。</p>
<p>然后在代码中我们判断childrenCount个数是否不为0，继续我们获取子View的list集合preorderedList；最后通过一个for循环倒序遍历所有的子view，这是因为preorderedList中的顺序是按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会因为Android的UI后刷新机制显示在上层；假如点击的地方有两个子View都包含的点击的坐标，那么后被添加到布局中的那个子view会先响应事件；也就是说后被添加的子view会浮在上层，点击的时候最上层的那个组件先去响应事件。</p>
<p>然后代码通过调用getTouchTarget去查找当前子View是否在mFirstTouchTarget.next这条target链中的某一个targe中，如果在则返回这个target，否则返回null。在这段代码的if判断通过说明找到了接收Touch事件的子View，即newTouchTarget，那么，既然已经找到了，所以执行break跳出for循环。如果没有break则继续向下执行，这里你可以看见一段if判断的代码if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))，那么这个方法又是执行什么逻辑的呢？</p>
<p>在该方法中为一个递归调用，会递归调用dispatchTouchEvent()方法。在dispatchTouchEvent()中如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()，如果子View为View那么就会调用其onTouchEvent()。dispatchTransformedTouchEvent方法如果返回true则表示子View消费掉该事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">            View child, int desiredPointerIdBits) &#123;</span><br><span class="line">        final boolean handled;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Canceling motions is a special case.  We don&#39;t need to perform any transformations</span><br><span class="line">        &#x2F;&#x2F; or filtering.  The important part is the action, not the contents.</span><br><span class="line">        final int oldAction &#x3D; event.getAction();</span><br><span class="line">        if (cancel || oldAction &#x3D;&#x3D; MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            if (child &#x3D;&#x3D; null) &#123;</span><br><span class="line">                handled &#x3D; super.dispatchTouchEvent(event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                handled &#x3D; child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            return handled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Calculate the number of pointers to deliver.</span><br><span class="line">        final int oldPointerIdBits &#x3D; event.getPointerIdBits();</span><br><span class="line">        final int newPointerIdBits &#x3D; oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If for some reason we ended up in an inconsistent state where it looks like we</span><br><span class="line">        &#x2F;&#x2F; might produce a motion event with no pointers in it, then drop the event.</span><br><span class="line">        if (newPointerIdBits &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If the number of pointers is the same and we don&#39;t need to perform any fancy</span><br><span class="line">        &#x2F;&#x2F; irreversible transformations, then we can reuse the motion event for this</span><br><span class="line">        &#x2F;&#x2F; dispatch as long as we are careful to revert any changes we make.</span><br><span class="line">        &#x2F;&#x2F; Otherwise we need to make a copy.</span><br><span class="line">        final MotionEvent transformedEvent;</span><br><span class="line">        if (newPointerIdBits &#x3D;&#x3D; oldPointerIdBits) &#123;</span><br><span class="line">            if (child &#x3D;&#x3D; null || child.hasIdentityMatrix()) &#123;</span><br><span class="line">                if (child &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    handled &#x3D; super.dispatchTouchEvent(event);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final float offsetX &#x3D; mScrollX - child.mLeft;</span><br><span class="line">                    final float offsetY &#x3D; mScrollY - child.mTop;</span><br><span class="line">                    event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                    handled &#x3D; child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                    event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">                &#125;</span><br><span class="line">                return handled;</span><br><span class="line">            &#125;</span><br><span class="line">            transformedEvent &#x3D; MotionEvent.obtain(event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            transformedEvent &#x3D; event.split(newPointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Perform any necessary transformations and dispatch.</span><br><span class="line">        if (child &#x3D;&#x3D; null) &#123;</span><br><span class="line">            handled &#x3D; super.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            final float offsetX &#x3D; mScrollX - child.mLeft;</span><br><span class="line">            final float offsetY &#x3D; mScrollY - child.mTop;</span><br><span class="line">            transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">            if (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">                transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handled &#x3D; child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Done.</span><br><span class="line">        transformedEvent.recycle();</span><br><span class="line">        return handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在在ViewGroup的dispatchTransformedTouchEvent方法中，调用了该ViewGroup的child View的dispatchTouchEvent方法，若其子View也是ViewGroup，则重复执行ViewGroup的dispatchTouchEvent方法，若其子View是View，则执行View的dispatchTouchEvent方法。</p>
<p>但这里大概分析了一下ViewGroup的事件分发流程</p>
<ul>
<li><p>首先在android的事件分发流程中，通过调用Activity的dispatchTouchEvent，事件会首先被派发是先传递到最顶级的DecorView也就是ViewGroup，再由ViewGroup递归传递到View的。</p>
</li>
<li><p>在ViewGroup中可以通过设置onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</p>
</li>
</ul>
<p>下面我们继续看一下View的dispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            &#x2F;&#x2F;noinspection SimplifiableIfStatement</span><br><span class="line">            ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">            if (li !&#x3D; null &amp;&amp; li.mOnTouchListener !&#x3D; null</span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) &#x3D;&#x3D; ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">                result &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>View的dispatchTouchEvent方法的内容比较长，我们重点看一下View对触摸事件的处理逻辑，首先调用了onFilterTouchEventForSecurity(event)方法判断当前的View是否被遮盖，若没有的话，则判断View的mListenerInfo城边变量是否为空，而这里的mListenerInfo又是什么呢？通过分析源码我们知道这里的mListenerInfo是通过setOnClickListener方法设置的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void setOnClickListener(@Nullable OnClickListener l) &#123;</span><br><span class="line">        if (!isClickable()) &#123;</span><br><span class="line">            setClickable(true);</span><br><span class="line">        &#125;</span><br><span class="line">        getListenerInfo().mOnClickListener &#x3D; l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以当前View一旦执行了setOnClickListener方法改View的mListenerInfo就不为空，若后有判断了该View是否可点击，最后是判断View的onTouchListener的onTouch方法的返回值。</p>
<p>所以当我们为当前View设置了OnTouchListener并且返回值为true的话，则直接执行其onTouch方法，若onTouch方法返回为true的话，则直接返回不在执行后续的View的onTouchEvent方法，否则继续执行View的onTouchEvent方法，而我们继续看一下View的onTouchEvent方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        final float x &#x3D; event.getX();</span><br><span class="line">        final float y &#x3D; event.getY();</span><br><span class="line">        final int viewFlags &#x3D; mViewFlags;</span><br><span class="line">        final int action &#x3D; event.getAction();</span><br><span class="line"></span><br><span class="line">        if ((viewFlags &amp; ENABLED_MASK) &#x3D;&#x3D; DISABLED) &#123;</span><br><span class="line">            if (action &#x3D;&#x3D; MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) !&#x3D; 0) &#123;</span><br><span class="line">                setPressed(false);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; A disabled view that is clickable still consumes the touch</span><br><span class="line">            &#x2F;&#x2F; events, it just doesn&#39;t respond to them.</span><br><span class="line">            return (((viewFlags &amp; CLICKABLE) &#x3D;&#x3D; CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) &#x3D;&#x3D; LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) &#x3D;&#x3D; CONTEXT_CLICKABLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mTouchDelegate !&#x3D; null) &#123;</span><br><span class="line">            if (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (((viewFlags &amp; CLICKABLE) &#x3D;&#x3D; CLICKABLE ||</span><br><span class="line">                (viewFlags &amp; LONG_CLICKABLE) &#x3D;&#x3D; LONG_CLICKABLE) ||</span><br><span class="line">                (viewFlags &amp; CONTEXT_CLICKABLE) &#x3D;&#x3D; CONTEXT_CLICKABLE) &#123;</span><br><span class="line">            switch (action) &#123;</span><br><span class="line">                case MotionEvent.ACTION_UP:</span><br><span class="line">                    boolean prepressed &#x3D; (mPrivateFlags &amp; PFLAG_PREPRESSED) !&#x3D; 0;</span><br><span class="line">                    if ((mPrivateFlags &amp; PFLAG_PRESSED) !&#x3D; 0 || prepressed) &#123;</span><br><span class="line">                        &#x2F;&#x2F; take focus if we don&#39;t have it already and we should in</span><br><span class="line">                        &#x2F;&#x2F; touch mode.</span><br><span class="line">                        boolean focusTaken &#x3D; false;</span><br><span class="line">                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken &#x3D; requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            &#x2F;&#x2F; The button is being released before we actually</span><br><span class="line">                            &#x2F;&#x2F; showed it as pressed.  Make it show the pressed</span><br><span class="line">                            &#x2F;&#x2F; state now (before scheduling the click) to ensure</span><br><span class="line">                            &#x2F;&#x2F; the user sees it.</span><br><span class="line">                            setPressed(true, x, y);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            &#x2F;&#x2F; This is a tap, so remove the longpress check</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; Only perform take click actions if we were in the pressed state</span><br><span class="line">                            if (!focusTaken) &#123;</span><br><span class="line">                                &#x2F;&#x2F; Use a Runnable and post this rather than calling</span><br><span class="line">                                &#x2F;&#x2F; performClick directly. This lets other visual state</span><br><span class="line">                                &#x2F;&#x2F; of the view update before click actions start.</span><br><span class="line">                                if (mPerformClick &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                    mPerformClick &#x3D; new PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (!post(mPerformClick)) &#123;</span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (mUnsetPressedState &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            mUnsetPressedState &#x3D; new UnsetPressedState();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            postDelayed(mUnsetPressedState,</span><br><span class="line">                                    ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                        &#125; else if (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                            &#x2F;&#x2F; If the post failed, unpress right now</span><br><span class="line">                            mUnsetPressedState.run();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIgnoreNextUpEvent &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_DOWN:</span><br><span class="line">                    mHasPerformedLongPress &#x3D; false;</span><br><span class="line"></span><br><span class="line">                    if (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Walk up the hierarchy to determine if we&#39;re inside a scrolling container.</span><br><span class="line">                    boolean isInScrollingContainer &#x3D; isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; For views inside a scrolling container, delay the pressed feedback for</span><br><span class="line">                    &#x2F;&#x2F; a short period in case this is a scroll.</span><br><span class="line">                    if (isInScrollingContainer) &#123;</span><br><span class="line">                        mPrivateFlags |&#x3D; PFLAG_PREPRESSED;</span><br><span class="line">                        if (mPendingCheckForTap &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            mPendingCheckForTap &#x3D; new CheckForTap();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingCheckForTap.x &#x3D; event.getX();</span><br><span class="line">                        mPendingCheckForTap.y &#x3D; event.getY();</span><br><span class="line">                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; Not inside a scrolling container, so show the feedback right away</span><br><span class="line">                        setPressed(true, x, y);</span><br><span class="line">                        checkForLongClick(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    setPressed(false);</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress &#x3D; false;</span><br><span class="line">                    mHasPerformedLongPress &#x3D; false;</span><br><span class="line">                    mIgnoreNextUpEvent &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case MotionEvent.ACTION_MOVE:</span><br><span class="line">                    drawableHotspotChanged(x, y);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Be lenient about moving outside of buttons</span><br><span class="line">                    if (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Outside button</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        if ((mPrivateFlags &amp; PFLAG_PRESSED) !&#x3D; 0) &#123;</span><br><span class="line">                            &#x2F;&#x2F; Remove any future long press&#x2F;tap checks</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            setPressed(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在ACTION为MotionEvent.ACTION_UP时，我们经过层层调用最终执行了performClick，方法而这个方法中我们回调了View的OnClickListener的onClick方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean performClick() &#123;</span><br><span class="line">        final boolean result;</span><br><span class="line">        final ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">        if (li !&#x3D; null &amp;&amp; li.mOnClickListener !&#x3D; null) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            li.mOnClickListener.onClick(this);</span><br><span class="line">            result &#x3D; true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以View组件分发触摸事件的时候：</p>
<ul>
<li><p>View控件会首先执行dispatchTouchEvent方法。</p>
</li>
<li><p>View控件在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法。</p>
</li>
<li><p>View的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调运onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。</p>
</li>
<li><p>View控件不是enable的，那么即使设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。</p>
</li>
<li><p>如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。</p>
</li>
</ul>
<p>参考：<br><a href="http://blog.csdn.net/xiaanming/article/details/21696315" target="_blank" rel="noopener">http://blog.csdn.net/xiaanming/article/details/21696315</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9097463" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9097463</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9153747" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9153747</a><br><a href="https://blog.csdn.net/suyimin2010/article/details/80958205" target="_blank" rel="noopener">https://blog.csdn.net/suyimin2010/article/details/80958205</a><br><a href="https://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">https://www.jianshu.com/p/e99b5e8bd67b</a><br><a href="https://juejin.im/entry/580042082e958a0055b6cbbc" target="_blank" rel="noopener">https://juejin.im/entry/580042082e958a0055b6cbbc</a><br><a href="https://juejin.im/entry/5928bfa92f301e0057d4f414" target="_blank" rel="noopener">解决 Android View 滑动冲突</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E7%B3%BB%E7%BB%9F%E5%B1%82/" rel="tag"># Android系统层</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/30/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-HashMap%E3%80%81ConcurrentHashMap/" rel="prev" title="JDK 源码解析 -- HashMap、ConcurrentHashMap">
      <i class="fa fa-chevron-left"></i> JDK 源码解析 -- HashMap、ConcurrentHashMap
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/30/1%20android%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/" rel="next" title="1 android项目构建流程">
      1 android项目构建流程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
