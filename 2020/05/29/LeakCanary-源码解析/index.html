<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一、 前言1. Java 内存模型     名称 特征 作用 配置参数 异常    程序计数器 占用内存小，线程私有，生命周期与线程相同 大致为字节码行号指示器 无 无   虚拟机栈 线程私有，生命周期与线程相同，使用连续的内存空间 Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息 -Xss StackOverflowError、OutOfMemoryError">
<meta property="og:type" content="article">
<meta property="og:title" content="LeakCanary 源码解析">
<meta property="og:url" content="http://yoursite.com/2020/05/29/LeakCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、 前言1. Java 内存模型     名称 特征 作用 配置参数 异常    程序计数器 占用内存小，线程私有，生命周期与线程相同 大致为字节码行号指示器 无 无   虚拟机栈 线程私有，生命周期与线程相同，使用连续的内存空间 Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息 -Xss StackOverflowError、OutOfMemoryError">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-2cac348b34cec6a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-ae32ae835a131864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-f743588dc091c83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-b38028b2e062bbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-42666d4316dae078.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-22d66e9d9eaa3a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-f26b0903a668ad77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-709824c69abcb277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-bb696c23031065fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2169292-41210c42d5eb1715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2020-05-29T15:49:03.383Z">
<meta property="article:modified_time" content="2020-06-07T09:42:26.885Z">
<meta property="article:author" content="yudesong">
<meta property="article:tag" content="Android开源框架源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2169292-2cac348b34cec6a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="canonical" href="http://yoursite.com/2020/05/29/LeakCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>LeakCanary 源码解析 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/LeakCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeakCanary 源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-29 23:49:03" itemprop="dateCreated datePublished" datetime="2020-05-29T23:49:03+08:00">2020-05-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h4><h6 id="1-Java-内存模型"><a href="#1-Java-内存模型" class="headerlink" title="1. Java 内存模型"></a>1. Java 内存模型</h6><p><img src="https://upload-images.jianshu.io/upload_images/2169292-2cac348b34cec6a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2169292-ae32ae835a131864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行时数据区域"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>特征</th>
<th>作用</th>
<th>配置参数</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>占用内存小，线程私有，生命周期与线程相同</td>
<td>大致为字节码行号指示器</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>线程私有，生命周期与线程相同，使用连续的内存空间</td>
<td>Java 方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息</td>
<td>-Xss</td>
<td>StackOverflowError、OutOfMemoryError</td>
</tr>
<tr>
<td>java堆</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>保存对象实例，所有对象实例（包括数组）都要在堆上分配</td>
<td>-Xms、-Xsx、-Xmn</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</td>
<td>-XX:PermSize:16M 、-XX:MaxPermSize64M</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>运行时常量池</td>
<td>方法区的一部分，具有动态性</td>
<td>存放字面量及符号引用</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="2-Java垃圾回收策略"><a href="#2-Java垃圾回收策略" class="headerlink" title="2. Java垃圾回收策略"></a>2. Java垃圾回收策略</h6><ul>
<li><strong>引用计数算法</strong>：给对象中添加一个引用计数器，每当有引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用。</li>
<li><strong>可达性分析算法</strong>：通过一系列的称为”GC Root”的对象作为起点，从这些节点开始向下搜索，搜素所走过的路径称为引用链（Reference Chain），当一个对象到GC Root没有任何的引用链相连，就判定对象可以被回收</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2169292-f743588dc091c83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象可达性"></p>
<h6 id="3-Java-四种引用类型"><a href="#3-Java-四种引用类型" class="headerlink" title="3. Java 四种引用类型"></a>3. Java 四种引用类型</h6><ul>
<li>强引用：默认的引用方式，当内存空间不足，JVM宁愿触发OOM，也不会对这部分内存进行回收。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">obj &#x3D; null;</span><br></pre></td></tr></table></figure></li>
<li>软引用(SoftReference)：当内存空间不足的时候，JVM会回收这部分内存，一般用来做缓存策略。</li>
<li>弱引用(WeakReference):  当GC回收的时候，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收这部分内存。</li>
<li>虚引用(PhantomReference):当 GC回收的时候会回收这部分内存， 主要用于检测对象是否已经从内存中删除。</li>
</ul>
<h6 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class TestReference &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line">        String sw &#x3D; &quot;虚引用&quot;;</span><br><span class="line"></span><br><span class="line">        switch (sw) &#123;</span><br><span class="line">            case &quot;软引用&quot;:</span><br><span class="line">                Object objSoft &#x3D; new Object();</span><br><span class="line">                SoftReference&lt;Object&gt; softReference &#x3D; new SoftReference&lt;&gt;(objSoft, referenceQueue);</span><br><span class="line">                System.out.println(&quot;GC前获取:&quot; + softReference.get());</span><br><span class="line">                objSoft &#x3D; null;</span><br><span class="line">                System.gc();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;GC后获取:&quot; + softReference.get());</span><br><span class="line">                System.out.println(&quot;队列中的结果:&quot; + referenceQueue.poll());</span><br><span class="line">                break;</span><br><span class="line">            case &quot;弱引用&quot;:</span><br><span class="line">                Object objWeak &#x3D; new Object();</span><br><span class="line">                WeakReference&lt;Object&gt; weakReference &#x3D; new WeakReference&lt;&gt;(objWeak, referenceQueue);</span><br><span class="line">                System.out.println(&quot;GC前获取:&quot; + weakReference.get());</span><br><span class="line">                objWeak &#x3D; null;</span><br><span class="line">                System.gc();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;GC后获取:&quot; + weakReference.get());</span><br><span class="line">                System.out.println(&quot;队列中的结果:&quot; + referenceQueue.poll());</span><br><span class="line">                break;</span><br><span class="line">            case &quot;虚引用&quot;:</span><br><span class="line">                Object objPhan &#x3D; new Object();</span><br><span class="line">                PhantomReference&lt;Object&gt; phantomReference &#x3D; new PhantomReference&lt;&gt;(objPhan, referenceQueue);</span><br><span class="line">                System.out.println(&quot;GC前获取:&quot; + phantomReference.get());</span><br><span class="line">                objPhan &#x3D; null;</span><br><span class="line">                System.gc();</span><br><span class="line">                &#x2F;&#x2F;此处的区别是当objPhan的内存被gc回收之前虚引用就会被加入到ReferenceQueue队列中，其他的引用都为当引用被gc掉时候，引用会加入到ReferenceQueue中</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;GC后获取:&quot; + phantomReference.get());</span><br><span class="line">                System.out.println(&quot;队列中的结果:&quot; + referenceQueue.poll());</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>软引用运行结果：</strong><br><img src="https://upload-images.jianshu.io/upload_images/2169292-b38028b2e062bbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="软引用运行结果"></p>
<p><strong>弱引用运行结果:</strong><br><img src="https://upload-images.jianshu.io/upload_images/2169292-42666d4316dae078.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="弱引用运行结果"></p>
<p><strong>虚引用运行结果:</strong><br><img src="https://upload-images.jianshu.io/upload_images/2169292-22d66e9d9eaa3a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚引用运行结果"></p>
<h4 id="二、-集成"><a href="#二、-集成" class="headerlink" title="二、 集成"></a>二、 集成</h4><p>build.gradle文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   &#x2F;&#x2F; debug 版本依赖</span><br><span class="line">  debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:1.6.2&#39;</span><br><span class="line">  &#x2F;&#x2F; release 版本依赖  </span><br><span class="line">  releaseImplementation &#39;com.squareup.leakcanary:leakcanary-android-no-op:1.6.2&#39;</span><br><span class="line">  &#x2F;&#x2F; 如果使用了 support fragment，请同时依赖</span><br><span class="line">  debugImplementation &#39;com.squareup.leakcanary:leakcanary-support-fragment:1.6.2&#39;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 最新2.0版本，只需要导入如下依赖，不再需要在Application里面添加其他代码</span><br><span class="line">  &#x2F;&#x2F; debugImplementation because LeakCanary should only run in debug builds.</span><br><span class="line">  &#x2F;&#x2F; debugImplementation &#39;com.squareup.leakcanary:leakcanary-android:2.0-alpha-2&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Application#onCreate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (LeakCanary.isInAnalyzerProcess(this)) &#123;</span><br><span class="line">  &#x2F;&#x2F; This process is dedicated to LeakCanary for heap analysis.</span><br><span class="line">  &#x2F;&#x2F; You should not init your app in this process.</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">LeakCanary.install(this);</span><br></pre></td></tr></table></figure>

<h4 id="三、-LeakCanary源码导读"><a href="#三、-LeakCanary源码导读" class="headerlink" title="三、 LeakCanary源码导读"></a>三、 LeakCanary源码导读</h4><h6 id="3-1-LeakCanary项目架构"><a href="#3-1-LeakCanary项目架构" class="headerlink" title="3.1.  LeakCanary项目架构"></a>3.1.  LeakCanary项目架构</h6><p><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a> 项目结构图：<br><img src="https://upload-images.jianshu.io/upload_images/2169292-f26b0903a668ad77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LeakCanary项目结构"></p>
<ul>
<li>leakcanary-analyzer : 负责分析内存泄漏</li>
<li>leakcanary-android : android 核心模块以及通知、界面展示等</li>
<li>leakcanary-android-instrumentation : 单元测试使用</li>
<li>leakcanary-sample : 使用案例</li>
<li>leakcanary-support-fragment : 支持 fragment v4包</li>
<li>leakcanary-watcher : 负责监听内存泄漏</li>
<li>leakcanary-android-no-op : release 版本使用</li>
</ul>
<h6 id="3-2-LeakCanary执行过程"><a href="#3-2-LeakCanary执行过程" class="headerlink" title="3.2.  LeakCanary执行过程"></a>3.2.  LeakCanary执行过程</h6><p><img src="https://upload-images.jianshu.io/upload_images/2169292-709824c69abcb277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LeakCanary执行过程"></p>
<h6 id="3-3-LeakCanary初始化"><a href="#3-3-LeakCanary初始化" class="headerlink" title="3.3.  LeakCanary初始化"></a>3.3.  LeakCanary初始化</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Whether the current process is the process running the &#123;@link HeapAnalyzerService&#125;, which is</span><br><span class="line"> * a different process than the normal app process.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static boolean isInAnalyzerProcess(@NonNull Context context) &#123;</span><br><span class="line">  Boolean isInAnalyzerProcess &#x3D; LeakCanaryInternals.isInAnalyzerProcess;</span><br><span class="line">  &#x2F;&#x2F; This only needs to be computed once per process.</span><br><span class="line">  Log.d(&quot;LeakCanary&quot;, &quot;isInAnalyzerProcess &#x3D; &quot; + isInAnalyzerProcess);</span><br><span class="line">  if (isInAnalyzerProcess &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; HeapAnalyzerService进程名是否等于主进程名称</span><br><span class="line">    isInAnalyzerProcess &#x3D; isInServiceProcess(context, HeapAnalyzerService.class);</span><br><span class="line">    LeakCanaryInternals.isInAnalyzerProcess &#x3D; isInAnalyzerProcess;</span><br><span class="line">  &#125;</span><br><span class="line">  return isInAnalyzerProcess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static @NonNull void install(@NonNull Application application) &#123;</span><br><span class="line">  refWatcher(application)</span><br><span class="line">      .listenerServiceClass(DisplayLeakService.class)  &#x2F;&#x2F; 设置 heapDumpListener</span><br><span class="line">      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) &#x2F;&#x2F; 去除Android SDK 引起的内存泄漏</span><br><span class="line">      .buildAndInstall();  &#x2F;&#x2F;创建RefWatcher</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) &#123;</span><br><span class="line">  return new AndroidRefWatcherBuilder(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isInAnalyzerProcess方法，用于检测内存分析进程是否和主进程名相同，如果是相同的，则设置RefWatcher = DISABLED ，不做任何处理。release 版本是通过以下以来确定的。<br>// release 版本依赖<br>releaseImplementation ‘com.squareup.leakcanary:leakcanary-android-no-op:1.6.2’</p>
<h6 id="3-4-AndroidRefWatcherBuilder-对象"><a href="#3-4-AndroidRefWatcherBuilder-对象" class="headerlink" title="3.4  AndroidRefWatcherBuilder 对象"></a>3.4  AndroidRefWatcherBuilder 对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public @NonNull AndroidRefWatcherBuilder listenerServiceClass(</span><br><span class="line">    @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) &#123;</span><br><span class="line">  &#x2F;&#x2F; isAssignableFrom()方法是判断是否为某个类的父类，instanceof()方法是判断是否某个类的子类。</span><br><span class="line">  &#x2F;&#x2F;（https:&#x2F;&#x2F;www.cnblogs.com&#x2F;bethunebtj&#x2F;p&#x2F;4681438.html）</span><br><span class="line">  enableDisplayLeakActivity &#x3D; DisplayLeakService.class.isAssignableFrom(listenerServiceClass);</span><br><span class="line">  return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final T heapDumpListener(HeapDump.Listener heapDumpListener) &#123;</span><br><span class="line">    this.heapDumpListener &#x3D; heapDumpListener;</span><br><span class="line">    return self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final T excludedRefs(ExcludedRefs excludedRefs) &#123;</span><br><span class="line">  heapDumpBuilder.excludedRefs(excludedRefs);</span><br><span class="line">  return self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override protected @NonNull HeapDumper defaultHeapDumper() &#123;</span><br><span class="line">  LeakDirectoryProvider leakDirectoryProvider &#x3D;</span><br><span class="line">      LeakCanaryInternals.getLeakDirectoryProvider(context);</span><br><span class="line">  return new AndroidHeapDumper(context, leakDirectoryProvider);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public @NonNull RefWatcher buildAndInstall() &#123;</span><br><span class="line">  if (LeakCanaryInternals.installedRefWatcher !&#x3D; null) &#123;</span><br><span class="line">    throw new UnsupportedOperationException(&quot;buildAndInstall() should only be called once.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  RefWatcher refWatcher &#x3D; build();</span><br><span class="line">  if (refWatcher !&#x3D; DISABLED) &#123;</span><br><span class="line">    Log.d(&quot;LeakCanary&quot;, &quot;enableDisplayLeakActivity &#x3D; &quot; + enableDisplayLeakActivity);</span><br><span class="line">    if (enableDisplayLeakActivity) &#123;</span><br><span class="line">      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(&quot;LeakCanary&quot;, &quot;watchActivities &#x3D; &quot; + watchActivities);</span><br><span class="line">    if (watchActivities) &#123;</span><br><span class="line">      ActivityRefWatcher.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(&quot;LeakCanary&quot;, &quot;watchFragments &#x3D; &quot; + watchFragments);</span><br><span class="line">    if (watchFragments) &#123;</span><br><span class="line">      FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LeakCanaryInternals.installedRefWatcher &#x3D; refWatcher;</span><br><span class="line">  return refWatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final RefWatcher build() &#123;</span><br><span class="line">    if (isDisabled()) &#123;</span><br><span class="line">        return RefWatcher.DISABLED; </span><br><span class="line">    &#125;</span><br><span class="line">    if (heapDumpBuilder.excludedRefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">        heapDumpBuilder.excludedRefs(defaultExcludedRefs());</span><br><span class="line">    &#125;</span><br><span class="line">    HeapDump.Listener heapDumpListener &#x3D; this.heapDumpListener;</span><br><span class="line">    if (heapDumpListener &#x3D;&#x3D; null) &#123;</span><br><span class="line">        heapDumpListener &#x3D; defaultHeapDumpListener();</span><br><span class="line">    &#125;</span><br><span class="line">    DebuggerControl debuggerControl &#x3D; this.debuggerControl;</span><br><span class="line">    if (debuggerControl &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 走这里</span><br><span class="line">        debuggerControl &#x3D; defaultDebuggerControl();</span><br><span class="line">    &#125;</span><br><span class="line">    HeapDumper heapDumper &#x3D; this.heapDumper;</span><br><span class="line">    if (heapDumper &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 走这里</span><br><span class="line">        heapDumper &#x3D; defaultHeapDumper();</span><br><span class="line">    &#125;</span><br><span class="line">    WatchExecutor watchExecutor &#x3D; this.watchExecutor;</span><br><span class="line">    if (watchExecutor &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 走这里</span><br><span class="line">        watchExecutor &#x3D; defaultWatchExecutor();</span><br><span class="line">    &#125;</span><br><span class="line">    GcTrigger gcTrigger &#x3D; this.gcTrigger;</span><br><span class="line">    if (gcTrigger &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 走这里</span><br><span class="line">        gcTrigger &#x3D; defaultGcTrigger();</span><br><span class="line">    &#125;</span><br><span class="line">    if (heapDumpBuilder.reachabilityInspectorClasses &#x3D;&#x3D; null) &#123;</span><br><span class="line">        heapDumpBuilder.reachabilityInspectorClasses(defaultReachabilityInspectorClasses());</span><br><span class="line">    &#125;</span><br><span class="line">    return new RefWatcher(watchExecutor, debuggerControl, gcTrigger</span><br><span class="line">                          , heapDumper, heapDumpListener, heapDumpBuilder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override protected @NonNull WatchExecutor defaultWatchExecutor() &#123;</span><br><span class="line">  return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buildAndInstall方法则用于设置heapDumpListener用于分析hprof文件， 过滤掉因为Android SDK引起的系统内存泄漏引用， 展示DisplayLeakActivity桌面icon，监听Activity 以及Fragment生命周期，在其销毁的时候调用RefWatcher的watch方法分析是否会发生内存泄漏对象。build方法则是初始化RefWatcher对象，</p>
<p>关于设置DisplayLeakActivity enabled = true的地方，需要看看详细的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);</span><br><span class="line"></span><br><span class="line">public static void setEnabledAsync(Context context, final Class&lt;?&gt; componentClass,</span><br><span class="line">                                   final boolean enabled) &#123;</span><br><span class="line">    final Context appContext &#x3D; context.getApplicationContext();</span><br><span class="line">    AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            setEnabledBlocking(appContext, componentClass, enabled);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void setEnabledBlocking(Context appContext, Class&lt;?&gt; componentClass,</span><br><span class="line">                                      boolean enabled) &#123;</span><br><span class="line">    ComponentName component &#x3D; new ComponentName(appContext, componentClass);</span><br><span class="line">    PackageManager packageManager &#x3D; appContext.getPackageManager();</span><br><span class="line">    int newState &#x3D; enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;</span><br><span class="line">    &#x2F;&#x2F; Blocks on IPC.</span><br><span class="line">    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是利用AsyncTask的THREAD_POOL_EXECUTOR线程池去执行PackageManager的setComponentEnabledSetting方法，动态设置COMPONENT_ENABLED_STATE_ENABLED<br><img src="https://upload-images.jianshu.io/upload_images/2169292-bb696c23031065fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="3-5-RefWatcher-对象"><a href="#3-5-RefWatcher-对象" class="headerlink" title="3.5  RefWatcher 对象"></a>3.5  RefWatcher 对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">private final Set&lt;String&gt; retainedKeys;</span><br><span class="line">private final ReferenceQueue&lt;Object&gt; queue; &#x2F;&#x2F; 引用队列</span><br><span class="line"></span><br><span class="line">public void watch(Object watchedReference) &#123;</span><br><span class="line">  watch(watchedReference, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void watch(Object watchedReference, String referenceName) &#123;</span><br><span class="line">  if (this &#x3D;&#x3D; DISABLED) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  checkNotNull(watchedReference, &quot;watchedReference&quot;);</span><br><span class="line">  checkNotNull(referenceName, &quot;referenceName&quot;);</span><br><span class="line">  final long watchStartNanoTime &#x3D; System.nanoTime();</span><br><span class="line">  String key &#x3D; UUID.randomUUID().toString();</span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  final KeyedWeakReference reference &#x3D;</span><br><span class="line">      new KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line"></span><br><span class="line">  ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureGoneAsync(final long watchStartNanoTime,</span><br><span class="line">                             final KeyedWeakReference reference) &#123;</span><br><span class="line">  &#x2F;&#x2F; 检测线程调度器</span><br><span class="line">  watchExecutor.execute(new Retryable() &#123;</span><br><span class="line">    @Override public Retryable.Result run() &#123;</span><br><span class="line">      return ensureGone(reference, watchStartNanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123;</span><br><span class="line">  long gcStartNanoTime &#x3D; System.nanoTime();</span><br><span class="line">  long watchDurationMs &#x3D; NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 移除所有弱引用可达对象</span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果VM正连接到Debuger，忽略这次检测，因为Debugger可能会持有一些在当前上下文中不可见的对象，导致误判</span><br><span class="line">  if (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">    &#x2F;&#x2F; The debugger can create false leaks.</span><br><span class="line">    return RETRY;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;上面执行 removeWeaklyReachableReferences 方法，判断是不是监视对象已经被回收了，如果被回收了，那么说明没有发生内存泄漏，直接结束</span><br><span class="line">  if (gone(reference)) &#123;</span><br><span class="line">    return DONE;</span><br><span class="line">  &#125;</span><br><span class="line">   &#x2F;&#x2F; 手动触发一次 GC 垃圾回收</span><br><span class="line">  gcTrigger.runGc();</span><br><span class="line">  &#x2F;&#x2F; 再次移除所有弱引用可达对象</span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line">  if (!gone(reference)) &#123;</span><br><span class="line">    long startDumpHeap &#x3D; System.nanoTime();</span><br><span class="line">    long gcDurationMs &#x3D; NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">    &#x2F;&#x2F; 利用Debug生成Hprof文件</span><br><span class="line">    File heapDumpFile &#x3D; heapDumper.dumpHeap();</span><br><span class="line">    if (heapDumpFile &#x3D;&#x3D; RETRY_LATER) &#123;</span><br><span class="line">      &#x2F;&#x2F; Could not dump the heap.</span><br><span class="line">      return RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    long heapDumpDurationMs &#x3D; NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line"></span><br><span class="line">    HeapDump heapDump &#x3D; heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class="line">        .referenceName(reference.name)</span><br><span class="line">        .watchDurationMs(watchDurationMs)</span><br><span class="line">        .gcDurationMs(gcDurationMs)</span><br><span class="line">        .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    heapdumpListener.analyze(heapDump);  &#x2F;&#x2F; 开始分析hprof文件</span><br><span class="line">  &#125;</span><br><span class="line">  return DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean gone(KeyedWeakReference reference) &#123;</span><br><span class="line">  return !retainedKeys.contains(reference.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void removeWeaklyReachableReferences() &#123;</span><br><span class="line">  &#x2F;&#x2F; WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span><br><span class="line">  &#x2F;&#x2F; reachable. This is before finalization or garbage collection has actually happened.</span><br><span class="line">  KeyedWeakReference ref;</span><br><span class="line">  while ((ref &#x3D; (KeyedWeakReference) queue.poll()) !&#x3D; null) &#123;</span><br><span class="line">    retainedKeys.remove(ref.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RefWatcher很重要的方法就是watch方法， 其中参数watchedReference就是对应的view、activity、fragment对象。 通过UUID 函数生成唯一的标识添加到Set<String>集合当中。 KeyedWeakReference继承了WeakReference，关联了watchedReference。当进弱引用对象发生回收的时候，虚拟机就会向该引用添加到与之关联的引用队列当中。</p>
<p>检测内存是否泄漏的过程也很简单：首先会清除所有的弱引用可达对象， 判断watchedReference对象是否已经被回收了， 如果没有，则手动进行一个GC，二次确认watchedReference对象是否被回收，如果没被回收则dump hprof文件，通知heapdumpListener分析hprof文件</p>
<h6 id="3-6-AndroidWatchExecutor-类"><a href="#3-6-AndroidWatchExecutor-类" class="headerlink" title="3.6.  AndroidWatchExecutor 类"></a>3.6.  AndroidWatchExecutor 类</h6> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public final class AndroidWatchExecutor implements WatchExecutor &#123;</span><br><span class="line"></span><br><span class="line">  static final String LEAK_CANARY_THREAD_NAME &#x3D; &quot;LeakCanary-Heap-Dump&quot;;</span><br><span class="line">  private final Handler mainHandler;</span><br><span class="line">  private final Handler backgroundHandler;</span><br><span class="line">  private final long initialDelayMillis;</span><br><span class="line">  private final long maxBackoffFactor;</span><br><span class="line"></span><br><span class="line">  public AndroidWatchExecutor(long initialDelayMillis) &#123;</span><br><span class="line">    mainHandler &#x3D; new Handler(Looper.getMainLooper());</span><br><span class="line">    HandlerThread handlerThread &#x3D; new HandlerThread(LEAK_CANARY_THREAD_NAME);</span><br><span class="line">    handlerThread.start();</span><br><span class="line">    backgroundHandler &#x3D; new Handler(handlerThread.getLooper());</span><br><span class="line">    this.initialDelayMillis &#x3D; initialDelayMillis;</span><br><span class="line">    maxBackoffFactor &#x3D; Long.MAX_VALUE &#x2F; initialDelayMillis;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public void execute(@NonNull Retryable retryable) &#123;</span><br><span class="line">    if (Looper.getMainLooper().getThread() &#x3D;&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">      waitForIdle(retryable, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      postWaitForIdle(retryable, 0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void postWaitForIdle(final Retryable retryable, final int failedAttempts) &#123;</span><br><span class="line">    mainHandler.post(new Runnable() &#123;</span><br><span class="line">      @Override public void run() &#123;</span><br><span class="line">        waitForIdle(retryable, failedAttempts);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void waitForIdle(final Retryable retryable, final int failedAttempts) &#123;</span><br><span class="line">    &#x2F;&#x2F; This needs to be called from the main thread.</span><br><span class="line">    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</span><br><span class="line">      @Override public boolean queueIdle() &#123;</span><br><span class="line">        postToBackgroundWithDelay(retryable, failedAttempts);</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) &#123;</span><br><span class="line">    long exponentialBackoffFactor &#x3D; (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor);</span><br><span class="line">    long delayMillis &#x3D; initialDelayMillis * exponentialBackoffFactor;</span><br><span class="line">    &#x2F;&#x2F; 利用HandlerThread对象里面的Looper进行子线程任务</span><br><span class="line">    backgroundHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">      @Override public void run() &#123;</span><br><span class="line">        Retryable.Result result &#x3D; retryable.run();</span><br><span class="line">        if (result &#x3D;&#x3D; RETRY) &#123;</span><br><span class="line">          postWaitForIdle(retryable, failedAttempts + 1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, delayMillis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WatchExecutor 是一个线程调度器。包含了一个主线程 mainHandler 和后台线程backgroundHandler。整个的逻辑就是当主线程空闲的时候，才回去启动后台线程去执行Retryable.run方法。</p>
<h6 id="3-7-AndroidHeapDumper-生成hprof文件"><a href="#3-7-AndroidHeapDumper-生成hprof文件" class="headerlink" title="3.7.  AndroidHeapDumper 生成hprof文件"></a>3.7.  AndroidHeapDumper 生成hprof文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public File dumpHeap() &#123;</span><br><span class="line">  &#x2F;&#x2F; 生成hprof文件</span><br><span class="line">  File heapDumpFile &#x3D; leakDirectoryProvider.newHeapDumpFile();</span><br><span class="line"></span><br><span class="line">  if (heapDumpFile &#x3D;&#x3D; RETRY_LATER) &#123;</span><br><span class="line">    return RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FutureResult&lt;Toast&gt; waitingForToast &#x3D; new FutureResult&lt;&gt;();</span><br><span class="line">  showToast(waitingForToast);</span><br><span class="line"></span><br><span class="line">  if (!waitingForToast.wait(5, SECONDS)) &#123;</span><br><span class="line">    Log.d(&quot;LeakCanary&quot;, &quot;Did not dump heap, too much time waiting for Toast.&quot;);</span><br><span class="line">    CanaryLog.d(&quot;Did not dump heap, too much time waiting for Toast.&quot;);</span><br><span class="line">    return RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 创建正在dumping通知</span><br><span class="line">  Notification.Builder builder &#x3D; new Notification.Builder(context)</span><br><span class="line">      .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));</span><br><span class="line">  Notification notification &#x3D; LeakCanaryInternals.buildNotification(context, builder);</span><br><span class="line">  NotificationManager notificationManager &#x3D;</span><br><span class="line">      (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">  int notificationId &#x3D; (int) SystemClock.uptimeMillis();</span><br><span class="line">  notificationManager.notify(notificationId, notification);</span><br><span class="line"></span><br><span class="line">  Toast toast &#x3D; waitingForToast.get();</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 系统Debug类提供的方法</span><br><span class="line">    Debug.dumpHprofData(heapDumpFile.getAbsolutePath());</span><br><span class="line">    cancelToast(toast);</span><br><span class="line">    notificationManager.cancel(notificationId);</span><br><span class="line">    return heapDumpFile;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    CanaryLog.d(e, &quot;Could not dump heap&quot;);</span><br><span class="line">    &#x2F;&#x2F; Abort heap dump</span><br><span class="line">    return RETRY_LATER;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void showToast(final FutureResult&lt;Toast&gt; waitingForToast) &#123;</span><br><span class="line">  mainHandler.post(new Runnable() &#123;</span><br><span class="line">    @Override public void run() &#123;</span><br><span class="line">      if (resumedActivity &#x3D;&#x3D; null) &#123;</span><br><span class="line">        waitingForToast.set(null);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      final Toast toast &#x3D; new Toast(resumedActivity);</span><br><span class="line">      toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);</span><br><span class="line">      toast.setDuration(Toast.LENGTH_LONG);</span><br><span class="line">      LayoutInflater inflater &#x3D; LayoutInflater.from(resumedActivity);</span><br><span class="line">      toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));</span><br><span class="line">      toast.show();</span><br><span class="line">      &#x2F;&#x2F; Waiting for Idle to make sure Toast gets rendered.</span><br><span class="line">      Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</span><br><span class="line">        @Override public boolean queueIdle() &#123;</span><br><span class="line">          waitingForToast.set(toast);</span><br><span class="line">          Log.d(&quot;LeakCanary&quot;, &quot;latch.countDown()&quot;);</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dumpHeap方法利用Debug.dumpHprofData(String filePath)生成hprof文件，同时会展示Toast以及通知栏状态。如果dump失败或者Toast展示时间太长就会返回RETRY_LATER。</p>
<h6 id="3-8-HeapAnalyzerService-分析hprof文件，找出泄漏路径"><a href="#3-8-HeapAnalyzerService-分析hprof文件，找出泄漏路径" class="headerlink" title="3.8  HeapAnalyzerService 分析hprof文件，找出泄漏路径"></a>3.8  HeapAnalyzerService 分析hprof文件，找出泄漏路径</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override protected void onHandleIntentInForeground(@Nullable Intent intent) &#123;</span><br><span class="line">  if (intent &#x3D;&#x3D; null) &#123;</span><br><span class="line">    CanaryLog.d(&quot;HeapAnalyzerService received a null intent, ignoring.&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  String listenerClassName &#x3D; intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">  HeapDump heapDump &#x3D; (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line"></span><br><span class="line">  HeapAnalyzer heapAnalyzer &#x3D;</span><br><span class="line">      new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);</span><br><span class="line"></span><br><span class="line">  Log.d(&quot;LeakCanary&quot;, &quot;leak path:&quot; + heapDump.heapDumpFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">  AnalysisResult result &#x3D; heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,</span><br><span class="line">      heapDump.computeRetainedHeapSize);</span><br><span class="line">  AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeapAnalyzer 是hprof文件解析类， 使用了squareup的另外一个开源库—Haha。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,</span><br><span class="line">    @NonNull String referenceKey,</span><br><span class="line">    boolean computeRetainedSize) &#123;</span><br><span class="line">  long analysisStartNanoTime &#x3D; System.nanoTime();</span><br><span class="line"></span><br><span class="line">  Log.d(&quot;LeakCanary&quot;, &quot;heapDumpFile path:&quot; + heapDumpFile.getAbsolutePath());</span><br><span class="line">  Log.d(&quot;LeakCanary&quot;, &quot;referenceKey &#x3D; &quot; + referenceKey);</span><br><span class="line">  if (!heapDumpFile.exists()) &#123;</span><br><span class="line">    Exception exception &#x3D; new IllegalArgumentException(&quot;File does not exist: &quot; + heapDumpFile);</span><br><span class="line">    return failure(exception, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Hprof 文件协议介绍： https:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;217380&#x2F;blog&#x2F;1507542</span><br><span class="line">  try &#123;</span><br><span class="line">    listener.onProgressUpdate(READING_HEAP_DUMP_FILE);</span><br><span class="line">    &#x2F;&#x2F; 把hprof文件映射到内存 ByteBuffer[]</span><br><span class="line">    HprofBuffer buffer &#x3D; new MemoryMappedFileBuffer(heapDumpFile);</span><br><span class="line">    HprofParser parser &#x3D; new HprofParser(buffer);</span><br><span class="line">    listener.onProgressUpdate(PARSING_HEAP_DUMP);</span><br><span class="line">    &#x2F;&#x2F; 创建了HprofParser对象，parse方法解析hprof协议，生成Snapshot</span><br><span class="line">    Snapshot snapshot &#x3D; parser.parse();</span><br><span class="line">    listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);</span><br><span class="line">    &#x2F;&#x2F; 去除重复的GC root对象</span><br><span class="line">    deduplicateGcRoots(snapshot);</span><br><span class="line">    listener.onProgressUpdate(FINDING_LEAKING_REF);</span><br><span class="line">    Instance leakingRef &#x3D; findLeakingReference(referenceKey, snapshot);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 此对象不存在，表示已经被gc清除了，不存在泄露因此返回无泄漏</span><br><span class="line">    &#x2F;&#x2F; False alarm, weak reference was cleared in between key check and heap dump.</span><br><span class="line">    if (leakingRef &#x3D;&#x3D; null) &#123;</span><br><span class="line">      String className &#x3D; leakingRef.getClassObj().getClassName();</span><br><span class="line">      return noLeak(className, since(analysisStartNanoTime));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 此对象存在, 也不能确认它内存泄漏了，要检测此对象的gc root</span><br><span class="line">    return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);</span><br><span class="line">  &#125; catch (Throwable e) &#123;</span><br><span class="line">    return failure(e, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/2169292-41210c42d5eb1715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h6 id="3-9-DisplayLeakService-生成内存泄漏通知栏"><a href="#3-9-DisplayLeakService-生成内存泄漏通知栏" class="headerlink" title="3.9  DisplayLeakService 生成内存泄漏通知栏"></a>3.9  DisplayLeakService 生成内存泄漏通知栏</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) &#123;</span><br><span class="line">  Log.d(&quot;LeakCanary&quot;, &quot;[DisplayLeakService]: onHeapAnalyzed&quot;);</span><br><span class="line">  HeapDump heapDump &#x3D; analyzedHeap.heapDump;</span><br><span class="line">  AnalysisResult result &#x3D; analyzedHeap.result;</span><br><span class="line"></span><br><span class="line">  String leakInfo &#x3D; leakInfo(this, heapDump, result, true);</span><br><span class="line">  CanaryLog.d(&quot;%s&quot;, leakInfo);</span><br><span class="line"></span><br><span class="line">  heapDump &#x3D; renameHeapdump(heapDump);</span><br><span class="line">  boolean resultSaved &#x3D; saveResult(heapDump, result);</span><br><span class="line"></span><br><span class="line">  String contentTitle;</span><br><span class="line">  if (resultSaved) &#123;</span><br><span class="line">    PendingIntent pendingIntent &#x3D;</span><br><span class="line">        DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);</span><br><span class="line">    if (result.failure !&#x3D; null) &#123;</span><br><span class="line">      contentTitle &#x3D; &quot;Leak analysis failed&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      String className &#x3D; classSimpleName(result.className);</span><br><span class="line">      if (result.leakFound) &#123;</span><br><span class="line">        if (result.retainedHeapSize &#x3D;&#x3D; AnalysisResult.RETAINED_HEAP_SKIPPED) &#123;</span><br><span class="line">          if (result.excludedLeak) &#123;</span><br><span class="line">            contentTitle &#x3D; getString(R.string.leak_canary_leak_excluded, className);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            contentTitle &#x3D; getString(R.string.leak_canary_class_has_leaked, className);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          String size &#x3D; formatShortFileSize(this, result.retainedHeapSize);</span><br><span class="line">          if (result.excludedLeak) &#123;</span><br><span class="line">            contentTitle &#x3D;</span><br><span class="line">                getString(R.string.leak_canary_leak_excluded_retaining, className, size);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            contentTitle &#x3D;</span><br><span class="line">                getString(R.string.leak_canary_class_has_leaked_retaining, className, size);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        contentTitle &#x3D; getString(R.string.leak_canary_class_no_leak, className);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String contentText &#x3D; getString(R.string.leak_canary_notification_message);</span><br><span class="line">    showNotification(pendingIntent, contentTitle, contentText);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  afterDefaultHandling(heapDump, result, leakInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、LeakCanary不足"><a href="#四、LeakCanary不足" class="headerlink" title="四、LeakCanary不足"></a>四、LeakCanary不足</h5><p>虽然 LeakCanary 有诸多优点，但是它也有做不到的地方，比如说检测申请大容量内存导致的OOM问题、Bitmap内存未释放问题，Service 中的内存泄漏可能无法检测等。</p>
<h6 id="五、延申阅读"><a href="#五、延申阅读" class="headerlink" title="五、延申阅读"></a>五、延申阅读</h6><p><a href="https://mp.weixin.qq.com/s/XL55txToSCJXM8ErwrUGMw" target="_blank" rel="noopener">1. Matrix ResourceCanary – Activity 泄漏及Bitmap冗余检测</a><br><a href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088" target="_blank" rel="noopener">2. Hprof 文件协议</a><br><a href="https://juejin.im/post/57ffa4290e3dd90057ea2a83" target="_blank" rel="noopener">3. GC那些事儿–Android内存优化第一弹</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># Android开源框架源码分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/28/Hexo%20%E4%BD%BF%E7%94%A8/" rel="prev" title="Hexo 使用">
      <i class="fa fa-chevron-left"></i> Hexo 使用
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/29/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" rel="next" title="JDK 源码解析 -- 集合框架">
      JDK 源码解析 -- 集合框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、-前言"><span class="nav-number">1.</span> <span class="nav-text">一、 前言</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Java-内存模型"><span class="nav-number">1.0.1.</span> <span class="nav-text">1. Java 内存模型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Java垃圾回收策略"><span class="nav-number">1.0.2.</span> <span class="nav-text">2. Java垃圾回收策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-Java-四种引用类型"><span class="nav-number">1.0.3.</span> <span class="nav-text">3. Java 四种引用类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#代码示例"><span class="nav-number">1.0.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、-集成"><span class="nav-number">2.</span> <span class="nav-text">二、 集成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、-LeakCanary源码导读"><span class="nav-number">3.</span> <span class="nav-text">三、 LeakCanary源码导读</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#3-1-LeakCanary项目架构"><span class="nav-number">3.0.1.</span> <span class="nav-text">3.1.  LeakCanary项目架构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-2-LeakCanary执行过程"><span class="nav-number">3.0.2.</span> <span class="nav-text">3.2.  LeakCanary执行过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-3-LeakCanary初始化"><span class="nav-number">3.0.3.</span> <span class="nav-text">3.3.  LeakCanary初始化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-4-AndroidRefWatcherBuilder-对象"><span class="nav-number">3.0.4.</span> <span class="nav-text">3.4  AndroidRefWatcherBuilder 对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-5-RefWatcher-对象"><span class="nav-number">3.0.5.</span> <span class="nav-text">3.5  RefWatcher 对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-6-AndroidWatchExecutor-类"><span class="nav-number">3.0.6.</span> <span class="nav-text">3.6.  AndroidWatchExecutor 类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-7-AndroidHeapDumper-生成hprof文件"><span class="nav-number">3.0.7.</span> <span class="nav-text">3.7.  AndroidHeapDumper 生成hprof文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-8-HeapAnalyzerService-分析hprof文件，找出泄漏路径"><span class="nav-number">3.0.8.</span> <span class="nav-text">3.8  HeapAnalyzerService 分析hprof文件，找出泄漏路径</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-9-DisplayLeakService-生成内存泄漏通知栏"><span class="nav-number">3.0.9.</span> <span class="nav-text">3.9  DisplayLeakService 生成内存泄漏通知栏</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、LeakCanary不足"><span class="nav-number">3.1.</span> <span class="nav-text">四、LeakCanary不足</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#五、延申阅读"><span class="nav-number">3.1.1.</span> <span class="nav-text">五、延申阅读</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
