<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="转载自：Java集合框架实例 1- 介绍 集合是程序和语言的基本思想。应用程序通常都会应用到集合，例如雇员的信息，图像的收集等的存储。像其他语言，Java还支持数组作为最基本的集合。然而，数组在许多情况下工作并不是那么方便，因为数组生命周期，增加元素或移除元素是非常困难的，甚至需要程序付出效率。 下图说明了一个数组的操作： 2- 第一个示例 首先，我们有链表(LinkedList)的例子。它是元素">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK 源码解析 -- 集合框架">
<meta property="og:url" content="http://yoursite.com/2020/05/29/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="转载自：Java集合框架实例 1- 介绍 集合是程序和语言的基本思想。应用程序通常都会应用到集合，例如雇员的信息，图像的收集等的存储。像其他语言，Java还支持数组作为最基本的集合。然而，数组在许多情况下工作并不是那么方便，因为数组生命周期，增加元素或移除元素是非常困难的，甚至需要程序付出效率。 下图说明了一个数组的操作： 2- 第一个示例 首先，我们有链表(LinkedList)的例子。它是元素">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-29T15:53:31.014Z">
<meta property="article:modified_time" content="2020-05-29T15:54:17.406Z">
<meta property="article:author" content="yudesong">
<meta property="article:tag" content="JDK源码分析">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/05/29/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JDK 源码解析 -- 集合框架 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/29/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JDK 源码解析 -- 集合框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-29 23:53:31 / 修改时间：23:54:17" itemprop="dateCreated datePublished" datetime="2020-05-29T23:53:31+08:00">2020-05-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>转载自：Java集合框架实例</p>
<p>1- 介绍</p>
<p>集合是程序和语言的基本思想。应用程序通常都会应用到集合，例如雇员的信息，图像的收集等的存储。像其他语言，Java还支持数组作为最基本的集合。然而，数组在许多情况下工作并不是那么方便，因为数组生命周期，增加元素或移除元素是非常困难的，甚至需要程序付出效率。</p>
<p>下图说明了一个数组的操作：</p>
<p>2- 第一个示例</p>
<p>首先，我们有链表(LinkedList)的例子。它是元素数不像数组一样限制的多变列表。</p>
<p>HelloLinkedList.java</p>
<p>package com.yiibai.tutorial.javacollection.helloworld;</p>
<p>import java.util.LinkedList;</p>
<p>public class HelloLinkedList {</p>
<pre><code>public static void main(String[] args) {

    // Create collection object - LinkedList

    LinkedList list = new LinkedList();

    // Add elements to the linked list

    list.add(&quot;F&quot;);

    list.add(&quot;B&quot;);

    list.add(&quot;D&quot;);

    list.add(&quot;E&quot;);

    list.add(&quot;C&quot;);



    // Appends the specified element to the end of this list.

    list.addLast(&quot;Z&quot;);

    list.addFirst(&quot;A&quot;);

    // Inserts the specified element at the beginning of this list.

    list.add(1, &quot;A2&quot;);

    // Print out, all elements

    System.out.println(&quot;Original contents of list: &quot; + list);

    // Remove elements from the linked list

    list.remove(&quot;F&quot;);

    // Remove the element at index 2.

    list.remove(2);

    // Print out the list, after removing two elements.

    System.out.println(&quot;Contents of list after deletion: &quot; + list);

    // Remove first and last elements

    list.removeFirst();

    list.removeLast();



    // Print out collection

    System.out.println(&quot;List after deleting first and last: &quot; + list);

    // Get and set a value

    Object val = list.get(2);



    // Set element at index 2

    list.set(2, (String) val + &quot; Changed&quot;);

    System.out.println(&quot;List after change: &quot; + list);

}</code></pre><p>}</p>
<p>运行示例的结果：</p>
<p>使用HashMap的一个例子。这是一种含有对的键/值的对象。考虑一个实例：电话簿，电话号码是一个键，同时用户的信息是一个值。键必须是不一样的。</p>
<p>HelloHashMap.java</p>
<p>package com.yiibai.tutorial.javacollection.helloworld;</p>
<p>import java.util.HashMap;</p>
<p>public class HelloHashMap {</p>
<pre><code>public static void main(String[] args) {



    // Create a HashMap objects, store employee-code and salaries.

    // String key: Employee-code

    // Float value: Salary

    HashMap salaryMap = new HashMap();



    salaryMap.put(&quot;E01&quot;, 1000f);

    salaryMap.put(&quot;E02&quot;, 12000f);

    salaryMap.put(&quot;E03&quot;, 12300f);

    salaryMap.put(&quot;E04&quot;, 1000f);

    salaryMap.put(&quot;E05&quot;, 300.5f);



    // Get the salary of employee &apos;E02&apos;

    Float salary= salaryMap.get(&quot;E01&quot;);

    System.out.println(&quot;Salary of employee E01 = &quot;+ salary);



    // Change the salary for employee &apos;E05&apos;

    salaryMap.put(&quot;E05&quot;, 400f);



    System.out.println(&quot;Salary of employee E05 = &quot;+ salaryMap.get(&quot;E05&quot;));



}</code></pre><p>}</p>
<p>运行示例的结果：</p>
<p>Salary of employee E01 = 1000.0</p>
<p>Salary of employee E05 = 400.0</p>
<p>3- 使用数组的局限性 - 一个建议来解决这个问题</p>
<p>3.1- 数组是一个基本的集合类型</p>
<p>数组是非常基本的也是大家最熟悉的。</p>
<p>存储引用类型，基本类型</p>
<p>int[] myArray=new int[]{1,4,3};</p>
<p>Object[] myArrayObj =new Object[]{“Object”,new Integer(100)};</p>
<p>数组具有固定的大小和尺寸。</p>
<p>这使得数组难以扩展</p>
<p>元件排列并顺序地引用在内存中。</p>
<p>这使得难以从数组中删除指定的元素。</p>
<p>3.2- 从数组中删除元素</p>
<p>数组中的元素是连续排列在内存中的，所以如果你有意数组要删除一个元素是比较困难的，因为它会失去了延续性。通常情况下，在技术上创建一个新的数组是存储上次的数组对象并丢弃不必要的元素，但这种降低了程序的执行效率。类似的技术被应用到数组的扩展，在此我们会以更大的空间来创建一个新的数组，然后将之前的数组元素复制到新的的数组。</p>
<p>显然，这种数组应用在应用程序中在许多情况下不是好方法。</p>
<p>3.3- 链表</p>
<p>链表是克服的数组的弱点数据管理方式之一。当然，也有在Java管理列表的各种方法，例如：ArrayList</p>
<p>让我们来看看链表(LinkedList)的特点： </p>
<p>在这个列表中的元素可以在存储器中，不连续地分离出来。</p>
<p>它是元素间双向链路。</p>
<p>列表中的每个元素，使它前面的元素和它后面的元素的引用。</p>
<p>链表是一个双向链路。</p>
<p>链接元素是需要管理一个包含对象的数据。它有两个引用链接元素的前面和后面。</p>
<p>就像一群人在排队，每个人需要记住两个人 - 站面前和在后面他/她。</p>
<p>移除LinkedList的一个元素</p>
<p>移除LinkedList的一个元素是一样的去除类似站在队列的人。 靠近此人两个人不得不重新更新的人面前，背后的人。</p>
<p>添加元素到链表中(在末尾或在链表中)</p>
<p>总之，虽然我们只是有一个链表的例子，它可以帮助我们理解java.util包更多的信息。</p>
<p>注：链表方案是解决数组的一个弱点。 ArrayList是管理数据集合的方法。它可以处理数组的弱点，但它管理数据的方式与LinkedList是不同的。</p>
<p>4- Java Collections框架概述</p>
<p>意识到数组局限性，从版本Java1.0就有java.util.Vector，是对象的类存储列表。 java.util.Hashtable是一个存储对键/值的类。其次，Java 2平台仍在不断推出接近集合的方式，命名为集合框架。java.util.Vector，java.util.Hashtable依然存在，现在是巨大的平台的一部分。 这些集合都建在java.util包中一些接口的基础上。它们被分成由2个接口主导两个层次结构系统，java.util.Collection包含对象和键/值对的java.util.Map列表。</p>
<p>4.1- Java集合框架接口</p>
<p>上面的图片是Java Collections Framework的重要接口。我们将把它们按用途和用法讨论这些接口的使用目的。在java.util包，类实现一个或多个这些接口。 因此，java.util中的类可以具有许多不同的功能。例如，java.util.HashMap：</p>
<p>Class Hashtable:</p>
<p>public class HashMap extends AbstractMap</p>
<pre><code>implements Map, Cloneable, Serializable</code></pre><p>Class Vector:</p>
<p>public class Vector extends AbstractList</p>
<pre><code>implements List, RandomAccess, Cloneable, Serializable</code></pre><p>4.2- 接口集合和映射引导两个层次- 数据存储方法</p>
<p>集合组存储对象。</p>
<p>在集合组三个子分支： Queue, List, 和 Set.</p>
<p>元素可以是相似或不相似这取决于它们的分支。 (更多细节将在后面讨论)。</p>
<p>映射组存储key和value对</p>
<p>映射的键是不允许相同的。</p>
<p>如果我们知道键，就可以提取等于其映射键对应的值。</p>
<p>在引用类型的形式集合组存储数据，MAP组存储对键和值。</p>
<p>Collection c=new ArrayList();</p>
<p>// Add elements to collection</p>
<p>c.add(“One”);</p>
<p>Map m=new LinkedHashMap();</p>
<p>Integer key=new Integer(123);</p>
<p>String value=”One two three”;</p>
<p>// Associates the specified value with the specified key in this map.</p>
<p>// If the map previously contained a mapping for the key, the old</p>
<p>// value is replaced.</p>
<p>m.put(key,value);</p>
<p>//</p>
<p>System.out.println(m.get(new Integer(123));</p>
<p>4.3- 接口迭代器和随机访问 - 数据访问方法</p>
<p>java.util.Iterator</p>
<p>要检索数据，从一个元素到另一个元素依次访问迭代器。</p>
<p>java.util.RandomAccess</p>
<p>随机接入方法，例如定位元素和设定检索该元素</p>
<p>例如，java.util.Vector实现了这个接口，可以检索随机元素使用vector.get (int index)。</p>
<p>集合组也可以反过来通过调用方法iterator() 来检索访问Iterator对象。</p>
<p>java.util.Collection接口是从java.lang.Iterable扩展，所以它继承了public Iterator iterator() 方法，来迭代集合的元素。</p>
<p>在上述2个接口迭代器和随机访问的示例，它代表了两种方法如何访问一个集合中的元素。</p>
<p>看看 Vector 类:</p>
<p>public class Vector extends AbstractList</p>
<pre><code>implements List, RandomAccess, Cloneable, Serializable</code></pre><p>Vector属于集合组，可以通过get (index) 方法访问，或通过迭代器，或随机访问来元素。</p>
<p>注：对于列表组类，也可以检索对象的ListIterator， 这个迭代器可以让你在列表中向后或向前仅向前的光标位置，而不是像迭代器一样。</p>
<p>5- 集合组</p>
<p>5.1- 集合组中的接口</p>
<p>集合有三种直接子接口：Queue，List和Set。其中，Queue从1.5版本中增加，并考虑为这是一个等待队列。Queue也有一个子接口：BlockingQueue，属于java.util.concurrent包， 但我们没有在这节教程中讨论。Queue是一个包含许多定义以及组织我们需要最注重的接口方式。三个接口Queue , List , Set被视为集合组的三个分支。</p>
<p>在学习这几个组的细节之前，让我们来看看Collection接口的概述。</p>
<p>5.2- java.util.Collection接口</p>
<p>继承关系</p>
<p>java.util.Collection</p>
<p>public interface Collection extends java.lang.Iterable {</p>
<p>  //</p>
<p>  // Add element to collection</p>
<p>  // return true if this collection changed as a result of the call</p>
<p>  //</p>
<p>  boolean add(E o);</p>
<p>  //</p>
<p>  // Adds all of the elements in the specified collection to this collection.</p>
<p>  // return true if this collection changed as a result of the call</p>
<p>  //</p>
<p>  boolean addAll(Collection c);</p>
<p>  // Removes all of the elements from this collection (optional operation).</p>
<p>  // The collection will be empty after this method returns.</p>
<p>  void clear();</p>
<p>  // Returns true if this collection contains the specified element.</p>
<p>  boolean contains(Object o);</p>
<p>  // Returns true if this collection contains all of the elements</p>
<p>  // in the specified collection.</p>
<p>  boolean containsAll(Collection c);</p>
<p>  // Compares the specified object with this collection for equality</p>
<p>  boolean equals(Object o);</p>
<p>  int hashCode();</p>
<p>  // Returns true if this collection contains no elements.</p>
<p>  boolean isEmpty();</p>
<p>  //</p>
<p>  // Removes a single instance of the specified element from this</p>
<p>  // collection, if it is present (optional operation).</p>
<p>  //</p>
<p>  boolean remove(Object o);</p>
<p>  // Removes all of this collection’s elements that are also contained in the</p>
<p>  // specified collection (optional operation)</p>
<p>  boolean removeAll(Collection c);</p>
<p>  //</p>
<p>  // Retains only the elements in this collection that are contained in the</p>
<p>  // specified collection (optional operation)</p>
<p>  //</p>
<p>  boolean retainAll(Collection c);</p>
<p>  // Returns the number of elements in this collection</p>
<p>  int size();</p>
<p>  // Returns an array containing all of the elements in this collection</p>
<p>  Object[] toArray();</p>
<p>  T[] toArray(T[] a);</p>
<p>  // Returns an iterator over the elements in this collection.</p>
<p>  Iterator iterator();</p>
<p>}</p>
<p>5.3- 访问集合中的元素</p>
<p>集合中的元素迭代器。</p>
<p>例如，使用迭代访问集合的元素。</p>
<p>CollectionAndIterator.java</p>
<p>package com.yiibai.tutorial.javacollection.collection;</p>
<p>import java.util.Collection;</p>
<p>import java.util.Iterator;</p>
<p>import java.util.Vector;</p>
<p>public class CollectionAndIterator {</p>
<pre><code>public static void main(String[] args) {



    // Create empty collection

    // A Collection containing only String.

    Collection coll = new Vector();

    coll.add(&quot;Collection&quot;);

    coll.add(&quot;Queue&quot;);

    coll.add(&quot;List&quot;);

    coll.add(&quot;Map&quot;);

    // Print out the number of elements in this collection

    System.out.println(&quot;Size:&quot; + coll.size());

    // Returns an iterator over the elements in this collection.

    // This Iterator containing only String.

    Iterator ite = coll.iterator();





    // Returns true if the iteration has more elements

    while (ite.hasNext()) {

        // Returns the next element in the iteration.

        String s = ite.next();

        System.out.println(&quot;Element:&quot; + s);

    }

}</code></pre><p>}</p>
<p>运行实例的结果：</p>
<p>Size:4</p>
<p>Element:Collection</p>
<p>Element:Queue</p>
<p>Element:List</p>
<p>Element:Map</p>
<p>5.4- 集合的分支</p>
<p>正如上面所说的，集合有三个子接口，包括Queue ，List 和 Set。它们之间的差别是存储数据的方式。</p>
<p>java.util.Queuejava.util.Listjava.util.Set</p>
<p>允许包含重复的元素允许包含重复的元素不允许重复的元素</p>
<p>不允许包含null元素允许包含一个或多个null元素根据不同的类实现Set接口，是否支持包含空元素。如果支持，它仅包含至多有一个null元素。</p>
<p>一个列表(List)的目的，是一个相同的对象很可能出现不止一次的有序列表。 例如 : [1, 7, 1, 3, 1, 1, 1, 5]. 说说在列表中的“第三个元素”是很有意义的。 可以在列表的任意位置添加元素，在列表中的任何位置更改元素，或从列表中的任何位置删除元素。</p>
<ul>
<li>队列也是有顺序的，但你永远只能触及一端的元素。元素被插入在“结尾”，并从队列中的“开头”(或头部)删除。你可以知道在队列中有多少个元素，但不能找出说，“第三个”元素是什么。当你到达那里，你会看到它。</li>
</ul>
<p>一个集合（Set）不是有序的，也不能包含重复的元素。任何给定的对象是不在集合中的。{7, 5, 3, 1} 集合是确实相同于 {1, 7, 1, 3, 1, 1, 1, 5}. 因此无法要求提供“第三个”元素，甚至“第一”的元素，因为它们不以任何特定的顺序。 您可以添加或删除元素，也可以找出某个元素是否存在（例如，“7在这一集合中？”）</p>
<p>5.5- java.util.List 接口</p>
<p>列表（List）是集合（Collection）的子接口。它拥有Collection的全部功能，以及一些特殊的功能：</p>
<p>允许重复元素</p>
<p>允许零个或多个null元素存在。</p>
<p>列表（List）是对象的有序列表</p>
<p>除了通过使用迭代访问，我们可以通过使用 ListIterator 访问。允许 ListIterator 向前或向后移动光标。</p>
<p>// Returns a list iterator over the elements in this list </p>
<p>public ListIterator listIterator() của list .</p>
<p>// Returns a list iterator over the elements in this list (in proper</p>
<p>// sequence), starting at the specified position in the list..</p>
<p>public ListIterator listIterator(int index) :</p>
<p>ListAndListIterator.java</p>
<p>package com.yiibai.tutorial.javacollection.list;</p>
<p>import java.util.ArrayList;</p>
<p>import java.util.List;</p>
<p>import java.util.ListIterator;</p>
<p>public class ListAndListIterator {</p>
<pre><code>public static void main(String[] args) {

    // Create List object (Containing only String)

    List list = new ArrayList();

    list.add(&quot;One&quot;);

    list.add(&quot;Two&quot;);

    list.add(&quot;Three&quot;);

    list.add(&quot;Four&quot;);

    // Returns a list iterator over the elements in this list

    // (in proper sequence)

    ListIterator listIterator = list.listIterator();



    // Currently the cursor at the first position of the interator.

    // (Index 0).

    // Get the first element in the interator, the cursor forward one step.

    String first = listIterator.next();

    System.out.println(&quot;first:&quot; + first);// --&gt;&quot;One&quot;

    // Current cursor at index 1

    // Get next element.

    String second = listIterator.next();

    System.out.println(&quot;second:&quot; + second);// --&gt;&quot;Two&quot;

    // true if the list iterator has more elements when

    // traversing the list in the reverse direction

    if (listIterator.hasPrevious()) {

        // the previous element in the list

        String value = listIterator.previous();

        System.out.println(&quot;value:&quot; + value);// --&gt;&quot;Two&quot;

    }

    System.out.println(&quot; ----- &quot;);

    while (listIterator.hasNext()) {

        String value = listIterator.next();

        System.out.println(&quot;value:&quot; + value);

    }

}</code></pre><p>}</p>
<p>运行实例的结果：</p>
<p>first:One</p>
<p>second:Two</p>
<p>value:Two</p>
<hr>
<p>value:Two</p>
<p>value:Three</p>
<p>value:Four</p>
<p>5.6- java.util.Set接口</p>
<p>Set是Collection的子接口。它拥有集合的全部功能，以及其他一些特点：</p>
<p>描述了一组不允许重复元素的集合</p>
<p>允许一个空元素的存在，如果有的话。</p>
<p>HashSetExample.java</p>
<p>package com.yiibai.tutorial.javacollection.set;</p>
<p>import java.util.HashSet;</p>
<p>import java.util.Iterator;</p>
<p>import java.util.Set;</p>
<p>public class HashSetExample {</p>
<pre><code>public static void main(String[] args) {



    // Create a Set object with initial capacity 10

    // Automatically increase capacity 80% if the number of elements to

    // overcome the current capacity.

    // HashSet (LIFO - Last in first out)

    //  (element to be added later will stand first).

    Set set = new HashSet(10, (float) 0.8);

    set.add(&quot;One&quot;);

    set.add(&quot;Two&quot;);



    // Duplication occurs.

    // With HashSet: It will add new element, and remove the old element.

    set.add(&quot;One&quot;);

    set.add(&quot;Three&quot;);

    Iterator it = set.iterator();

    while (it.hasNext()) {

        System.out.println(it.next());

    }

}</code></pre><p>}</p>
<p>运行实例的结果：</p>
<p>One</p>
<p>Two</p>
<p>Three</p>
<p>5.7- java.util.Queue接口</p>
<p>Queue是Collection的子类型的接口，它充满着集合的特点，相当类似于列表(List)，但是，使用目的略有不同。队列(Queue)被设计成只能访问第一个元素(删除元素时)在队列中，它会删除队列的第一个元素。有点类似于人在超市排队一样，只有在队列的头部将可访问，新人如要插入到该队列中，插入位置可能不是队列的末尾。插入的元素位置取决于队列的类型和元素的优先级。</p>
<p>队列允许元素重复</p>
<p>不允许null元素</p>
<p>有两个类都实现了Queue接口：</p>
<p>java.util.LinkedList</p>
<p>java.util.PriorityQueue</p>
<p>LinkedList是一个非常标准的队列实现。但请记住，LinkedList同时实现List和Queue接口。</p>
<p>PriorityQueue根据自己的自然顺序存储的元素(如果它们实现Comparable)或者根据Comparator 传递给PriorityQueue。请注意，一个类可以实现了List 和Queue接口，所以你不需要关心元素是如何安排在上述内部类的，如果把它作为一个队列，请参阅访问队列中元素的方式。考虑队列的典型方法，它模拟人在超市排队队列。</p>
<p>抛出异常返回指定值</p>
<p>Insertadd(e)offer(e)</p>
<p>Removeremove()poll()</p>
<p>Examineelement()peek()</p>
<p>boolean add(E)</p>
<p>将指定的元素插入此队列中，如果它是立即可行且不违反容量限制，成功则返回true，如果当前没有空间可用则抛出IllegalStateException。</p>
<p>boolean offer(E)</p>
<p>将指定的元素插入此队列中，如果它是立即可行且不违反容量限制。当使用有容量限制的队列通常是使用 add(E)方法，它可能在无法插入的元素时抛出异常 。</p>
<p>E remove()</p>
<p>检索并移除此队列的头元素。该方法与poll不同在于如果此队列为空，它会抛出一个异常。</p>
<p>E poll()</p>
<p>检索，但是不移除此队列的头元素。这种方法与 peek 方法不同，如果此队列为空它抛出一个异常。</p>
<p>E element()</p>
<p>检索，但是不移除此队列的头元素。这种方法与peek方法不同，如果此队列为空它抛出一个异常。</p>
<p>E peek()</p>
<p>检索，但是不移除此队列的头元素，或者如果此队列为空则返回null。</p>
<p>解释:</p>
<p>除了上面提到的队列方法外，您可以在队列中访问其他元素，除了第一个元素，也不能指定将被插入元素的位置。</p>
<p>QueueDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.queue;</p>
<p>import java.util.LinkedList;</p>
<p>import java.util.Queue;</p>
<p>public class QueueDemo {</p>
<pre><code>public static void main(String[] args) {

    Queue names = new LinkedList();



    // offer(E): Insert element to queue.

    // With LinkedList, element will inserted at the end of queue.

    // Return true if success.

    // Return false if queue full.

    names.offer(&quot;E&quot;);

    names.offer(&quot;A&quot;);

    names.offer(&quot;M&quot;);





    // add(E): Insert element to queue

    // With LinkedList, element will inserted at the end of queue.

    // Return true if success.

    // Throw exception if queue full.   

    names.add(&quot;G&quot;);

    names.add(&quot;B&quot;);

    while (true) {     



        // Retrieves and removes the head of this queue,

        // or returns null if this queue is empty.

        String name = names.poll();

        if (name == null) {

            break;

        }

        System.out.println(&quot;Name=&quot; + name);

    }

}</code></pre><p>}</p>
<p>运行实例的结果：</p>
<p>Name=E</p>
<p>Name=A</p>
<p>Name=M</p>
<p>Name=G</p>
<p>Name=B</p>
<p>例如，使用一个优先队列PriorityQueue。此队列在内部根据自己的自然顺序(如果实现Comparable)，或者根据传递给PriorityQueue比较器(Comparator )来存储它的元素。</p>
<p>String就是实现了Comparable接口的类，它们可以相互比较后并按字母顺序排列。</p>
<p>PriorityQueueDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.queue;</p>
<p>import java.util.PriorityQueue;</p>
<p>import java.util.Queue;</p>
<p>public class PriorityQueueDemo {</p>
<pre><code>public static void main(String[] args) {



    // With PriorityQueue queue, the elements will be arranged on the natural order

    Queue names = new PriorityQueue();

    // offer(E): Insert element to queue

    // Return true if success

    // Return false if queue is full.

    names.offer(&quot;E&quot;);

    names.offer(&quot;A&quot;);

    names.offer(&quot;M&quot;);

    // add(E): Insert element to queue.

    // Return true if success

    // Throw exceptiono if queue is full.

    names.add(&quot;G&quot;);

    names.add(&quot;B&quot;);

    while (true) {



        // Retrieves and removes the head of this queue,

        // or returns null if this queue is empty.

        String name = names.poll();

        if (name == null) {

            break;

        }

        System.out.println(&quot;Name=&quot; + name);

    }

}</code></pre><p>}</p>
<p>运行实例的结果：</p>
<p>Name=A</p>
<p>Name=B</p>
<p>Name=E</p>
<p>Name=G</p>
<p>Name=M</p>
<p>5.8- Collection组类之间的继承关系</p>
<p>一些常见的类：</p>
<p>实现</p>
<p>Hash TableResizable ArrayBalanced TreeLinked ListHash Table + Linked List</p>
<p>InterfacesSetHashSetTreeSetLinkedHashSet</p>
<p>ListArrayList</p>
<p>5.9- java.util.ArrayList</p>
<p>ArrayList拥有充分的List接口的功能。此外，它允许访问随机元素，由于继承了RandomAccess。</p>
<p>它基本上类似于Vector类。然而，虽然Vector方法是同步的，这些ArrayList都没有。 因此ArrayList适合于单线程的应用程序。</p>
<p>ArrayListDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.list;</p>
<p>import java.util.ArrayList;</p>
<p>public class ArrayListDemo {</p>
<p>  public static void main(String[] args) {</p>
<pre><code>// Create an ArrayList object that contains the element Integer.

ArrayList list = new ArrayList(10);



// Add elements

list.add(123);

list.add(245);

list.add(new Integer(345));



// ArrayList allow add null elements.

// (Feature of List)

list.add(null);



// Print out the number of elements in this list.

System.out.println(&quot;Size:&quot; + list.size());// =4



// Random access to elements of index 1.

Integer i = list.get(1);

System.out.println(&quot;Element index 1 =&quot; + i);// =245

Integer newInt = 1000;



// Replaces the element at the specified position

// in this list with the specified element.

Integer old = list.set(1, newInt);

//

System.out.println(&quot;Old value:&quot; +old);// =245 .

System.out.println(&quot;New value:&quot; + list.get(1));// =1000 .</code></pre><p>  }</p>
<p>}</p>
<p>运行实例的结果：</p>
<p>Size:4</p>
<p>Element index 1 =245</p>
<p>Old value:245</p>
<p>New value:1000</p>
<p>5.10- java.util.Vector</p>
<p>Vector是一个类，其功能类似于ArrayList。 所不同的是Vector 的方法同步，而ArrayList的方法不同步。</p>
<p>Vector 的方法是同步的，所以在多线程应用程序它运行良好。</p>
<p>Vector有一些是1.0版继承附加的方法，在Java提到集合框架的概念之前。</p>
<p>// Legacy method from 1.0, get element at index position</p>
<p>// Like get(index)</p>
<p>public E elementAt(int index)</p>
<p>// Method inherited from the List interface, get element at position index.</p>
<p>public E get(int index)</p>
<p>// Replaces the element at the specified position in this list with the specified element</p>
<p>// Return old element.</p>
<p>// setElementAt(int,E) like set(int,E)</p>
<p>public void setElementAt(int index, E element);</p>
<p>// Replaces the element at the specified position in this list with the specified element</p>
<p>// Return old element.</p>
<p>public E set(int index, E element)</p>
<p>VectorDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.list;</p>
<p>import java.util.Vector;</p>
<p>public class VectorDemo {</p>
<pre><code>public static void main(String[] args) {

    // Create Vector object with capacity 10 (element)

    // Automatically increase capacity 5, if the number of elements to

    // overcome the current capacity.

    Vector v = new Vector(10, 5);

    v.add(123);

    v.add(245);

    v.add(new Integer(345));

    v.add(null);

    // Returns the number of elements in this vector. (Not capacity).

    System.out.println(&quot;Size:&quot; + v.size());// =4

    // Get element at index 1

    // (like method get(int))

    Integer i = v.elementAt(1);

    System.out.println(&quot;v.elementAt(1)=&quot; + i);// 245

    // Method này trả về phần tử cũ.



    // Set element at index 1,

    // and return old element at index 1.

    v.setElementAt(1, 1000);

    //

    System.out.println(&quot;New value:&quot; + v.get(1));// =1000 .

}</code></pre><p>}</p>
<p>运行示例的结果：</p>
<p>5.11- java.util.SortedSet</p>
<p>SortedSet是Set接口的子类型的接口，它充满着Set的功能。SortedSet是具有一个有组织的Set类，加入到集合类新元素自动放在一个合适的位置，以确保集合仍在排列(升序或降序)。</p>
<p>因此，SortedSet的元素必须彼此进行比较，并且它们必须是java.lang.Comparable的对象(可以是comparable)。  </p>
<p>如果添加不是Comparable的元素到SortedSet对象，会得到一个异常。</p>
<p>类实现 SortedSet:  TreeSet.</p>
<p>考虑球员(Player)类，包括以下信息：姓名，金牌数，银牌数，铜牌数。</p>
<p>球员(Player)可以相互根据原理进行比较：</p>
<p>谁拥有更多的金牌则排名会更高</p>
<p>如果两个人有相同数量的金牌，谁拥有更多的银牌则排名就越靠前</p>
<p>如果两个人有相同数量的金牌和银牌，谁拥有更多铜牌则排名将更高</p>
<p>其他的则被视为是同等级的</p>
<p>Player类将实现 java.lang.Comparable 的接口</p>
<p>Player.java</p>
<p>package com.yiibai.tutorial.javacollection.sortedset;</p>
<p>public class Player implements Comparable {</p>
<pre><code>private String name;

private int goldMedal;

private int silverMedal;

private int bronzeMedal;

public Player(String name, int goldMedal, int silverMedal, int bronzeMedal) {

    this.name = name;

    this.goldMedal = goldMedal;

    this.silverMedal = silverMedal;

    this.bronzeMedal = bronzeMedal;

}



// Compare this player with other player

// Return &lt; 0 means this player &lt; other

// Return &gt; 0 means this player &gt; other

// Return 0 means this player = other

@Override

public int compareTo(Player other) {

    // Compare the number of gold medals.

    int value = this.goldMedal - other.goldMedal;

    if (value != 0) {

        return value;

    }



    // Compare the number of silver medals.

    value = this.silverMedal - other.silverMedal;

    if (value != 0) {

        return value;

    }



    // Compare the number of bronze medals.

    value = this.bronzeMedal - other.bronzeMedal;

    return value;

}

@Override

public String toString() {

    return &quot;[&quot; + this.name + &quot;, Gold: &quot; + this.goldMedal + &quot;, Silver: &quot; + this.silverMedal + &quot;, Bronze: &quot;

            + this.bronzeMedal + &quot;]&quot;;

}</code></pre><p>}</p>
<p>SortedSetDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.sortedset;</p>
<p>import java.util.SortedSet;</p>
<p>import java.util.TreeSet;</p>
<p>public class SortedSetDemo {</p>
<pre><code>public static void main(String[] args) {



    // Create SortedSet object.

    SortedSet players = new TreeSet();

    Player tom = new Player(&quot;Tom&quot;, 1, 3, 5);

    Player jerry = new Player(&quot;Jerry&quot;, 3, 1, 3);

    Player donald = new Player(&quot;Donal&quot;, 2, 10, 0);





    // Add element to set

    // They will automatically be sorted (Ascending).

    players.add(tom);

    players.add(jerry);

    players.add(donald);





    // Print out elements

    for(Player player : players) {

        System.out.println(&quot;Player: &quot;+ player);

    }

}</code></pre><p>}</p>
<p>运行 SortedSetDemo 实例的结果如下：</p>
<p>Player: [Tom, Gold: 1, Silver: 3, Bronze: 5]</p>
<p>Player: [Donal, Gold: 2, Silver: 10, Bronze: 0]</p>
<p>Player: [Jerry, Gold: 3, Silver: 1, Bronze: 3]</p>
<p>6- Map组</p>
<p>6.1- 映射组接口</p>
<p>由 java.util.Map 接口主导 Map 组。该接口有2个子接口分别是java.util.SortedMap和java.util.concurrent.ConcurrentMap。 ConcurrentMap不属于java.util包，它是从Java版本1.5引入的，我们不打算在教程讲解它。 Map组特点是存储键/值对的数据。</p>
<p>6.2- 在Map组中的类</p>
<p>6.3- java.util.Map接口</p>
<p>SN方法及描述</p>
<p>1void clear( )</p>
<p>调用移除Map中的所有键/值对(可选操作)</p>
<p>2boolean containsKey(Object k)</p>
<p>如果调用映射包含一个键k，则返回true，否则返回false</p>
<p>3boolean containsValue(Object v)</p>
<p>如果Map包含一个值v，则返回true。否则，返回false</p>
<p>4Set&gt; entrySet( )</p>
<p>返回包含在映射中条目的集合。集合中包含 Map.Entry 类型的对象。这种方法提供调用映射设置视图</p>
<p>5boolean equals(Object obj)</p>
<p>如果 obj 是一个在 Map 中包含的相同项目，则返回true。否则，返回false</p>
<p>6Object get(K k)</p>
<p>返回与k关联的值</p>
<p>7int hashCode( )</p>
<p>返回调用映射的哈希码</p>
<p>8boolean isEmpty( )</p>
<p>返回true如果调用映射为空。否则，返回false</p>
<p>9Set keySet( )</p>
<p>返回包含调用Map中的键的集合(Set)，该方法提供了在调用映射中的键的一组视图</p>
<p>10Object put(K k, V v)</p>
<p>放入调用映射一个条目，覆盖先前与键相关联的值。键和值分别为K和V。如果该键不存在，则返回null。否则关联到键先前的值被返回(可选操作)</p>
<p>11void putAll(Map m)</p>
<p>把 m 中的全部项目放入此Map(可选操作)</p>
<p>12Object remove(Object k)</p>
<p>删除其键等于k处的项(可选操作)</p>
<p>13int size( )</p>
<p>返回映射的键/值对的数量</p>
<p>14Collection values( )</p>
<p>返回包含映射中值的集合，该方法提供了在映射中的值的集合视图。</p>
<p>可选方法(可选操作)，可以被支持它的实现类或没有，如果不支持，它会抛出 UnsupportedOperationException 异常：</p>
<p>import java.util.Collection;</p>
<p>import java.util.Map;</p>
<p>import java.util.Set;</p>
<p>public class MyMap implements Map{</p>
<p>  …..</p>
<pre><code>// If you call this method, an exception will be thrown (unconditional).

@Override

public void clear() {

    throw new java.lang.UnsupportedOperationException();       

} </code></pre><p>} </p>
<p>因此，MyMap类不支持clear()方法的真正含意。如果用户有意使用 MyMap 中的这个方法，会收到一个异常。</p>
<p>MapDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.map;</p>
<p>import java.util.HashMap;</p>
<p>import java.util.Map;</p>
<p>import java.util.Set;</p>
<p>public class MapDemo {</p>
<pre><code>public static void main(String[] args) {

    Map map = new HashMap();

    map.put(&quot;01000005&quot;, &quot;Tom&quot;);

    map.put(&quot;01000002&quot;, &quot;Jerry&quot;);

    map.put(&quot;01000003&quot;, &quot;Tom&quot;);

    map.put(&quot;01000004&quot;, &quot;Donald&quot;);





    // Get a set view of the keys contained in this map

    // This collection is not sorted

    Set phones = map.keySet();

    for (String phone : phones) {

        System.out.println(&quot;Phone: &quot; + phone + &quot; : &quot; + map.get(phone));

    }

}</code></pre><p>}</p>
<p>运行实例的结果如下：</p>
<p>Phone: 01000004 : Donald</p>
<p>Phone: 01000003 : Tom</p>
<p>Phone: 01000005 : Tom</p>
<p>Phone: 01000002 : Jerry</p>
<p>您可以通过Map.Entry访问映射的数据，见下图：</p>
<p>MapEntryDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.map;</p>
<p>import java.util.HashMap;</p>
<p>import java.util.Map;</p>
<p>import java.util.Set;</p>
<p>import java.util.Map.Entry;</p>
<p>public class MapEntryDemo {</p>
<pre><code>public static void main(String[] args) {

    Map map = new HashMap();

    map.put(&quot;01000005&quot;, &quot;Tom&quot;);

    map.put(&quot;01000002&quot;, &quot;Jerry&quot;);

    map.put(&quot;01000003&quot;, &quot;Tom&quot;);

    map.put(&quot;01000004&quot;, &quot;Donald&quot;);



    // Get set of entries

    // This entry may not sort by key.

    Set&gt; entries = map.entrySet();

    for (Entry entry : entries) {

        System.out.println(&quot;Phone: &quot; + entry.getKey() + &quot; : &quot; + entry.getValue());

    }

}</code></pre><p>}</p>
<p>运行实例的结果如下：</p>
<p>Phone: 01000004 : Donald</p>
<p>Phone: 01000003 : Tom</p>
<p>Phone: 01000005 : Tom</p>
<p>Phone: 01000002 : Jerry</p>
<p>6.4- java.util.SortedMap接口</p>
<p>SortedMap是 Map 的子接口。它确保键/值对根据键以升序排列。</p>
<p>在java.util中只有一个类实现 SortedMap 接口，它就是TreeMap。</p>
<p>SortedMap 类的方法：</p>
<p>SN描述及方法</p>
<p>1Comparator comparator( )</p>
<p>返回调用Map的比较器(comparator)，如果自然顺序用于调用映射，则返回null</p>
<p>2Object firstKey( )</p>
<p>返回调用映射的第一个键</p>
<p>3SortedMap headMap(Object end)</p>
<p>返回映射条目与小于 end 键的有序映射</p>
<p>4Object lastKey( )</p>
<p>返回调用映射的最后一个键</p>
<p>5SortedMap subMap(Object start, Object end)</p>
<p>返回一个包含键大于或等于start 并小于 end 的那些条目的映射</p>
<p>6SortedMap tailMap(Object start)</p>
<p>返回包含键大于或等于 start 的那些条目的映射.</p>
<p>SortedMapDemo.java</p>
<p>package com.yiibai.tutorial.javacollection.sortedmap;</p>
<p>import java.util.Map;</p>
<p>import java.util.Set;</p>
<p>import java.util.TreeMap;</p>
<p>public class SortedMapDemo {</p>
<pre><code>public static void main(String[] args) {

    Map map = new TreeMap();

    map.put(&quot;01000005&quot;, &quot;Tom&quot;);

    map.put(&quot;01000002&quot;, &quot;Jerry&quot;);

    map.put(&quot;01000003&quot;, &quot;Tom&quot;);

    map.put(&quot;01000004&quot;, &quot;Donald&quot;);



    // This set has been sorted in ascending

    Set keys = map.keySet();

    for (String key : keys) {

        System.out.println(&quot;Phone: &quot; + key);

    }



    System.out.println(&quot;-----&quot;);



    // This set has been sorted in ascending

    Set&gt; entries = map.entrySet();

    for (Map.Entry entry : entries) {

        System.out.println(&quot;Phone: &quot; + entry.getKey());

    }

}</code></pre><p>}</p>
<p>运行实例的结果如下：</p>
<p>Phone: 01000002</p>
<p>Phone: 01000003</p>
<p>Phone: 01000004</p>
<p>Phone: 01000005</p>
<hr>
<p>Phone: 01000002</p>
<p>Phone: 01000003</p>
<p>Phone: 01000004</p>
<p>Phone: 01000005</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># JDK源码分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/29/LeakCanary-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="prev" title="LeakCanary 源码解析">
      <i class="fa fa-chevron-left"></i> LeakCanary 源码解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/29/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Object/" rel="next" title="JDK 源码解析 -- Object">
      JDK 源码解析 -- Object <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">102</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
