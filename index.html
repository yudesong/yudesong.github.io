<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/12/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">Java基础部分复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 23:57:56" itemprop="dateCreated datePublished" datetime="2021-03-12T23:57:56+08:00">2021-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、Java基础部分"><a href="#一、Java基础部分" class="headerlink" title="一、Java基础部分"></a>一、Java基础部分</h2><h3 id="1-String、StringBuilder、StringBuffer"><a href="#1-String、StringBuilder、StringBuffer" class="headerlink" title="1. String、StringBuilder、StringBuffer"></a>1. String、StringBuilder、StringBuffer</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/12/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/12/Java%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/Java%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">Java高级部分复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 23:57:39" itemprop="dateCreated datePublished" datetime="2021-03-12T23:57:39+08:00">2021-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、JVM"><a href="#一、JVM" class="headerlink" title="一、JVM"></a>一、JVM</h2><h3 id="1-1-JVM-内存模型"><a href="#1-1-JVM-内存模型" class="headerlink" title="1.1 JVM 内存模型"></a>1.1 JVM 内存模型</h3><h3 id="1-2-JVM-类加载机制"><a href="#1-2-JVM-类加载机制" class="headerlink" title="1.2 JVM 类加载机制"></a>1.2 JVM 类加载机制</h3><h3 id="1-3-垃圾回收机制"><a href="#1-3-垃圾回收机制" class="headerlink" title="1.3 垃圾回收机制"></a>1.3 垃圾回收机制</h3><h2 id="二、JDK源码"><a href="#二、JDK源码" class="headerlink" title="二、JDK源码"></a>二、JDK源码</h2><h3 id="2-1-HashMap源码"><a href="#2-1-HashMap源码" class="headerlink" title="2.1 HashMap源码"></a>2.1 HashMap源码</h3><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><h3 id="2-3-ThreadLocal源码"><a href="#2-3-ThreadLocal源码" class="headerlink" title="2.3 ThreadLocal源码"></a>2.3 ThreadLocal源码</h3><h3 id="2-4-线程池源码"><a href="#2-4-线程池源码" class="headerlink" title="2.4 线程池源码"></a>2.4 线程池源码</h3><h3 id="2-5-AQS源码"><a href="#2-5-AQS源码" class="headerlink" title="2.5 AQS源码"></a>2.5 AQS源码</h3><h3 id="2-6"><a href="#2-6" class="headerlink" title="2.6"></a>2.6</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/11/PackageManagerService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/11/PackageManagerService%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">PackageManagerService启动过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-11 23:08:52 / 修改时间：23:08:53" itemprop="dateCreated datePublished" datetime="2021-03-11T23:08:52+08:00">2021-03-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>和installd进行连接，安装卸载操作</li>
<li>创建PackageHandler线程，处理外部安装卸载请求</li>
<li>处理系统权限相关的文件/system/etc/permission/*.xml</li>
<li>扫描安装jar、APK并得到安装包信息</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/05/ButterKnife%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/05/ButterKnife%20%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">ButterKnife 原理剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-05 14:30:28 / 修改时间：15:19:13" itemprop="dateCreated datePublished" datetime="2021-03-05T14:30:28+08:00">2021-03-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public final class ButterKnife &#123;</span><br><span class="line">    </span><br><span class="line">  public static Unbinder bind(@NonNull Activity target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取顶层View对象DecorView</span><br><span class="line">    View sourceView &#x3D; target.getWindow().getDecorView();</span><br><span class="line">    return bind(target, sourceView);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Unbinder bind(@NonNull Object target, @NonNull View source) &#123;</span><br><span class="line">    Class&lt;?&gt; targetClass &#x3D; target.getClass();</span><br><span class="line">    &#x2F;&#x2F; 获取注解处理器生成类：clsName + &quot;_ViewBinding&quot; 类构造器</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor &#x3D; findBindingConstructorForClass(targetClass);</span><br><span class="line">    if (constructor &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return Unbinder.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      return constructor.newInstance(target, source);</span><br><span class="line">    &#125; catch(...) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor &#x3D; BINDINGS.get(cls);</span><br><span class="line">    if (bindingCtor !&#x3D; null || BINDINGS.containsKey(cls)) &#123;</span><br><span class="line">      return bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName &#x3D; cls.getName();</span><br><span class="line">    &#x2F;&#x2F; 过滤系统类</span><br><span class="line">    if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)</span><br><span class="line">        || clsName.startsWith(&quot;androidx.&quot;)) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 当前target类加载器去加载_ViewBinding类</span><br><span class="line">      Class&lt;?&gt; bindingClass &#x3D; cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);</span><br><span class="line">      bindingCtor &#x3D; (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">      bindingCtor &#x3D; findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    return bindingCtor;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解处理器生成的-ViewBinding"><a href="#注解处理器生成的-ViewBinding" class="headerlink" title="注解处理器生成的_ViewBinding"></a>注解处理器生成的_ViewBinding</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class LiveRoomActivity_ViewBinding implements Unbinder &#123;</span><br><span class="line">    private LiveRoomActivity target;</span><br><span class="line">    private View view7f0909f6;</span><br><span class="line">    </span><br><span class="line">    @UiThread</span><br><span class="line">    public LiveRoomActivity_ViewBinding(LiveRoomActivity target) &#123;</span><br><span class="line">        this(target, target.getWindow().getDecorView());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @UiThread</span><br><span class="line">    public LiveRoomActivity_ViewBinding(final LiveRoomActivity target, View source) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">        View view;</span><br><span class="line">        target.live_content &#x3D; Utils.findRequiredView(source, R.id.live_content, &quot;field &#39;live_content&#39;&quot;);</span><br><span class="line">        target.room_background &#x3D; Utils.findRequiredViewAsType(source, R.id.room_background, &quot;field &#39;room_background&#39;&quot;, GlideImageView.class);</span><br><span class="line">        view7f0909f6 &#x3D; view;</span><br><span class="line">        view.setOnClickListener(new DebouncingOnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doClick(View p0) &#123;</span><br><span class="line">                target.onClick(p0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @CallSuper</span><br><span class="line">    public void unbind() &#123;</span><br><span class="line">        LiveRoomActivity target &#x3D; this.target;</span><br><span class="line">        this.target &#x3D; null;</span><br><span class="line">        target.ll_quick_reply &#x3D; null;</span><br><span class="line">        view7f0909f6.setOnClickListener(null);</span><br><span class="line">        view7f0909f6 &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解处理器ButterKnifeProcessor"><a href="#注解处理器ButterKnifeProcessor" class="headerlink" title="注解处理器ButterKnifeProcessor"></a>注解处理器ButterKnifeProcessor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public final class ButterKnifeProcessor extends AbstractProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Types typeUtils; &#x2F;&#x2F;</span><br><span class="line">    private Filer filer;     &#x2F;&#x2F;</span><br><span class="line">    private @Nullable Trees trees;</span><br><span class="line"></span><br><span class="line">    @Override </span><br><span class="line">    public synchronized void init(ProcessingEnvironment env) &#123;</span><br><span class="line">        super.init(env);    </span><br><span class="line">        typeUtils &#x3D; env.getTypeUtils();</span><br><span class="line">        filer &#x3D; env.getFiler();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override </span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;</span><br><span class="line">        Map&lt;TypeElement, BindingSet&gt; bindingMap &#x3D; findAndParseTargets(env);</span><br><span class="line">        for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">            TypeElement typeElement &#x3D; entry.getKey();</span><br><span class="line">            BindingSet binding &#x3D; entry.getValue();</span><br><span class="line"></span><br><span class="line">            JavaFile javaFile &#x3D; binding.brewJava(sdk, debuggable);</span><br><span class="line">            try &#123;</span><br><span class="line">                javaFile.writeTo(filer);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</span><br><span class="line">        Map&lt;TypeElement, BindingSet.Builder&gt; builderMap &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">        Set&lt;TypeElement&gt; erasedTargetNames &#x3D; new LinkedHashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                parseBindView(element, builderMap, erasedTargetNames);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logParsingError(element, BindView.class, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span><br><span class="line">      Set&lt;TypeElement&gt; erasedTargetNames) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取该元素的父元素</span><br><span class="line">        TypeElement enclosingElement &#x3D; (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Start by verifying common generated code restrictions.</span><br><span class="line">    boolean hasError &#x3D; isInaccessibleViaGeneratedCode(BindView.class, &quot;fields&quot;, element)</span><br><span class="line">        || isBindingInWrongPackage(BindView.class, element);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Verify that the target type extends from View.</span><br><span class="line">    TypeMirror elementType &#x3D; element.asType();</span><br><span class="line">    if (elementType.getKind() &#x3D;&#x3D; TypeKind.TYPEVAR) &#123;</span><br><span class="line">      TypeVariable typeVariable &#x3D; (TypeVariable) elementType;</span><br><span class="line">      elementType &#x3D; typeVariable.getUpperBound();</span><br><span class="line">    &#125;</span><br><span class="line">    Name qualifiedName &#x3D; enclosingElement.getQualifiedName();</span><br><span class="line">    Name simpleName &#x3D; element.getSimpleName();</span><br><span class="line">    if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123;</span><br><span class="line">      if (elementType.getKind() &#x3D;&#x3D; TypeKind.ERROR) &#123;</span><br><span class="line">        note(element, &quot;@%s field with unresolved type (%s) &quot;</span><br><span class="line">                + &quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;,</span><br><span class="line">            BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        error(element, &quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;,</span><br><span class="line">            BindView.class.getSimpleName(), qualifiedName, simpleName);</span><br><span class="line">        hasError &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasError) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Assemble information on the field.</span><br><span class="line">    int id &#x3D; element.getAnnotation(BindView.class).value();</span><br><span class="line">    BindingSet.Builder builder &#x3D; builderMap.get(enclosingElement);</span><br><span class="line">    Id resourceId &#x3D; elementToId(element, BindView.class, id);</span><br><span class="line">    if (builder !&#x3D; null) &#123;</span><br><span class="line">      String existingBindingName &#x3D; builder.findExistingBindingName(resourceId);</span><br><span class="line">      if (existingBindingName !&#x3D; null) &#123;</span><br><span class="line">        error(element, &quot;Attempt to use @%s for an already bound ID %d on &#39;%s&#39;. (%s.%s)&quot;,</span><br><span class="line">            BindView.class.getSimpleName(), id, existingBindingName,</span><br><span class="line">            enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      builder &#x3D; getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name &#x3D; simpleName.toString();</span><br><span class="line">    TypeName type &#x3D; TypeName.get(elementType);</span><br><span class="line">    boolean required &#x3D; isFieldRequired(element);</span><br><span class="line"></span><br><span class="line">    builder.addField(resourceId, new FieldViewBinding(name, type, required));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Add the type-erased version to the valid binding targets set.</span><br><span class="line">    erasedTargetNames.add(enclosingElement);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/04/LeakCanary2.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/LeakCanary2.0/" class="post-title-link" itemprop="url">LeakCanary2.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-04 16:46:34" itemprop="dateCreated datePublished" datetime="2021-03-04T16:46:34+08:00">2021-03-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>LeakCanary 2.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">internal sealed class AppWatcherInstaller : ContentProvider() &#123;</span><br><span class="line">  override fun onCreate(): Boolean &#123;</span><br><span class="line">    val application &#x3D; context!!.applicationContext as Application</span><br><span class="line">    InternalAppWatcher.install(application)</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[InternalAppWatcher.kt]</span><br><span class="line">internal object InternalAppWatcher &#123;</span><br><span class="line">  fun install(application: Application) &#123;</span><br><span class="line">    SharkLog.logger &#x3D; DefaultCanaryLog()</span><br><span class="line">    SharkLog.d &#123; &quot;Installing AppWatcher&quot; &#125;</span><br><span class="line">    checkMainThread()</span><br><span class="line">    if (this::application.isInitialized) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    InternalAppWatcher.application &#x3D; application</span><br><span class="line"></span><br><span class="line">    val configProvider &#x3D; &#123; AppWatcher.config &#125;</span><br><span class="line">    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    onAppWatcherInstalled(application)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ActivityDestroyWatcher.kt]</span><br><span class="line">internal class ActivityDestroyWatcher private constructor(</span><br><span class="line">  private val objectWatcher: ObjectWatcher,</span><br><span class="line">  private val configProvider: () -&gt; Config</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  private val lifecycleCallbacks &#x3D;</span><br><span class="line">    object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">      override fun onActivityDestroyed(activity: Activity) &#123;</span><br><span class="line">        if (configProvider().watchActivities) &#123;</span><br><span class="line">          &#x2F;&#x2F; [监控activity对象]</span><br><span class="line">          objectWatcher.watch(activity)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  companion object &#123;</span><br><span class="line">    fun install(</span><br><span class="line">      application: Application,</span><br><span class="line">      objectWatcher: ObjectWatcher,</span><br><span class="line">      configProvider: () -&gt; Config</span><br><span class="line">    ) &#123;</span><br><span class="line">      val activityDestroyWatcher &#x3D;</span><br><span class="line">        ActivityDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[FragmentDestroyWatcher.kt]</span><br><span class="line">internal object FragmentDestroyWatcher &#123;</span><br><span class="line"></span><br><span class="line">  private const val ANDROIDX_FRAGMENT_CLASS_NAME &#x3D; &quot;androidx.fragment.app.Fragment&quot;</span><br><span class="line">  private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME &#x3D;</span><br><span class="line">    &quot;leakcanary.internal.AndroidXFragmentDestroyWatcher&quot;</span><br><span class="line"></span><br><span class="line">  private const val ANDROID_SUPPORT_FRAGMENT_CLASS_NAME &#x3D; &quot;android.support.v4.app.Fragment&quot;</span><br><span class="line">  private const val ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME &#x3D;</span><br><span class="line">    &quot;leakcanary.internal.AndroidSupportFragmentDestroyWatcher&quot;</span><br><span class="line"></span><br><span class="line">  fun install(</span><br><span class="line">    application: Application,</span><br><span class="line">    objectWatcher: ObjectWatcher,</span><br><span class="line">    configProvider: () -&gt; AppWatcher.Config</span><br><span class="line">  ) &#123;</span><br><span class="line">    val fragmentDestroyWatchers &#x3D; mutableListOf&lt;(Activity) -&gt; Unit&gt;()</span><br><span class="line">    if (SDK_INT &gt;&#x3D; O) &#123;</span><br><span class="line">      &#x2F;&#x2F; 针对Android O版本，</span><br><span class="line">      fragmentDestroyWatchers.add(</span><br><span class="line">          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">        ANDROIDX_FRAGMENT_CLASS_NAME,</span><br><span class="line">        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">        objectWatcher,</span><br><span class="line">        configProvider</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,</span><br><span class="line">        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">        objectWatcher,</span><br><span class="line">        configProvider</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fragmentDestroyWatchers.size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123;</span><br><span class="line">      override fun onActivityCreated(</span><br><span class="line">        activity: Activity,</span><br><span class="line">        savedInstanceState: Bundle?</span><br><span class="line">      ) &#123;</span><br><span class="line">        for (watcher in fragmentDestroyWatchers) &#123;</span><br><span class="line">          watcher(activity)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [AndroidOFragmentDestroyWatcher]</span><br><span class="line">internal class AndroidOFragmentDestroyWatcher(</span><br><span class="line">  private val objectWatcher: ObjectWatcher,</span><br><span class="line">  private val configProvider: () -&gt; Config</span><br><span class="line">) : (Activity) -&gt; Unit &#123;</span><br><span class="line">  private val fragmentLifecycleCallbacks &#x3D; object : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onFragmentViewDestroyed(</span><br><span class="line">      fm: FragmentManager,</span><br><span class="line">      fragment: Fragment</span><br><span class="line">    ) &#123;</span><br><span class="line">      val view &#x3D; fragment.view</span><br><span class="line">      if (view !&#x3D; null &amp;&amp; configProvider().watchFragmentViews) &#123;</span><br><span class="line">        objectWatcher.watch(view)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onFragmentDestroyed(</span><br><span class="line">      fm: FragmentManager,</span><br><span class="line">      fragment: Fragment</span><br><span class="line">    ) &#123;</span><br><span class="line">      if (configProvider().watchFragments) &#123;</span><br><span class="line">        objectWatcher.watch(fragment)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun invoke(activity: Activity) &#123;</span><br><span class="line">    &#x2F;&#x2F;【重要细节】</span><br><span class="line">    val fragmentManager &#x3D; activity.fragmentManager</span><br><span class="line">    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">AndroidX</span><br><span class="line">&#x2F;&#x2F;val supportFragmentManager &#x3D; activity.supportFragmentManager</span><br><span class="line">&#x2F;&#x2F;supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)</span><br></pre></td></tr></table></figure>
<p>它是在什么时机，去判断是否存在内存泄露的</p>
<ul>
<li>1.Activity：通过在Application中注册registerActivityLifecycleCallbacks绑定Activity生命周期回调，并在onActivityDestroyed回调中监控Activity</li>
<li>2.Fragment：通过在Application中注册registerActivityLifecycleCallbacks绑定Activity生命周期回调，并在onActivityCreated回调中，通过在Activity中注册注册FragmentLifecycleCallbacks回调，并在onFragmentDestroyed回调时，监控fragment</li>
<li>3.Fragment View：通过在Application中注册registerActivityLifecycleCallbacks绑定Activity生命周期回调，并在onActivityCreated回调中，通过在Activity中注册注册FragmentLifecycleCallbacks回调，并在onFragmentViewDestroyed回调中监控Fragment View</li>
<li>4.ViewModel：针对AndroidX库中的Activity，对于Activit，在onActivityCreated回调中注册监听，对于Fragment，在onFragmentCreated回调中注册监听，在ViewModel的onCleared回调中监控ViewModel</li>
</ul>
<h2 id="监控流程"><a href="#监控流程" class="headerlink" title="监控流程"></a>监控流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class ObjectWatcher constructor(</span><br><span class="line">  private val clock: Clock,</span><br><span class="line">  private val checkRetainedExecutor: Executor,</span><br><span class="line">  private val isEnabled: () -&gt; Boolean &#x3D; &#123; true &#125;</span><br><span class="line">) &#123;</span><br><span class="line">  private val watchedObjects &#x3D; mutableMapOf&lt;String, KeyedWeakReference&gt;()</span><br><span class="line">  private val queue &#x3D; ReferenceQueue&lt;Any&gt;()</span><br><span class="line">  </span><br><span class="line">  @Synchronized fun watch(watchedObject: Any) &#123;</span><br><span class="line">    watch(watchedObject, &quot;&quot;)</span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  @Synchronized fun watch(</span><br><span class="line">    watchedObject: Any,</span><br><span class="line">    name: String</span><br><span class="line">  ) &#123;</span><br><span class="line">    if (!isEnabled()) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    removeWeaklyReachableObjects()</span><br><span class="line">    val key &#x3D; UUID.randomUUID().toString()</span><br><span class="line">    val watchUptimeMillis &#x3D; clock.uptimeMillis()</span><br><span class="line">    val reference &#x3D; KeyedWeakReference(watchedObject, key, name, watchUptimeMillis, queue)</span><br><span class="line"></span><br><span class="line">    watchedObjects[key] &#x3D; reference</span><br><span class="line">    checkRetainedExecutor.execute &#123;</span><br><span class="line">      moveToRetained(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun removeWeaklyReachableObjects() &#123;</span><br><span class="line">    &#x2F;&#x2F; 弱引用一旦变得弱可达，就会立即入队。这将在 finalization 或者 GC 之前发生。</span><br><span class="line">    var ref: KeyedWeakReference?</span><br><span class="line">    do &#123;</span><br><span class="line">      ref &#x3D; queue.poll() as KeyedWeakReference?</span><br><span class="line">      &#x2F;&#x2F; 引用队列里面的元素都是已经回收过的，所以需要剔除出去</span><br><span class="line">      if (ref !&#x3D; null) &#123;</span><br><span class="line">        watchedObjects.remove(ref.key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while (ref !&#x3D; null)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 其实是在主线程里面执行的，Looper为mainLooper对象</span><br><span class="line">  @Synchronized private fun moveToRetained(key: String) &#123;</span><br><span class="line">    removeWeaklyReachableObjects() &#x2F;&#x2F; [第一次确认是否被回收]</span><br><span class="line">    val retainedRef &#x3D; watchedObjects[key]</span><br><span class="line">    if (retainedRef !&#x3D; null) &#123;</span><br><span class="line">      retainedRef.retainedUptimeMillis &#x3D; clock.uptimeMillis()</span><br><span class="line">      onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a>InternalLeakCanary</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">internal object InternalLeakCanary : (Application) -&gt; Unit, OnObjectRetainedListener &#123;</span><br><span class="line"></span><br><span class="line">  override fun onObjectRetained() &#123;</span><br><span class="line">    if (this::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">      heapDumpTrigger.onObjectRetained()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;[HeapDumpTrigger]</span><br><span class="line">internal class HeapDumpTrigger(</span><br><span class="line">  private val application: Application,</span><br><span class="line">  private val backgroundHandler: Handler,</span><br><span class="line">  private val objectWatcher: ObjectWatcher,</span><br><span class="line">  private val gcTrigger: GcTrigger,</span><br><span class="line">  private val heapDumper: HeapDumper,</span><br><span class="line">  private val configProvider: () -&gt; Config</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  fun onObjectRetained() &#123;</span><br><span class="line">    scheduleRetainedObjectCheck(&quot;found new object retained&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private fun scheduleRetainedObjectCheck(reason: String) &#123;</span><br><span class="line">    if (checkScheduled) &#123;</span><br><span class="line">      SharkLog.d &#123; &quot;Already scheduled retained check, ignoring ($reason)&quot; &#125;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    checkScheduled &#x3D; true</span><br><span class="line">    backgroundHandler.post &#123;</span><br><span class="line">      checkScheduled &#x3D; false</span><br><span class="line">      checkRetainedObjects(reason)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 转交后台线程运行</span><br><span class="line">  private fun checkRetainedObjects(reason: String) &#123;</span><br><span class="line">    val config &#x3D; configProvider()</span><br><span class="line"></span><br><span class="line">    var retainedReferenceCount &#x3D; objectWatcher.retainedObjectCount</span><br><span class="line">    &#x2F;&#x2F; --&gt; 1. removeWeaklyReachableObjects()</span><br><span class="line">    &#x2F;&#x2F; --&gt; 2. watchedObjects.count &#123; it.value.retainedUptimeMillis !&#x3D; -1L &#125;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    if (retainedReferenceCount &gt; 0) &#123;</span><br><span class="line">      gcTrigger.runGc()</span><br><span class="line">      &#x2F;&#x2F; --&gt; 1. Runtime.getRuntime().gc()</span><br><span class="line">      &#x2F;&#x2F; --&gt; 2. Thread.sleep(100)</span><br><span class="line">      &#x2F;&#x2F; --&gt; 3. System.runFinalization()</span><br><span class="line">      retainedReferenceCount &#x3D; objectWatcher.retainedObjectCount</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当前泄露实例个数小于 5 个，不进行 heap dump</span><br><span class="line">    if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return</span><br><span class="line"></span><br><span class="line">    if (!config.dumpHeapWhenDebugging &amp;&amp; DebuggerControl.isDebuggerAttached) &#123;</span><br><span class="line">      showRetainedCountWithDebuggerAttached(retainedReferenceCount)</span><br><span class="line">      scheduleRetainedObjectCheck(&quot;debugger was attached&quot;, WAIT_FOR_DEBUG_MILLIS)</span><br><span class="line">      SharkLog.d &#123;</span><br><span class="line">          &quot;Not checking for leaks while the debugger is attached, will retry in $WAIT_FOR_DEBUG_MILLIS ms&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharkLog.d &#123; &quot;Found $retainedReferenceCount retained references, dumping the heap&quot; &#125;</span><br><span class="line">    val heapDumpUptimeMillis &#x3D; SystemClock.uptimeMillis()</span><br><span class="line">    KeyedWeakReference.heapDumpUptimeMillis &#x3D; heapDumpUptimeMillis</span><br><span class="line">    dismissRetainedCountNotification()</span><br><span class="line">    val heapDumpFile &#x3D; heapDumper.dumpHeap()</span><br><span class="line">    if (heapDumpFile &#x3D;&#x3D; null) &#123;</span><br><span class="line">      SharkLog.d &#123; &quot;Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms&quot; &#125;</span><br><span class="line">      scheduleRetainedObjectCheck(&quot;failed to dump heap&quot;, WAIT_AFTER_DUMP_FAILED_MILLIS)</span><br><span class="line">      showRetainedCountWithHeapDumpFailed(retainedReferenceCount)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    lastDisplayedRetainedObjectCount &#x3D; 0</span><br><span class="line">    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line"></span><br><span class="line">    HeapAnalyzerService.runAnalysis(application, heapDumpFile)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>分享</li>
<li>点赞、关注：</li>
<li>组件WebView组件优化：单独进程之中</li>
<li>多渠道打包</li>
</ol>
<p>MultiDex优化总结<br>方案1：直接在闪屏页开个子线程去执行MultiDex逻辑，MultiDex不影响冷启动速度，但是难维护。</p>
<p>方案2：今日头条的MultiDex优化方案：</p>
<p>在Application 的attachBaseContext 方法里，启动另一个进程的LoadDexActivity去异步执行MultiDex逻辑，显示Loading。<br>然后主进程Application进入while循环，不断检测MultiDex操作是否完成<br>MultiDex执行完之后主进程Application继续走，ContentProvider初始化和Application onCreate方法，也就是执行主进程正常的逻辑。</p>
<p>避免OOM的方法<br>减小对象的内存占用<br>避免OOM的第一步就是要尽量减少新分配出来的对象占用内存的大小，尽量使用更加轻量级的对象。</p>
<ol>
<li><p>使用更加轻量的数据结构<br>使用 ArrayMap/ SparseArray替代HashMap等传统数据结构。<br>ArrayMap是Android系统专为移动操作系统编写的容器，在大多数情况下，比HashMap效率更高，占用内存更少。<br>SparseArray更加高效在于它们避免了对key和value的autobox自动装箱，并且避免了装箱后的解箱。</p>
</li>
<li><p>避免在Android里面使用Enum</p>
</li>
</ol>
<p>Android官方说明”Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.“，所以应避免在Android里面使用枚举。</p>
<ol start="3">
<li>减小Bitmap对象的内存占用</li>
</ol>
<p>Bitmap是一个极容易消耗内存的大胖子，减小创建处理的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>
<p>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。<br>decode format：解码格式，选择 ARGB_8888/ RGB_565/ ARGB_4444/ ALPHA_8，存在很大差异。<br>4. 使用更小的图片</p>
<p>对应资源图片，要特别留意这张图片是否存在可压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的 InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候会因为内存不足而发生 InflationException，这个问题的根本原因其实是发生了OOM。</p>
<p>内存对象的重复利用<br>大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显示的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。<br>在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，建议操作原理如下图所示：</p>
<ol>
<li>复用系统自带的资源<br>Android系统本身内置了许多的资源，如字符串、颜色、图片、动画、样式以及简单布局等，这些资源可以在应用程序中直接使用。这样做不仅仅可以减少应用程序的自身负重，减小APK的大小。但是要留意Android系统的版本差异性。</li>
<li>注意在ListView/GridView等出现大量重复子组件的视图里面对ConvertView的复用3. Bitmap对象的复用<br>在RecyclerView、ListView、GridView等显示大量图片的控件里面需要使用LRU机制来缓存处理好的Bitmap。<br>利用 inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率上的提升。使用 inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的 pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的大小。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/03/JDK-Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/03/JDK-Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">JDK-Java 8 新特性总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-03 15:49:39 / 修改时间：16:56:08" itemprop="dateCreated datePublished" datetime="2021-03-03T15:49:39+08:00">2021-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p>
<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>Java8 新增了非常多的特性，我们主要讨论以下几个：</p>
<ul>
<li>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>
<li>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>
<li>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li>Date Time API − 加强对日期与时间的处理。</li>
<li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h2 id="1-Optional类"><a href="#1-Optional类" class="headerlink" title="1. Optional类"></a>1. Optional类</h2><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>Optional 类的引入很好的解决空指针异常。</p>
<p>我们看看Optional的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    private static final Optional&lt;?&gt; EMPTY &#x3D; new Optional&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public static&lt;T&gt; Optional&lt;T&gt; empty() &#123;</span><br><span class="line">        Optional&lt;T&gt; t &#x3D; (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Optional(T value) &#123;</span><br><span class="line">        this.value &#x3D; Objects.requireNonNull(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 允许传递为 null 参数</span><br><span class="line">    public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;</span><br><span class="line">        return value &#x3D;&#x3D; null ? empty() : of(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 不允许传递 null 参数</span><br><span class="line">    public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;</span><br><span class="line">        return new Optional&lt;&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; value !&#x3D;null 返回true</span><br><span class="line">    public boolean isPresent() &#123;</span><br><span class="line">        return value !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果值存在，返回它，否则返回默认值</span><br><span class="line">    public T orElse(T other) &#123;</span><br><span class="line">        return value !&#x3D; null ? value : other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-默认方法"><a href="#2-默认方法" class="headerlink" title="2. 默认方法"></a>2. 默认方法</h2><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。<br>我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
<blockquote>
<p>为什么要有这个特性？</p>
<p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8 之前的集合框架没有 foreach 方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
</blockquote>
<h2 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3. 方法引用"></a>3. 方法引用</h2><p>方法引用使用一对冒号 :: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</span><br><span class="line">final Car car &#x3D; Car.create(Car::new );</span><br><span class="line">final List&lt; Car &gt; cars &#x3D; Arrays.asList( car );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 静态方法引用：它的语法是Class::static_method，实例如下：</span><br><span class="line">cars.forEach( Car::collide );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特定类的任意对象的方法引用：它的语法是Class::method实例如下：</span><br><span class="line">cars.forEach( Car::repair );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 特定对象的方法引用：它的语法是instance::method实例如下：</span><br><span class="line">final Car police &#x3D; Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>

<h2 id="4-日期时间-API"><a href="#4-日期时间-API" class="headerlink" title="4. 日期时间 API"></a>4. 日期时间 API</h2><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p>
<p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p>
<ul>
<li>非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。<br>设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。<br>时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li>
<li>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：</li>
<li>Local(本地) − 简化了日期时间的处理，没有时区的问题。</li>
<li>Zoned(时区) − 通过制定的时区处理日期时间。</li>
</ul>
<p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime currentTime &#x3D; LocalDateTime.now();</span><br><span class="line">LocalDate date1 &#x3D; currentTime.toLocalDate();</span><br><span class="line">Month month &#x3D; currentTime.getMonth();</span><br><span class="line"></span><br><span class="line">ZonedDateTime date1 &#x3D; ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia&#x2F;Shanghai]&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="5-Lambda-表达式"><a href="#5-Lambda-表达式" class="headerlink" title="5. Lambda 表达式"></a>5. Lambda 表达式</h2><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MathOperation addition &#x3D; (int a, int b) -&gt; a + b;</span><br><span class="line">MathOperation subtraction &#x3D; (a, b) -&gt; a - b;</span><br><span class="line">MathOperation multiplication &#x3D; (int a, int b) -&gt; &#123; return a * b; &#125;;</span><br><span class="line">MathOperation division &#x3D; (int a, int b) -&gt; a &#x2F; b;</span><br></pre></td></tr></table></figure>

<h2 id="6-Stream"><a href="#6-Stream" class="headerlink" title="6. Stream"></a>6. Stream</h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。<br>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li><strong>元素是特定类型的对象，形成一个队列。</strong> Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源 流的来源。</strong> 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>*<em>聚合操作 *</em>类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<p><strong>生成流</strong></p>
<ul>
<li>stream() − 为集合创建串行流。</li>
<li>parallelStream() − 为集合创建并行流。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><strong>forEach</strong><br>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;a&quot;, &quot;ba&quot;, &quot;bb&quot;, &quot;abc&quot;, &quot;cbb&quot;, &quot;bba&quot;, &quot;cab&quot;);</span><br><span class="line">Map&lt;Integer, String&gt; strMap &#x3D; new HashMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">strMap &#x3D; strList.stream()</span><br><span class="line">         .collect( Collectors.toMap( str -&gt; strList.indexOf(str), str -&gt; str ) );</span><br><span class="line">strMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">    System.out.println(key+&quot;::&quot;+value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>** map **方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">&#x2F;&#x2F; 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList &#x3D; numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>** filter **方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取空字符串的数量</span><br><span class="line">long count &#x3D; strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<p>** limit **方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>*<em>sorted *</em>方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>*<em>Collectors *</em>类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/02/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-HashMap%E3%80%81ConcurrentHashMap%20-%20%E5%89%AF%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/JDK-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-HashMap%E3%80%81ConcurrentHashMap%20-%20%E5%89%AF%E6%9C%AC/" class="post-title-link" itemprop="url">JDK 源码解析 -- HashMap、ConcurrentHashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-02 10:30:21" itemprop="dateCreated datePublished" datetime="2021-03-02T10:30:21+08:00">2021-03-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>HashMap ：先说HashMap，HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。</li>
<li>HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是1.HashTable不允许key和value为null；2.HashTable是线程安全的。但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>首先看看HashMap的结构图,采用了数组+链表的方式。<br><img src="http://upload-images.jianshu.io/upload_images/2169292-f46bc2b4b818d8de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-29 21.28.36.png"></p>
<p>实现原理<br><img src="http://upload-images.jianshu.io/upload_images/2169292-ab0b9d4d53b3d2d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-29 21.40.44.png"></p>
<p><strong>1. 定义interface Map、interface Entry 接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Map&lt;K, V&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean containsKey(Object key);</span><br><span class="line">    V get(Object key);</span><br><span class="line">    V put(K key, V value);</span><br><span class="line">    V remove(Object key);</span><br><span class="line">    void clear();</span><br><span class="line"></span><br><span class="line">    interface Entry&lt;K, V&gt; &#123;</span><br><span class="line">        K getKey();</span><br><span class="line">        V getValue();</span><br><span class="line">        V setValue(V value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. HashMap类剖析</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始大小桶大小</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</span><br><span class="line">    &#x2F;&#x2F; 填装因子</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F;红黑树阈值</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash &#x3D; hash;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 取对象的hashCode值高16位和低16位异或</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回大于输入参数且最近的2的整数次幂的数, 比如10，则返回16</span><br><span class="line">    static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n &#x3D; cap - 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">        n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashMap() &#123;</span><br><span class="line">        this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; 16</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashMap(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this.loadFactor &#x3D; loadFactor;</span><br><span class="line">        this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点】put操作</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        &#x2F;&#x2F; 初始化tab、n变量</span><br><span class="line">        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">        &#x2F;&#x2F; 根据hash值从tab数组中查找元素</span><br><span class="line">        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F; 不存在，则创建新Node节点</span><br><span class="line">            tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 插入的节点已经存在，接下来就要根据key找到该节点</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F; hash相等并且key也相等</span><br><span class="line">                e &#x3D; p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                &#x2F;&#x2F; 在红黑树中查找</span><br><span class="line">                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; 在链表中查找</span><br><span class="line">                for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 替换之前的节点值，返回之前的旧值</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                V oldValue &#x3D; e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                    e.value &#x3D; value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            &#x2F;&#x2F; 扩容</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点】get操作</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F; 初始化tab、n、first变量, 根据hash查找Node节点</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                &#x2F;&#x2F; 如果hash相等并且key也相等</span><br><span class="line">                return first;</span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    &#x2F;&#x2F; 在红黑树中查找</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                &#x2F;&#x2F; 顺序遍历链表</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点】remove</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; removeNode(hash(key), key, null, false, true)) &#x3D;&#x3D; null ?</span><br><span class="line">            null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                               boolean matchValue, boolean movable) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">            if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                node &#x3D; p;</span><br><span class="line">            else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">                if (p instanceof TreeNode)</span><br><span class="line">                    node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                else &#123;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                            ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                             (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node &#x3D; e;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p &#x3D; e;</span><br><span class="line">                    &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                                 (value !&#x3D; null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                if (node instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">                else if (node &#x3D;&#x3D; p)</span><br><span class="line">                    tab[index] &#x3D; node.next;</span><br><span class="line">                else</span><br><span class="line">                    p.next &#x3D; node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 【重点JDK 1.8】tab扩容</span><br><span class="line">    final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table; &#x2F;&#x2F; 将当前table暂存到oldtab来操作</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123; &#x2F;&#x2F; 旧table容量大于最大容量</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; 设置装载因子为最大值</span><br><span class="line">                return oldTab; &#x2F;&#x2F; 不用扩容</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                &#x2F;&#x2F; 新table长度扩大一倍，装载因子扩大一倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0)</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        else &#123;</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        &#x2F;&#x2F; 重新hash过程</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            &#x2F;&#x2F; 此时，旧数组上的数据就会根据(e.hash &amp; oldCap) 是否等于0这个算法,被很巧妙地分为2类:</span><br><span class="line">                            &#x2F;&#x2F; ① 等于0时，则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置,记为低位区链表lo开头-low;</span><br><span class="line">                            &#x2F;&#x2F; ② 不等于0时,则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置再加上旧数组长度，记为高位区链表hi开头high.</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><img src="http://upload-images.jianshu.io/upload_images/2169292-f4c022a8e6a1d0f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-29 22.00.36.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                               float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">          if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class="line">              throw new IllegalArgumentException();</span><br><span class="line">          &#x2F;&#x2F;MAX_SEGMENTS 为1&lt;&lt;16&#x3D;65536，也就是最大并发数为65536</span><br><span class="line">          if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">              concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class="line">          &#x2F;&#x2F;2的sshif次方等于ssize，例:ssize&#x3D;16,sshift&#x3D;4;ssize&#x3D;32,sshif&#x3D;5</span><br><span class="line">         int sshift &#x3D; 0;</span><br><span class="line">         &#x2F;&#x2F;ssize 为segments数组长度，根据concurrentLevel计算得出</span><br><span class="line">         int ssize &#x3D; 1;</span><br><span class="line">         while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">             ++sshift;</span><br><span class="line">             ssize &lt;&lt;&#x3D; 1;</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;segmentShift和segmentMask这两个变量在定位segment时会用到，后面会详细讲</span><br><span class="line">         this.segmentShift &#x3D; 32 - sshift;</span><br><span class="line">         this.segmentMask &#x3D; ssize - 1;</span><br><span class="line">         if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">             initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">         &#x2F;&#x2F;计算cap的大小，即Segment中HashEntry的数组长度，cap也一定为2的n次方.</span><br><span class="line">         int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">         if (c * ssize &lt; initialCapacity)</span><br><span class="line">             ++c;</span><br><span class="line">         int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">         while (cap &lt; c)</span><br><span class="line">             cap &lt;&lt;&#x3D; 1;</span><br><span class="line">         &#x2F;&#x2F;创建segments数组并初始化第一个Segment，其余的Segment延迟初始化</span><br><span class="line">         Segment&lt;K,V&gt; s0 &#x3D;</span><br><span class="line">             new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                              (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">         Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">         UNSAFE.putOrderedObject(ss, SBASE, s0); </span><br><span class="line">         this.segments &#x3D; ss;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        &#x2F;&#x2F;concurrentHashMap不允许key&#x2F;value为空</span><br><span class="line">        if (value &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F;hash函数对key的hashCode重新散列，避免差劲的不合理的hashcode，保证散列均匀</span><br><span class="line">        int hash &#x3D; hash(key);</span><br><span class="line">        &#x2F;&#x2F;返回的hash值无符号右移segmentShift位与段掩码进行位运算，定位segment</span><br><span class="line">        int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">            s &#x3D; ensureSegment(j);</span><br><span class="line">        return s.put(key, hash, value, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; </span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        int h &#x3D; hash(key);</span><br><span class="line">        long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        &#x2F;&#x2F;先定位Segment，再定位HashEntry</span><br><span class="line">        if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class="line">            (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class="line">            for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class="line">                    return e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">                scanAndLockForPut(key, hash, value);&#x2F;&#x2F;tryLock不成功时会遍历定位到的HashEnry位置的链表（遍历主要是为了使CPU缓存链表），若找不到，则创建HashEntry。tryLock一定次数后（MAX_SCAN_RETRIES变量决定），则lock。若遍历过程中，由于其他线程的操作导致链表头结点变化，则需要重新遍历。</span><br><span class="line">            V oldValue;</span><br><span class="line">            try &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">                int index &#x3D; (tab.length - 1) &amp; hash;&#x2F;&#x2F;定位HashEntry，可以看到，这个hash值在定位Segment时和在Segment中定位HashEntry都会用到，只不过定位Segment时只用到高几位。</span><br><span class="line">                HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line">                for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">                    if (e !&#x3D; null) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                            (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue &#x3D; e.value;</span><br><span class="line">                            if (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value &#x3D; value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e &#x3D; e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (node !&#x3D; null)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        else</span><br><span class="line">                            node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        int c &#x3D; count + 1;</span><br><span class="line">　　　　　　　　　　　　　　&#x2F;&#x2F;若c超出阈值threshold，需要扩容并rehash。扩容后的容量是当前容量的2倍。这样可以最大程度避免之前散列好的entry重新散列，具体在另一篇文章中有详细分析，不赘述。扩容并rehash的这个过程是比较消耗资源的。</span><br><span class="line">                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        else</span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count &#x3D; c;</span><br><span class="line">                        oldValue &#x3D; null;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList是Java并发包中提供的一个并发容器，它是个线程安全且读操作无锁的ArrayList，写操作则通过创建底层数组的新副本来实现，是一种读写分离的并发策略，我们也可以称这种容器为”写时复制器”，Java并发包中类似的容器还有CopyOnWriteSet。</p>
<p><strong>实现原理</strong><br>我们都知道，集合框架中的ArrayList是非线程安全的，Vector虽是线程安全的，但由于简单粗暴的锁同步机制，性能较差。而CopyOnWriteArrayList则提供了另一种不同的并发处理策略。很多时候，我们的系统应对的都是读多写少的并发场景。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p>
<p><strong>优缺点分析</strong><br>了解了CopyOnWriteArrayList的实现原理，分析它的优缺点及使用场景就很容易了。</p>
<ul>
<li><p>优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。Java的list在遍历时，若中途有别的线程对list容器进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其”读写分离”的思想，遍历和修改操作分别作用在不同的list容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了</p>
</li>
<li><p>缺点：缺点也很明显，一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC；二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        &#x2F;&#x2F;ReentrantLock加锁，保证线程安全</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            &#x2F;&#x2F;拷贝原容器，长度为原容器长度加一</span><br><span class="line">            Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br><span class="line">            &#x2F;&#x2F;在新副本上执行添加操作</span><br><span class="line">            newElements[len] &#x3D; e;</span><br><span class="line">            &#x2F;&#x2F;将原容器引用指向新副本</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">        &#x2F;&#x2F;加锁</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements &#x3D; getArray();</span><br><span class="line">            int len &#x3D; elements.length;</span><br><span class="line">            E oldValue &#x3D; get(elements, index);</span><br><span class="line">            int numMoved &#x3D; len - index - 1;</span><br><span class="line">            if (numMoved &#x3D;&#x3D; 0)</span><br><span class="line">                &#x2F;&#x2F;如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span><br><span class="line">                setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F;否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用</span><br><span class="line">                Object[] newElements &#x3D; new Object[len - 1];</span><br><span class="line">                System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">                System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                                 numMoved);</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F;解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">        return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">        return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考博客<br><a href="http://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">1.HashMap实现原理及源码分析</a><br><a href="http://www.cnblogs.com/chengxiao/p/6881974.html" target="_blank" rel="noopener">2.CopyOnWriteArrayList实现原理及源码分析</a><br><a href="http://blog.csdn.net/eson_15/article/details/51543812" target="_blank" rel="noopener">3. 造成HashMap非线程安全的原因</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/01/LocalBroadcastManager%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/LocalBroadcastManager%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">LocalBroadcastManager源码剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 16:13:23" itemprop="dateCreated datePublished" datetime="2021-03-01T16:13:23+08:00">2021-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/LocalBroadcastManager/" itemprop="url" rel="index"><span itemprop="name">LocalBroadcastManager</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LocalBroadcastManager"><a href="#LocalBroadcastManager" class="headerlink" title="LocalBroadcastManager"></a>LocalBroadcastManager</h3><ul>
<li>LocalBroadcast的广播接收者是运行在主线程中</li>
<li>LocalBroadcast数据传递需要存放到Intent里面去，且onReceive函数需要传递Context上下文</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public final class LocalBroadcastManager &#123;</span><br><span class="line">    private static final Object mLock &#x3D; new Object();</span><br><span class="line">    &#x2F;&#x2F; 单例模式，但是效率不高，每次获取的时候都要申请锁</span><br><span class="line">    &#x2F;&#x2F; 其实可以调整为双重检验锁，效率更高一些</span><br><span class="line">    public static LocalBroadcastManager getInstance(@NonNull Context context) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            if (mInstance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mInstance &#x3D; new LocalBroadcastManager(context.getApplicationContext());</span><br><span class="line">            &#125;</span><br><span class="line">            return mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private final Handler mHandler;</span><br><span class="line">    private final Context mAppContext;</span><br><span class="line">    &#x2F;&#x2F; LocalBroadcast运行在主线程之中</span><br><span class="line">    private LocalBroadcastManager(Context context) &#123;</span><br><span class="line">        mAppContext &#x3D; context;</span><br><span class="line">        mHandler &#x3D; new Handler(context.getMainLooper()) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line">                switch (msg.what) &#123;</span><br><span class="line">                    case MSG_EXEC_PENDING_BROADCASTS:</span><br><span class="line">                        executePendingBroadcasts();</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        super.handleMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 待分发广播列表</span><br><span class="line">    private final ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    void executePendingBroadcasts() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F; ArrayList 转换为数组</span><br><span class="line">            final BroadcastRecord[] brs;</span><br><span class="line">            synchronized (mReceivers) &#123;</span><br><span class="line">                final int N &#x3D; mPendingBroadcasts.size();</span><br><span class="line">                if (N &lt;&#x3D; 0) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                brs &#x3D; new BroadcastRecord[N];</span><br><span class="line">                mPendingBroadcasts.toArray(brs);</span><br><span class="line">                mPendingBroadcasts.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 分发执行receiver.onReceive方法</span><br><span class="line">            for (int i&#x3D;0; i&lt;brs.length; i++) &#123;</span><br><span class="line">                final BroadcastRecord br &#x3D; brs[i];</span><br><span class="line">                final int nbr &#x3D; br.receivers.size();</span><br><span class="line">                for (int j&#x3D;0; j&lt;nbr; j++) &#123;</span><br><span class="line">                    final ReceiverRecord rec &#x3D; br.receivers.get(j);</span><br><span class="line">                    if (!rec.dead) &#123;</span><br><span class="line">                        rec.receiver.onReceive(mAppContext, br.intent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态内部类</span><br><span class="line">    private static final class ReceiverRecord &#123;</span><br><span class="line">        final IntentFilter filter;</span><br><span class="line">        final BroadcastReceiver receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 静态内部类</span><br><span class="line">    private static final class BroadcastRecord &#123;</span><br><span class="line">        final Intent intent;</span><br><span class="line">        final ArrayList&lt;ReceiverRecord&gt; receivers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 目的：方便快速的解注册用，根据BroadcastReceiver，快速从mActions移除解注册的ReceiverRecord</span><br><span class="line">private final HashMap&lt;BroadcastReceiver, ArrayList&lt;ReceiverRecord&gt;&gt; mReceivers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F; 目的：发送广播使用，根据Action快速找到广播接收器</span><br><span class="line">private final HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void registerReceiver(@NonNull BroadcastReceiver receiver, @NonNull IntentFilter filter) &#123;</span><br><span class="line">    synchronized (mReceivers) &#123;</span><br><span class="line">        ReceiverRecord entry &#x3D; new ReceiverRecord(filter, receiver);</span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; filters &#x3D; mReceivers.get(receiver);</span><br><span class="line">        if (filters &#x3D;&#x3D; null) &#123;</span><br><span class="line">            filters &#x3D; new ArrayList&lt;&gt;(1);</span><br><span class="line">            mReceivers.put(receiver, filters);</span><br><span class="line">        &#125;</span><br><span class="line">        filters.add(entry); &#x2F;&#x2F; Java值传递问题？em~~是的(https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;31203609)</span><br><span class="line">        for (int i&#x3D;0; i&lt;filter.countActions(); i++) &#123;</span><br><span class="line">            String action &#x3D; filter.getAction(i);</span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; entries &#x3D; mActions.get(action);</span><br><span class="line">            if (entries &#x3D;&#x3D; null) &#123;</span><br><span class="line">                entries &#x3D; new ArrayList&lt;ReceiverRecord&gt;(1);</span><br><span class="line">                mActions.put(action, entries);</span><br><span class="line">            &#125;</span><br><span class="line">            entries.add(entry); &#x2F;&#x2F; Java值传递问题？em~~是的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendBroadcast(@NonNull Intent intent) &#123;</span><br><span class="line">    synchronized (mReceivers) &#123;</span><br><span class="line">        final String action &#x3D; intent.getAction();</span><br><span class="line">        final String type &#x3D; intent.resolveTypeIfNeeded(mAppContext.getContentResolver());</span><br><span class="line">        final Uri data &#x3D; intent.getData();</span><br><span class="line">        final String scheme &#x3D; intent.getScheme();</span><br><span class="line">        final Set&lt;String&gt; categories &#x3D; intent.getCategories();</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; entries &#x3D; mActions.get(intent.getAction());</span><br><span class="line">        if (entries !&#x3D; null) &#123;</span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; receivers &#x3D; null;</span><br><span class="line">            for (int i&#x3D;0; i&lt;entries.size(); i++) &#123;</span><br><span class="line">                ReceiverRecord receiver &#x3D; entries.get(i);</span><br><span class="line">                if (receiver.broadcasting) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 匹配指定的action</span><br><span class="line">                int match &#x3D; receiver.filter.match(action, type, scheme, data,categories, &quot;LocalBroadcastManager&quot;);</span><br><span class="line">                if (match &gt;&#x3D; 0) &#123;</span><br><span class="line">                    if (receivers &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        receivers &#x3D; new ArrayList&lt;ReceiverRecord&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    receivers.add(receiver);</span><br><span class="line">                    receiver.broadcasting &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (receivers !&#x3D; null) &#123;</span><br><span class="line">                for (int i&#x3D;0; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                    receivers.get(i).broadcasting &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingBroadcasts.add(new BroadcastRecord(intent, receivers));</span><br><span class="line">                if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;</span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解注册广播"><a href="#解注册广播" class="headerlink" title="解注册广播"></a>解注册广播</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void unregisterReceiver(@NonNull BroadcastReceiver receiver) &#123;</span><br><span class="line">    synchronized (mReceivers) &#123;</span><br><span class="line">        final ArrayList&lt;ReceiverRecord&gt; filters &#x3D; mReceivers.remove(receiver);</span><br><span class="line">        if (filters &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 从mActions快速移除指定的注册的ReceiverRecord</span><br><span class="line">        for (int i&#x3D;filters.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">            final ReceiverRecord filter &#x3D; filters.get(i);</span><br><span class="line">            filter.dead &#x3D; true;</span><br><span class="line">            for (int j&#x3D;0; j&lt;filter.filter.countActions(); j++) &#123;</span><br><span class="line">                final String action &#x3D; filter.filter.getAction(j);</span><br><span class="line">                final ArrayList&lt;ReceiverRecord&gt; receivers &#x3D; mActions.get(action);</span><br><span class="line">                if (receivers !&#x3D; null) &#123;</span><br><span class="line">                    for (int k&#x3D;receivers.size()-1; k&gt;&#x3D;0; k--) &#123;</span><br><span class="line">                        final ReceiverRecord rec &#x3D; receivers.get(k);</span><br><span class="line">                        if (rec.receiver &#x3D;&#x3D; receiver) &#123;</span><br><span class="line">                            rec.dead &#x3D; true;</span><br><span class="line">                            receivers.remove(k);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (receivers.size() &lt;&#x3D; 0) &#123;</span><br><span class="line">                        mActions.remove(action);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/26/InputManagerService%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/26/InputManagerService%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">InputManagerService 工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-26 16:35:39 / 修改时间：16:41:32" itemprop="dateCreated datePublished" datetime="2021-02-26T16:35:39+08:00">2021-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Android6-0系统触摸事件工作原理——InputManagerService"><a href="#Android6-0系统触摸事件工作原理——InputManagerService" class="headerlink" title="Android6.0系统触摸事件工作原理——InputManagerService"></a>Android6.0系统触摸事件工作原理——InputManagerService</h2><p>Android的事件处理是在Linux基础上完成的。事件的最开始是由硬件监听到，然后通过硬件分到Kernel，Kernel在分到框架层，最后最后框架层把事件分布到应用程序的UI中。下面就以触摸事件为例进行分析。<br>当有事件发生的时候，硬件首先监听到，然后InputDriver起作用，而框架层的EventHub类一直在InputDriver中读事件；当EventHub类读到事件之后，EventHub就会通过NativeInputManager类首先分发事件到Java层的InputManager，而Java层的InputManager又会把这个事件分发到服务WindowManagerService(WMS)，之后又分发到PhoneWindowManager中，最后分发到ViewRootImpl中，ViewRootImpl将事件分发到应用程序的Activity和View中。</p>
<p>具体流程：首先有一个线程在不断的监听屏幕，一旦有触摸事件，就将其事件捕获；其次，还应该存在某种方式可以找到目标窗口，因为可能有多个APP的多个界面为用户可见，必须确定这个事件究竟通知哪个窗口；最后才是目标窗口如何消费事件的问题。<br>总体来说，Android事件投递(主要以触摸事件为主)的工作流程分为4个部分，如图所示：<br>这里写图片描述<br>(1) 采集<br>即对“硬件源”所产生的原始信息进行收集的过程。它需要Linux内核驱动的支持，Android系统则是通过/dev/input/下的节点来访问当前发生的事件。<br>(2) 前期处理<br>上一步采集到的信息为“原始数据”，这其中一部分内容对应程序而言并不是“必须”的，而且格式上也相对烦琐，所以需要先经过前期的提炼和转化。<br>(3)WMS分配<br>WindowManagerService是窗口的大主管，同时也是InputEvent的派发者。WMS记录了当前系统中所有窗口的完整状态信息，所以只有它才能判断出应该把事件投递给哪一个具体的应用进程进行处理。其派发策略也因事件类型的不同而有所差异，以触摸消息为例，则要先计算出触摸点落在哪个区域，然后才能传递给相应的窗口单元。<br>(4)应用程序处理<br>应用开发人员的工作主要体现在这一部分。经过前面的几个步骤的传递，应用程序端收到的事件已经相对“可理解”“好处理”了，接下来要做的就是充分利用这些事件来实现软件的功能。</p>
<p>1、InputManagerService(IMS)诞生<br>IMS服务的创建过程是在SystemServer进程启动的时候实例化的，并注册到ServiceManager中去，这个服务对外主要是用来提供一些输入设备的信息的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java</span><br><span class="line">private void startOtherServices() &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;新建IMS对象</span><br><span class="line">    inputManager &#x3D; new InputManagerService(context);</span><br><span class="line">    wm &#x3D; WindowManagerService.main(context, inputManager,</span><br><span class="line">            mFactoryTestMode !&#x3D; FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">            !mFirstBoot, mOnlyCore);</span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">    &#x2F;&#x2F;将IMS发布给ServiceManager，以便其他人可以访问IMS提供的接口</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">    mActivityManagerService.setWindowManager(wm);</span><br><span class="line">    &#x2F;&#x2F;设置向WMS发起回调Callback对象</span><br><span class="line">    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">    &#x2F;&#x2F;启动IMS</span><br><span class="line">    inputManager.start();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputManagerService和WindowManagerService有密切的联系，也是触摸事件处理的时候同时涉及两个服务，InputManagerService主要负责事件(以触摸事件为例)的采集，而WindowManagerService负责找到目标窗口。接下来，继续分析InputManagerService如何完成触摸事件的采集。</p>
<p>2、事件的采集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;jni&#x2F;com_android_server_input_InputManagerService.cpp</span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(true) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;NativeInputManager创建了EventHub</span><br><span class="line">    sp&lt;EventHub&gt; eventHub &#x3D; new EventHub();</span><br><span class="line">    &#x2F;&#x2F;继续创建Native层的InputManager</span><br><span class="line">    mInputManager &#x3D; new InputManager(eventHub, this, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的EventHub，可以看作是事件集线器，是利用Linux的inotify和epoll机制，对设备节点增删事件以及可读状态的监听，例如，各种触摸、按钮事件等等，主要面向的是/dev/input目录下的设备节点，比如说/dev/input/event0上的事件就是输入事件，通过EventHub的getEvents就可以监听并获取该事件。在InputManager创建的时候，同时也会再创建一个InputReader对象及InputReaderThread Loop线程，这个loop线程的主要作用就是像一台水泵一样，通过EventHub的getEvents获取Input事件。<br>/frameworks/native/services/inputflinger/InputManager.cpp</p>
<p>InputManager::InputManager(<br>        const sp<EventHubInterface>&amp; eventHub,<br>        const sp<InputReaderPolicyInterface>&amp; readerPolicy,<br>        const sp<InputDispatcherPolicyInterface>&amp; dispatcherPolicy) {<br>    //创建InputDispatcher，事件分发执行类<br>    mDispatcher = new InputDispatcher(dispatcherPolicy);<br>    //创建InputReader，事件读取执行类<br>    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);<br>    //将InputReader与InputDispatcher建立关联<br>    initialize();<br>}<br>void InputManager::initialize() {<br>    //创建供InputReader运行的线程InputReaderThread<br>    mReaderThread = new InputReaderThread(mReader);<br>    //创建供InputDispatcher运行的线程InputDispatcherThread<br>    mDispatcherThread = new InputDispatcherThread(mDispatcher);<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>/frameworks/native/services/inputflinger/InputReader.cpp</p>
<p>void InputReader::loopOnce() {<br>    int32_t oldGeneration;<br>    int32_t timeoutMillis;<br>    bool inputDevicesChanged = false;<br>    Vector<InputDeviceInfo> inputDevices;<br>    …<br>    //监听事件<br>    size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);<br>    …<br>            //处理事件<br>            processEventsLocked(mEventBuffer, count);<br>    …<br>     //通知派发(对上面mDispatcher的进一步封装)<br>    mQueuedListener-&gt;flush();<br>}<br>bool InputReaderThread::threadLoop() {<br>    mReader-&gt;loopOnce();<br>    return true;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>上面代码的流程，输入事件就可以被读取，经过processEventsLocked被初步封装成RawEvent，最后发通知，请求派发消息。</p>
<p>3、派发事件<br>在新建InputManager的时候，不但创建了一个事件读取线程(InputReaderThread)，而且还创建了一个事件派发线程()InputDispatcherThread，虽然也可以直接在读取线程中派发，但是这样肯定会增加耗时，不利于事件的及时读取，因此，事件读取完毕后，直接向派发线程发个通知，请派发线程去处理，这样读取线程就可以更加敏捷，防止事件丢失。<br>InputReader的mQueuedListener其实就是InputDispatcher对象，因此mQueuedListener-&gt;flush()就是通知InputDispatcher事件读取完毕，可以派发事件了, InputDispatcherThread是一个典型Looper线程，基于native的Looper实现了Hanlder消息处理模型，如果有Input事件到来就被唤醒处理事件，处理完毕后继续睡眠等待。<br>/frameworks/native/services/inputflinger/InputDispatcher.cpp</p>
<p>bool InputDispatcherThread::threadLoop() {<br>    mDispatcher-&gt;dispatchOnce();<br>    return true;<br>}<br>void InputDispatcher::dispatchOnce() {<br>    nsecs_t nextWakeupTime = LONG_LONG_MAX;<br>    { …<br>        //被唤醒 ，处理Input消息<br>        if (!haveCommandsLocked()) {<br>            dispatchOnceInnerLocked(&amp;nextWakeupTime);<br>        }<br>    …<br>    } </p>
<pre><code>nsecs_t currentTime = now();
int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
//睡眠等待input事件
mLooper-&gt;pollOnce(timeoutMillis);</code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>上面代码是派发线程的模型，dispatchOnceInnerLocked是具体的派发处理逻辑，里面有很多的分支，以触摸事件为例：</p>
<p>void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {<br>     case EventEntry::TYPE_MOTION: {<br>        MotionEntry* typedEntry = static_cast&lt;MotionEntry<em>&gt;(mPendingEvent);<br>        …<br>        done = dispatchMotionLocked(currentTime, typedEntry,<br>                &amp;dropReason, nextWakeupTime);<br>        break;<br>    }<br>}<br>bool InputDispatcher::dispatchMotionLocked(<br>        nsecs_t currentTime, MotionEntry</em> entry, DropReason* dropReason, nsecs_t* nextWakeupTime) {<br>    …<br>    Vector<InputTarget> inputTargets;</p>
<pre><code>bool conflictingPointerActions = false;
int32_t injectionResult;
if (isPointerEvent) {
    //关键点1: 找到目标Window
    injectionResult = findTouchedWindowTargetsLocked(currentTime,
            entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);
} else {
    // Non touch event.  (eg. trackball)
    injectionResult = findFocusedWindowTargetsLocked(currentTime,
            entry, inputTargets, nextWakeupTime);
}
...
//关键点2: 消息派发到目标窗口中
dispatchEventLocked(currentTime, entry, inputTargets);
return true;</code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>触摸事件会首先通过findTouchedWindowTargetsLocked()函数找到目标Window，进而通过dispatchEventLocked()将消息发送到目标窗口。</p>
<p>4、触摸事件找到对应目标窗口<br>根据触摸事件的位置及窗口的属性来确定将事件发送到哪个窗口<br>/frameworks/native/services/inputflinger/InputDispatcher.cpp</p>
<p>int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,<br>        const MotionEntry* entry, Vector<InputTarget>&amp; inputTargets, nsecs_t* nextWakeupTime,<br>        bool* outConflictingPointerActions) {<br>        …<br>        sp<InputWindowHandle> newTouchedWindowHandle;<br>        bool isTouchModal = false;<br>        //遍历所有窗口<br>        size_t numWindows = mWindowHandles.size();<br>        for (size_t i = 0; i &lt; numWindows; i++) {<br>            sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);<br>            const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();<br>            if (windowInfo-&gt;displayId != displayId) {<br>                continue; // wrong display<br>            }</p>
<pre><code>int32_t flags = windowInfo-&gt;layoutParamsFlags;
if (windowInfo-&gt;visible) {
    if (! (flags &amp; InputWindowInfo::FLAG_NOT_TOUCHABLE)) {
        isTouchModal = (flags &amp; (InputWindowInfo::FLAG_NOT_FOCUSABLE
                | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0;
        //找到目标窗口       
        if (isTouchModal || windowInfo-&gt;touchableRegionContainsPoint(x, y)) {
            newTouchedWindowHandle = windowHandle;
            break; // found touched window, exit window loop
        }
     }
...     </code></pre><p>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>mWindowHandles代表着所有窗口，findTouchedWindowTargetsLocked的就是从mWindowHandles中找到目标窗口。mWindowHandles是怎么来的呢，窗口增删的时候怎样才能保持最新的？这里就引进来WindowManagerService交互问题了，接着分析：</p>
<p>void InputDispatcher::setInputWindows(const Vector&lt;sp<InputWindowHandle> &gt;&amp; inputWindowHandles) {<br>…<br>mWindowHandles = inputWindowHandles;<br>…<br>1<br>2<br>3<br>4<br>WindowManagerService中的InputMonitor，会间接调用InputDispatcher::setInputWindows，这个主要是跟窗口增改删除等逻辑相关。</p>
<p>5、发送事件到目标窗口<br>找到了目标窗口，事件也封装完毕，剩下的就是通知目标窗口。目前所有的操作都是在SystemServer进程完成的，如何才能通知窗口位于APP端的用户进程呢？接下来Socket的通信方式出场了，它是处理input事件的。Socket是怎么来的呢？在当APP端向WMS请求添加窗口的时候，会伴随着Input通道的创建，窗口的添加一定会调用ViewRootImpl中的setView函数：<br>/frameworks/native/services/inputflinger/ViewRootImpl.cpp</p>
<p>public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {<br>                …<br>                requestLayout();<br>                if ((mWindowAttributes.inputFeatures<br>                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {<br>                    //创建InputChannel容器<br>                    mInputChannel = new InputChannel();<br>                }<br>                try {<br>                    mOrigWindowType = mWindowAttributes.type;<br>                    mAttachInfo.mRecomputeGlobalAttributes = true;<br>                    collectViewAttributes();<br>                    //添加窗口，并请求开辟Socket Input通信通道<br>                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,<br>                            getHostVisibility(), mDisplay.getDisplayId(),<br>                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,<br>                            mAttachInfo.mOutsets, mInputChannel);<br>                } …<br>                //监听，开启Input信道<br>                if (mInputChannel != null) {<br>                    if (mInputQueueCallback != null) {<br>                        mInputQueue = new InputQueue();<br>                        mInputQueueCallback.onInputQueueCreated(mInputQueue);<br>                    }<br>                    mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,<br>                            Looper.myLooper());<br>                }<br>                …<br>}                </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public int addWindow(Session session, IWindow client, int seq,<br>        WindowManager.LayoutParams attrs, int viewVisibility, int displayId,<br>        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,<br>        InputChannel outInputChannel) {<br>    if (outInputChannel != null &amp;&amp; (attrs.inputFeatures<br>            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {<br>        String name = win.makeInputChannelName();<br>        //关键点1创建通信信道<br>        InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);<br>        //本地用<br>        win.setInputChannel(inputChannels[0]);<br>        //APP端用<br>        inputChannels[1].transferTo(outInputChannel);<br>        //注册信道与窗口<br>        mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WMS首先创建socketpair作为全双工通道，并分别填充到Client与Server的InputChannel中去；再让InputManager将Input通信信道与当前的窗口ID绑定，这样就能知道哪个窗口用哪个信道通信了；最后通过Binder将outInputChannel回传到APP端，以下是SocketPair的创建代码：</span><br><span class="line">frameworks&#x2F;native&#x2F;libs&#x2F;Input&#x2F;tests&#x2F;InputTransport.cpp</span><br><span class="line"></span><br><span class="line">status_t InputChannel::openInputChannelPair(const String8&amp; name,</span><br><span class="line">        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</span><br><span class="line">    int sockets[2];</span><br><span class="line">    if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123;</span><br><span class="line">        status_t result &#x3D; -errno;</span><br><span class="line">        ...</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int bufferSize &#x3D; SOCKET_BUFFER_SIZE;</span><br><span class="line">    setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize));</span><br><span class="line">    setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize));</span><br><span class="line">    setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize));</span><br><span class="line">    setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize));</span><br><span class="line">    &#x2F;&#x2F;填充到server inputchannel</span><br><span class="line">    String8 serverChannelName &#x3D; name;</span><br><span class="line">    serverChannelName.append(&quot; (server)&quot;);</span><br><span class="line">    outServerChannel &#x3D; new InputChannel(serverChannelName, sockets[0]);</span><br><span class="line">    &#x2F;&#x2F;填充到client inputchannel</span><br><span class="line">    String8 clientChannelName &#x3D; name;</span><br><span class="line">    clientChannelName.append(&quot; (client)&quot;);</span><br><span class="line">    outClientChannel &#x3D; new InputChannel(clientChannelName, sockets[1]);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">socketpair的创建与访问还是借助文件描述符(Fd)，WMS需要借助Binder通信向APP端回传文件描述符，在内核层面实现两个进程的转换，窗口添加成功后，socketpair被创建，被传递到了APP端，但是信道并未完全建立，还需要一个主动的监听，当消息到来的时候是需要通知的。APP端的监听消息的手段是：将socket添加到Looper线程的epoll数组中去，当有消息到来时，Looper线程就会被唤醒，并获取事件内容，通信信道的打开是伴随WindowInputEventReceiver的创建来完成的。</span><br><span class="line">信息到来，Looper根据文件描述符(Fd)找到对应的监听器：NativeInputEventReceiver，并调用handleEvent处理对应事件：</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;native&#x2F;android&#x2F;android_view_InputEventReceiver.cpp</span><br><span class="line"></span><br><span class="line">int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123;</span><br><span class="line">   ...</span><br><span class="line">   if (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env &#x3D; AndroidRuntime::getJNIEnv();</span><br><span class="line">        status_t status &#x3D; consumeEvents(env, false &#x2F;*consumeBatches*&#x2F;, -1, NULL);</span><br><span class="line">        mMessageQueue-&gt;raiseAndClearException(env, &quot;handleReceiveCallback&quot;);</span><br><span class="line">        return status &#x3D;&#x3D; OK || status &#x3D;&#x3D; NO_MEMORY ? 1 : 0;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">进一步读取事件，并封装成Java层对象，传递给Java层，进行相应的回调：</span><br><span class="line"></span><br><span class="line">status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,</span><br><span class="line">        bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123;</span><br><span class="line">     ...</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">        uint32_t seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        &#x2F;&#x2F;获取事件</span><br><span class="line">        status_t status &#x3D; mInputConsumer.consume(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);   </span><br><span class="line">     ...</span><br><span class="line">     &#x2F;&#x2F;处理touch事件</span><br><span class="line">     case AINPUT_EVENT_TYPE_MOTION: </span><br><span class="line">                ...</span><br><span class="line">                MotionEvent* motionEvent &#x3D; static_cast&lt;MotionEvent*&gt;(inputEvent);</span><br><span class="line">                if ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;</span><br><span class="line">                    *outConsumedBatch &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                inputEventObj &#x3D; android_view_MotionEvent_obtainAsCopy(env, motionEvent);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">              ...</span><br><span class="line">              &#x2F;&#x2F;回调处理函数</span><br><span class="line">               if (inputEventObj) &#123;</span><br><span class="line">                ...</span><br><span class="line">                   env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                      gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);              </span><br><span class="line"></span><br><span class="line">最后就是触摸事件被封装成了inputEvent，并通过InputEventReceiver的dispatchInputEvent（WindowInputEventReceiver）进行处理，这里就返回到我们常见的Java世界了。</span><br><span class="line">6、在目标窗口中处理事件</span><br><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;ViewRootImpl.java</span><br><span class="line"></span><br><span class="line"> final class WindowInputEventReceiver extends InputEventReceiver &#123;</span><br><span class="line">        public WindowInputEventReceiver(InputChannel inputChannel, Looper looper)&#123; </span><br><span class="line">            super(inputChannel, looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onInputEvent(InputEvent event) &#123;</span><br><span class="line">         enqueueInputEvent(event, this, 0, true);</span><br><span class="line">        &#125;</span><br><span class="line">   ...     </span><br><span class="line">  &#125;</span><br><span class="line">  void enqueueInputEvent(InputEvent event,</span><br><span class="line">            InputEventReceiver receiver, int flags, boolean processImmediately) &#123;</span><br><span class="line">       ...</span><br><span class="line">        if (processImmediately) &#123;</span><br><span class="line">            doProcessInputEvents();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">  void doProcessInputEvents() &#123;</span><br><span class="line">      ...</span><br><span class="line">      deliverInputEvent(q);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  private void deliverInputEvent(QueuedInputEvent q) &#123;</span><br><span class="line">        ...</span><br><span class="line">        InputStage stage;</span><br><span class="line">        if (q.shouldSendToSynthesizer()) &#123;</span><br><span class="line">            stage &#x3D; mSyntheticInputStage;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stage &#x3D; q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (stage !&#x3D; null) &#123;</span><br><span class="line">            stage.deliver(q);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">   &#125;</span><br><span class="line">   final class ViewPostImeInputStage extends InputStage &#123;</span><br><span class="line">        ...</span><br><span class="line">        @Override</span><br><span class="line">        protected int onProcess(QueuedInputEvent q) &#123;</span><br><span class="line">            if (q.mEvent instanceof KeyEvent) &#123;</span><br><span class="line">                return processKeyEvent(q);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; If delivering a new non-key event, make sure the window is</span><br><span class="line">                &#x2F;&#x2F; now allowed to start updating.</span><br><span class="line">                handleDispatchWindowAnimationStopped();</span><br><span class="line">                final int source &#x3D; q.mEvent.getSource();</span><br><span class="line">                if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) !&#x3D; 0) &#123;</span><br><span class="line">                    return processPointerEvent(q);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        private int processPointerEvent(QueuedInputEvent q) &#123;</span><br><span class="line">            ...</span><br><span class="line">            boolean handled &#x3D; mView.dispatchPointerEvent(event);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>processPointerEvent()方法通过调用mView的dispatchPointerEvent()方法来做进一步的操作，变量mView是一个DecorView类型的对象，它的父类View来实现这个方法，这个调用最终就会进入它的父类View的dispatchPointerEvent()方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;view&#x2F;View.java</span><br><span class="line">public final boolean dispatchPointerEvent(MotionEvent event) &#123;</span><br><span class="line">    if (event.isTouchEvent()) &#123;</span><br><span class="line">        return dispatchTouchEvent(event);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return dispatchGenericMotionEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View的dispatchPointerEvent()方法首先通过MotionEvent的isTouchEvent()方法来判断当前的事件是不是TouchEvent事件，若当前是TouchEvent事件，就用dispatchTouchEvent()方法来做分发事件的处理，这个分发过程分为两种情况：<br>(1)若目前的View是普通的View，就会调用View.java的dispatchTouchEvent()方法来处理。普通的View，比如TextView里面并没有实现dispatchTouchEvent()方法，由于它又是继承View，所有在View的dispatchPointerEvent()方法中调用dispatchTouchEvent()方法或者进入View的dispatchTouchEvent()方法。<br>(2)若目前的View是容器类View，比如DecorView，由于它实现了dispatchTouchEvent()方法，所以View的dispatchPointerEvent()方法中调用dispatchTouchEvent()方法就会进入DecorView的dispatchTouchEvent()方法。<br>这两种分发过程在下篇文章《Android6.0系统View事件分发》中继续分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/24/Android%E4%B8%ADView%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/Android%E4%B8%ADView%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Android中View的绘制流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-24 10:23:02 / 修改时间：10:32:43" itemprop="dateCreated datePublished" datetime="2021-02-24T10:23:02+08:00">2021-02-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    &#x2F;&#x2F;这个mView是通过setView方法传进来的,也就是Activity的根布局DecorView，使用final修饰，以防在遍历过程中被修改</span><br><span class="line">    final View host &#x3D; mView;</span><br><span class="line">    &#x2F;&#x2F;mAdded在setView方法修改为true，表明Decorview已经添加到了PhoneWindow</span><br><span class="line">    if (host &#x3D;&#x3D; null || !mAdded)</span><br><span class="line">        return;</span><br><span class="line">    &#x2F;&#x2F;是否正在遍历</span><br><span class="line">    mIsInTraversal &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;是否需要马上绘制</span><br><span class="line">    mWillDrawSoon &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;视图大小改变</span><br><span class="line">    boolean windowSizeMayChange &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;新视图</span><br><span class="line">    boolean newSurface &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;视图改变</span><br><span class="line">    boolean surfaceChanged &#x3D; false;</span><br><span class="line">    WindowManager.LayoutParams lp &#x3D; mWindowAttributes;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Activity窗口的宽度和高度</span><br><span class="line">    int desiredWindowWidth;</span><br><span class="line">    int desiredWindowHeight;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;DecorView是否可见</span><br><span class="line">    final int viewVisibility &#x3D; getHostVisibility();</span><br><span class="line">    final boolean viewVisibilityChanged &#x3D; !mFirst</span><br><span class="line">            &amp;&amp; (mViewVisibility !&#x3D; viewVisibility || mNewSurfaceNeeded);</span><br><span class="line">    WindowManager.LayoutParams params &#x3D; null;</span><br><span class="line">    if (mWindowAttributesChanged) &#123;</span><br><span class="line">        mWindowAttributesChanged &#x3D; false;</span><br><span class="line">        surfaceChanged &#x3D; true;</span><br><span class="line">        params &#x3D; lp;</span><br><span class="line">    &#125;</span><br><span class="line">    CompatibilityInfo compatibilityInfo &#x3D;</span><br><span class="line">            mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">    if (compatibilityInfo.supportsScreen() &#x3D;&#x3D; mLastInCompatMode) &#123;</span><br><span class="line">        params &#x3D; lp;</span><br><span class="line">        mFullRedrawNeeded &#x3D; true;</span><br><span class="line">        mLayoutRequested &#x3D; true;</span><br><span class="line">        if (mLastInCompatMode) &#123;</span><br><span class="line">            params.privateFlags &amp;&#x3D; ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">            mLastInCompatMode &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            params.privateFlags |&#x3D; WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">            mLastInCompatMode &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        mWindowAttributesChangesFlag &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;用来保存窗口宽度和高度，来自于全局变量mWinFrame，这个mWinFrame保存了窗口最新尺寸</span><br><span class="line">        Rect frame &#x3D; mWinFrame;</span><br><span class="line">        &#x2F;&#x2F;构造方法里mFirst赋值为true，意思是第一次执行遍历吗	</span><br><span class="line">        if (mFirst) &#123;</span><br><span class="line">        	&#x2F;&#x2F;是否需要重绘</span><br><span class="line">            mFullRedrawNeeded &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F;是否需要重新确定Layout</span><br><span class="line">            mLayoutRequested &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F;判断要绘制的窗口是否包含状态栏，有就去掉，然后确定要绘制的Decorview的高度和宽度</span><br><span class="line">            if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                &#x2F;&#x2F; NOTE -- system code, won&#39;t try to do compat mode.</span><br><span class="line">                Point size &#x3D; new Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth &#x3D; size.x;</span><br><span class="line">                desiredWindowHeight &#x3D; size.y;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;宽度和高度为整个屏幕的值</span><br><span class="line">                Configuration config &#x3D; mContext.getResources().getConfiguration();</span><br><span class="line">                desiredWindowWidth &#x3D; dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight &#x3D; dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 因为第一次遍历，View树第一次显示到窗口</span><br><span class="line">             * 然后对mAttachinfo进行一些赋值</span><br><span class="line">             * AttachInfo是View类中的静态内部类AttachInfo类的对象</span><br><span class="line">             * 它主要储存一组当View attach到它的父Window的时候视图信息</span><br><span class="line">             *&#x2F;</span><br><span class="line">            mAttachInfo.mUse32BitDrawingCache &#x3D; true;&#x2F;&#x2F;使用32位绘图缓存</span><br><span class="line">            mAttachInfo.mHasWindowFocus &#x3D; false;&#x2F;&#x2F;视图窗口当前不具有焦点。</span><br><span class="line">            mAttachInfo.mWindowVisibility &#x3D; viewVisibility;&#x2F;&#x2F;当前窗口不可见</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes &#x3D; false;&#x2F;&#x2F;ViewAncestor应在下次执行遍历时触发全局布局更改</span><br><span class="line">            mLastSystemUiVisibility &#x3D; mAttachInfo.mSystemUiVisibility;</span><br><span class="line">            &#x2F;&#x2F; 如果之前未设置布局方向，则设置布局方向（View.LAYOUT_DIRECTION_INHERIT 是默认值）</span><br><span class="line">            if (mViewLayoutDirectionInitial &#x3D;&#x3D; View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">                host.setLayoutDirection(mLastConfiguration.getLayoutDirection());</span><br><span class="line">            &#125;</span><br><span class="line">            host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">            dispatchApplyInsets(host);</span><br><span class="line">            &#x2F;&#x2F;Log.i(mTag, &quot;Screen on initialized: &quot; + attachInfo.mKeepScreenOn);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         		&#x2F;&#x2F;如果不是第一次进来这个方法，它的当前宽度和高度就从之前的mWinFrame获取</span><br><span class="line">            desiredWindowWidth &#x3D; frame.width();</span><br><span class="line">            desiredWindowHeight &#x3D; frame.height();</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * mWidth和mHeight是由WindowManagerService服务计算出的窗口大小，</span><br><span class="line">             * 如果这次测量的窗口大小与这两个值不同，说明WMS单方面改变了窗口的尺寸</span><br><span class="line">             *&#x2F;</span><br><span class="line">            if (desiredWindowWidth !&#x3D; mWidth || desiredWindowHeight !&#x3D; mHeight) &#123;</span><br><span class="line">                if (DEBUG_ORIENTATION) Log.v(mTag, &quot;View &quot; + host + &quot; resized to: &quot; + frame);</span><br><span class="line">                &#x2F;&#x2F;需要进行完整的重绘以适应新的窗口尺寸</span><br><span class="line">                mFullRedrawNeeded &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F;需要对控件树进行重新布局</span><br><span class="line">                mLayoutRequested &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F;window窗口大小改变</span><br><span class="line">                windowSizeMayChange &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">		&#x2F;&#x2F;如果窗口可见性变了，进行判断</span><br><span class="line">        if (viewVisibilityChanged) &#123;</span><br><span class="line">            mAttachInfo.mWindowVisibility &#x3D; viewVisibility;</span><br><span class="line">            host.dispatchWindowVisibilityChanged(viewVisibility);</span><br><span class="line">            host.dispatchVisibilityAggregated(viewVisibility &#x3D;&#x3D; View.VISIBLE);</span><br><span class="line">            if (viewVisibility !&#x3D; View.VISIBLE || mNewSurfaceNeeded) &#123;</span><br><span class="line">            	&#x2F;&#x2F;不可见就结束调整大小事件，释放相关硬件资源</span><br><span class="line">                endDragResizing();</span><br><span class="line">                destroyHardwareResources();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果窗口不可见，就修改标志位</span><br><span class="line">            if (viewVisibility &#x3D;&#x3D; View.GONE) &#123;</span><br><span class="line">                &#x2F;&#x2F; After making a window gone, we will count it as being</span><br><span class="line">                &#x2F;&#x2F; shown for the first time the next time it gets focus.</span><br><span class="line">                mHasHadWindowFocus &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果窗口不可见了，去掉可访问性焦点</span><br><span class="line">        if (mAttachInfo.mWindowVisibility !&#x3D; View.VISIBLE) &#123;</span><br><span class="line">            host.clearAccessibilityFocus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 执行HandlerActionQueue中HandlerAction数组保存的Runnable</span><br><span class="line">         * 我们平时会通过View.post()或View.postDelayed()方法将一个Runnable对象发送到主线程执行</span><br><span class="line">         * 其实就是通过这个mHandler去执行</span><br><span class="line">         * public void executeActions(Handler handler) &#123;</span><br><span class="line">             synchronized (this) &#123;</span><br><span class="line">                 final HandlerAction[] actions &#x3D; mActions;</span><br><span class="line">                 for (int i &#x3D; 0, count &#x3D; mCount; i &lt; count; i++) &#123;</span><br><span class="line">                     final HandlerAction handlerAction &#x3D; actions[i];</span><br><span class="line">                     handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">                 &#125;</span><br><span class="line">                 mActions &#x3D; null;</span><br><span class="line">                 mCount &#x3D; 0;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line"></span><br><span class="line">        boolean insetsChanged &#x3D; false;</span><br><span class="line"></span><br><span class="line">        boolean layoutRequested &#x3D; mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        &#x2F;&#x2F;进行预测量</span><br><span class="line">        if (layoutRequested) &#123;</span><br><span class="line">            final Resources res &#x3D; mView.getContext().getResources();</span><br><span class="line">            if (mFirst) &#123;</span><br><span class="line">                &#x2F;&#x2F; 视图窗口当前是否处于触摸模式。</span><br><span class="line">                mAttachInfo.mInTouchMode &#x3D; !mAddedTouchMode;</span><br><span class="line">                &#x2F;&#x2F;确保这个Window的触摸模式已经被设置</span><br><span class="line">                ensureTouchModeLocally(mAddedTouchMode);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            		&#x2F;**</span><br><span class="line">                 * 判断一下几个insects的值和上一次相比有没有什么变化，不同的话就改变insetsChanged</span><br><span class="line">                 * mOverscanInsets 记录屏幕中的 overscan 区域               见贴图中相应描述区域</span><br><span class="line">                 * mContentInsets  记录了屏幕中的控件在布局时必须预留的空间   见贴图中相应描述区域</span><br><span class="line">                 * mStableInsets   记录了Stable区域，比mContentInsets区域大  见贴图中相应描述区域</span><br><span class="line">                 * mVisibleInsets  记录了被遮挡的区域，如正在进行输入的TextView等不被遮挡，这样VisibleInsets的变化并不会导致重新布局，</span><br><span class="line">                 *                 所以这里仅仅是将VisibleInsets保存到mAttachInfo中，以便绘制时使用</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">                    insetsChanged &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123;</span><br><span class="line">                    insetsChanged &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123;</span><br><span class="line">                    insetsChanged &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123;</span><br><span class="line">                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mVisibleInsets);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) &#123;</span><br><span class="line">                    insetsChanged &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (mPendingAlwaysConsumeNavBar !&#x3D; mAttachInfo.mAlwaysConsumeNavBar) &#123;</span><br><span class="line">                    insetsChanged &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                 &#x2F;**</span><br><span class="line">                 * 如果当前窗口的根布局的width或height被指定为WRAP_CONTENT时，</span><br><span class="line">                 * 比如Dialog，那我们还是给它尽量大的长宽，这里是将屏幕长宽赋值给它</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                if (lp.width &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                        || lp.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                    windowSizeMayChange &#x3D; true;</span><br><span class="line"> 					&#x2F;&#x2F;判断要绘制的窗口是否包含状态栏，有就去掉，然后确定要绘制的Decorview的高度和宽度</span><br><span class="line">                    if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; NOTE -- system code, won&#39;t try to do compat mode.</span><br><span class="line">                        Point size &#x3D; new Point();</span><br><span class="line">                        mDisplay.getRealSize(size);</span><br><span class="line">                        desiredWindowWidth &#x3D; size.x;</span><br><span class="line">                        desiredWindowHeight &#x3D; size.y;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Configuration config &#x3D; res.getConfiguration();</span><br><span class="line">                        desiredWindowWidth &#x3D; dipToPx(config.screenWidthDp);</span><br><span class="line">                        desiredWindowHeight &#x3D; dipToPx(config.screenHeightDp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 进行预测量窗口大小，以达到更好的显示大小</span><br><span class="line">            windowSizeMayChange |&#x3D; measureHierarchy(host, lp, res,</span><br><span class="line">                    desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp,</span><br><span class="line">            final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123;</span><br><span class="line">        &#x2F;&#x2F;用于描述宽度的MeasureSpec</span><br><span class="line">        int childWidthMeasureSpec;</span><br><span class="line">        &#x2F;&#x2F;用于描述高度的MeasureSpec</span><br><span class="line">        int childHeightMeasureSpec;</span><br><span class="line">        &#x2F;&#x2F;表示测量结果是否可能导致窗口的尺寸发生变化</span><br><span class="line">        boolean windowSizeMayChange &#x3D; false;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                &quot;Measuring &quot; + host + &quot; in display &quot; + desiredWindowWidth</span><br><span class="line">                + &quot;x&quot; + desiredWindowHeight + &quot;...&quot;);</span><br><span class="line">        &#x2F;&#x2F;表示测量是否能满足控件树充分显示内容的要求</span><br><span class="line">        boolean goodMeasure &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;其实测量协商仅仅发生在width被指定为WRAP_CONTENT情况</span><br><span class="line">        if (lp.width &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            &#x2F;&#x2F; 进入到这里就让窗口的大小不以屏幕大小去布局，而是给一个固定的值看看是否合适</span><br><span class="line">            final DisplayMetrics packageMetrics &#x3D; res.getDisplayMetrics();</span><br><span class="line">            res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, true);</span><br><span class="line">            int baseSize &#x3D; 0;</span><br><span class="line">            if (mTmpValue.type &#x3D;&#x3D; TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">                &#x2F;&#x2F;取出一个固定值来用，来自于config_prefDialogWidth</span><br><span class="line">                baseSize &#x3D; (int)mTmpValue.getDimension(packageMetrics);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: baseSize&#x3D;&quot; + baseSize</span><br><span class="line">                    + &quot;, desiredWindowWidth&#x3D;&quot; + desiredWindowWidth);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;假设上面config_prefDialogWidth值是320dp</span><br><span class="line">            if (baseSize !&#x3D; 0 &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">                &#x2F;&#x2F;使用getRootMeasureSpec()函数组合SPEC_MODE与SPEC_SIZE为一个MeasureSpec</span><br><span class="line">                childWidthMeasureSpec &#x3D; getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">                childHeightMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">                &#x2F;&#x2F;第一次测量</span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot;</span><br><span class="line">                        + host.getMeasuredWidth() + &quot;,&quot; + host.getMeasuredHeight()</span><br><span class="line">                        + &quot;) from width spec: &quot; + MeasureSpec.toString(childWidthMeasureSpec)</span><br><span class="line">                        + &quot; and height spec: &quot; + MeasureSpec.toString(childHeightMeasureSpec));</span><br><span class="line"></span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 控件树的测量结果可以通过mView的getmeasuredWidthAndState()方法获取。</span><br><span class="line">                 * 如果控件树对这个测量结果不满意，则会在返回值中添加MEASURED_STATE_TOO_SMALL位</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    goodMeasure &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;**</span><br><span class="line">                     * 走到这里说明上面的尺寸不适合View树</span><br><span class="line">                     * 需要对宽度再进行放松，使用上面的预期值与最大值的平均值作为新的宽度</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                    baseSize &#x3D; (baseSize+desiredWindowWidth)&#x2F;2;</span><br><span class="line">                    if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: next baseSize&#x3D;&quot;</span><br><span class="line">                            + baseSize);</span><br><span class="line">                    &#x2F;&#x2F;重新获取MeasureSpec</span><br><span class="line">                    childWidthMeasureSpec &#x3D; getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">                    &#x2F;&#x2F;第二次测量</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot;</span><br><span class="line">                            + host.getMeasuredWidth() + &quot;,&quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">                    &#x2F;&#x2F;再次判断View树对新的结果是否满意</span><br><span class="line">                    if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        if (DEBUG_DIALOG) Log.v(mTag, &quot;Good!&quot;);</span><br><span class="line">                        goodMeasure &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 如果上面两次尝试测量结果，View树都不满意</span><br><span class="line">         * 那老哥也没办法了，做不了优化了，只能以屏幕宽高去给View树测量了</span><br><span class="line">         * 这是第三次也是最后一次测量了</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (!goodMeasure) &#123;</span><br><span class="line">            childWidthMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">            childHeightMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            &#x2F;&#x2F;如果测量得出的结果与当前窗口值不一样，就需要调整窗口大小了</span><br><span class="line">            if (mWidth !&#x3D; host.getMeasuredWidth() || mHeight !&#x3D; host.getMeasuredHeight()) &#123;</span><br><span class="line">                windowSizeMayChange &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DBG) &#123;</span><br><span class="line">            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">            System.out.println(&quot;performTraversals -- after measure&quot;);</span><br><span class="line">            host.debug();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return windowSizeMayChange;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</span><br><span class="line">        int measureSpec;</span><br><span class="line">        switch (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">        case ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">            &#x2F;&#x2F; Window can&#39;t resize. Force root view to be windowSize.</span><br><span class="line">            measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">            break;</span><br><span class="line">        case ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">            &#x2F;&#x2F; Window can resize. Set max size for root view.</span><br><span class="line">            measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            &#x2F;&#x2F; Window wants to be an exact size. Force root view to be that size.</span><br><span class="line">            measureSpec &#x3D; MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return measureSpec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>详情：<a href="https://blog.csdn.net/qq_30993595/article/details/80931556" target="_blank" rel="noopener">https://blog.csdn.net/qq_30993595/article/details/80931556</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
