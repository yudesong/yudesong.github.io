<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/%E5%89%91%E6%8C%87Offer%20--%20%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/%E5%89%91%E6%8C%87Offer%20--%20%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">剑指Offer -- 刷题笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 17:05:08" itemprop="dateCreated datePublished" datetime="2020-06-06T17:05:08+08:00">2020-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1. 二维数组中的查找</strong></p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>思路： 首先获取二维数组的行数以及列数, 从第一行的最后一列开始比较，如果array[i][j] &gt; target, 那就在数组的前面一列里面寻找，否则在下面一行寻找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 获取数组行数</span><br><span class="line">        int row &#x3D; array.length;</span><br><span class="line">        &#x2F;&#x2F; 获取数组列数</span><br><span class="line">        int col &#x3D; array[0].length;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; col - 1;</span><br><span class="line">        while (i &lt; row &amp;&amp; j &gt;&#x3D; 0) &#123;</span><br><span class="line">            if (target &#x3D;&#x3D; array[i][j]) return true;</span><br><span class="line">            if (target &gt; array[i][j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (target &lt; array[i][j]) j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 替换空格</strong></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">	String string &#x3D; str.toString();</span><br><span class="line">	string &#x3D; string.replaceAll(&quot; &quot;, &quot;%20&quot;);</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 从尾到头打印链表</strong></p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    if (listNode !&#x3D; null) &#123;</span><br><span class="line">        printListFromTailToHead(listNode.next);</span><br><span class="line">        arrayList.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非递归</span><br><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    while (listNode !&#x3D; null) &#123;</span><br><span class="line">        arrayList.add(0, listNode.val);</span><br><span class="line">        listNode &#x3D; listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 反转链表(重点)</strong></p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 非递归</span><br><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">    ListNode pre &#x3D; null;</span><br><span class="line">    ListNode cur &#x3D; head;</span><br><span class="line">    while (cur !&#x3D; null) &#123;</span><br><span class="line">        ListNode next &#x3D; cur.next;</span><br><span class="line">        cur.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; cur;</span><br><span class="line">        cur &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode node &#x3D; ReverseList(head.next);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 合并两个排序的链表</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">    ListNode head &#x3D; new ListNode(0);</span><br><span class="line">    ListNode root &#x3D; head;</span><br><span class="line">    while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123;</span><br><span class="line">        if (list1.val &lt; list2.val) &#123;</span><br><span class="line">            head.next &#x3D; list1;</span><br><span class="line">            list1 &#x3D; list1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head.next &#x3D; list2;</span><br><span class="line">            list2 &#x3D; list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (list1 !&#x3D; null) head.next &#x3D; list1;</span><br><span class="line">    if (list2 !&#x3D; null) head.next &#x3D; list2;</span><br><span class="line">    return root.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 二叉树的深度</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return 0;</span><br><span class="line">    int left &#x3D; TreeDepth(root.left);</span><br><span class="line">    int right &#x3D; TreeDepth(root.right);</span><br><span class="line">    return left &gt; right ? left + 1 : right + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>7. 平衡二叉树</strong></p>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return true;</span><br><span class="line">    int left &#x3D; getTreeDepth(root.left);</span><br><span class="line">    int right &#x3D; getTreeDepth(root.right);</span><br><span class="line">    if ((left - right) &#x3D;&#x3D; -1 || (left - right) &#x3D;&#x3D; 1 || (left - right) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private int getTreeDepth(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return 0;</span><br><span class="line">    return 1 + Math.max(getTreeDepth(root.left), getTreeDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8. 对称的二叉树</strong></p>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      8</span><br><span class="line">  6       6</span><br><span class="line">5   7  7    5</span><br><span class="line"></span><br><span class="line">boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">    if (pRoot &#x3D;&#x3D; null) return true;</span><br><span class="line">    return compare(pRoot.left, pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">boolean compare(TreeNode left, TreeNode right) &#123;</span><br><span class="line">    if (left &#x3D;&#x3D; null) return right &#x3D;&#x3D; null;</span><br><span class="line">    if (right &#x3D;&#x3D; null) return false;</span><br><span class="line">    if (left.val &#x3D;&#x3D; right.val) &#123;</span><br><span class="line">        return compare(left.left, right.right) &amp;&amp; compare(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9. 斐波那契数列</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。<br>n&lt;=39</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    return Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10. 跳台阶</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1) + f(n-2);</span><br><span class="line">public int JumpFloor(int target) &#123;</span><br><span class="line">    if (target &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (target &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (target &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    return JumpFloor(target - 1) + JumpFloor(target - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>11. 变态跳台阶</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f(n)   &#x3D; f(n-1) + f(n-2) + f(n-3) + ... + f(2) + f(1)</span><br><span class="line">f(n-1) &#x3D; f(n-2) + f(n-3) + ... + f(2) + f(1);</span><br><span class="line"></span><br><span class="line">2式相减： f(n) &#x3D; 2 * f(n-1)</span><br><span class="line"></span><br><span class="line">public int JumpFloorII(int target) &#123;</span><br><span class="line">  	if (target &#x3D;&#x3D; 0) return 0;</span><br><span class="line">   	if (target &#x3D;&#x3D; 1) return 1;</span><br><span class="line">   	return 2 * JumpFloorII(target - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>12. 矩形覆盖</strong></p>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int RectCover(int target) &#123;</span><br><span class="line">    if (target &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (target &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (target &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    return RectCover(target - 1) + RectCover(target - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>13. 二进制中1的个数</strong></p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p>
<p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    while (n !&#x3D; 0) &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        n &#x3D; n &amp; (n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14. 链表中倒数第k个结点</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点。 (快慢指针)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">    ListNode p &#x3D; null;</span><br><span class="line">    ListNode q &#x3D; head;</span><br><span class="line">    while (q !&#x3D; null &amp;&amp; k &gt; 0) &#123;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (k &gt; 0) return p;</span><br><span class="line">    p &#x3D; head;</span><br><span class="line">    while (q !&#x3D; null) &#123;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>15. 调整数组顺序使奇数位于偶数前面</strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void reOrderArray(int [] array) &#123;</span><br><span class="line">    int size &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (array[i] % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            int j &#x3D; i;</span><br><span class="line">            int temp &#x3D; array[i];</span><br><span class="line">            while (j &gt; size) &#123;</span><br><span class="line">                array[j] &#x3D; array[j - 1];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[size++] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>16. 数值的整数次方</strong></p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p>
<p><strong>注意exponent为负数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">    if (exponent &#x3D;&#x3D; 0) return 1;</span><br><span class="line">    </span><br><span class="line">    double ans &#x3D; base;</span><br><span class="line">    </span><br><span class="line">    if (exponent &lt; 0) &#123;</span><br><span class="line">        ans &#x3D; 1 &#x2F; base;</span><br><span class="line">        base &#x3D; 1 &#x2F; base;</span><br><span class="line">        exponent &#x3D; -exponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; exponent; i++) &#123;</span><br><span class="line">        ans &#x3D; ans * base;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>17. 二叉树的镜像(重点)</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return;</span><br><span class="line">    TreeNode temp &#x3D; root.right;</span><br><span class="line">    root.right &#x3D; root.left;</span><br><span class="line">    root.left &#x3D; temp;</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非递归</span><br><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">    if(root &#x3D;&#x3D; null) return;</span><br><span class="line">    Queue&lt;TreeNode&gt; nodes &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode curr, temp;</span><br><span class="line">    nodes.offer(root);</span><br><span class="line">    while (!nodes.isEmpty()) &#123;</span><br><span class="line">        int len &#x3D; nodes.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)&#123;</span><br><span class="line">            curr &#x3D; nodes.poll();</span><br><span class="line">            temp &#x3D; curr.left;</span><br><span class="line">            curr.left &#x3D; curr.right;</span><br><span class="line">            curr.right &#x3D; temp;</span><br><span class="line">            if (curr.left !&#x3D; null) nodes.offer(curr.left);</span><br><span class="line">            if (curr.right !&#x3D; null) nodes.offer(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">JVM常见参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 23:56:34" itemprop="dateCreated datePublished" datetime="2020-06-05T23:56:34+08:00">2020-06-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>先从一道笔试题开始</strong></p>
<blockquote>
<p>对于JVM内存配置参数：-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3<br>,其最小内存值和Survivor区总大小分别是多少？</p>
</blockquote>
<p>如果对JVM参数不了解，基本就可以歇歇了。本题主要考察的就是Java堆内存的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xmx  最大堆大小</span><br><span class="line">-Xms  初始堆大小</span><br><span class="line">-Xmn  年轻代大小</span><br><span class="line">-XX:NewRatio  年轻代（年轻代包括：Eden和两个Surivor）与年老代（年老代不包括持久代）的比值</span><br><span class="line">-XX:SurvivorRatio  年轻代中Eden区与Survivor区的大小比值</span><br><span class="line">年轻代5120m， Eden：Survivor&#x3D;3，Survivor区大小&#x3D;1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。</span><br><span class="line">-Xms初始堆大小即最小内存值为10240m</span><br><span class="line">新生代大部分要回收，采用Copying算法，快！</span><br><span class="line">老年代 大部分不需要回收，采用Mark-Compact算法</span><br></pre></td></tr></table></figure>

<img src="/2020/06/05/JVM%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0/Java-Memory-Model.png" class="" title="[Java-Memory-Model]">

<p><strong>永久区分配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize    设置永久区的初始空间</span><br><span class="line">-XX:MaxPermSize 设置永久区的最大空间</span><br></pre></td></tr></table></figure>

<p><strong>栈的分配</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 设置栈空间的大小,通常只有几百K</span><br></pre></td></tr></table></figure>

<p><strong>GC参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails  打印GC详细日志</span><br><span class="line">-Xloggc:log&#x2F;gc.log   指定GClog的位置</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/loveer/p/11522493.html" target="_blank" rel="noopener">JVM参数配置</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/05/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8812%EF%BC%89ReentrantLock%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/05/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8812%EF%BC%89ReentrantLock%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">啃碎并发（12）ReentrantLock原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 11:02:41" itemprop="dateCreated datePublished" datetime="2020-06-05T11:02:41+08:00">2020-06-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ReentrantLock-简介"><a href="#ReentrantLock-简介" class="headerlink" title="ReentrantLock 简介"></a>ReentrantLock 简介</h4><p>ReentrantLock是一个继承Lock接口并且是基于CAS操作来实现的Java锁，ReentrantLock还支持公平锁和非公平锁两种方式。 </p>
<img src="/2020/06/05/%E5%95%83%E7%A2%8E%E5%B9%B6%E5%8F%91%EF%BC%8812%EF%BC%89ReentrantLock%E5%8E%9F%E7%90%86/32fe52d9f90b34b6082b3ce032d373c5.png" class="" title="[啃碎并发（12）ReentrantLock原理]">

<p><strong>一般的用法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock mLock &#x3D; new ReentrantLock();</span><br><span class="line">mLock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">	&#x2F;&#x2F; 业务逻辑</span><br><span class="line">&#125; finaly &#123;</span><br><span class="line">	mLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>0. Condition 接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line">	void await() throws InterruptedException;</span><br><span class="line">	void awaitUninterruptibly();</span><br><span class="line">	void signal(); &#x2F;&#x2F; 唤醒单个线程</span><br><span class="line">	void signalAll(); &#x2F;&#x2F;唤醒多有线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>1. Lock 接口 *</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">	void lock(); &#x2F;&#x2F; 如果没获取到锁则阻塞</span><br><span class="line">	void lockInterruptibly() throws InterruptedException; </span><br><span class="line">	boolean tryLock(); &#x2F;&#x2F; 如果获取到锁立即返回true，否则立即返回false</span><br><span class="line">	void unlock();</span><br><span class="line">	Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. ReentrantLock 类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">	private final Sync sync;</span><br><span class="line">	</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync &#x3D; new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public void lock() &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	public boolean tryLock() &#123;</span><br><span class="line">        return sync.nonfairTryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	public Condition newCondition() &#123;</span><br><span class="line">        return sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing</span><br><span class="line">         * is to allow fast path for nonfair version.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        abstract void lock();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line">         * subclasses, but both need nonfair try for trylock method.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c &#x3D; getState() - releases;</span><br><span class="line">            if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free &#x3D; false;</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                free &#x3D; true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean isHeldExclusively() &#123;</span><br><span class="line">            &#x2F;&#x2F; While we must in general read state before owner,</span><br><span class="line">            &#x2F;&#x2F; we don&#39;t need to do so to check if current thread is owner</span><br><span class="line">            return getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ConditionObject newCondition() &#123;</span><br><span class="line">            return new ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Methods relayed from outer class</span><br><span class="line"></span><br><span class="line">        final Thread getOwner() &#123;</span><br><span class="line">            return getState() &#x3D;&#x3D; 0 ? null : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getHoldCount() &#123;</span><br><span class="line">            return isHeldExclusively() ? getState() : 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean isLocked() &#123;</span><br><span class="line">            return getState() !&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Reconstitutes the instance from a stream (that is, deserializes it).</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">            throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(0); &#x2F;&#x2F; reset to unlocked state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sync object for non-fair locks</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread()); &#x2F;&#x2F; 体现重入锁</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sync object for fair locks</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>AbstractQueuedSynchronizer：抽象同步队列，简称AQS主要依赖一个int成员变量来表示同步状态state，以及一个CLH等待队列.</p>
<pre><code>public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    static final class Node {
        static final Node SHARED = new Node(); // 共享
        static final Node EXCLUSIVE = null;    // 独占
        volatile Node prev;
        volatile Node next;
        volatile Thread thread;
        Node nextWaiter;
    }
    private volatile int state;
    private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();
    private transient volatile Node head;
    private transient volatile Node tail;
    protected final int getState() { return state; }
    // 通常用于当前正持有锁的线程对state变量进行修改，不存在竞争，是线程安全的，所以此处没必要用CAS保证原子性，修改的性能更重要。
    protected final void setState(int newState) { state = newState; }
    // 通常用于在获取到锁之前，尝试加锁时，对state进行修改，这种场景下，由于当前线程不是锁持有者，所以对state的修改是线程不安全的，也就是说可能存在多个线程都尝试修改state,所以需要保证对state修改的原子性操作，即使用了unsafe类的本地CAS方法；
    protected final boolean compareAndSetState(int expect, int update) {
        return U.compareAndSwapInt(this, STATE, expect, update);
    }

    // 初始化CLH队列head
    private final void initializeSyncQueue() {
        Node h;
        if (U.compareAndSwapObject(this, HEAD, null, (h = new Node())))
            tail = h;
    }

    // 尝试去获取锁，如果没获取到则将当前线程添加到等待队列
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

    private Node addWaiter(Node mode) {
        Node node = new Node(mode);

        for (;;) {
            Node oldTail = tail;
            if (oldTail != null) {
                U.putObject(node, Node.PREV, oldTail);
                if (compareAndSetTail(oldTail, node)) {
                    oldTail.next = node;
                    return node;
                }
            } else {
                initializeSyncQueue();
            }
        }
    }

    private Node enq(Node node) {
        for (;;) {
            Node oldTail = tail;
            if (oldTail != null) {
                U.putObject(node, Node.PREV, oldTail);
                if (compareAndSetTail(oldTail, node)) {
                    oldTail.next = node;
                    return oldTail;
                }
            } else {
                initializeSyncQueue();
            }
        }
    }

    final boolean acquireQueued(final Node node, int arg) {
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } catch (Throwable t) {
            cancelAcquire(node);
            throw t;
        }
    }

    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }

    public final boolean hasQueuedPredecessors() {
        Node t = tail;
        Node h = head;
        Node s;
        return h != t &amp;&amp;
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    /**
     * 以下为父类 AbstractOwnableSynchronizer 定义
     */
    private transient Thread exclusiveOwnerThread;
    protected final void setExclusiveOwnerThread(Thread thread) { exclusiveOwnerThread = thread; }
    protected final Thread getExclusiveOwnerThread() { return exclusiveOwnerThread; }

}

【解读】
lock() -&gt; acquire(1) -&gt; tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
                                |

3. LinkedBlockingQueue 类
public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
        implements BlockingQueue&lt;E&gt;, java.io.Serializable {
    private final AtomicInteger count = new AtomicInteger();
    transient Node&lt;E&gt; head;
    private transient Node&lt;E&gt; last;
    private final ReentrantLock takeLock = new ReentrantLock();
    private final Condition notEmpty = takeLock.newCondition();
    private final ReentrantLock putLock = new ReentrantLock();
    private final Condition notFull = putLock.newCondition();    

    public LinkedBlockingQueue() {
        this(Integer.MAX_VALUE);
    }

    public LinkedBlockingQueue(int capacity) {
        if (capacity &lt;= 0) throw new IllegalArgumentException();
        this.capacity = capacity;
        last = head = new Node&lt;E&gt;(null);
    }

    private static final long serialVersionUID = -6903933977591709194L;
        static class Node&lt;E&gt; {
        E item;
        Node&lt;E&gt; next;
        Node(E x) { item = x; }
    }

    //【****重点****】
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();

        int c = -1;
        Node&lt;E&gt; node = new Node&lt;E&gt;(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            while (count.get() == capacity) {
                notFull.await();
            }
            enqueue(node);
            c = count.getAndIncrement();
            if (c + 1 &lt; capacity)
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            signalNotEmpty();
    }

    private void enqueue(Node&lt;E&gt; node) {
        last = last.next = node;
    }

    //【****重点****】
    public E take() throws InterruptedException {
        E x;
        int c = -1;
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
            while (count.get() == 0) {
                notEmpty.await();
            }
            x = dequeue();
            c = count.getAndDecrement();
            if (c &gt; 1)
                notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }

    private E dequeue() {
        Node&lt;E&gt; h = head;
        Node&lt;E&gt; first = h.next;
        h.next = h; // help GC
        head = first;
        E x = first.item;
        first.item = null;
        return x;
    }    
}

3. Semaphore/CountDownLatch (共享锁)

3.1 Semaphore 



[用法]
Semaphore semaphore = new Semaphore(2);
try {
    semaphore.acquire();
    // 业务逻辑
    semaphore.release();
} finaly (InterruptedException e) {
    e.printStackTrace();
}
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/Android%20Bitmap%20%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/Android%20Bitmap%20%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Android Bitmap 详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-04 14:35:15" itemprop="dateCreated datePublished" datetime="2020-06-04T14:35:15+08:00">2020-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="0-Bitmap"><a href="#0-Bitmap" class="headerlink" title="0. Bitmap"></a>0. Bitmap</h4><p>Bitmap位图包括<strong>像素以及长、宽、颜色等描述信息</strong>。长宽和像素位数是用来描述图片的，可以通过这些信息计算出图片的像素占用内存的大小。</p>
<p>Android中创建Bitmap对象的方法主要是依赖<strong>BitmapFactory</strong></p>
<ul>
<li>public static Bitmap decodeFile(String pathName, Options opts)</li>
<li>public static Bitmap decodeFile(String pathName)</li>
<li>public static Bitmap decodeStream(InputStream is)</li>
<li>public static Bitmap decodeFileDescriptor(FileDescriptor fd)</li>
<li>public static Bitmap decodeResource(Resources res, int id)</li>
</ul>
<p>里面重载了很多带有<strong>Options opts</strong>参数的函数</p>
<h5 id="0-1-Config属性"><a href="#0-1-Config属性" class="headerlink" title="0.1. Config属性"></a>0.1. Config属性</h5><p>表示图片像素类型，包括ALPHA_8、RGB_565、ARGB_4444、ARGB_8888 A：透明度；RGB分别是Red、Green、Blue，三种原色</p>
<ul>
<li>ARGB_8888：四个通道都是8位，每个像素占用4个字节，图片质量是最高的，但是占用的内存也是最大的；</li>
<li>ARGB_4444：四个通道都是4位，每个像素占用2个字节，图片的失真比较严重；</li>
<li>RGB_565：没有A通道，每个像素占用2个字节，图片失真小，但是没有透明度；</li>
<li>ALPHA_8：只有A通道，每个像素占用1个字节大大小，只有透明度，没有颜色值。</li>
</ul>
<p>使用场景总结：ARGB_4444失真严重，基本不用；ALPHA_8使用场景特殊，比如设置遮盖效果等；不需要设置透明度，RGB_565是个不错的选择；既要设置透明度，对图片质量要求又高，就用ARGB_8888。</p>
<h5 id="0-2-CompressFormat"><a href="#0-2-CompressFormat" class="headerlink" title="0.2. CompressFormat"></a>0.2. CompressFormat</h5><p>图片的压缩格式总共有三种：Bitmap.CompressFormat.JPEG、Bitmap.CompressFormat.PNG、Bitmap.CompressFormat.WEBP</p>
<ul>
<li>JPEG：一种有损压缩（JPEG2000既可以有损也可以无损），”.jpg”或者”.jpeg”; 优点：采用了直接色，有丰富的色彩，适合存储照片和生动图像效果；缺点：有损，不适合用来存储logo、线框类图。</li>
<li>PNG: 一种无损压缩，”.png”; 优点：支持透明、无损，主要用于小图标，透明背景等；缺点：若色彩复杂，则图片生成后文件很大；</li>
<li>WEBP:以WebP算法进行压缩；Google开发的新的图片格式，同时支持无损和有损压缩，使用直接色。无损压缩，相同质量的webp比PNG小大约26%；有损压缩，相同质量的webp比JPEG小25%-34% 支持动图，基本取代gif</li>
</ul>
<h4 id="1-BitmapFactory-Options"><a href="#1-BitmapFactory-Options" class="headerlink" title="1. BitmapFactory.Options"></a>1. BitmapFactory.Options</h4><p><strong>BitmapFactory.Options 定义</strong></p>
<p>Options是BitmapFactory 的静态内部类，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class BitmapFactory &#123;</span><br><span class="line">    private static final int DECODE_BUFFER_SIZE &#x3D; 16 * 1024;</span><br><span class="line">    public static class Options &#123;</span><br><span class="line">		public Bitmap inBitmap;</span><br><span class="line">		public boolean inMutable;</span><br><span class="line">		public boolean inJustDecodeBounds;</span><br><span class="line">		public int inSampleSize;</span><br><span class="line">		&#x2F;&#x2F; 设置彩色模式</span><br><span class="line">		public Bitmap.Config inPreferredConfig &#x3D; Bitmap.Config.ARGB_8888;</span><br><span class="line">		public ColorSpace inPreferredColorSpace &#x3D; null;</span><br><span class="line">		public int outWidth;</span><br><span class="line">		public int outHeight;</span><br><span class="line">		&#x2F;&#x2F; 获取图像的Mime类型</span><br><span class="line">		public String outMimeType;</span><br><span class="line">		public int inDensity;</span><br><span class="line">		public int inTargetDensity;</span><br><span class="line">		public int inScreenDensity;</span><br><span class="line">		public boolean inScaled;</span><br><span class="line">		&#x2F;&#x2F; 设置缓存区,如果不设置默认为16M</span><br><span class="line">		public byte[] inTempStorage</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BitmapFactory.Options options = new BitmapFactory.Options();</p>
</blockquote>
<p><strong>Options 常用的参数含义</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认值为false，如果设置成true，那么在解码的时候就不会返回bitmap，即bitmap &#x3D; null。</span><br><span class="line">options.inJustDecodeBounds &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以复用之前用过的bitmap</span><br><span class="line">options.inBitmap &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;是该bitmap缓存是否可变，如果设置为true，将可被inBitmap复用</span><br><span class="line">options.inMutable &#x3D; true;</span><br><span class="line"></span><br><span class="line">DisplayMetrics dm &#x3D; getResources().getDisplayMetrics();</span><br><span class="line">&#x2F;&#x2F;表示这个bitmap的像素密度，当inDensity为0时，系统默认赋值为屏幕当前像素密度</span><br><span class="line">options.inDensity &#x3D; dm.densityDpi;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示要被画出来时的目标像素密度，当inTargetDensity为0时，系统默认赋值为屏幕当前像素密度</span><br><span class="line">options.inTargetDensity &#x3D; options.inDensity;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示实际设备的像素密度</span><br><span class="line">options.inScreenDensity &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个参数可以改变bitmap分辨率大小，inSampleSize &gt;&#x3D; 1。</span><br><span class="line">&#x2F;&#x2F;当inSampleSize &lt; 1时，inSampleSize就默认是1。</span><br><span class="line">&#x2F;&#x2F;假如：图片的宽和高分别是width、height，那么图片解码生成的bitmap的宽度是：width &#x2F; inSampleSize，高度是：height &#x2F; inSampleSize</span><br><span class="line">&#x2F;&#x2F;inSampleSize影响bitmap的分辨率，从而影响bitmap占用内存的大小。</span><br><span class="line">options.inSampleSize &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置这个Bitmap是否可以被缩放，默认值是true，表示可以被缩放。</span><br><span class="line">options.inScaled &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>这里重点讲解一下<strong>inBitmap参数</strong></p>
<p>这个参数用来实现Bitmap内存的复用，但复用存在一些限制，具体体现在：<strong>在Android 4.4之前只能重用相同大小的Bitmap的内存，而Android 4.4及以后版本则只要后来的Bitmap比之前的小即可。</strong>使用inBitmap参数前，每创建一个Bitmap对象都会分配一块内存供其使用，而使用了inBitmap参数后，多个Bitmap可以复用一块内存，这样可以提高性能。<br>关于这个复用Bitmap内存的详细方法以及注意事项Android Developer网站已给出了详细的说明（Managing Bitmap Memory）。这里简单的贴出部分示例代码了解下它的大致用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static void addInBitmapOptions(BitmapFactory.Options options, ImageCache cache) &#123; </span><br><span class="line">  &#x2F;&#x2F; inBitmap only works with mutable bitmaps, so force the decoder to </span><br><span class="line">  &#x2F;&#x2F; return mutable bitmaps. </span><br><span class="line">  options.inMutable &#x3D; true; </span><br><span class="line">  if (cache !&#x3D; null) &#123; </span><br><span class="line">    &#x2F;&#x2F; Try to find a bitmap to use for inBitmap. </span><br><span class="line">    Bitmap inBitmap &#x3D; cache.getBitmapFromReusableSet(options); </span><br><span class="line">    if (inBitmap !&#x3D; null) &#123; </span><br><span class="line">      &#x2F;&#x2F; If a suitable bitmap has been found, </span><br><span class="line">      &#x2F;&#x2F; set it as the value of inBitmap. </span><br><span class="line">      options.inBitmap &#x3D; inBitmap; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static boolean canUseForInBitmap( Bitmap candidate, </span><br><span class="line">    BitmapFactory.Options targetOptions) &#123; </span><br><span class="line">  if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123; </span><br><span class="line">    &#x2F;&#x2F; From Android 4.4 (KitKat) onward we can re-use </span><br><span class="line">    &#x2F;&#x2F; if the byte size of the new bitmap is smaller than </span><br><span class="line">    &#x2F;&#x2F; the reusable bitmap candidate </span><br><span class="line">    &#x2F;&#x2F; allocation byte count. </span><br><span class="line">    int width &#x3D; targetOptions.outWidth &#x2F; targetOptions.inSampleSize; </span><br><span class="line">    int height &#x3D; targetOptions.outHeight &#x2F; targetOptions.inSampleSize; </span><br><span class="line">    int byteCount &#x3D; width * height * getBytesPerPixel(candidate.getConfig()); </span><br><span class="line">    return byteCount &lt;&#x3D; candidate.getAllocationByteCount(); </span><br><span class="line">  &#125; </span><br><span class="line">  &#x2F;&#x2F; On earlier versions, </span><br><span class="line">  &#x2F;&#x2F; the dimensions must match exactly and the inSampleSize must be 1 </span><br><span class="line">  return candidate.getWidth() &#x3D;&#x3D; targetOptions.outWidth </span><br><span class="line">      &amp;&amp; candidate.getHeight() &#x3D;&#x3D; targetOptions.outHeight </span><br><span class="line">      &amp;&amp; targetOptions.inSampleSize &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图片加载之前先计算图片大小</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap &#x3D; BitmapFactory.decodeFile(FileDirUtil.getInstance().getExternalStorageDirectory() + File.separator + &quot;temp.jpg&quot;);</span><br></pre></td></tr></table></figure>

<p>我们看一下上面的代码，那是解码一张本地图片，解码之后bitmap将占用内存空间，如果bitmap太大导致app性能降低，甚至导致OOM发生，为了防止这种现象，我们可以先计算本地图片的分辨率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">Bitmap bitmap &#x3D; BitmapFactory.decodeFile(FileDirUtil.getInstance().getExternalStorageDirectory() + File.separator + &quot;temp.jpg&quot;, options );</span><br><span class="line">int imageHeight &#x3D; options.outHeight;</span><br><span class="line">Log.d(TAG, &quot;图片的高度：&quot;+imageHeight);</span><br><span class="line">int imageWidth &#x3D; options.outWidth;</span><br><span class="line">Log.d(TAG, &quot;图片的宽度：&quot;+imageWidth);</span><br></pre></td></tr></table></figure>

<p>当inJustDecodeBounds设置true时，本地图片解码之后bitmap为null，只计算图片的宽度和高度。拿到图片宽度和高度之后可以根据我们自己的策略是否放大或缩小图片分辨率。</p>
<p><strong>像素密度分析</strong><br>BitmapFactory.Options中与像素密度有关的主要有三个参数：<strong>inDensity、inTargetDensity、inScreenDensity</strong>，配合inScaled参数可以控制图像缩放。</p>
<p>我们先看一下源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static void setDensityFromOptions(Bitmap outputBitmap, Options opts) &#123;</span><br><span class="line">    if (outputBitmap &#x3D;&#x3D; null || opts &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">    final int density &#x3D; opts.inDensity;</span><br><span class="line">    if (density !&#x3D; 0) &#123;</span><br><span class="line">        outputBitmap.setDensity(density);</span><br><span class="line">        final int targetDensity &#x3D; opts.inTargetDensity;</span><br><span class="line">        if (targetDensity &#x3D;&#x3D; 0 || density &#x3D;&#x3D; targetDensity || density &#x3D;&#x3D; opts.inScreenDensity) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] np &#x3D; outputBitmap.getNinePatchChunk();</span><br><span class="line">        final boolean isNinePatch &#x3D; np !&#x3D; null &amp;&amp; NinePatch.isNinePatchChunk(np);</span><br><span class="line">        if (opts.inScaled || isNinePatch) &#123;</span><br><span class="line">			&#x2F;&#x2F; 如果图片可以伸缩或者是9Patch，则设置图片的像素密度为targetDensity</span><br><span class="line">            outputBitmap.setDensity(targetDensity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (opts.inBitmap !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; bitmap复用过, 重新设置density值为屏幕默认像素密度</span><br><span class="line">		&#x2F;&#x2F; 相当于DisplayMetrics dm &#x3D; getResources().getDisplayMetrics(); </span><br><span class="line">		&#x2F;&#x2F; 获取屏幕像素密度：dm.densityDpi</span><br><span class="line">        outputBitmap.setDensity(Bitmap.getDefaultDensity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inDensity、inTargetDensity、inScreenDensity、inScaled配合使用可以对图片进行缩放，缩放的比例是targetDensity / density</p>
<h5 id="采样压缩示例"><a href="#采样压缩示例" class="headerlink" title="采样压缩示例"></a>采样压缩示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.Options options &#x3D; new BitmapFactory.Options();  </span><br><span class="line">&#x2F;&#x2F;inJustDecodeBounds为true，不返回bitmap，只返回这个bitmap的尺寸  </span><br><span class="line">options.inJustDecodeBounds &#x3D; true; </span><br><span class="line">BitmapFactory.decodeResource(getResources(), images[position], options);  </span><br><span class="line">&#x2F;&#x2F;利用返回的原图片的宽高，我们就可以计算出缩放比inSampleSize（只能是2的整数次幂）</span><br><span class="line">options.inSampleSize &#x3D; caluelateInSampleSize(options, reqWidth, reqHeight);&#x2F;&#x2F;使用RGB_565减少图片大小  </span><br><span class="line">options.inPreferredConfig &#x3D; Bitmap.Config.RGB_565;  </span><br><span class="line">&#x2F;&#x2F;释放内存，共享引用（21版本后失效）  </span><br><span class="line">options.inPurgeable &#x3D; true;  </span><br><span class="line">options.inInputShareable &#x3D; true;  </span><br><span class="line">             </span><br><span class="line">&#x2F;&#x2F;inJustDecodeBounds为false，返回bitmap  </span><br><span class="line">options.inJustDecodeBounds &#x3D; false;  </span><br><span class="line">Bitmap bitmap &#x3D; BitmapFactory.decodeResource(getResources(), images[position], options);  </span><br><span class="line"></span><br><span class="line">private int calculateSampleSize(BitmapFactory.Options options,int reqWidth,int reqHeight)&#123;</span><br><span class="line">	int width &#x3D; options.outWidth;</span><br><span class="line">    int height &#x3D;options.outHeight;int inSampleSize &#x3D; 1;</span><br><span class="line">    int halfWidth &#x3D; width &#x2F; 2;</span><br><span class="line">    int halfHeight &#x3D; height &#x2F; 2;</span><br><span class="line">    while((halfWidth &#x2F; inSampleSize) &gt;&#x3D; reqWidth &amp;&amp; (halfHeight &#x2F; inSampleSize) &gt;&#x3D; reqHeight)&#123;</span><br><span class="line">        inSampleSize *&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用BitmapRegionDecoder区域加载器加载大图"><a href="#利用BitmapRegionDecoder区域加载器加载大图" class="headerlink" title="利用BitmapRegionDecoder区域加载器加载大图"></a>利用BitmapRegionDecoder区域加载器加载大图</h4><p>最主要的就是BitmapRegionDecode.newInstance(…)获取一个对象，然后通过这个对象去调用decodeRegion（…）得到bitmap，最后就可以显示在屏幕上了。考虑到用户可以触摸移动图像，我们用手势控制器GestureDetector来控制图片显示的区域。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/04/View%20%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/View%20%E7%BB%98%E5%88%B6%E4%B8%8E%E5%8A%A8%E7%94%BB/" class="post-title-link" itemprop="url">View 绘制与动画</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-04 10:53:39 / 修改时间：13:19:53" itemprop="dateCreated datePublished" datetime="2020-06-04T10:53:39+08:00">2020-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="View绘制onMeasure重载"><a href="#View绘制onMeasure重载" class="headerlink" title="View绘制onMeasure重载"></a>View绘制onMeasure重载</h4><p><strong>锁定宽高比Layout</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private float mRatio &#x3D; 16f &#x2F; 9;</span><br><span class="line">private boolean mIsWidthFollowsHeight;&#x2F;&#x2F;是否是宽度跟随高度变化，默认false，即默认高度跟随宽度变化</span><br><span class="line"></span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    if (mIsWidthFollowsHeight) &#123;</span><br><span class="line">        int height &#x3D; MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        int width &#x3D; (int) (height * mRatio + 0.5f);</span><br><span class="line">        super.onMeasure(MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY), heightMeasureSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int width &#x3D; MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int height &#x3D; (int) (width &#x2F; mRatio + 0.5f);</span><br><span class="line">        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RecyclerView 横向滑动冲突</strong></p>
<p>通过ACTION_DOWN的点击位置，以及ACTION_MOVE计算是否是横向滑动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent e) &#123;</span><br><span class="line">        ViewParent parent &#x3D; getParent();</span><br><span class="line">        if (parent &#x3D;&#x3D; null || !mIsInterceptTouchEvent) &#123;</span><br><span class="line">            if (parent !&#x3D; null) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(false);</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onInterceptTouchEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line">        switch (e.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mDownX &#x3D; (int) e.getX();</span><br><span class="line">                mDownY &#x3D; (int) e.getY();</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(true);</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                float x &#x3D; e.getX();</span><br><span class="line">                float y &#x3D; e.getY();</span><br><span class="line">                float deltaX &#x3D; Math.abs(x - mDownX);</span><br><span class="line">                float deltaY &#x3D; Math.abs(y - mDownY);</span><br><span class="line">                if (deltaX &lt; mTouchSlop &amp;&amp; deltaY &lt; mTouchSlop) &#123;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(true);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    boolean isHorizontal &#x3D; deltaX &gt; deltaY * 2;</span><br><span class="line">                    parent.requestDisallowInterceptTouchEvent(isHorizontal);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通用下滑关闭RelativeLayout</strong></p>
<ol>
<li>解决事件拦截</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mDownX &#x3D; (int) ev.getRawX();</span><br><span class="line">            mDownY &#x3D; mTempY &#x3D; (int) ev.getRawY();</span><br><span class="line">            return false;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            int moveX &#x3D; (int) ev.getRawX();</span><br><span class="line">            int moveY &#x3D; (int) ev.getRawY();</span><br><span class="line">            &#x2F;&#x2F; 可以调整最小滑动识别距离</span><br><span class="line">            if (Math.abs(moveY - mDownY) &gt; mTouchSlop &amp;&amp; Math.abs(moveX - mDownX) &gt; mTouchSlop &#x2F; 10) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/wait%E3%80%81notify%20%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/wait%E3%80%81notify%20%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/" class="post-title-link" itemprop="url">wait、notify 实现生产者消费者</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 20:44:23" itemprop="dateCreated datePublished" datetime="2020-06-03T20:44:23+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java中的wait/notify/notifyAll可用来实现线程间通信，是Object类的方法，这三个方法都是native方法，是平台相关的，常用来实现生产者/消费者模式。先来我们来看下相关定义：</p>
<ul>
<li>wait() :调用该方法的线程进入WATTING状态，只有等待另外线程的通知或中断才会返回，调用wait()方法后，会释放对象的锁。</li>
<li>wait(long):超时等待最多long毫秒，如果没有通知就超时返回。</li>
<li>notify() : 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了对象的锁。</li>
<li>notifyAll()：通知所有等待在该对象上的线程。</li>
</ul>
<p>实例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ThreadA extends Thread&#123;</span><br><span class="line">	public ThreadA(String name) &#123;</span><br><span class="line">		super(name);</span><br><span class="line">	&#125;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			try &#123;						</span><br><span class="line">				Thread.sleep(1000);	&#x2F;&#x2F;	使当前线阻塞 1 s，确保主程序的 t1.wait(); 执行之后再执行 notify()</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;			</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot; call notify()&quot;);</span><br><span class="line">			&#x2F;&#x2F; 唤醒当前的wait线程</span><br><span class="line">			this.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class WaitTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ThreadA t1 &#x3D; new ThreadA(&quot;t1&quot;);</span><br><span class="line">		synchronized(t1) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F; 启动“线程t1”</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot; start t1&quot;);</span><br><span class="line">				t1.start();</span><br><span class="line">				&#x2F;&#x2F; 主线程等待t1通过notify()唤醒。</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot; wait()&quot;);</span><br><span class="line">				t1.wait();  &#x2F;&#x2F;  不是使t1线程等待，而是当前执行wait的线程等待</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot; continue&quot;);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinkedBlockingQueue-实现"><a href="#LinkedBlockingQueue-实现" class="headerlink" title="LinkedBlockingQueue 实现"></a>LinkedBlockingQueue 实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer extends Thread &#123;</span><br><span class="line">    private Storage storage;</span><br><span class="line">    public Consumer(Storage storage) &#123;</span><br><span class="line">        this.storage &#x3D; storage;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Storage.Goods goods &#x3D; storage.goods.take();</span><br><span class="line">                System.out.printf(String.valueOf(storage.goods.size())+&quot;\\n&quot;);</span><br><span class="line">                Thread.sleep(300);</span><br><span class="line">                System.out.println(&quot;消费&quot; + &quot; &quot; + goods.getName());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Producer extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private Storage storage;</span><br><span class="line">    private int i &#x3D; 0;</span><br><span class="line">    public Producer(Storage storage) &#123;</span><br><span class="line">        this.storage &#x3D; storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                storage.goods.put(new Storage.Goods(&quot;苹果&quot;+ i));</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Storage &#123;</span><br><span class="line"></span><br><span class="line">    public static int MAX_COUNT &#x3D; 5;    &#x2F;&#x2F;容量为5</span><br><span class="line"></span><br><span class="line">    public BlockingQueue&lt;Goods&gt; goods &#x3D; new LinkedBlockingQueue&lt;Goods&gt;(MAX_COUNT);</span><br><span class="line">    public Storage() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Goods &#123;</span><br><span class="line">        int id;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Goods(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    public static Object obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService service &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        Storage storage &#x3D; new Storage();</span><br><span class="line">        Consumer consumer1 &#x3D; new Consumer(storage);</span><br><span class="line">        Consumer consumer2 &#x3D; new Consumer(storage);</span><br><span class="line">        Producer producer &#x3D; new Producer(storage);</span><br><span class="line"></span><br><span class="line">        service.submit(consumer1);</span><br><span class="line">        service.submit(consumer2);</span><br><span class="line">        service.submit(producer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考博客<br><a href="http://www.cnblogs.com/chengxiao/p/7043529.html" target="_blank" rel="noopener">1.Java线程间通信之wait/notify</a><br><a href="http://blog.csdn.net/zhuqiuhui/article/details/52083821" target="_blank" rel="noopener">2. Java并发之生产者-消费者几种实现</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Java异常处理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 20:01:27 / 修改时间：20:04:20" itemprop="dateCreated datePublished" datetime="2020-06-03T20:01:27+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="JAVA异常机制"><a href="#JAVA异常机制" class="headerlink" title="JAVA异常机制"></a>JAVA异常机制</h4><h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>在Java中这种在程序中运行时可能出现的一些错误称为异常。Java处理异常时，如果某个方法抛出异常，既可以在当前方法中进行捕捉，然后处理该异常，也可以将异常向上抛出，由方法调用者来处理。异常产生后，如果不做任何处理，程序就会被终止。</p>
<h5 id="二、异常捕获和处理"><a href="#二、异常捕获和处理" class="headerlink" title="二、异常捕获和处理"></a>二、异常捕获和处理</h5><p><strong>1、Java异常处理涉及到五个关键字，分别是：try、catch、finally、throw、throws。</strong></p>
<ul>
<li>Try：可能发生异常的Java语句</li>
<li>Catch：激发被捕获的异常</li>
<li>finally：方法返回前总要执行的代码.</li>
<li>throw：用于抛出一个异常对象</li>
<li>throws：在声明方法时，用于指定该方法可能抛出的异常。</li>
</ul>
<p><strong>2、try、catch、finally三个语句块应注意的问题</strong></p>
<ul>
<li>第一、try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。</li>
<li>第二、try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。</li>
<li>第三、多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下。</li>
<li>第四、无论程序是否有异常，并且无论之间try-catch是否顺利执行完毕，都会执行finally语句。在以下特殊情况下，finally块不会执行：在finally语句块中发生异常；在前面代码中使用了System.exit()退出程序；程序所在线程死亡；关闭cpu。</li>
<li>第五、当程序执行try块，catch块时遇到return语句或者throw语句，这两个语句都会导致该方法立即结束，所以系统并不会立即执行这两个语句，而是去寻找该异常处理流程中的finally块，如果没有finally块，程序立即执行return语句或者throw语句，方法终止。如果有finally块，系统立即开始执行finally块，只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句，如果finally块里也使用了return或throw等导致方法终止的语句，则finally块已经终止了方法，不用再跳回去执行try块、catch块里的任何代码了。</li>
</ul>
<p><strong>3、throw与throws</strong></p>
<p>1、throws出现在方法函数头；而throw出现在函数体。throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。</p>
<h5 id="三、异常结构"><a href="#三、异常结构" class="headerlink" title="三、异常结构"></a>三、异常结构</h5><p>Throwable类派生了两个子类。Error类用来描述Java运行系统中的内部错误以及资源耗尽的错误；Exception类为非致命性类，可以通过捕捉处理使程序继续执行。Exception类根据错误发生的原因分为运行时异常和检查异常。如图所示。</p>
<p><strong>1、检查异常</strong></p>
<p>检查异常是RuntimeException以外的异常（IOException、SQLException等），必须显示的地处理否则无法编译通过。处理方法有两种，一是用try…catch捕捉异常，二是使用throws声明抛出该异常。</p>
<p><strong>2、运行时异常</strong></p>
<p>运行时异常的特点是Java编译器不会检查它，程序中可以选择捕获处理，也可以不处理。</p>
<p><strong>3、错误</strong></p>
<p>Error（错误）:是程序无法处理的错误，表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。</p>
<h5 id="四、自定义异常"><a href="#四、自定义异常" class="headerlink" title="四、自定义异常"></a>四、自定义异常</h5><p>自定义异常只需编写一个类继承Exception类（Throwable及其子类均可）即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/%E7%B2%BE%E7%AE%80%E7%89%88LruCache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/%E7%B2%BE%E7%AE%80%E7%89%88LruCache/" class="post-title-link" itemprop="url">精简版LruCache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 19:56:42 / 修改时间：19:57:31" itemprop="dateCreated datePublished" datetime="2020-06-03T19:56:42+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java已经为我们提供了这种形式的数据结构-LinkedHashMap！它甚至提供可覆盖回收策略的方法。唯一需要我们注意的事情是，改链表的顺序是插入的顺序，而不是访问的顺序。但是，有一个构造函数提供了一个选项，可以使用访问的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public LRUCache extends LinkedHashMap &#123;</span><br><span class="line">  private int cacheSize;</span><br><span class="line"></span><br><span class="line">  public LRUCache(int cacheSize) &#123;</span><br><span class="line">    &#x2F;&#x2F;true for access-order, false for insertion-order</span><br><span class="line">    super(16, 0.75, true);</span><br><span class="line">    this.cacheSize &#x3D; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">    return size() &gt;&#x3D; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java线程池原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 19:30:49 / 修改时间：19:49:01" itemprop="dateCreated datePublished" datetime="2020-06-03T19:30:49+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>new Thread 的弊端：</p>
<ul>
<li>每次new Thread新建对象性能差</li>
<li>线程缺乏统一管理，可能无限制新建线程、相互之间竞争，可能占用过多的系统资源导致死机活着OOM</li>
<li>缺乏更多的功能，如定时执行、定期执行、线程中断</li>
</ul>
<p>线程池的好处：</p>
<ul>
<li>重用存在的线程、减少对象的创建、消亡的开销、性能佳</li>
<li>可有控制最大并发线程数、提高系统资源的利用率，同时避免过多的资源竞争、避免堵塞</li>
<li>提供定时、定期、单线程、并发数控制等功能</li>
</ul>
<h3 id="Java-线程池种类"><a href="#Java-线程池种类" class="headerlink" title="Java 线程池种类"></a>Java 线程池种类</h3><p>JDK 为我们内置了4种常见线程池的实现，均可以使用 Executors 工厂类创建。</p>
<ul>
<li>CachedThreadPool 用于并发执行大量短期的小任务，或者是负载较轻的服务器。</li>
<li>FixedThreadPool 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。</li>
<li>SingleThreadExecutor 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行。</li>
<li>ScheduledThreadPoolExecutor 用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。</li>
<li>自定义线程池时，<ul>
<li>如果任务是 CPU 密集型（需要进行大量计算、处理），则应该配置尽量少的线程，比如 CPU 个数 + 1，这样可以避免出现每个线程都需要使用很长时间但是有太多线程争抢资源的情况； </li>
<li>如果任务是 IO密集型（主要时间都在 I/O，CPU 空闲时间比较多），则应该配置多一些线程，比如 CPU 数的两倍，这样可以更高地压榨 CPU。</li>
</ul>
</li>
</ul>
<p>为了错误避免创建过多线程导致系统奔溃，建议使用有界队列。因为它在无法添加更多任务时会拒绝任务，这样可以提前预警，避免影响整个系统。</p>
<p>执行时间、顺序有要求的话可以选择优先级队列，同时也要保证低优先级的任务有机会被执行。</p>
<p>创建线程池需要使用<strong>ThreadPoolExecutor</strong>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, &#x2F;&#x2F;核心线程的数量</span><br><span class="line">    int maximumPoolSize,    &#x2F;&#x2F;最大线程数量</span><br><span class="line">    long keepAliveTime,    &#x2F;&#x2F;超出核心线程数量以外的线程空余存活时间</span><br><span class="line">    TimeUnit unit,    &#x2F;&#x2F;存活时间的单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,    &#x2F;&#x2F;保存待执行任务的队列</span><br><span class="line">    ThreadFactory threadFactory,    &#x2F;&#x2F;创建新线程使用的工厂</span><br><span class="line">    RejectedExecutionHandler handler &#x2F;&#x2F; 当任务无法执行时的处理器</span><br><span class="line">    ) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>其核心的方法<strong>execute</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    &#x2F;&#x2F;1.当前池中线程比核心数少，新建一个线程执行任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;   </span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2.核心池已满，但任务队列未满，添加到队列中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   </span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))    </span><br><span class="line">        &#x2F;&#x2F;如果这时被关闭了，拒绝任务</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)    </span><br><span class="line">        &#x2F;&#x2F;如果之前的线程已被销毁完，新建一个线程</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;3.核心池已满，队列已满，试着创建一个新线程</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);    </span><br><span class="line">        &#x2F;&#x2F;如果创建新线程失败了，说明线程池被关闭或者线程池完全满了，拒绝任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下线程池的主要工作流程：</p>
<img src="/2020/06/03/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/2169292-54031fde31b2a847.jpg" class="" title="[线程池的主要工作流程]">

<p>由于 1 和 3 新建线程时需要获取全局锁，这将严重影响性能。因此 ThreadPoolExecutor 这样的处理流程是为了在执行 execute() 方法时尽量少地执行 1 和 3，多执行 2。</p>
<p>在 ThreadPoolExecutor 完成预热后（当前线程数不少于核心线程数），几乎所有的 execute() 都是在执行步骤 2。</p>
<p>前面提到的 ThreadPoolExecutor 构造函数的参数，分别影响以下内容：</p>
<ul>
<li>corePoolSize：核心线程池数量<br>在线程数少于核心数量时，有新任务进来就新建一个线程，即使有的线程没事干<br>等超出核心数量后，就不会新建线程了，空闲的线程就得去任务队列里取任务执行了</li>
<li>maximumPoolSize：最大线程数量<br>包括核心线程池数量 + 核心以外的数量<br>如果任务队列满了，并且池中线程数小于最大线程数，会再创建新的线程执行任务</li>
<li>keepAliveTime：核心池以外的线程存活时间，即没有任务的外包的存活时间<br>如果给线程池设置 allowCoreThreadTimeOut(true)，则核心线程在空闲时头上也会响起死亡的倒计时<br>如果任务是多而容易执行的，可以调大这个参数，那样线程就可以在存活的时间里有更大可能接受新任务</li>
<li>workQueue：保存待执行任务的阻塞队列<br>不同的任务类型有不同的选择，下一小节介绍</li>
<li>threadFactory：每个线程创建的地方<br>可以给线程起个好听的名字，设置个优先级啥的</li>
<li>handler：饱和策略，大家都很忙，咋办呢，有四种策略 <ul>
<li>CallerRunsPolicy：只要线程池没关闭，就直接用调用者所在线程来运行任务</li>
<li>AbortPolicy：直接抛出 RejectedExecutionException 异常</li>
<li>DiscardPolicy：悄悄把任务放生，不做了</li>
<li>DiscardOldestPolicy：把队列里待最久的那个任务扔了，然后再调用execute() 试试看能行不</li>
<li>我们也可以实现自己的 RejectedExecutionHandler 接口自定义策略，比如如记录日志什么的</li>
</ul>
</li>
</ul>
<h3 id="保存待执行任务的阻塞队列"><a href="#保存待执行任务的阻塞队列" class="headerlink" title="保存待执行任务的阻塞队列"></a>保存待执行任务的阻塞队列</h3><p>当线程池中的核心线程数已满时，任务就要保存到队列中了。</p>
<p>线程池中使用的队列是 BlockingQueue 接口，常用的实现有如下几种：</p>
<ul>
<li>ArrayBlockingQueue：基于数组、有界，按FIFO（先进先出）原则对元素进行排序</li>
<li>LinkedBlockingQueue：基于链表，按FIFO （先进先出） 排序元素 <ul>
<li>吞吐量通常要高于 ArrayBlockingQueue               </li>
<li>Executors.newFixedThreadPool() 使用了这个队列</li>
</ul>
</li>
<li>SynchronousQueue：不存储元素的阻塞队列 <ul>
<li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态</li>
<li>吞吐量通常要高于 LinkedBlockingQueue</li>
<li>Executors.newCachedThreadPool使用了这个队列</li>
</ul>
</li>
<li>PriorityBlockingQueue：具有优先级的、无限阻塞队列</li>
</ul>
<h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolManager &#123;</span><br><span class="line">    private final String TAG &#x3D; this.getClass().getSimpleName();</span><br><span class="line">    private static final int CORE_POOL_SIZE &#x3D; Runtime.getRuntime().availableProcessors() * 2; </span><br><span class="line">    &#x2F;&#x2F; 核心线程数为 CPU数＊2</span><br><span class="line">    private static final int MAXIMUM_POOL_SIZE &#x3D; 64;    </span><br><span class="line">    &#x2F;&#x2F; 线程队列最大线程数</span><br><span class="line">    private static final int KEEP_ALIVE_TIME &#x3D; 1;    </span><br><span class="line">    &#x2F;&#x2F; 保持存活时间 1秒</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">    ** 如果是要求高吞吐量的，可以使用 SynchronousQueue 队列；如果对执行顺序有要求，可以使用 PriorityBlockingQueue；如果最大积攒的待做任务有上限，可以使用 LinkedBlockingQueue</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private final BlockingQueue&lt;Runnable&gt; mWorkQueue &#x3D; new LinkedBlockingQueue&lt;&gt;(128);</span><br><span class="line"></span><br><span class="line">    private final ThreadFactory DEFAULT_THREAD_FACTORY &#x3D; new ThreadFactory() &#123;</span><br><span class="line">        private final AtomicInteger mCount &#x3D; new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">        public Thread newThread(Runnable r) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(r, TAG + &quot; #&quot; + mCount.getAndIncrement());</span><br><span class="line">            thread.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            return thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private ThreadPoolExecutor mExecutor &#x3D; new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS, mWorkQueue, DEFAULT_THREAD_FACTORY,</span><br><span class="line">            new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    private static volatile ThreadPoolManager mInstance &#x3D; new ThreadPoolManager();</span><br><span class="line"></span><br><span class="line">    public static ThreadPoolManager getInstance() &#123;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addTask(Runnable runnable) &#123;</span><br><span class="line">        mExecutor.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public void shutdownNow() &#123;</span><br><span class="line">        mExecutor.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两种提交任务的方法"><a href="#两种提交任务的方法" class="headerlink" title="两种提交任务的方法"></a>两种提交任务的方法</h3><p>ExecutorService 提供了两种提交任务的方法：</p>
<ul>
<li>execute()：提交不需要返回值的任务<br>execute() 的参数是一个 Runnable，也没有返回值。因此提交后无法判断该任务是否被线程池执行成功。</li>
<li>submit()：提交需要返回值的任务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>
submit() 有三种重载，参数可以是 Callable 也可以是 Runnable。<br>同时它会返回一个 Funture 对象，通过它我们可以判断任务是否执行成功。<br>获得执行结果调用 Future.get()方法，这个方法会阻塞当前线程直到任务完成。<br>提交一个 Callable 任务时，需要使用 FutureTask 包一层<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FutureTask futureTask &#x3D; new FutureTask(new Callable&lt;String&gt;() &#123;    &#x2F;&#x2F;创建 Callable 任务</span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        String result &#x3D; &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;?&gt; submit &#x3D; executor.submit(futureTask);    &#x2F;&#x2F;提交到线程池</span><br><span class="line">try &#123;</span><br><span class="line">    Object result &#x3D; submit.get();    &#x2F;&#x2F;获取结果</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>线程池即使不执行任务也会占用一些资源，所以在我们要退出任务时最好关闭线程池。</p>
<p>有两个方法关闭线程池：</p>
<ul>
<li>shutdown()<br>将线程池的状态设置为 SHUTDOWN，然后中断所有没有正在执行的线程</li>
<li>shutdownNow()<br>将线程池设置为 STOP，然后尝试停止所有线程，并返回等待执行任务的列表</li>
</ul>
<p>它们的共同点是：都是通过遍历线程池中的工作线程，逐个调用 Thread.interrup()来中断线程，所以一些无法响应中断的任务可能永远无法停止（比如 Runnable）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/03/Hexo%E4%BD%BF%E7%94%A8next.Pisces%E4%B8%BB%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/03/Hexo%E4%BD%BF%E7%94%A8next.Pisces%E4%B8%BB%E9%A2%98/" class="post-title-link" itemprop="url">Hexo使用next.Pisces主题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-03 17:53:16 / 修改时间：17:55:37" itemprop="dateCreated datePublished" datetime="2020-06-03T17:53:16+08:00">2020-06-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前Hexo博客一直是使用的Jacman主题,用久的有点儿审美疲劳，最近看上比较简洁的主题Next,视觉上确实要好看很多,配色简洁看着比较舒服.</p>
<p>首先进入到你的博客的根目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Blog git:(master) ✗ </span><br><span class="line">➜  Blog git:(master) ✗ git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>接下来就是把主题配置成Next,修改博客根目录下的配置文件_config.yml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Extensions</span><br><span class="line"></span><br><span class="line"># Themes: http:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>然后启动博客就可以看到效果了.</p>
<p>修改next样式</p>
<p>不过默认的博客样式不是很好,一些标签页展示的不是很好,所以还需要改下样式.进入themes/next文件夹,修改_config.yml</p>
<p>修改导航菜单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  about: &#x2F;about&#x2F; || user</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">修改了这几个之后还不够,需要创建这几个的导航页面(home导航页为根目录不需要创建):</span><br><span class="line"></span><br><span class="line">创建归档页面</span><br><span class="line">创建页面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;hexo new page categories</span><br><span class="line">修改内容:</span><br></pre></td></tr></table></figure>
<p>title: 分类<br>date: 2018-05-14 23:34:12<br>type: “categories”</p>
<hr>
<p>创建标签页<br>创建标签页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;hexo new page tags</span><br><span class="line">修改内容:</span><br></pre></td></tr></table></figure>
<p>title: 标签<br>date: 2018-05-14 23:36:18<br>type: “tags”</p>
<hr>
<p>个人主页<br>创建个人主页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;hexo new page about</span><br><span class="line">修改内容:</span><br></pre></td></tr></table></figure>
<p>title: 个人简介<br>date: 2018-05-14 23:38:55</p>
<hr>
<p>切换主题布局<br>可以看到_config.yaml文件中默认是使用的Muse主题,这个主题是把标签之类的放到顶部,我更喜欢双栏布局，所以把对应部分改成下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>设置语言<br>默认语言在~/Blog/next/languages下面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  next git:(master) ✗ ls -l languages&#x2F;zh-*</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2100 5月  15 10:47 languages&#x2F;zh-CN.yml</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2094 5月  15 10:47 languages&#x2F;zh-HK.yml</span><br><span class="line">-rw-rw-r-- 1 anonymous anonymous 2094 5月  15 10:47 languages&#x2F;zh-TW.yml</span><br></pre></td></tr></table></figure>

<p>默认zh-CN.yml就已经给我们映射好了，只需要把博客设置成对应的语言,修改~/Blog/_config.yml:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia&#x2F;Chongqing</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
