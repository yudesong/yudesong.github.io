<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yudesong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/19%20Android-IPC-Binder%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/19%20Android-IPC-Binder%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">19 Android-IPC-Binder机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 16:16:56 / 修改时间：16:16:28" itemprop="dateCreated datePublished" datetime="2020-06-21T16:16:56+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Binder%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">Binder机制</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android为什么要采用Binder作为IPC方式：</p>
<ul>
<li>性能：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</li>
<li>稳定性：Binder基于C/S架构，Client端有什么需求，直接发送给Server端去完成，架构清晰明朗，Server端与Client端相对独立，稳定性较好。</li>
<li>语言：Linux基于C语言(面向过程的语言)，而Android基于Java语言(面向对象的语句)，Binder符合面向对象的思想，将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其它进程，让大家都能访问同一Server，就像将一个对象或引用赋值给另一个引用一样。</li>
<li>安全：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份；Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。</li>
<li>协议：Linux内核所开放源代码受许可协议GPL保护，该协议具有“病毒式感染”的能力，受GPL保护的Linux Kernel是运行在内核空间，对于上层的任何类库、服务、应用等运行在用户空间，一旦进行SysCall（系统调用），调用到底层Kernel，那么也必须遵循GPL协议。Google巧妙地将GPL协议控制在内核空间，将用户空间的协议采用Apache-2.0协议（允许基于Android的开发商不向社区反馈源码），同时在GPL协议与Apache-2.0之间的Lib库中采用BSD证授权方法，有效隔断了GPL的传染性。</li>
</ul>
<p>每种Linux的IPC机制都有存在的价值，同时在Android系统中也依然采用了大量Linux现有的IPC机制，根据每类IPC的原理特性，因时制宜，不同场景特性往往会采用其下最适宜的。比如在Android OS中的Zygote进程的IPC采用的是Socket（套接字）机制，Android中的Kill Process采用的signal（信号）机制等等。而Binder更多则用在system_server进程与上层App层的IPC交互。</p>
<p>binder通信是一种client-server的通信结构，Client、Server和ServiceManager这三者之间的交互关系，如图所示：</p>
<p><img src="IPC-Binder%E5%85%B3%E7%B3%BB.jpg" alt="三者关系"></p>
<ol>
<li>Server进程要先注册一些Service到ServiceManager中，所以Server是ServiceManager的客户端，而ServiceManager就是服务端了。</li>
<li>如果某个Client进程要使用某个Service，必须先到ServiceManager中获取该Service的相关信息，所以Client是ServiceManager的客户端。</li>
<li>Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互了，所以Client也是Server的客户端。</li>
<li>最重要的一点是，三者的交互都是基于Binder通信的</li>
</ol>
<h1 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>传统的Linux通信机制如Socket，管道等都是内核支持的；但是Binder并不是Linux内核的一部分，它是怎么做到访问内核空间的呢？Linux的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p>
<p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动。</p>
<p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；驱动就是操作硬件的接口。</p>
<p>binder驱动作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。如下图：</p>
<p><img src="Binder%E9%A9%B1%E5%8A%A8.jpeg" alt="Binder驱动"></p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><ul>
<li>binder_init：注册初始化字符设备。</li>
<li>binder_open：打开binder驱动设备，创建binder_proc对象，并把当前进程等信息保存到binder_proc对象，该对象管理IPC所需的各种信息并拥有其他结构体链表的头节点，再把binder_proc对象保存到文件指针filp，以及把binder_proc加入到全局链表binder_procs。</li>
<li>binder_mmap：首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的Buffer和内核空间的Buffer同步操作的功能。</li>
<li>binder_ioctl：负责在两个进程间收发IPC数据和IPC reply数据。</li>
</ul>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>先列举一次完整的Binder通信过程：</p>
<p><img src="binder%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.jpg" alt="binder通信协议"></p>
<p>Binder协议包含在IPC数据中，分为两类:</p>
<ul>
<li>BINDER_COMMAND_PROTOCOL：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；</li>
<li>BINDER_RETURN_PROTOCOL ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</li>
</ul>
<p>Binder IPC通信至少是两个进程的交互：</p>
<ul>
<li>client进程执行binder_thread_write，根据BC_XXX命令，生成相应的binder_work；</li>
<li>server进程执行binder_thread_read，根据binder_work.type类型，生成BR_XXX，发送到用户空间处理。</li>
</ul>
<p>Binder通信过程如下：</p>
<p><img src="binder_protocol.jpg" alt="binder_protocol"></p>
<p>其中binder_work.type共有6种类型：</p>
<ul>
<li>BINDER_WORK_TRANSACTION</li>
<li>BINDER_WORK_TRANSACTION_COMPLETE</li>
<li>BINDER_WORK_NODE</li>
<li>BINDER_WORK_DEAD_BINDER</li>
<li>BINDER_WORK_DEAD_BINDER_AND_CLEAR</li>
<li>BINDER_WORK_CLEAR_DEATH_NOTIFICATION</li>
</ul>
<h1 id="Binder内存机制"><a href="#Binder内存机制" class="headerlink" title="Binder内存机制"></a>Binder内存机制</h1><p>Binder进程间通信效率高的最主要原因是Binder的内存机制：虚拟进程地址空间(用户空间)和虚拟内核地址空间(内核空间)都映射到同一块物理内存空间。当Client端与Server端发送数据时，Client（作为数据发送端）先从自己的进程空间把IPC通信数据copy_from_user拷贝到内核空间，而Server端（作为数据接收端）与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可获悉内存地址，整个过程只发生一次内存拷贝。</p>
<p>而一般IPC的做法，需要Client端进程空间拷贝到内核空间，再由内核空间拷贝到Server进程空间，会发生两次拷贝。</p>
<p>对于进程和内核虚拟地址映射到同一个物理内存的操作是发生在数据接收端，而数据发送端还是需要将用户态的数据复制到内核态。</p>
<p>见图解：<a href="https://ljd1996.github.io/2019/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">操作系统-进程与线程</a>。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ServiceManager是一个进程，Server是另一个进程，Binder的实现比较巧妙：ServiceManager和其它进程同样采用Binder通信，ServiceManager是Server端，有自己的Binder对象（实体），其它进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。ServiceManager提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成ServiceManager时Binder驱动会自动为它创建Binder实体。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。</p>
<p>ServiceManager是Binder IPC通信过程中的守护进程，本身也是一个Binder服务，但并没有采用libbinder中的多线程模型来与Binder驱动通信，而是自行编写了binder.c直接和Binder驱动来通信，并且只有一个循环binder_loop来进行读取和处理事务，这样的好处是简单而高效。</p>
<p>ServiceManager本身工作相对简单，其功能：查询和注册服务。</p>
<h2 id="启动ServiceManager"><a href="#启动ServiceManager" class="headerlink" title="启动ServiceManager"></a>启动ServiceManager</h2><p>在Binder通信过程中，其启动的流程图如下：</p>
<p><img src="ServiceManager%E5%90%AF%E5%8A%A8.jpeg" alt="ServiceManager启动"></p>
<center>ServiceManager 启动</center>

<ul>
<li>ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。其所对应的可执行程序/system/bin/servicemanager，所对应的源文件是service_manager.c，进程名为/system/bin/servicemanager。</li>
<li>ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。</li>
</ul>
<h2 id="获取ServiceManager"><a href="#获取ServiceManager" class="headerlink" title="获取ServiceManager"></a>获取ServiceManager</h2><p>获取Service Manager是通过defaultServiceManager()方法来完成，当进程注册服务(addService)或获取服务(getService)之前，都需要先调用defaultServiceManager()方法来获取gDefaultServiceManager对象。对于gDefaultServiceManager对象，如果存在则直接返回；如果不存在则创建该对象，创建过程包括调用open()打开binder驱动设备，利用mmap()映射内核的地址空间。</p>
<p><code>defaultServiceManager()</code> 等价于 <code>new BpServiceManager(new BpBinder(0));</code></p>
<h2 id="addService"><a href="#addService" class="headerlink" title="addService"></a>addService</h2><p>服务注册过程(addService)核心功能：在服务所在进程创建binder_node，在servicemanager进程创建binder_ref。</p>
<ul>
<li>每个进程binder_proc所记录的binder_ref的handle值是从1开始递增的；</li>
<li>所有进程binder_proc所记录的handle=0的binder_ref都指向service manager；</li>
<li>同一个服务的binder_node在不同进程的binder_ref的handle值可以不同；</li>
</ul>
<p>以注册MediaPlayer服务为例，其注册流程如下图：</p>
<p><img src="ServiceManager%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1.jpeg" alt="ServiceManager注册服务"></p>
<center>ServiceManager注册服务</center>

<ul>
<li>通过 ServiceManager 的 addService() 方法来注册MediaPlayerService服务。</li>
<li>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。</li>
<li>Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。</li>
<li>事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。</li>
</ul>
<h2 id="getService"><a href="#getService" class="headerlink" title="getService"></a>getService</h2><p>以获取MediaPlayer服务为例，其获取流程如下图：</p>
<p><img src="ServiceManager%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1.jpeg" alt="ServiceManager获取服务"></p>
<center>ServiceManager获取服务</center>

<ul>
<li>获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。</li>
<li>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。</li>
<li>Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ServiceManager启动流程：</p>
<ol>
<li>打开binder驱动，并调用mmap()方法分配128k的内存映射空间：binder_open();</li>
<li>通知binder驱动使其成为守护进程：binder_become_context_manager()；</li>
<li>验证selinux权限，判断进程是否有权注册或查看指定服务；</li>
<li>进入循环状态，等待Client端的请求：binder_loop()。</li>
<li>注册服务的过程，根据服务名称，但同一个服务已注册，重新注册前会先移除之前的注册信息；</li>
<li>死亡通知: 当binder所在进程死亡后,会调用binder_release方法,然后调用binder_node_release.这个过程便会发出死亡通知的回调.</li>
</ol>
<p>ServiceManager最核心的两个功能为查询和注册服务：</p>
<ul>
<li>注册服务：记录服务名和handle信息，保存到svclist列表；</li>
<li>查询服务：根据服务名查询相应的的handle信息。</li>
</ul>
<h1 id="FrameWork层"><a href="#FrameWork层" class="headerlink" title="FrameWork层"></a>FrameWork层</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>FrameWork层的Binder架构如下：</p>
<p><img src="Binder%E6%9E%B6%E6%9E%84.jpeg" alt="Binder架构"></p>
<ul>
<li>图中红色代表整个framework层 binder架构相关组件；</li>
<li>图中蓝色代表Native层Binder架构相关组件；</li>
<li>上层framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑都是交予Native层方法来处理。</li>
<li>framework层的ServiceManager类与Native层的功能并不完全对应，framework层的ServiceManager类的实现最终是通过BinderProxy传递给Native层来完成的。</li>
</ul>
<p>Binder类图如下：</p>
<p><img src="Binder%E7%B1%BB%E5%9B%BE.jpg" alt="Binder类图"></p>
<ul>
<li>图中浅蓝色都是Interface，其余都是Class；</li>
<li>ServiceManager：通过getIServiceManager方法获取的是ServiceManagerProxy对象；ServiceManager的addService, getService实际工作都交由ServiceManagerProxy的相应方法来处理；</li>
<li>ServiceManagerProxy：其成员变量mRemote指向BinderProxy对象，ServiceManagerProxy的addService, getService方法最终是交由mRemote来完成。</li>
<li>ServiceManagerNative：其方法asInterface()返回的是ServiceManagerProxy对象，ServiceManager便是借助ServiceManagerNative类来找到ServiceManagerProxy；</li>
<li>Binder：其成员变量mObject和方法execTransact()用于native方法</li>
<li>BinderInternal：内部有一个GcWatcher类，用于处理和调试与Binder相关的垃圾回收。</li>
<li>IBinder：接口中常量FLAG_ONEWAY：客户端利用binder跟服务端通信是阻塞式的，但如果设置了FLAG_ONEWAY，这成为非阻塞的调用方式，客户端能立即返回，服务端采用回调方式来通知客户端完成情况。另外IBinder接口有一个内部接口DeathDecipient(死亡通告)。</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>IBinder 是一个接口，它代表了一种跨进程传输的能力。只要实现了这个接口，就能将这个对象进行跨进程传递。它最重要的有这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>code：要执行的动作，类似 Handler 的 msg.what，IBinder 中定义了以下几个 code <ul>
<li>PING_TRANSACTION，表示要调用 pingBinder() 方法</li>
<li>DUMP_TRANSACTION，表示要获取 Binder 内部状态</li>
<li>SHELL_COMMAND_TRANSACTION，执行一个 shell 命令</li>
<li>INTERFACE_TRANSACTION，询问被调用方的接口描述符号</li>
<li>TWEET_TRANSACTION</li>
<li>LIKE_TRANSACTION</li>
<li>如果我们需要自定义 code，code 的值范围需要在 FIRST_CALL_TRANSACTION(0x00000001) 和 LAST_CALL_TRANSACTION(0x00ffffff) 之间</li>
</ul>
</li>
<li>data, reply：传入的参数和返回的值</li>
<li>flags：表示是否需要阻塞等待返回值，有两个值 <ul>
<li>0</li>
<li>FLAG_ONEWAY (0x00000001)，表示 Client 的 transact() 是单向调用，执行后立即返回</li>
</ul>
</li>
</ul>
<p>①经常的场景是，我们调用 IBinder.transact() 给一个 IBinder 对象发送请求，然后经过 Binder Binder.onTransact() 得到调用，接着远程操作的目标得到对应的调用。这个过程不仅在同一进程中可以进行，在跨进程（IPC）间也可以完成。IBinder.transact() 方法是同步的，它被调用后一直到 Binder.onTransact() 调用完成后才返回。</p>
<p>②通过 IBinder.transact() 方法传输的数据被保存为一个 Parcel 对象，Parcel 中保存了数据以及描述数据的元数据，元数据在缓存区中保持了 IBinder 对象的引用，这样不同进程都可以访问同一个数据。因此在一个 IBinder 对象写入 Parcel 对象然后发送到另一个进程时，另外那进程将这个 IBinder 对象发送回去时，原本进程接收到的 IBinder 对象和开始发送出去的是同一个引用。在跨进程传输后引用没有改变，这是非常关键的一点，这就使得 IBinder/Binder 对象在跨进程通信时可以作为唯一的标识（比如作为 token 什么的）。</p>
<p>③系统在每个进程中都有一个处理事物的线程池，这些线程用于调度其他进程对当前进程的跨进程访问。比如说进程 A 对进程 B 发起 IPC 时，A 中调用 transact() 的线程会阻塞。B 中的事物线程池收到 A 的 IPC，调用目标对象的 Binder.onTransact() 方法，然后返回带结果的 Parcel。一旦接收到结果，A 中阻塞的线程得以继续执行。</p>
<p>④Binder 机制还支持进程间的递归调用。比如，进程 A 向进程 B 发起 IPC，而进程 B 在其 Binder.onTransact() 中又用 transact() 向进程 A 发起 IPC，那么进程 A 在等待它发出的调用返回的同时，也会响应 B 的调用，对调用的对象执行 Binder.onTransact() 方法。</p>
<p>⑤在跨进程通信时，我们常常想要知道另外进程是否可用，IBinder 提供了三个检查的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查远程 Binder 对象是否存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当不存在时返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pingBinder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册一个 Binder 销毁的监听</span></span><br><span class="line"><span class="comment">   如果一个 Binder 被销毁（通常是它所在的进程被关闭），会回调 DeathRecipient 的 BinderDied 方法</span></span><br><span class="line"><span class="comment"> * 注意，只会监听远程的 Binder，本地 Binder 一般不会销毁，除非当前进程退出</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果要注册的 Binder 进程已经销毁，就抛出 RemoteException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkToDeath</span><span class="params">(DeathRecipient recipient, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * linkToDeath 注册监听回调的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binder通信流程"><a href="#Binder通信流程" class="headerlink" title="Binder通信流程"></a>Binder通信流程</h1><p><img src="Binder%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.jpeg" alt="Binder通信流程"></p>
<ol>
<li>ServiceManager 初始化 <ol>
<li>当该应用程序启动时，ServiceManager 会和 Binder 驱动进行通信，告诉 Binder 驱动它是服务管理者</li>
<li>Binder 驱动新建 ServiceManager 对应的 Binder 实体</li>
</ol>
</li>
<li>Server 向 ServiceManager 注册自己 <ol>
<li>Server 向 Binder 驱动发起注册请求，Binder 为它创建 Binder 实体</li>
<li>然后如果 ServiceManager 中没有这个 Server 时就添加 Server 名称与 Binder 引用到它的 Binder 引用表</li>
</ol>
</li>
<li>Client 获取远程服务 <ol>
<li>Client 首先会向 Binder 驱动发起获取服务的请求，传递要获取的服务名称</li>
<li>Binder 驱动将该请求转发给 ServiceManager 进程</li>
<li>ServiceManager 查找到 Client 需要的 Server 对应的 Binder 实体的 Binder 引用信息，然后通过 Binder 驱动反馈给 Client</li>
<li>Client 收到 Server 对应的 Binder 引用后，会创建一个 Server 对应的远程服务（即 Server 在当前进程的代理）</li>
</ol>
</li>
<li>Client 通过代理调用 Server <ol>
<li>Client 调用远程服务，远程服务收到 Client 请求之后，会和 Binder 驱动通信</li>
<li>因为远程服务中有 Server 的 Binder 引用信息，因此驱动就能轻易的找到对应的 Server，进而将Client 的请求内容发送 Server</li>
</ol>
</li>
</ol>
<h1 id="实例一：同进程"><a href="#实例一：同进程" class="headerlink" title="实例一：同进程"></a>实例一：同进程</h1><p>不能跨进程，需要使用AIDL等，本质还是Binder。</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service1</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder binder = <span class="keyword">new</span> Binder1();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Binder1</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">"LLL"</span>, <span class="string">"binder"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btn1</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, Service1<span class="class">.<span class="keyword">class</span>), <span class="title">new</span> <span class="title">ServiceConnection</span>() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            ((Service1.Binder1) service).binder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Context.BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实例二：跨进程"><a href="#实例二：跨进程" class="headerlink" title="实例二：跨进程"></a>实例二：跨进程</h1><p>可以跨进程</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder binder = <span class="keyword">new</span> Binder() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, @NonNull Parcel data, @Nullable Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (code == <span class="number">1</span>) &#123;</span><br><span class="line">                String name;</span><br><span class="line">                name = data.readString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reply = Parcel.obtain();</span><br><span class="line">                &#125;</span><br><span class="line">                reply.writeString(name + <span class="string">"-"</span> + name);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Parcel data = Parcel.obtain();</span><br><span class="line">            data.writeString(<span class="string">"hearing"</span>);</span><br><span class="line">            Parcel reply = Parcel.obtain();</span><br><span class="line">            IBinder binder = iBinder;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                binder.transact(<span class="number">1</span>, data, reply, <span class="number">0</span>);</span><br><span class="line">                Log.d(<span class="string">"LLL"</span>, <span class="string">"name = "</span> + reply.readString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                data.recycle();</span><br><span class="line">                reply.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BinderService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unbindService(serviceConnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实例三：Nativie"><a href="#实例三：Nativie" class="headerlink" title="实例三：Nativie"></a>实例三：Nativie</h1><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><ul>
<li>ClientDemo.cpp: 客户端程序</li>
<li>ServerDemo.cpp：服务端程序</li>
<li>IMyService.h：自定义的MyService服务的头文件</li>
<li>IMyService.cpp：自定义的MyService服务</li>
<li>Android.mk：源码build文件</li>
</ul>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IMyService.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取service manager引用</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    <span class="comment">//注册名为"service.myservice"的服务到service manager</span></span><br><span class="line">    sm-&gt;addService(String16(<span class="string">"service.myservice"</span>), <span class="keyword">new</span> BnMyService());</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool(); <span class="comment">//启动线程池</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool(); <span class="comment">//把主线程加入线程池</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将名为”service.myservice”的BnMyService服务添加到ServiceManager，并启动服务</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IMyService.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取service manager引用</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    <span class="comment">//获取名为"service.myservice"的binder接口</span></span><br><span class="line">    sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(<span class="string">"service.myservice"</span>));</span><br><span class="line">    <span class="comment">//将biner对象转换为强引用类型的IMyService</span></span><br><span class="line">    sp&lt;IMyService&gt; cs = interface_cast&lt;IMyService&gt;(binder);</span><br><span class="line">    <span class="comment">//利用binder引用调用远程sayHello()方法</span></span><br><span class="line">    cs-&gt;sayHello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取名为”service.myservice”的服务，再进行类型，最后调用远程方法sayHello()</p>
<h2 id="创建MyService"><a href="#创建MyService" class="headerlink" title="创建MyService"></a>创建MyService</h2><h3 id="IMyService-h"><a href="#IMyService-h" class="headerlink" title="IMyService.h"></a>IMyService.h</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> android</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IMyService</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        DECLARE_META_INTERFACE(MyService); <span class="comment">//使用宏，申明MyService</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//定义方法</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义命令字段</span></span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        HELLO = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申明客户端BpMyService</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BpMyService</span>:</span> <span class="keyword">public</span> BpInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        BpMyService(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申明服务端BnMyService</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BnMyService</span>:</span> <span class="keyword">public</span> BnInterface&lt;IMyService&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能：</p>
<ul>
<li>申明IMyService</li>
<li>申明BpMyService（Binder客户端）</li>
<li>申明BnMyService（Binder的服务端）</li>
</ul>
<h3 id="IMyService-cpp"><a href="#IMyService-cpp" class="headerlink" title="IMyService.cpp"></a>IMyService.cpp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IMyService.h"</span></span></span><br><span class="line"><span class="keyword">namespace</span> android</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用宏，完成MyService定义</span></span><br><span class="line">    IMPLEMENT_META_INTERFACE(MyService, <span class="string">"android.demo.IMyService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    BpMyService::BpMyService(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl) :</span><br><span class="line">            BpInterface&lt;IMyService&gt;(impl) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现客户端sayHello方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BpMyService::sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"BpMyService::sayHello\n"</span>);</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMyService::getInterfaceDescriptor());</span><br><span class="line">        remote()-&gt;transact(HELLO, data, &amp;reply);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get num from BnMyService: %d\n"</span>, reply.readInt32());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端，接收远程消息，处理onTransact方法</span></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">BnMyService::onTransact</span><span class="params">(<span class="keyword">uint_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">            Parcel* reply, <span class="keyword">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> HELLO: &#123;    <span class="comment">//收到HELLO命令的处理流程</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"BnMyService:: got the client hello\n"</span>);</span><br><span class="line">            CHECK_INTERFACE(IMyService, data, reply);</span><br><span class="line">            sayHello();</span><br><span class="line">            reply-&gt;writeInt32(<span class="number">2015</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现服务端sayHello方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BnMyService::sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"BnMyService::sayHello\n"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="native_binder_demo.jpg" alt="native_binder_demo"></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol>
<li>编译生成：利用Android.mk编译上述代码，在Android的源码中，通过mm编译后，可生成两个可执行文件ServerDemo，ClientDemo。</li>
<li>执行：将这两个可执行文件push到手机，然后运行。</li>
</ol>
<h1 id="实例四：Framework"><a href="#实例四：Framework" class="headerlink" title="实例四：Framework"></a>实例四：Framework</h1><h2 id="源码结构-1"><a href="#源码结构-1" class="headerlink" title="源码结构"></a>源码结构</h2><p>Server端：</p>
<ul>
<li>ServerDemo.java：可执行程序</li>
<li>IMyService.java: 定义IMyService接口</li>
<li>MyService.java：定义MyService</li>
</ul>
<p>Client端：</p>
<ul>
<li>ClientDemo.java：可执行程序</li>
<li>IMyService.java: 与Server端完全一致</li>
<li>MyServiceProxy.java：定义MyServiceProxy</li>
</ul>
<p>注意：ServiceManager被@hide隐藏了，在高版本Android机型上，即使通过反射去调用ServiceManager中的方法，也会报错：<code>java.lang.SecurityException</code>。</p>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><h3 id="ServerDemo-java"><a href="#ServerDemo-java" class="headerlink" title="ServerDemo.java"></a>ServerDemo.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyService Start"</span>);</span><br><span class="line">        <span class="comment">//准备Looper循环执行</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="comment">//设置为前台优先级</span></span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        <span class="comment">//注册服务</span></span><br><span class="line">        ServiceManager.addService(<span class="string">"MyService"</span>, <span class="keyword">new</span> MyService());</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IMyService-java"><a href="#IMyService-java" class="headerlink" title="IMyService.java"></a>IMyService.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyService</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.hearing.frameworkBinder.MyServer"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> <span class="keyword">throws</span> RemoteException </span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_say = IBinder.FIRST_CALL_TRANSACTION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyService-java"><a href="#MyService-java" class="headerlink" title="MyService.java"></a>MyService.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IMyService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 将MyService转换为IMyService接口 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMyService <span class="title">asInterface</span><span class="params">( IBinder obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IInterface iInterface = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (((iInterface != <span class="keyword">null</span>) &amp;&amp; (iInterface <span class="keyword">instanceof</span> IMyService)))&#123;</span><br><span class="line">            <span class="keyword">return</span> ((IMyService) iInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 服务端，接收远程消息，处理onTransact方法 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_say: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                String str = data.readString();</span><br><span class="line">                sayHello(str);</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 自定义sayHello()方法 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyService:: Hello, "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><h3 id="ClientDemo-java"><a href="#ClientDemo-java" class="headerlink" title="ClientDemo.java"></a>ClientDemo.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client start"</span>);</span><br><span class="line">        IBinder binder = ServiceManager.getService(<span class="string">"MyService"</span>); <span class="comment">//获取名为"MyService"的服务</span></span><br><span class="line">        IMyService myService = <span class="keyword">new</span> MyServiceProxy(binder); <span class="comment">//创建MyServiceProxy对象</span></span><br><span class="line">        myService.sayHello(<span class="string">"binder"</span>); <span class="comment">//通过MyServiceProxy对象调用接口的方法</span></span><br><span class="line">        System.out.println(<span class="string">"Client end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IMyService-java-1"><a href="#IMyService-java-1" class="headerlink" title="IMyService.java"></a>IMyService.java</h3><p>与Server端的IMyService是一致，基本都是拷贝一份过来。</p>
<h3 id="MyServiceProxy-java"><a href="#MyServiceProxy-java" class="headerlink" title="MyServiceProxy.java"></a>MyServiceProxy.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceProxy</span> <span class="keyword">implements</span> <span class="title">IMyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IBinder mRemote;  <span class="comment">//代表BpBinder</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServiceProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 自定义的sayHello()方法 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Parcel _data = Parcel.obtain();</span><br><span class="line">        Parcel _reply = Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(str);</span><br><span class="line">            mRemote.transact(TRANSACTION_say, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h2><p><img src="MyServer_framework_binder.jpg" alt="MyServer_framework_binder"></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><h2 id="Binder概述"><a href="#Binder概述" class="headerlink" title="Binder概述"></a>Binder概述</h2><ul>
<li>从IPC角度来说：Binder是Android中的一种跨进程通信方式，该通信方式在linux中没有，是Android独有；</li>
<li>从Android Driver层：Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder；</li>
<li>从Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；</li>
<li>从Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；</li>
<li>从Android APP层：Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的 Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</li>
</ul>
<h2 id="Binder进程与线程"><a href="#Binder进程与线程" class="headerlink" title="Binder进程与线程"></a>Binder进程与线程</h2><p><img src="Binder%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png" alt="Binder进程和线程"></p>
<p>对于底层Binder驱动，通过binder_procs链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应，且每个进程有且只有一个ProcessState对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是binder_thread结构体。在binder_proc结构体中通过成员变量<code>rb_root threads</code>，来记录当前进程内所有的binder_thread。</p>
<p>Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。</p>
<h2 id="Binder传输过程"><a href="#Binder传输过程" class="headerlink" title="Binder传输过程"></a>Binder传输过程</h2><p>Binder IPC机制，就是指在进程间传输数据（binder_transaction_data），一次数据的传输，称为事务（binder_transaction）。对于多个不同进程向同一个进程发送事务时，这个同一个进程或线程的事务需要串行执行，在Binder驱动中为binder_proc和binder_thread都有todo队列。</p>
<p>也就是说对于进程间的通信，就是发送端把binder_transaction节点，插入到目标进程或其子线程的todo队列中，等目标进程或线程不断循环地从todo队列中取出数据并进行相应的操作。</p>
<p>在Binder驱动层，每个接收端进程都有一个todo队列，用于保存发送端进程发送过来的binder请求，这类请求可以由接收端进程的任意一个空闲的binder线程处理；接收端进程存在一个或多个binder线程，在每个binder线程里都有一个todo队列，也是用于保存发送端进程发送过来的binder请求，这类请求只能由当前binder线程来处理。binder线程在空闲时进入可中断的休眠状态，当自己的todo队列或所属进程的todo队列有新的请求到来时便会唤醒，如果是由所需进程唤醒的，那么进程会让其中一个线程处理响应的请求，其他线程再次进入休眠状态。</p>
<h2 id="Binder路由"><a href="#Binder路由" class="headerlink" title="Binder路由"></a>Binder路由</h2><p>先来看看Native Binder IPC的两个重量级对象：BpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来。</p>
<ul>
<li>IBinder有一个重要方法queryLocalInterface， 默认返回值为NULL；<ul>
<li>BBinder/BpBinder都没有实现，默认返回NULL；BnInterface重写该方法；</li>
<li>BinderProxy(Java)默认返回NULL；Binder(Java)重写该方法；</li>
</ul>
</li>
<li>IInterface有一个重要方法asBinder；</li>
<li>IInterface子类(服务端)会有一个方法asInterface；</li>
</ul>
<p>Native层通过宏IMPLEMENT_META_INTERFACE来完成asInterface实现和descriptor的赋值过程；</p>
<p>对于Java层跟Native一样，也有完全对应的一套对象和方法:</p>
<ul>
<li>例如ActivityManagerNative， 通过实现asInterface方法，以及其通过其构造函数调用attachInterface()，完成descriptor的赋值过程。</li>
<li>再如AIDL全自动生成asInterface和descriptor赋值过程。</li>
</ul>
<p>同一个进程，请求binder服务，不需要创建binder_ref，BpBinder等这些对象，但是是否需要经过binder call，取决于descriptor是否设置。这就涉及到Java服务在Native层使用，或许Native服务在Java层使用，需要格外注意。</p>
<p><strong>binder的路由原理</strong>：BpBinder发送端，根据handler，在当前binder_proc中，找到相应的binder_ref，由binder_ref再找到目标binder_node实体，由目标binder_node再找到目标进程binder_proc。简单地方式是直接把binder_transaction节点插入到binder_proc的todo队列中，完成传输过程。</p>
<p>对于binder驱动来说应尽可能地把binder_transaction节点插入到目标进程的某个线程的todo队列，效率更高。当binder驱动可以找到合适的线程，就会把binder_transaction节点插入到相应线程的todo队列中，如果找不到合适的线程，就把节点之间插入binder_proc的todo队列。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/18%20SharePreference%20%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/18%20SharePreference%20%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">18 SharePreference 深入原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 15:40:51 / 修改时间：15:41:45" itemprop="dateCreated datePublished" datetime="2020-06-21T15:40:51+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/SharePreference/" itemprop="url" rel="index"><span itemprop="name">SharePreference</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>SharePreference 是Android 系统中的持久化存储工具其基于XML文件(/data/data/<package name>/shared_prefs/目录下面)，一次性将数据读取到内存中，适合单个进程、数据量较小的情况。</p>
<h4 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h4><p>使用SharedPreferences的正确姿势<br>1.1 创建SharedPreferences对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences spf &#x3D; context.getSharedPreferences(&quot;xx&quot;,Context.MODE_PRIVATE);</span><br><span class="line">&#x2F;&#x2F; MODE_PRIVATE，则该配置文件只能被自己的应用程序访问</span><br><span class="line">&#x2F;&#x2F; MODE_WORLD_READABLE，则该配置文件除了自己访问外还可以被其它应该程序读取</span><br><span class="line">&#x2F;&#x2F; MODE_WORLD_WRITEABLE，则该配置文件除了自己访问外还可以被其它应该程序读取和写入</span><br><span class="line">&#x2F;&#x2F; MODE_APPEND，检查文件是否存在，存在就往文件追加内容，否则就创建新文件</span><br></pre></td></tr></table></figure>

<p>1.2 获得SharedPreferences.Editor对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences.Editor editor &#x3D; spf.edit();</span><br><span class="line">editor.putString(key, value);</span><br></pre></td></tr></table></figure>
<p>1.3 插入、删除、查找key-value数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">editor.putString(key, value);</span><br><span class="line">editor.remove(key);</span><br><span class="line">editor.get(key,default-value);</span><br><span class="line">Map&lt;String,?&gt; key_Value&#x3D;(Map&lt;String, ?&gt;)spf.getAll(); </span><br><span class="line">&#x2F;&#x2F; 获取所有保存在对应标识下的数据，并以Map形式返回</span><br></pre></td></tr></table></figure>
<p>1.4 保存key-value数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">editor.apply(); &#x2F;&#x2F; 异步</span><br><span class="line">editor.commit();  &#x2F;&#x2F; 同步</span><br></pre></td></tr></table></figure>

<h4 id="三、原理解析"><a href="#三、原理解析" class="headerlink" title="三、原理解析"></a>三、原理解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *xml对应的SharePreferences是否已经被创建加载，如果没有那么该创建就创建，</span><br><span class="line"> *该加载就加载，在加载之后，要将所有的key-value保存到内幕才能中去</span><br><span class="line"> *&#x2F;</span><br><span class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</span><br><span class="line">    SharedPreferencesImpl sp;</span><br><span class="line">    synchronized (ContextImpl.class) &#123;</span><br><span class="line">        if (sSharedPrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sSharedPrefs &#x3D; new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String packageName &#x3D; getPackageName();</span><br><span class="line">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs &#x3D; sSharedPrefs.get(packageName);</span><br><span class="line">        if (packagePrefs &#x3D;&#x3D; null) &#123;</span><br><span class="line">            packagePrefs &#x3D; new ArrayMap&lt;String, SharedPreferencesImpl&gt;();</span><br><span class="line">            sSharedPrefs.put(packageName, packagePrefs);</span><br><span class="line">        &#125;</span><br><span class="line">        sp &#x3D; packagePrefs.get(name);</span><br><span class="line">        if (sp &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 读取XML文件</span><br><span class="line">            File prefsFile &#x3D; getSharedPrefsFile(name);</span><br><span class="line">            sp &#x3D; new SharedPreferencesImpl(prefsFile, mode);</span><br><span class="line">            &#x2F;&#x2F; 缓存sp对象</span><br><span class="line">            packagePrefs.put(name, sp);</span><br><span class="line">            return sp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;跨进程同步问题,不推荐使用</span><br><span class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) !&#x3D; 0 ||</span><br><span class="line">        getApplicationInfo().targetSdkVersion &lt; </span><br><span class="line">                              android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        &#x2F;&#x2F; If somebody else (some other process) changed the prefs</span><br><span class="line">        &#x2F;&#x2F; file behind our back, we reload it.  This has been the</span><br><span class="line">        &#x2F;&#x2F; historical (if undocumented) behavior.</span><br><span class="line">        sp.startReloadIfChangedUnexpectedly();</span><br><span class="line">    &#125;</span><br><span class="line">    return sp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SharedPreferencesImpl初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数传入file 、mode</span><br><span class="line"> SharedPreferencesImpl(File file, int mode) &#123;</span><br><span class="line">    mFile &#x3D; file;</span><br><span class="line">    mBackupFile &#x3D; makeBackupFile(file);</span><br><span class="line">    mMode &#x3D; mode;</span><br><span class="line">    mLoaded &#x3D; false;</span><br><span class="line">    mMap &#x3D; null;</span><br><span class="line">    startLoadFromDisk();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 加载XML文件到内存中</span><br><span class="line">private void loadFromDiskLocked() &#123;</span><br><span class="line">   ...</span><br><span class="line">    Map map &#x3D; null;</span><br><span class="line">    StructStat stat &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stat &#x3D; Os.stat(mFile.getPath());</span><br><span class="line">        if (mFile.canRead()) &#123;</span><br><span class="line">            BufferedInputStream str &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">    &lt;!--读取xml中配置--&gt;</span><br><span class="line">                str &#x3D; new BufferedInputStream(</span><br><span class="line">                        new FileInputStream(mFile), 16*1024);</span><br><span class="line">                map &#x3D; XmlUtils.readMapXml(str);</span><br><span class="line">            &#125;...</span><br><span class="line">    mLoaded &#x3D; true;</span><br><span class="line">    ...</span><br><span class="line">    &lt;!--唤起其他等待线程--&gt;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><ul>
<li>SharePreferences是Android基于xml实现的一种数据持久化手段</li>
<li>SharePreferences不支持多进程，不适合大数据量存储。</li>
<li>SharePreferences的commit与apply前者同步方法、后者为异步</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/4984f66f9a4b" target="_blank" rel="noopener">1. SharePreference原理及跨进程数据共享的问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/21/17%20Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/17%20Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">17 Android渲染机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-21 11:30:53 / 修改时间：15:14:47" itemprop="dateCreated datePublished" datetime="2020-06-21T11:30:53+08:00">2020-06-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">Android渲染机制</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>优化性能一般从渲染，运算与内存，电量三个方面进行，今天开始说聊一聊Android的渲染机制，我们要知道Android系统每隔16ms就重新绘制一次Activity，也就是说，我们的应用必须在16ms内完成屏幕刷新的全部逻辑操作，即每一帧只能停留16ms，渲染机制说完之后，然后在说如何去优化UI。</p>
<h4 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h4><p>首先屏幕系统主要包括CPU、GPU、屏幕显示器三个部分，CPU（中央处理器）主要负责数据计算，GPU（图像处理器）负责图片渲染，屏幕显示器负责最后的显示。Android中的UI绘制逻辑大概是：CPU负责View树的遍历（measure、layout、draw），然后把计算好的数据交给GPU，告诉GPU在屏幕什么位置如何绘制图形，GPU对数据渲染，渲染好后放到buffer里存起来，交给显示器，显示器负责把buffer里面的数据显示到屏幕上。</p>
<p>Android系统每隔16ms发出<strong>VSYNC信号(1000ms/60=16.66ms)，触发对UI进行渲染</strong>， 如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着计算渲染的大多数操作都必须在16ms内完成。</p>
<img src="/2020/06/21/17%20Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/1836169-d802cafdfb48ce34.png" class="" title="[Drawing with Vsync]">

<p>当CPU和GPU处理时间都很慢，或因为其他的原因，如在主线程中干活太多，那么就会出现如下图这样的状况:</p>
<img src="/2020/06/21/17%20Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/1836169-0e0a92773dcc7035.png" class="" title="[Drawing without Vsync]">

<p>从上图可以看到，CPU和GPU的处理时间因为各种原因都大于一个VSync的间隔（16.6ms），所以在第二个VSync还在处理1区域的绘制时，不可能实现理论上的FPS60，同时也出现了丢帧(SF: Skipped Frame)情况。试想用户盯着同一张图看了32ms而不是16ms，当然很容易察觉出卡顿感，哪怕仅仅出现一次掉帧，用户都会发现动画不是很顺畅，大家在察觉到APP卡顿的时候，可以看看logcat控制台，会有drop frames类似的警告，那么是什么原因导致16ms没能完成绘制的操作呢？</p>
<h4 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h4><p>参考：<a href="https://www.cnblogs.com/dasusu/p/8311324.html" target="_blank" rel="noopener">Android 屏幕刷新机制</a></p>
<h4 id="过度绘制（overdraw）检测"><a href="#过度绘制（overdraw）检测" class="headerlink" title="过度绘制（overdraw）检测"></a>过度绘制（overdraw）检测</h4><img src="/2020/06/21/17%20Android%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/1836169-56ffcb4175ebe337.png" class="" title="[overdraw检测]">

<p>蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况:</p>
<ul>
<li>蓝色： 意味着overdraw 1倍。像素绘制了两次。大片的蓝色还是可以接受的（若整个窗口是蓝色的，可以摆脱一层）。</li>
<li>绿色： 意味着overdraw 2倍。像素绘制了三次。中等大小的绿色区域是可以接受的但你应该尝试优化、减少它们。</li>
<li>淡红： 意味着overdraw 3倍。像素绘制了四次，小范围可以接受。</li>
<li>深红： 意味着overdraw 4倍。像素绘制了五次或者更多。这是错误的，要修复它们。</li>
</ul>
<p>我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。</p>
<h4 id="Overdraw-的处理方案"><a href="#Overdraw-的处理方案" class="headerlink" title="Overdraw 的处理方案"></a>Overdraw 的处理方案</h4><ul>
<li><p>Overdraw 的处理方案一：去掉window的默认背景<br>当我们使用了Android自带的一些主题时，window会被默认添加一个纯色的背景，这个背景是被DecorView持有的。当我们的自定义布局时又添加了一张背景图或者设置背景色，那么DecorView的background此时对我们来说是无用的，但是它会产生一次Overdraw，带来绘制性能损耗。去掉window的背景可以在onCreate()中setContentView()之后调用getWindow().setBackgroundDrawable(null);或者在theme中添加android:windowbackground=”null”；</p>
</li>
<li><p>Overdraw 的处理方案二：去掉其他不必要的背景<br>有时候为了方便会先给Layout设置一个整体的背景，再给子View设置背景，这里也会造成重叠，如果子View宽度mach_parent，可以看到完全覆盖了Layout的一部分，这里就可以通过分别设置背景来减少重绘。再比如如果采用的是selector的背景，将normal状态的color设置为“@android:color/transparent”,也同样可以解决问题。这里只简单举两个例子，我们在开发过程中的一些习惯性思维定式会带来不经意的Overdraw，所以开发过程中我们为某个View或者ViewGroup设置背景的时候，先思考下是否真的有必要，或者思考下这个背景能不能分段设置在子View上，而不是图方便直接设置在根View上。</p>
</li>
<li><p>Overdraw 的处理方案三：clipRect的使用<br>我们可以通过canvas.clipRect()来 帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠 组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。</p>
</li>
<li><p>Overdraw 的处理方案四：ViewStub<br>ViewStub称之为“延迟化加载”，在教多数情况下，程序无需显示ViewStub所指向的布局文件，只有在特定的某些较少条件下，此时ViewStub所指向的布局文件才需要被inflate，且此布局文件直接将当前ViewStub替换掉，具体是通过viewStub.infalte()或viewStub.setVisibility(View.VISIBLE)来完成；</p>
</li>
<li><p>Overdraw 的处理方案五：Merge标签</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/16%20Android%20Context%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/16%20Android%20Context%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">16 Android Context详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-20 22:44:20" itemprop="dateCreated datePublished" datetime="2020-06-20T22:44:20+08:00">2020-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Context/" itemprop="url" rel="index"><span itemprop="name">Context</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Context类结构"><a href="#Context类结构" class="headerlink" title="Context类结构"></a>Context类结构</h4><img src="/2020/06/20/16%20Android%20Context%E8%AF%A6%E8%A7%A3/Context%E7%BB%93%E6%9E%84.png" class="" title="[Context结构]">

<p>问题：一个应用程序中到底有多少个Context呢？</p>
<blockquote>
<p>Context数量 = Activity数量 + Service数量 + 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [Context.java]</span><br><span class="line">public abstract class Context &#123;</span><br><span class="line">    public final String getString(@StringRes int resId) &#123;</span><br><span class="line">        return getResources().getString(resId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void sendBroadcast(Intent intent) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    </span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        if (mBase !&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Base context already set&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mBase &#x3D; base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Context getBaseContext() &#123;</span><br><span class="line">        return mBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        mBase.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">        mBase.sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Intent registerReceiver(</span><br><span class="line">        BroadcastReceiver receiver, IntentFilter filter) &#123;</span><br><span class="line">        return mBase.registerReceiver(receiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void unregisterReceiver(BroadcastReceiver receiver) &#123;</span><br><span class="line">        mBase.unregisterReceiver(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        return mBase.startService(service);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean stopService(Intent name) &#123;</span><br><span class="line">        return mBase.stopService(name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean bindService(Intent service, ServiceConnection conn,</span><br><span class="line">            int flags) &#123;</span><br><span class="line">        return mBase.bindService(service, conn, flags);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void unbindService(ServiceConnection conn) &#123;</span><br><span class="line">        mBase.unbindService(conn);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public Object getSystemService(String name) &#123;</span><br><span class="line">        return mBase.getSystemService(name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Application执行顺序"><a href="#Application执行顺序" class="headerlink" title="Application执行顺序"></a>Application执行顺序</h4><img src="/2020/06/20/16%20Android%20Context%E8%AF%A6%E8%A7%A3/Application%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="" title="[Application方法执行顺序]">

<p>Application中在onCreate()方法里去初始化各种全局的变量数据是一种比较推荐的做法，但是如果你想把初始化的时间点提前到极致，也可以去重写attachBaseContext()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void attachBaseContext(Context base) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 在这里调用Context的方法会崩溃  </span><br><span class="line">        super.attachBaseContext(base);  </span><br><span class="line">        &#x2F;&#x2F; 在这里可以正常调用Context的方法  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/15%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/15%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">15 事件分发流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-20 21:51:51" itemprop="dateCreated datePublished" datetime="2020-06-20T21:51:51+08:00">2020-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">事件分发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="事件传递规则"><a href="#事件传递规则" class="headerlink" title="事件传递规则"></a>事件传递规则</h4><ul>
<li>public boolean dispatchTouchEvent(MotionEvent ev):用来进行事件的分发。如果事件能够传递给当前 View ，一定会调用此方法，返回结果受当前 View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消费当前事件。</li>
<li>public boolean onInterceptTouchEvent(MotionEvent event):用来判断是否拦截某事件，如果当前 View 拦截了某事件，那么在同一事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</li>
<li>public boolean onTouchEvent(MotionEvent event):在 dispatchTouchEvent 方法中调用，用来处理点击事件，返回结果表示是否消费当前事件，如果不消费，则在同一个事件序列中，当前 View 无法再次接收到事件。</li>
</ul>
<h4 id="事件传递顺序"><a href="#事件传递顺序" class="headerlink" title="事件传递顺序"></a>事件传递顺序</h4><p>顺序： Activity –&gt; ViewGroup –&gt; View</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [Activity.java]</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() &#x3D;&#x3D; MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空方法</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 事件交给 Activity 所属的 Window 进行分发，返回 true 事件结束</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果没有 View 处理事件，调用 Activity 的 onTouchEvent</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 空方法</span><br><span class="line">public void onUserInteraction() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用了getWindow().suerDispatchTouchEvent()方法，我们分析过Activity的加载绘制流程，而这里的getWindow()就是返回Activity中的mWindow对象，而我们知道Activity中的mWindow对象就是一个PhoneWindow的实例。并且这里的window.superDispatchTouchEvent若返回值为ture，则直接返回true，否则的话会执行Activity的onTouchEvent方法，继续我们看一下PhoneWindow的superDispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [PhoneWindow.java]</span><br><span class="line">public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    return mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在PhoneWindow中的superDispatchTouchEvent方法中调用的是mDecor.superDispatchTouchEvent方法，而这里的mDecor是我们Activity显示的ViewTree的根View，并且mDecor是一个FrameLayout的子类，所以这里我们看一下mDecor的superDispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private final class DecorView extends FrameLayout implements RootViewSurfaceTaker&#123;</span><br><span class="line">	...</span><br><span class="line">	public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return super.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DecorView的superDispatchTouchEvent方法中我们调用了super.dispatchTouchEvent方法，而我们的DecorView继承于FrameLayout，但是经过查看之后我们知道FrameLayout中并没有实现dispatchTouchEvent方法，而由于我们的FrameLayout继承于ViewGroup，所以这里的dispatchTouchEvent方法应该就是ViewGroup的dispatchTouchEvent方法。</p>
<p>好了，这里先暂时说一下Acitivty中的事件分发流程</p>
<ul>
<li>ViewRootImpl层的事件分发会首先调用Activity的dispatchTouchEvent方法；</li>
<li>Activity的dispatchTouchEvent方法中会通过Window.superDispatchTouchEvent方法将事件传递给DecorView即ViewGroup。</li>
<li>若window的superDispatchTouchEvent方法返回true，则事件分发完成，Activity的dispatchTouchEvent直接返回为true，否则的话调用Activity的onTouchEvent方法，并且Acitivty的dispatchTouchEvent返回值与Activity的onTouchEvent返回值一致。</li>
</ul>
<p>下面我们在继续看一下ViewGroup的dispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    final boolean intercepted;</span><br><span class="line">    &#x2F;&#x2F; Step 1 判断按下或者mFirstTouchTarget</span><br><span class="line">    if (actionMasked &#x3D;&#x3D; MotionEvent.ACTION_DOWN || mFirstTouchTarget !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; Step 2 判断 mGroupFlags 和 FLAG_DISALLOW_INTERCEPT</span><br><span class="line">        final boolean disallowIntercept &#x3D; (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) !&#x3D; 0;</span><br><span class="line">        if (!disallowIntercept) &#123;</span><br><span class="line">            intercepted &#x3D; onInterceptTouchEvent(ev);</span><br><span class="line">            ev.setAction(action); &#x2F;&#x2F; restore action in case it was changed</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            intercepted &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 没有触摸目标且不是最初的按下事件，所以</span><br><span class="line">        &#x2F;&#x2F; 该 ViewGroup 继续处理事件</span><br><span class="line">        intercepted &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们知道触摸事件是由一个触摸按下事件，一个触摸抬起事件和N个触摸滑动事件组成的，而这里的触摸按下事件就是这里的ACTION_DOWN，同时友谊ACTION_DOWN是一系列事件的开端，所以我们在ACTION_DOWN时进行一些初始化操作，从上面源码中注释也可以看出来，清除以往的Touch状态然后开始新的手势。并在在cancelAndClearTouchTargets(ev)方法中将mFirstTouchTarget设置为了null，接着在resetTouchState()方法中重置Touch状态标识。</p>
<p>然后标记ViewGroup是否拦截Touch事件的传递，if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)这一条判断语句说明当事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立，否则if不成立，然后将intercepted设置为true，也即拦截事件。这里说明一下ViewGroup中的onInterceptTouchEvent方法是ViewGroup中特有的方法用于表示是否拦截触摸事件，返回为true的话则表示拦截事件，事件不在向子View中分发，若范围为false的话，则表示不拦截事件，继续分发事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般的我们可以在自定义的ViewGroup中重写该方法，用于拦截事件的分发。而当我们在父ViewGroup重写该方法返回为true执行事件拦截的逻辑的时候，可以在子View中通过调用requestDisallowInterceptTouchEvent方法，重新设置父ViewGroup的onInterceptTouchEvent方法为false，不拦截对事件的分发逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123;</span><br><span class="line">    if (disallowIntercept &#x3D;&#x3D; ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) !&#x3D; 0)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (disallowIntercept) &#123;</span><br><span class="line">        mGroupFlags |&#x3D; FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mGroupFlags &amp;&#x3D; ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mParent !&#x3D; null) &#123;</span><br><span class="line">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如常见的向我们的ViewPager中由于需要处理左右滑动事件从而在其onInterceptTouchEvent方法中重写了返回值，返回为true，拦截对事件的处理逻辑，但是若这时候ViewPager中嵌套了ListView，则listView也需要处理触摸事件的逻辑，但是ViewPager中已经重写了onInterceptTouchEvent方法，这时候怎么办呢？幸运的是ListView也在内部的实现中调用了requestDisallowInterceptTouchEvent方法，保证自身获得对触摸事件的处理。</p>
<p>然后在代码中我们判断childrenCount个数是否不为0，继续我们获取子View的list集合preorderedList；最后通过一个for循环倒序遍历所有的子view，这是因为preorderedList中的顺序是按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会因为Android的UI后刷新机制显示在上层；假如点击的地方有两个子View都包含的点击的坐标，那么后被添加到布局中的那个子view会先响应事件；也就是说后被添加的子view会浮在上层，点击的时候最上层的那个组件先去响应事件。</p>
<p>然后代码通过调用getTouchTarget去查找当前子View是否在mFirstTouchTarget.next这条target链中的某一个targe中，如果在则返回这个target，否则返回null。在这段代码的if判断通过说明找到了接收Touch事件的子View，即newTouchTarget，那么，既然已经找到了，所以执行break跳出for循环。如果没有break则继续向下执行，这里你可以看见一段if判断的代码if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))，那么这个方法又是执行什么逻辑的呢？</p>
<p>在该方法中为一个递归调用，会递归调用dispatchTouchEvent()方法。在dispatchTouchEvent()中如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()，如果子View为View那么就会调用其onTouchEvent()。dispatchTransformedTouchEvent方法如果返回true则表示子View消费掉该事件。</p>
<p>但这里大概分析了一下ViewGroup的事件分发流程</p>
<ul>
<li>首先在android的事件分发流程中，通过调用Activity的dispatchTouchEvent，事件会首先被派发是先传递到最顶级的DecorView也就是ViewGroup，再由ViewGroup递归传递到View的。</li>
<li>在ViewGroup中可以通过设置onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。</li>
</ul>
<p>下面我们继续看一下View的dispatchTouchEvent方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">        if (li !&#x3D; null &amp;&amp; li.mOnTouchListener !&#x3D; null</span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) &#x3D;&#x3D; ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">            result &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View的dispatchTouchEvent方法的内容比较长，我们重点看一下View对触摸事件的处理逻辑，首先调用了onFilterTouchEventForSecurity(event)方法判断当前的View是否被遮盖，若没有的话，则判断View的mListenerInfo城边变量是否为空，而这里的mListenerInfo又是什么呢？通过分析源码我们知道这里的mListenerInfo是通过setOnClickListener方法设置的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void setOnClickListener(@Nullable OnClickListener l) &#123;</span><br><span class="line">    if (!isClickable()) &#123;</span><br><span class="line">        setClickable(true);</span><br><span class="line">    &#125;</span><br><span class="line">    setListenerInfo().mOnClickListener &#x3D; l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以当前View一旦执行了setOnClickListener方法改View的mListenerInfo就不为空，若后有判断了该View是否可点击，最后是判断View的onTouchListener的onTouch方法的返回值。</p>
<p>所以当我们为当前View设置了OnTouchListener并且返回值为true的话，则直接执行其onTouch方法，若onTouch方法返回为true的话，则直接返回不在执行后续的View的onTouchEvent方法，否则继续执行View的onTouchEvent方法，而我们继续看一下View的onTouchEvent方法的实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    final float x &#x3D; event.getX();</span><br><span class="line">    final float y &#x3D; event.getY();</span><br><span class="line">    final int viewFlags &#x3D; mViewFlags;</span><br><span class="line">    final int action &#x3D; event.getAction();</span><br><span class="line"></span><br><span class="line">    if (((viewFlags &amp; CLICKABLE) &#x3D;&#x3D; CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) &#x3D;&#x3D; LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) &#x3D;&#x3D; CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        switch (action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                if (mPerformClick &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    mPerformClick &#x3D; new PerformClick();</span><br><span class="line">                &#125;</span><br><span class="line">                if (!post(mPerformClick)) &#123;</span><br><span class="line">                    performClick();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                ...</span><br><span class="line">            case MotionEvent.ACTION_CANCEL:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ACTION为MotionEvent.ACTION_UP时，我们经过层层调用最终执行了performClick，方法而这个方法中我们回调了View的OnClickListener的onClick方法。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean performClick() &#123;</span><br><span class="line">    final boolean result;</span><br><span class="line">    final ListenerInfo li &#x3D; mListenerInfo;</span><br><span class="line">    if (li !&#x3D; null &amp;&amp; li.mOnClickListener !&#x3D; null) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        &#x2F;&#x2F; 回调OnClickListener的onClick函数</span><br><span class="line">        li.mOnClickListener.onClick(this);</span><br><span class="line">        result &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以View组件分发触摸事件的时候：</p>
<ul>
<li>View控件会首先执行dispatchTouchEvent方法。</li>
<li>View控件在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法。</li>
<li>View的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调运onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。</li>
<li>View控件不是enable的，那么即使设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。</li>
<li>如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。</li>
</ul>
<p>参考：<br><a href="http://blog.csdn.net/xiaanming/article/details/21696315" target="_blank" rel="noopener">http://blog.csdn.net/xiaanming/article/details/21696315</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9097463" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9097463</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9153747" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9153747</a><br><a href="https://blog.csdn.net/suyimin2010/article/details/80958205" target="_blank" rel="noopener">https://blog.csdn.net/suyimin2010/article/details/80958205</a><br><a href="https://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">https://www.jianshu.com/p/e99b5e8bd67b</a><br><a href="https://juejin.im/entry/580042082e958a0055b6cbbc" target="_blank" rel="noopener">https://juejin.im/entry/580042082e958a0055b6cbbc</a><br><a href="https://juejin.im/entry/5928bfa92f301e0057d4f414" target="_blank" rel="noopener">解决 Android View 滑动冲突</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/14%20Android%20View%E7%BB%98%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/14%20Android%20View%E7%BB%98%E5%88%B6/" class="post-title-link" itemprop="url">14 Android View绘制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-20 18:55:10" itemprop="dateCreated datePublished" datetime="2020-06-20T18:55:10+08:00">2020-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/View%E7%BB%98%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">View绘制</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="View绘制的三个流程"><a href="#View绘制的三个流程" class="headerlink" title="View绘制的三个流程"></a>View绘制的三个流程</h4><p>在自定义View的时候一般需要重写父类的onMeasure()、onLayout()、onDraw()三个方法，来完成视图的展示过程</p>
<ul>
<li>measure：测量。系统会先根据xml布局文件和代码中对控件属性的设置，来获取或者计算出每个View和ViewGrop的尺寸，并将这些尺寸保存下来。</li>
<li>layout：布局。根据测量出的结果以及对应的参数，来确定每一个控件应该显示的位置。</li>
<li>draw：绘制。确定好位置后，就将这些控件绘制到屏幕上。</li>
</ul>
<h4 id="Android-View层级结构"><a href="#Android-View层级结构" class="headerlink" title="Android View层级结构"></a>Android View层级结构</h4><img src="/2020/06/20/14%20Android%20View%E7%BB%98%E5%88%B6/6770217-5222a036101c3a37.png" class="" title="[Android View层级结构]">

<p>PhoneWindow 是 Android 系统中最基本的窗口系统，每个 Activity 会创建一个。PhoneWindow 是 Activity 和 View 系统交互的借口。DecorView 本质上是一个 FrameLayout，是 Activity 中所有 View 的祖先。</p>
<h4 id="View绘制源码"><a href="#View绘制源码" class="headerlink" title="View绘制源码"></a>View绘制源码</h4><h5 id="1-View绘制起点"><a href="#1-View绘制起点" class="headerlink" title="1. View绘制起点"></a>1. View绘制起点</h5><img src="/2020/06/20/14%20Android%20View%E7%BB%98%E5%88%B6/View%E7%BB%98%E5%88%B6%E8%B5%B7%E5%A7%8B%E7%82%B9.png" class="" title="[View绘制起始点]">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [ActivityThread.java]</span><br><span class="line">public void handleResumeActivity(IBinder token, boolean finalStateRequest, </span><br><span class="line">    boolean isForward, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; r.window就是PhoneWindow对象</span><br><span class="line">    r.window &#x3D; r.activity.getWindow();</span><br><span class="line">    View decor &#x3D; r.window.getDecorView();</span><br><span class="line">    decor.setVisibility(View.INVISIBLE);</span><br><span class="line">    &#x2F;&#x2F; a.getWindowManager()返回WindowManagerImpl对象</span><br><span class="line">    ViewManager wm &#x3D; a.getWindowManager();</span><br><span class="line">    wm.addView(decor, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ViewManager.java]</span><br><span class="line">public interface ViewManager&#123;</span><br><span class="line">    public void addView(View view, ViewGroup.LayoutParams params);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [WindowManager.java]</span><br><span class="line">public interface WindowManager extends ViewManager &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [WindowManagerImpl.java]</span><br><span class="line">public final class WindowManagerImpl implements WindowManager &#123;</span><br><span class="line">    private final WindowManagerGlobal mGlobal &#x3D; WindowManagerGlobal.getInstance();</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [WindowManagerGlobal.java]</span><br><span class="line">public final class WindowManagerGlobal &#123;</span><br><span class="line">    public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow) &#123;</span><br><span class="line">        ViewRootImpl root &#x3D; new ViewRootImpl(view.getContext(), display);    </span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [ViewRootImpl.java]</span><br><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">    requestLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void requestLayout() &#123;</span><br><span class="line">    if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested &#x3D; true;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final TraversalRunnable mTraversalRunnable &#x3D; new TraversalRunnable();</span><br><span class="line"></span><br><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">    if (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 插入同步屏障</span><br><span class="line">        mTraversalBarrier &#x3D; mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">        if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void doTraversal() &#123;</span><br><span class="line">    performTraversals();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void performTraversals() &#123;</span><br><span class="line">    int childWidthMeasureSpec &#x3D; getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">    int childHeightMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 其实就是设置为屏幕的宽高</span><br><span class="line">private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</span><br><span class="line">    int measureSpec;</span><br><span class="line">    switch (rootDimension) &#123;</span><br><span class="line">    case ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        break;</span><br><span class="line">    case ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        measureSpec &#x3D; MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>performMeasure()：从根节点向下遍历View树，完成所有ViewGroup和View的测量工作，计算出所有ViewGroup和View显示出来需要的高度和宽度；</li>
<li>performLayout()：从根节点向下遍历View树，完成所有ViewGroup和View的布局计算工作，根据测量出来的宽高及自身属性，计算出所有ViewGroup和View显示在屏幕上的区域；</li>
<li>performDraw()：从根节点向下遍历View树，完成所有ViewGroup和View的绘制工作，根据布局过程计算出的显示区域，将所有View的当前需显示的内容画到屏幕上。</li>
</ul>
<h5 id="MeasureSpec、ViewGroup-LayoutParams-简介"><a href="#MeasureSpec、ViewGroup-LayoutParams-简介" class="headerlink" title="MeasureSpec、ViewGroup.LayoutParams 简介"></a>MeasureSpec、ViewGroup.LayoutParams 简介</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [View.java]</span><br><span class="line">public static class MeasureSpec &#123;</span><br><span class="line">    private static final int MODE_SHIFT &#x3D; 30;</span><br><span class="line">    private static final int MODE_MASK  &#x3D; 0x3 &lt;&lt; MODE_SHIFT;</span><br><span class="line">    &#x2F;&#x2F; UNSPECIFIED：未指定尺寸模式。父布局没有对子view强加任何限制。它可以是任意想要的尺寸。</span><br><span class="line">    public static final int UNSPECIFIED &#x3D; 0 &lt;&lt; MODE_SHIFT;</span><br><span class="line">    &#x2F;&#x2F; EXACTLY：精确值模式。父布局决定了子view的准确尺寸。</span><br><span class="line">    public static final int EXACTLY     &#x3D; 1 &lt;&lt; MODE_SHIFT;</span><br><span class="line">    &#x2F;&#x2F; AT_MOST：最大值模式。子view可以一直大到指定的值。</span><br><span class="line">    public static final int AT_MOST     &#x3D; 2 &lt;&lt; MODE_SHIFT;</span><br><span class="line">    </span><br><span class="line">    @IntDef(&#123;UNSPECIFIED, EXACTLY, AT_MOST&#125;)</span><br><span class="line">    @Retention(RetentionPolicy.SOURCE)</span><br><span class="line">    public @interface MeasureSpecMode &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static int getMode(int measureSpec) &#123;</span><br><span class="line">        return (measureSpec &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int getSize(int measureSpec) &#123;</span><br><span class="line">        return (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int makeMeasureSpec(@IntRange(from &#x3D; 0, to &#x3D; (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,</span><br><span class="line">                @MeasureSpecMode int mode) &#123;</span><br><span class="line">        if (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">            return size + mode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个MeasureSpec的模式int长度为32位置，高2位表示mode，后30位用于表示size。</p>
<ul>
<li>精确模式（MeasureSpec.EXACTLY）：在这种模式下，尺寸的值是多少，那么这个组件的长或宽就是多少，对应 MATCH_PARENT 和确定的值。</li>
<li>最大模式（MeasureSpec.AT_MOST）：这个也就是父组件，能够给出的最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。对应 WRAP_CONETNT。</li>
<li>未指定模式（MeasureSpec.UNSPECIFIED）：这个就是说，当前组件，可以随便用空间，不受限制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; [ViewGroup.java]</span><br><span class="line">public static class LayoutParams &#123;</span><br><span class="line">    public static final int MATCH_PARENT &#x3D; -1;</span><br><span class="line">    public static final int WRAP_CONTENT &#x3D; -2;</span><br><span class="line">    public int height;</span><br><span class="line">    public int width;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-performMeasure流程"><a href="#2-performMeasure流程" class="headerlink" title="2. performMeasure流程"></a>2. performMeasure流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 【ViewGroup的测量过程】</span><br><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">    &#x2F;&#x2F; mView 其实就是DecorView对象</span><br><span class="line">    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [DecorView.java]</span><br><span class="line">public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123;</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [FrameLayout.java]</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    int count &#x3D; getChildCount();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child &#x3D; getChildAt(i);</span><br><span class="line">        if (mMeasureAllChildren || child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">            childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">    int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">    int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">    final MarginLayoutParams lp &#x3D; (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    final int childWidthMeasureSpec &#x3D; getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">            + widthUsed, lp.width);</span><br><span class="line">    final int childHeightMeasureSpec &#x3D; getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">            + heightUsed, lp.height);</span><br><span class="line">    </span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ----------------------------------------------------------------------</span><br><span class="line">&#x2F;&#x2F; 【普通View的测量过程】</span><br><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int getSuggestedMinimumWidth() &#123;</span><br><span class="line">    return (mBackground &#x3D;&#x3D; null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int getSuggestedMinimumHeight() &#123;</span><br><span class="line">    return (mBackground &#x3D;&#x3D; null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</span><br><span class="line">    int result &#x3D; size;</span><br><span class="line">    int specMode &#x3D; MeasureSpec.getMode(measureSpec);</span><br><span class="line">    int specSize &#x3D; MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果父布局没有施加任何限制，即MeasureSpec的mode为UNSPECIFIED，那么返回值为参数中提供的size值。</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result &#x3D; size;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;&#x2F; 如果父布局施加了限制，则返回的默认尺寸为保存在参数measureSpec中的specSize值。    </span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            result &#x3D; specSize;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; measuredWidth：该view被测量出宽度值, measuredHeight：该view被测量出的高度值</span><br><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    mMeasuredWidth &#x3D; measuredWidth;</span><br><span class="line">    mMeasuredHeight &#x3D; measuredHeight;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  获取原始的测量宽度值，一般会拿这个方法和layout执行后getWidth()方法做比较。</span><br><span class="line">&#x2F;&#x2F; 该方法需要在setMeasuredDimension()方法执行后才有效，否则返回值为0。</span><br><span class="line">public final int getMeasuredWidth() &#123;</span><br><span class="line">   return mMeasuredWidth &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br><span class="line">public final int getMeasuredHeight() &#123;</span><br><span class="line">   return mMeasuredHeight &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-performLayout流程"><a href="#3-performLayout流程" class="headerlink" title="3. performLayout流程"></a>3. performLayout流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">    int desiredWindowHeight) &#123;</span><br><span class="line">    &#x2F;&#x2F; mView就是DecorView</span><br><span class="line">    final View host &#x3D; mView;</span><br><span class="line">    &#x2F;&#x2F; 其实是调用ViewGroup的layout方法</span><br><span class="line">    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">    super.layout(l, t, r, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">    onLayout(changed, l, t, r, b);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [FrameLayout.java]</span><br><span class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, false &#x2F;* no force left gravity *&#x2F;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">    final int count &#x3D; getChildCount();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child &#x3D; getChildAt(i);</span><br><span class="line">        if (child.getVisibility() !&#x3D; GONE) &#123;</span><br><span class="line">            final LayoutParams lp &#x3D; (LayoutParams) child.getLayoutParams();</span><br><span class="line">            final int width &#x3D; child.getMeasuredWidth();</span><br><span class="line">            final int height &#x3D; child.getMeasuredHeight();</span><br><span class="line">            int childLeft;</span><br><span class="line">            int childTop;</span><br><span class="line">            int gravity &#x3D; lp.gravity;</span><br><span class="line">            if (gravity &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                gravity &#x3D; DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line">            final int layoutDirection &#x3D; getLayoutDirection();</span><br><span class="line">            final int absoluteGravity &#x3D; Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            final int verticalGravity &#x3D; gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft &#x3D; parentLeft + (parentRight - parentLeft - width) &#x2F; 2 +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.RIGHT:</span><br><span class="line">                    if (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft &#x3D; parentRight - width - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Gravity.LEFT:</span><br><span class="line">                    default:</span><br><span class="line">                        childLeft &#x3D; parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            switch (verticalGravity) &#123;</span><br><span class="line">                case Gravity.TOP:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop &#x3D; parentTop + (parentBottom - parentTop - height) &#x2F; 2 +</span><br><span class="line">                        lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.BOTTOM:</span><br><span class="line">                    childTop &#x3D; parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    childTop &#x3D; parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-performDraw流程"><a href="#4-performDraw流程" class="headerlink" title="4. performDraw流程"></a>4. performDraw流程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void performDraw() &#123;</span><br><span class="line">    boolean canUseAsync &#x3D; draw(fullRedrawNeeded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">    if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">        scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">         return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">            boolean scalingRequired, Rect dirty, Rect surfaceInsets) &#123;</span><br><span class="line">    mView.draw(canvas);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">    super.draw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [View.java]</span><br><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">    drawBackground(canvas);</span><br><span class="line">    if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">    drawDefaultFocusHighlight(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [ViewGroup.java]</span><br><span class="line">protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">    final int childrenCount &#x3D; mChildrenCount;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;</span><br><span class="line">    return child.draw(canvas, this, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延申阅读<br><a href="https://www.cnblogs.com/dasusu/p/8311324.html" target="_blank" rel="noopener">1. Android 屏幕刷新机制</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/20/13%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/13%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">13 activity启动流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-20 15:54:17" itemprop="dateCreated datePublished" datetime="2020-06-20T15:54:17+08:00">2020-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Activity启动流程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h4><img src="/2020/06/20/13%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/12239817-57bb34bbf201853d.png" class="" title="[Activity的生命周期]">

<table>
<thead>
<tr>
<th>方法</th>
<th align="right">描述</th>
<th align="center">用途（以当前界面播放视频为例）</th>
<th align="center">下一个方法</th>
</tr>
</thead>
<tbody><tr>
<td>onCreate()</td>
<td align="right">当Activity第一次创建时调用。该方法（如果有）会提供给你一个包含之前活动的冻结状态信息bundle包。</td>
<td align="center">进行一系列初始化操作，如：创建View，加载视频数据等。</td>
<td align="center">onStart()</td>
</tr>
<tr>
<td>onRestart()</td>
<td align="right">当Activity被停止后调用，在重新开始之前</td>
<td align="center">当活动停止后重新启动该活动时调用（不常用），针对停止后重启操作。</td>
<td align="center">onStart()</td>
</tr>
<tr>
<td>onStart()</td>
<td align="right">当Activity被展示在用户眼前时调用。如果活动出现在前台紧接着是onResume()，如果活动直接隐藏则紧接着是onStop()。</td>
<td align="center">该方法也不常用。</td>
<td align="center">onResume() or onStop()</td>
</tr>
<tr>
<td>onResume()</td>
<td align="right">当Activity将开始与用户进行交互时调用。在这个时间点你的活动将会在活动堆栈的顶端，用户输入将会访问它。</td>
<td align="center">暂停后恢复我们会在该方法中进行一些操作，例如视频继续播放。</td>
<td align="center">onPause()</td>
</tr>
<tr>
<td>onPause()</td>
<td align="right">当系统将要恢复一个之前的活动。这是一个有代表性的常常用于提交未被存储的改动信息为持久数据，停止动画和消耗CPU的东西等。实现该方法必须要特别的迅速，因为在此方法返回之前，下一个活动将不会恢复。如果活动将返回到前台则接下来调用onResume()，如果要隐藏到用户看不见的地方时，则调用onStop();</td>
<td align="center">该方法十分重要，用来做信息持久化存储操作以及停止消耗CPU资源操作，如记录视频播放进度时间，以及暂停视频播放操作等。</td>
<td align="center">onResume or onStop()</td>
</tr>
<tr>
<td>onStop()</td>
<td align="right">当另一个活动被恢复且完全覆盖该活动，而该Activity将不在展示给用户时调用。这种情况将发生在一个新的活动将被开始，一个退出的活动将被恢复，又或者该活动将要被销毁。如果该活动将恢复与用户交互则调用onRestart(),如果该活动将被销毁则调用onDestory()。</td>
<td align="center">界面将会隐藏或销毁，做一些重要信息或未被存储的信息的存储操作。但也不要太耗时。如存储用户信息等操作，以及用户此次观看的视频地址以及时间，便于下次打开该界面时继续</td>
<td align="center">onRestart() or onResume()</td>
</tr>
<tr>
<td>onDestory()</td>
<td align="right">Activity被销毁钱最后一个被调用的方法。这个方法将会发生因为活动将会结束（在活动中调用finish()方法，或者系统临时销毁该实例节约空间。你可以使用isFinishing()方法区别这两种场景）。</td>
<td align="center">界面将要销毁，释放一些实例节约空间，如置空List集合等。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h4><h5 id="1-启动模式的类别"><a href="#1-启动模式的类别" class="headerlink" title="1. 启动模式的类别"></a>1. 启动模式的类别</h5><ul>
<li>标准模式（standard）</li>
<li>栈顶复用模式（singleTop）</li>
<li>栈内复用模式（singleTask）</li>
<li>单例模式（singleInstance）</li>
</ul>
<h5 id="2-四种启动模式的解释"><a href="#2-四种启动模式的解释" class="headerlink" title="2. 四种启动模式的解释"></a>2. 四种启动模式的解释</h5><ul>
<li>standard:在清单文件中声明 Activity 时，如果不设置Activity的启动模式，系统会 默认 将其设置为standard。每次启动一个标准模式的Activity都会重新创建一个新的实例，不管这个Activity之前是否已经存在实例</li>
<li>singleTop:在这种模式下，如果新启动的Activity已经位于任务战的栈顶，那么此Activity不会被重新创建，只会重新调用 onNewIntent 方法，这个Activity的onCreate、onStart都不会被系统调用。如果新Activity实例已经存在但不在栈顶，那么重新创建 Activity 并放入栈顶。</li>
<li>singleTask:这是一种单实例模式，一个栈中同一个Activity只存在唯一一个实例，无论是否在栈顶，只要存在实例，都不会重新创建，和 singleTop 一样会重新调用 onNewIntent 方法。需要注意的是：如果一个Activity被设置为singleTask模式，那么当栈内已经存在该Activity实例时，再启动该Activity，会让该Activity实例之上的Activity被出栈。</li>
<li>singleInstance:这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是此种模式的Activity只能单独地位于一个任务栈中，不同的应用去打开这个activity 共享公用的同一个activity。他会运行在自己单独，独立的任务栈里面，并且任务栈里面只有他一个实例存在。</li>
</ul>
<h4 id="Activity的启动流程"><a href="#Activity的启动流程" class="headerlink" title="Activity的启动流程"></a>Activity的启动流程</h4><img src="/2020/06/20/13%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/20190610223539273.jpg" class="" title="[Activity的启动流程]">

<p>在前面”11 应用进程启动流程”的章节里面已经初步介绍了Activityy与AMS之间的进程通讯，下面我们从AMS的startActivity开始往下走。</p>
<h5 id="1-AMS到ApplicationThread的调用过程"><a href="#1-AMS到ApplicationThread的调用过程" class="headerlink" title="1. AMS到ApplicationThread的调用过程"></a>1. AMS到ApplicationThread的调用过程</h5><img src="/2020/06/20/13%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/AMS%E5%88%B0ApplicationThread%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" class="" title="[AMS到ApplicationThread的调用过程]">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">public final int startActivity(IApplicationThread caller, String callingPackage,</span><br><span class="line">         Intent intent, String resolvedType, IBinder resultTo, String resultWho, </span><br><span class="line">         int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123;</span><br><span class="line">	return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">    &#x2F;&#x2F; UserHandle.getCallingUserId(),这个方法会获得调用者的UserId, AMS根据这个UserId来确定调用者的权限        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final int startActivityAsUser(IApplicationThread caller, String callingPackage,</span><br><span class="line">       Intent intent, String resolvedType, IBinder resultTo, String resultWho, </span><br><span class="line">       int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, </span><br><span class="line">       int userId) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 判断调用者进程是否隔离，如果没被隔离则抛出SecurityException异常</span><br><span class="line">    enforceNotIsolatedCaller(&quot;startActivity&quot;);</span><br><span class="line">    &#x2F;&#x2F; 2. 检查调用者的权限</span><br><span class="line">    userId &#x3D; mUserController.handleIncomingUser(Binder.getCallingPid(),</span><br><span class="line">             Binder.getCallingUid(),userId, false, ALLOW_FULL_ONLY, </span><br><span class="line">             &quot;startActivity&quot;, null);</span><br><span class="line">    &#x2F;&#x2F; 3. 倒数第二个参数类型为TaskRecord，代表启动的Activity所在的栈，最后一个参数&quot;startActivityAsUser&quot;代表启动的理由         </span><br><span class="line">	return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,</span><br><span class="line">	       resolvedType, null,null, resultTo, resultWho,requestCode,startFlags,</span><br><span class="line">	       profilerInfo,null,null, bOptions, false, userId, null,</span><br><span class="line">	       null,&quot;startActivityAsUser&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int startActivityMayWait(IApplicationThread caller, int callingUid,</span><br><span class="line">            String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            IBinder resultTo, String resultWho, int requestCode, int startFlags,</span><br><span class="line">            ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">            Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, 	</span><br><span class="line">            int userId,IActivityContainer iContainer, TaskRecord inTask, String reason) &#123;</span><br><span class="line">	...</span><br><span class="line">    int res &#x3D; startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">    	aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">    	resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">    	callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">        options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">        inTask, reason);</span><br><span class="line">        ...</span><br><span class="line">        return res;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">	String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">	IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">	IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">	String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">	ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">	ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span><br><span class="line">	TaskRecord inTask, String reason) &#123;</span><br><span class="line">	&#x2F;&#x2F; 注释1</span><br><span class="line">    &#x2F;&#x2F; 判断启动</span><br><span class="line">    if (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">    	throw new IllegalArgumentException(&quot;Need to specify a reason.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mLastStartReason &#x3D; reason;</span><br><span class="line">    mLastStartActivityTimeMs &#x3D; System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[0] &#x3D; null;</span><br><span class="line">	&#x2F;&#x2F; 注释2</span><br><span class="line">    mLastStartActivityResult &#x3D; startActivity(caller, intent, ephemeralIntent, </span><br><span class="line">    			resolvedType,aInfo, rInfo, voiceSession, voiceInteractor, resultTo,</span><br><span class="line">    			resultWho, requestCode,callingPid, callingUid, callingPackage, </span><br><span class="line">    	        realCallingPid,realCallingUid,startFlags,options,ignoreTargetSecurity,</span><br><span class="line">    	        componentSpecified,mLastStartActivityRecord,container, inTask);</span><br><span class="line">    if (outActivity !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; mLastStartActivityRecord[0] is set in the call to startActivity above.</span><br><span class="line">        outActivity[0] &#x3D; mLastStartActivityRecord[0];</span><br><span class="line">    &#125;</span><br><span class="line">    return mLastStartActivityResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">	String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">    IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">    IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,</span><br><span class="line">    String callingPackage, int realCallingPid, int realCallingUid, int startFlags,</span><br><span class="line">    ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,</span><br><span class="line">    ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span><br><span class="line">    TaskRecord inTask) &#123;</span><br><span class="line">    </span><br><span class="line">    int err &#x3D; ActivityManager.START_SUCCESS;</span><br><span class="line">    &#x2F;&#x2F; Pull the optional Ephemeral Installer-only bundle out of the options early.</span><br><span class="line">    final Bundle verificationBundle</span><br><span class="line">    	&#x3D; options !&#x3D; null ? options.popAppVerificationBundle() : null;</span><br><span class="line"></span><br><span class="line">    ProcessRecord callerApp &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 注释1</span><br><span class="line">    &#x2F;&#x2F; caller为Launcher所在的应用程序进程的ApplicationThread对象，为IApplicationThread类型</span><br><span class="line">    if (caller !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 注释2</span><br><span class="line">        &#x2F;&#x2F; Launcher进程的callApp对象，它是ProcessRecord类型的</span><br><span class="line">        callerApp &#x3D; mService.getRecordForAppLocked(caller);</span><br><span class="line">        if (callerApp !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取Launcher进程的pid和uid</span><br><span class="line">            callingPid &#x3D; callerApp.pid;</span><br><span class="line">            callingUid &#x3D; callerApp.info.uid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller</span><br><span class="line">                   + &quot; (pid&#x3D;&quot; + callingPid + &quot;) when starting: &quot;</span><br><span class="line">                   + intent.toString());</span><br><span class="line">            err &#x3D; ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 注释3</span><br><span class="line">    &#x2F;&#x2F; 创建即将要启动的Activity的描述类ActivityRecord</span><br><span class="line">    ActivityRecord r &#x3D; new ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">    	callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">        resultRecord, resultWho, requestCode, componentSpecified, voiceSession !&#x3D; null,</span><br><span class="line">        mSupervisor, container, options, sourceRecord);</span><br><span class="line">    if (outActivity !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 注释4</span><br><span class="line">        outActivity[0] &#x3D; r;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    doPendingActivityLaunchesLocked(false);</span><br><span class="line">    &#x2F;&#x2F; 注释5</span><br><span class="line">    return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">    true,options, inTask, outActivity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">	IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">    int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">    ActivityRecord[] outActivity) &#123;</span><br><span class="line">    </span><br><span class="line">    int result &#x3D; START_CANCELED;</span><br><span class="line">    try &#123;</span><br><span class="line">    	mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        &#x2F;&#x2F; 注释1</span><br><span class="line">        result &#x3D; startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">             startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; startActivityUnchecked方法主要处理与栈管理相关的逻辑</span><br><span class="line">private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">            ActivityRecord[] outActivity) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 注释1</span><br><span class="line">        if (mStartActivity.resultTo &#x3D;&#x3D; null &amp;&amp; mInTask &#x3D;&#x3D; null &amp;&amp; !mAddingToTask</span><br><span class="line">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) !&#x3D; 0) &#123;</span><br><span class="line">            newTask &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 注释2</span><br><span class="line">            &#x2F;&#x2F; 创建一个新的Activity任务栈</span><br><span class="line">            result &#x3D; setTaskFromReuseOrCreateNewTask(</span><br><span class="line">                    taskToAffiliate, preferredLaunchStackId, topStack);</span><br><span class="line">        &#125; else if (mSourceRecord !&#x3D; null) &#123;</span><br><span class="line">            result &#x3D; setTaskFromSourceRecord();</span><br><span class="line">        &#125; else if (mInTask !&#x3D; null) &#123;</span><br><span class="line">            result &#x3D; setTaskFromInTask();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; This not being started from an existing activity, </span><br><span class="line">            &#x2F;&#x2F; and not part of a new task...</span><br><span class="line">            &#x2F;&#x2F; just put it in the top task, though these days this case should never happen.</span><br><span class="line">            setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">        &#125;</span><br><span class="line">    	...</span><br><span class="line">            </span><br><span class="line">        if (mDoResume) &#123;</span><br><span class="line">            final ActivityRecord topTaskActivity &#x3D;</span><br><span class="line">                    mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">            if (!mTargetStack.isFocusable()</span><br><span class="line">                    || (topTaskActivity !&#x3D; null &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                    &amp;&amp; mStartActivity !&#x3D; topTaskActivity)) &#123;</span><br><span class="line"> 			...</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mTargetStack.isFocusable()&amp;&amp;!mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                    	mTargetStack.moveToFront(&quot;startActivityUnchecked&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 注释3</span><br><span class="line">              mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack,mStartActivity,</span><br><span class="line">              			  mOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">    	ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)&#123;</span><br><span class="line">    if (targetStack !&#x3D; null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 注释1</span><br><span class="line">    &#x2F;&#x2F; 获取要启动的Activity所在的栈的栈顶的不是处于停止状态的ActivityRecord</span><br><span class="line">    final ActivityRecord r &#x3D; mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    &#x2F;&#x2F; 注释2</span><br><span class="line">    if (r &#x3D;&#x3D; null || r.state !&#x3D; RESUMED) &#123;</span><br><span class="line">        &#x2F;&#x2F; 注释3</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">    &#125; else if (r.state &#x3D;&#x3D; RESUMED) &#123;</span><br><span class="line">        &#x2F;&#x2F; Kick off any lingering app transitions form the MoveTaskToFront operation.</span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        &#x2F;&#x2F; Don&#39;t even start recursing.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Protect against recursion.</span><br><span class="line">        mStackSupervisor.inResumeTopActivity &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 注释1</span><br><span class="line">        result &#x3D; resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; </span><br><span class="line">    &#x2F;&#x2F; 注释1</span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(next, true, true);</span><br><span class="line">    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">void startSpecificActivityLocked(ActivityRecord r,boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    &#x2F;&#x2F; Is this activity&#39;s application already running?</span><br><span class="line">    &#x2F;&#x2F; 注释1</span><br><span class="line">    &#x2F;&#x2F; 获取即将启动的Activity的所在的应用进程</span><br><span class="line">    ProcessRecord app &#x3D; mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                        r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">    r.getStack().setLaunchTime(r);</span><br><span class="line">	&#x2F;&#x2F; 注释2</span><br><span class="line">    &#x2F;&#x2F; 判断要启动的Activity所在的应用程序进程如果已经运行的话，就会调用注释3处</span><br><span class="line">    if (app !&#x3D; null &amp;&amp; app.thread !&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) &#x3D;&#x3D; 0</span><br><span class="line">                || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 注释3</span><br><span class="line">                &#x2F;&#x2F; 这个方法第二个参数是代表要启动的Activity所在的应用程序进程的ProcessRecord</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If a dead object exception was thrown -- fall through to</span><br><span class="line">            &#x2F;&#x2F; restart the application.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">      boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; app是ProcessRecord类型的，thread是IApplicationThread类型的 </span><br><span class="line">	app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">    	System.identityHashCode(r), r.info,</span><br><span class="line">        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">        r.persistentState, results, newIntents, !andResume,</span><br><span class="line">        mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line">        ...</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-ActivityThread启动Activity的过程"><a href="#2-ActivityThread启动Activity的过程" class="headerlink" title="2. ActivityThread启动Activity的过程"></a>2. ActivityThread启动Activity的过程</h5><img src="/2020/06/20/13%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/ActivityThread%E5%90%AF%E5%8A%A8Activity%E7%9A%84%E8%BF%87%E7%A8%8B.png" class="" title="[ActivityThread启动Activity的过程]">

<p>接着查看ApplicationThread的scheduleLaunchActivity方法，ApplicationThread是ActivityThread的内部类，ActivityThread负责管理当前应用程序进程的主线程，scheduleLaunchActivity方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,</span><br><span class="line">		ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span><br><span class="line">		CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">		int procState, Bundle state, PersistableBundle persistentState,</span><br><span class="line">		List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span><br><span class="line">		boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123;</span><br><span class="line"></span><br><span class="line">	updateProcessState(procState, false);</span><br><span class="line">	&#x2F;&#x2F; 此处的r就是保存要启动activity的信息，作为参数通过sendMessage发送出去</span><br><span class="line">	ActivityClientRecord r &#x3D; new ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">    r.token &#x3D; token;</span><br><span class="line">    r.ident &#x3D; ident;</span><br><span class="line">    r.intent &#x3D; intent;</span><br><span class="line">    r.referrer &#x3D; referrer;</span><br><span class="line">    ...</span><br><span class="line">    updatePendingConfiguration(curConfig);</span><br><span class="line">    sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">        + &quot;: &quot; + arg1 + &quot; &#x2F; &quot; + obj);</span><br><span class="line">    Message msg &#x3D; Message.obtain();</span><br><span class="line">    msg.what &#x3D; what;</span><br><span class="line">    msg.obj &#x3D; obj;</span><br><span class="line">    msg.arg1 &#x3D; arg1;</span><br><span class="line">    msg.arg2 &#x3D; arg2;</span><br><span class="line">    if (async) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">            &#x2F;&#x2F; 注释1</span><br><span class="line">            &#x2F;&#x2F; 取出之前保存的要启动的Activity的信息</span><br><span class="line">            &#x2F;&#x2F; 这些信息封装在ActivityClientRecord这个类中</span><br><span class="line">            final ActivityClientRecord r &#x3D; (ActivityClientRecord) msg.obj;</span><br><span class="line">			&#x2F;&#x2F; 注释2</span><br><span class="line">            &#x2F;&#x2F; pachageinfo 指的是LoadedApk</span><br><span class="line">            r.packageInfo &#x3D; getPackageInfoNoCheck(</span><br><span class="line">                r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case RELAUNCH_ACTIVITY: &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityRestart&quot;);</span><br><span class="line">            ActivityClientRecord r &#x3D; (ActivityClientRecord)msg.obj;</span><br><span class="line">            handleRelaunchActivity(r);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125; break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F; Initialize before creating the activity</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">	&#x2F;&#x2F; 注释1</span><br><span class="line">    &#x2F;&#x2F; 启动Activity</span><br><span class="line">    Activity a &#x3D; performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a !&#x3D; null) &#123;</span><br><span class="line">        r.createdConfig &#x3D; new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState &#x3D; r.state;</span><br><span class="line">        &#x2F;&#x2F; 注释2</span><br><span class="line">        &#x2F;&#x2F; 将Activity的状态置为Resume</span><br><span class="line">        handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">              !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123;</span><br><span class="line">            performPauseActivityIfNeeded(r, reason);</span><br><span class="line">            if (r.isPreHoneycomb()) &#123;</span><br><span class="line">                r.state &#x3D; oldState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 注释3</span><br><span class="line">            &#x2F;&#x2F; 停止Activity启动</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                                Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) </span><br><span class="line">	&#x2F;&#x2F; 注释1 </span><br><span class="line">    &#x2F;&#x2F; 获取ActivityInfo类</span><br><span class="line">    ActivityInfo aInfo &#x3D; r.activityInfo;</span><br><span class="line">    if (r.packageInfo &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 注释2 </span><br><span class="line">        &#x2F;&#x2F; 获取APK文件的描述类</span><br><span class="line">        r.packageInfo &#x3D; getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                                       Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F; 注释3</span><br><span class="line">	&#x2F;&#x2F; 获取要启动Activity的ComponentName类，它保存了该Activity的包名和类名</span><br><span class="line">    ComponentName component &#x3D; r.intent.getComponent();</span><br><span class="line">    ...</span><br><span class="line">	&#x2F;&#x2F; 注释4</span><br><span class="line">    &#x2F;&#x2F; 创建要启动Activity的上下文</span><br><span class="line">    ContextImpl appContext &#x3D; createBaseContextForActivity(r);</span><br><span class="line">    Activity activity &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl &#x3D; appContext.getClassLoader();</span><br><span class="line">        &#x2F;&#x2F; 注释5</span><br><span class="line">        &#x2F;&#x2F; 通过类加载器来创建要启动的Activity的实例</span><br><span class="line">        activity &#x3D; mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 注释6</span><br><span class="line">        &#x2F;&#x2F; 创建Application</span><br><span class="line">        Application app &#x3D; r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">        ...</span><br><span class="line">        if (activity !&#x3D; null) &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 注释7</span><br><span class="line">            &#x2F;&#x2F; 初始化Activity</span><br><span class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                            r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                            r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                            r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">            ...</span><br><span class="line">            if (r.isPersistable()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 注释8</span><br><span class="line">          		&#x2F;&#x2F; 顾名思义下一步就是去调用Activity的onCreate方法</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        r.paused &#x3D; true;</span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line">    &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle,</span><br><span class="line">            PersistableBundle persistentState) &#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle, persistentState);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    &#x2F;&#x2F; 注释1</span><br><span class="line">    &#x2F;&#x2F; 正式进入Activity的生命周期方法</span><br><span class="line">    onCreate(icicle, persistentState);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><img src="/2020/06/20/13%20activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/untitled.png" class="" title="[Activity启动流程]">

<ul>
<li>Launcher—&gt;AMS: Instrumentation主要用来监控应用程序和系统的交互，过渡调用它的execStartActivity方法，在该方法中获取AMS的代理对象，调用startActivity，即binder通信，跨进程进入AMS所在进程SystemServer，调用AMS的startActivity方法</li>
<li>AMS—&gt;ApplicationThread: 这个过程涉及的类和方法相对较多，但主要完成下面三件事<br>①综合处理 launchMode 和 Intent 中的 Flag 标志位，并根据处理结果生成一个目标 Activity B 的对象（ActivityRecord）。<br>②判断是否需要为目标 Activity B 创建一个新的进程（ProcessRecord）、新的任务栈（TaskRecord）。<br>③获取ApplicationThread的代理对象，通过binder通信，跨进程到应用程序进程，去调用scheduleLaunchActivity去启动根Activity。</li>
<li>ActivityThread启动Activity的过程<br>scheduleLaunchActivity通过sendMessage向H类发送类型为LAUNCH_ACTIVITY的消息，H类的handleMessage方法，处理消息，调用ActivityThread的handleLaunchActivity，接着调用performLaunchActivity，又回到应用程序与系统交互的监控类Instrumentation，调用它的callActivityOnCreate方法，接着调用Activity的performCreate方法和onCreate方法，正式进入Activity的生命周期方法，启动Activity</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/%E9%A9%AC%E8%80%81%E5%B8%88%E7%AC%94%E8%AE%B0-%E8%AE%AD%E7%BB%83%E8%90%A5synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/%E9%A9%AC%E8%80%81%E5%B8%88%E7%AC%94%E8%AE%B0-%E8%AE%AD%E7%BB%83%E8%90%A5synchronized/" class="post-title-link" itemprop="url">马老师笔记-训练营synchronized</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-07 14:54:53 / 修改时间：20:20:11" itemprop="dateCreated datePublished" datetime="2020-06-07T14:54:53+08:00">2020-06-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h1><p>JDK早期，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db &quot;Hello&quot;, 0xA</span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, 1 ;文件描述符1 std_out</span><br><span class="line">    mov eax, 4 ;write函数系统调用号 4</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov eax, 1 ;exit函数系统调用号</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>

<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>Compare And Swap (Compare And Exchange) / 自旋 / 自旋锁 / 无锁 （无重量锁）</p>
<p>因为经常配合循环操作，直到完成为止，所以泛指一类操作</p>
<p>cas(v, a, b) ，变量v，期待值a, 修改值b</p>
<p>ABA问题，你的女朋友在离开你的这段儿时间经历了别的人，自旋就是你空转等待，一直等到她接纳你为止</p>
<p>解决办法（版本号 AtomicStampedReference），基础类型简单值不需要版本号</p>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>AtomicInteger:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>运用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField("i");</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: unsafe.cpp:</p>
<p>cmpxchg = compare and exchange</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p>
<p>is_MP = Multi Processor  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: os.hpp is_MP()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure>

<p>最终实现：</p>
<p>cmpxchg = cas修改变量值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure>

<p>硬件：</p>
<p>lock指令在执行后面指令的时候锁定一个北桥信号</p>
<p>（不采用锁总线的方式）</p>
<h1 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h1><h1 id="工具：JOL-Java-Object-Layout"><a href="#工具：JOL-Java-Object-Layout" class="headerlink" title="工具：JOL = Java Object Layout"></a>工具：JOL = Java Object Layout</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>jdk8u: markOop.hpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure>





<h1 id="synchronized的横切面详解"><a href="#synchronized的横切面详解" class="headerlink" title="synchronized的横切面详解"></a>synchronized的横切面详解</h1><ol>
<li>synchronized原理</li>
<li>升级过程</li>
<li>汇编实现</li>
<li>vs reentrantLock的区别</li>
</ol>
<h2 id="java源码层级"><a href="#java源码层级" class="headerlink" title="java源码层级"></a>java源码层级</h2><p>synchronized(o) </p>
<h2 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h2><p>monitorenter moniterexit</p>
<h2 id="JVM层级（Hotspot）"><a href="#JVM层级（Hotspot）" class="headerlink" title="JVM层级（Hotspot）"></a>JVM层级（Hotspot）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.insidesync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_Sync1</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.mashibing.insidesync.T01_Sync1$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.mashibing.insidesync.T02_Sync2$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">90</span> <span class="number">2</span>e <span class="number">1</span>e (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">00101110</span> <span class="number">00011110</span>) (<span class="number">506368005</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">1</span>b <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00011011</span> <span class="number">00000010</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">539</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes tota</span><br></pre></td></tr></table></figure>

<p>InterpreterRuntime:: monitorenter方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<p>synchronizer.cpp</p>
<p>revoke_and_rebias</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: <span class="built_in">release</span> stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inflate方法：膨胀为重量级锁</p>
<h1 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h1><h2 id="JDK8-markword实现表："><a href="#JDK8-markword实现表：" class="headerlink" title="JDK8 markword实现表："></a>JDK8 markword实现表：</h2><p><img src="C:%5Cwork%5Ccourses%5C%E5%85%AC%E5%BC%80%E8%AF%BE%5C%E9%9D%A2%E8%AF%95%E9%A2%98%5C%E4%BD%A0%E4%BB%A5%E4%B8%BA%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82Synchronized%5Clock_step.png" alt="image-20200419213508934"></p>
<p><img src="C:%5Cwork%5Ccourses%5C%E5%85%AC%E5%BC%80%E8%AF%BE%5C%E9%9D%A2%E8%AF%95%E9%A2%98%5C%E4%BD%A0%E4%BB%A5%E4%B8%BA%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82Synchronized%5Cmarkword-64.png" alt=""></p>
<p><strong>自旋锁什么时候升级为重量级锁？</strong></p>
<p><strong>为什么有自旋锁还需要重量级锁？</strong></p>
<blockquote>
<p>自旋是消耗CPU资源的，如果锁的时间长，或者自旋线程多，CPU会被大量消耗</p>
<p>重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源</p>
</blockquote>
<p><strong>偏向锁是否一定比自旋锁效率高？</strong></p>
<blockquote>
<p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁</p>
<p>JVM启动过程，会有很多线程竞争（明确），所以默认情况启动时不打开偏向锁，过一段儿时间再打开</p>
</blockquote>
<p>new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p>
<p>synchronized优化的过程和markword息息相关</p>
<p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p>
<ol>
<li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p>
</li>
<li><p>o.hashCode()<br>001 + hashcode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>little endian big endian </p>
<p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p>
</li>
<li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p>
</li>
<li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p>
</li>
<li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p>
</li>
<li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p>
</li>
</ol>
<p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)</p>
<p>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p>
<p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p>
<blockquote>
<p>轻量级锁重量级锁的hashCode存在与什么地方？</p>
<p>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p>
</blockquote>
<p>关于epoch: (不重要)</p>
<blockquote>
<p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
</blockquote>
<p>没错，我就是厕所所长</p>
<p>加锁，指的是锁定对象</p>
<p>锁升级的过程</p>
<p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p>
<p>现代版本进行了优化</p>
<p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p>
<p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p>
<p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p>
<p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p>
<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p>
<h2 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h2><p>sychronized是可重入锁</p>
<p>重入次数必须记录，因为要解锁几次必须得对应</p>
<p>偏向锁 自旋锁 -&gt; 线程栈 -&gt; LR + 1</p>
<p>重量级锁 -&gt; ? ObjectMonitor字段上</p>
<h2 id="synchronized最底层实现"><a href="#synchronized最底层实现" class="headerlink" title="synchronized最底层实现"></a>synchronized最底层实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publics <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1000_000</span>; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</p>
<p>C1 Compile Level 1 (一级优化)</p>
<p>C2 Compile Level 2 (二级优化)</p>
<p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p>
<h2 id="synchronized-vs-Lock-CAS"><a href="#synchronized-vs-Lock-CAS" class="headerlink" title="synchronized vs Lock (CAS)"></a>synchronized vs Lock (CAS)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在高争用 高耗时的环境下synchronized效率更高</span><br><span class="line">在低争用 低耗时的环境下CAS效率更高</span><br><span class="line">synchronized到重量级之后是等待队列（不消耗CPU）</span><br><span class="line">CAS（等待期间消耗CPU）</span><br><span class="line"></span><br><span class="line">一切以实测为准</span><br></pre></td></tr></table></figure>



<h1 id="锁消除-lock-eliminate"><a href="#锁消除-lock-eliminate" class="headerlink" title="锁消除 lock eliminate"></a>锁消除 lock eliminate</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">         StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">         sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p>
<h1 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="headerlink" title="锁粗化 lock coarsening"></a>锁粗化 lock coarsening</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">       <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">           sb.append(str);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p>
<h1 id="锁降级（不重要）"><a href="#锁降级（不重要）" class="headerlink" title="锁降级（不重要）"></a>锁降级（不重要）</h1><p><a href="https://www.zhihu.com/question/63859501" target="_blank" rel="noopener">https://www.zhihu.com/question/63859501</a></p>
<p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p>
<h1 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h1><p>一个ALU + 两组Registers + PC</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
<h1 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h1><h2 id="1-线程可见性"><a href="#1-线程可见性" class="headerlink" title="1.线程可见性"></a>1.线程可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.testvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ThreadVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do sth</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;, <span class="string">"server"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-防止指令重排序"><a href="#2-防止指令重排序" class="headerlink" title="2.防止指令重排序"></a>2.防止指令重排序</h2><h3 id="问题：DCL单例需不需要加volatile？"><a href="#问题：DCL单例需不需要加volatile？" class="headerlink" title="问题：DCL单例需不需要加volatile？"></a>问题：DCL单例需不需要加volatile？</h3><h3 id="CPU的基础知识"><a href="#CPU的基础知识" class="headerlink" title="CPU的基础知识"></a>CPU的基础知识</h3><ul>
<li><p>缓存行对齐<br>缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高<br>Disruptor</p>
</li>
<li><p><strong>需要注意，JDK8引入了@sun.misc.Contended注解，来保证缓存行隔离效果</strong><br>要使用此注解，必须去掉限制参数：-XX:-RestrictContended</p>
</li>
<li><p>另外，java编译器或者JIT编译器有可能会去除没用的字段，所以填充字段必须加上volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_028_FalseSharing;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">//</span></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</span><br><span class="line">          arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                  arr[<span class="number">0</span>].x = i;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  </span><br><span class="line">          Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                  arr[<span class="number">1</span>].x = i;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">          t1.join();</span><br><span class="line">          t2.join();</span><br><span class="line">          System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>MESI</p>
</li>
<li><p>伪共享</p>
</li>
<li><p>合并写<br>CPU内部的4个字节的Buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_029_WriteCombining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>指令重排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span></span><br><span class="line">                    <span class="comment">//shortWait(100000);</span></span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();other.start();</span><br><span class="line">            one.join();other.join();</span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125;<span class="keyword">while</span>(start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="系统底层如何实现数据一致性"><a href="#系统底层如何实现数据一致性" class="headerlink" title="系统底层如何实现数据一致性"></a>系统底层如何实现数据一致性</h3><ol>
<li>MESI如果能解决，就使用MESI</li>
<li>如果不能，就锁总线</li>
</ol>
<h3 id="系统底层如何保证有序性"><a href="#系统底层如何保证有序性" class="headerlink" title="系统底层如何保证有序性"></a>系统底层如何保证有序性</h3><ol>
<li>内存屏障sfence mfence lfence等系统原语</li>
<li>锁总线</li>
</ol>
<h3 id="volatile如何解决指令重排序"><a href="#volatile如何解决指令重排序" class="headerlink" title="volatile如何解决指令重排序"></a>volatile如何解决指令重排序</h3><p>1: volatile i</p>
<p>2: ACC_VOLATILE</p>
<p>3: JVM的内存屏障</p>
<p>​    屏障两边的指令不可以重排！保障有序！</p>
<p>​    happends-before </p>
<p>​    as - if - serial</p>
<p>4：hotspot实现</p>
<p>bytecodeinterpreter.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">          <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">              OrderAccess::fence();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>orderaccess_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>LOCK 用于在多处理器中执行指令时对共享内存的独占使用。<br>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。</strong><br><strong>另外还提供了有序的指令无法越过这个内存屏障的作用。</strong></p>
</blockquote>
<h1 id="用hsdis观察synchronized和volatile"><a href="#用hsdis观察synchronized和volatile" class="headerlink" title="用hsdis观察synchronized和volatile"></a>用hsdis观察synchronized和volatile</h1><ol>
<li><p>安装hsdis (自行百度)</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">       m();</span><br><span class="line">       n();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="css"><span class="selector-tag">java</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+UnlockDiagnosticVMOptions</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+PrintAssembly</span> <span class="selector-tag">T</span> &gt; 1<span class="selector-class">.txt</span>
&lt;!<span class="selector-tag">--</span>￼30<span class="selector-tag">--</span>&gt;
</code></pre>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/" class="post-title-link" itemprop="url">JVM虚拟机底层原理分析与性能优化【图灵学院】</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-07 14:18:05 / 修改时间：17:42:10" itemprop="dateCreated datePublished" datetime="2020-06-07T14:18:05+08:00">2020-06-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-深入剖析Java虚拟机内存模型"><a href="#1-深入剖析Java虚拟机内存模型" class="headerlink" title="1. 深入剖析Java虚拟机内存模型"></a>1. 深入剖析Java虚拟机内存模型</h4><img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/JDK%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class="" title="[JDK体系结构]">

<p>JDK 包含 JRE 以及 Tools(编译工具) &amp; Tool APIs(API库)</p>
<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/Java%E5%AD%97%E8%8A%82%E7%A0%81.png" class="" title="[Java字节码]">

<p>下载JDK时候，会选择不同的操作系统对应的JDK版本。一次编译到处运行，在于JVM屏蔽了不同操作系统的差别。JVM执行Java程序的本质是执行其字节码。</p>
<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA.png" class="" title="[JVM虚拟机]">

<p>类加载子系统，将class文件加载到JVM内存中。注意JVM内存中堆、方法区是线程共享的。其他的是线程所私有的。(new int[] 数组也是在堆内存上分配的，数组的引用是在栈上分配的)</p>
<p>方法区主要是存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。</p>
<p>虚拟机栈包括： 局部变量表、操作数栈、动态链接、方法出口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Math &#123;</span><br><span class="line">    public static int initData &#x3D; 666;</span><br><span class="line">    public static User uer &#x3D; new User;</span><br><span class="line"></span><br><span class="line">    public int compute() &#123;</span><br><span class="line">        int a &#x3D; 1;</span><br><span class="line">        int b &#x3D; 2;</span><br><span class="line">        int c &#x3D; (a + b) * 10;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Math math &#x3D; new Math();</span><br><span class="line">        math.compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>javap -c Math.class</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int compute();</span><br><span class="line">  Code:</span><br><span class="line">     0: iconst_1</span><br><span class="line">     1: istore_1</span><br><span class="line">     2: iconst_2</span><br><span class="line">     3: istore_2</span><br><span class="line">     4: iload_1</span><br><span class="line">     5: iload_2</span><br><span class="line">     6: iadd</span><br><span class="line">     7: bipush        10</span><br><span class="line">     9: imul</span><br><span class="line">    10: istore_3</span><br><span class="line">    11: iload_3</span><br><span class="line">    12: ireturn</span><br></pre></td></tr></table></figure>

<p>常见的JVM指令集</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>iconst_x</td>
<td>将int型x推送至栈顶</td>
</tr>
<tr>
<td>istore_x</td>
<td>将栈顶int型数值存入第x个本地变量</td>
</tr>
<tr>
<td>iload_x</td>
<td>将第x个int型本地变量推送至栈顶</td>
</tr>
</tbody></table>
<p>更多<a href="https://www.jianshu.com/p/d64a5dcccaa5" target="_blank" rel="noopener">JVM指令集</a></p>
<p><strong>堆里面的对象通过对象头的类型指针指向了方法区、方法区里面的静态对象的、常量引用指向了堆</strong></p>
<p><strong>方法区特点</strong></p>
<ul>
<li>1.方法区是线程共享的，多个线程都用到一个类的时候，若这个类还未被加载，应该只有一个线程去加载类，其他线程等待；</li>
<li>2.方法区的大小可以是非固定的，jvm可以根据应用需要动态调整，jvm也支持用户和程序指定方法区的初始大小；</li>
<li>3.方法区有垃圾回收机制，一些类不再被使用则变为垃圾，需要进行垃圾清理。</li>
</ul>
<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" class="" title="[可达性分析]">

<p>可达性分析中可以作为GC Root对象的有： 类加载器、Thread、虚拟机栈本地变量表、static 、final 引用对象</p>
<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/GC%E8%BF%87%E7%A8%8B.png" class="" title="[GC过程]">

<p>Eden空间满了的时候，会进行Minor GC， S0、S1 会进行交换。分代年龄大于15的时候，会直接放到老年代。<br>如果老年代满的时候，会进行Full GC。</p>
<ul>
<li>每次 Minor GC 会清理年轻代的内存</li>
<li>Major GC 是清理永久代</li>
<li>Full GC 是清理整个堆空间—包括年轻代和永久代</li>
<li>System.gc()方法的调用,建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC</li>
</ul>
<h4 id="1-Volatile-底层原理"><a href="#1-Volatile-底层原理" class="headerlink" title="1. Volatile 底层原理"></a>1. Volatile 底层原理</h4><img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/%E5%A4%9A%E6%A0%B8%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.png" class="" title="[多核并发缓存架构]">

<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" class="" title="[JMM内存模型]">

<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/JMM%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.png" class="" title="[JMM数据原子操作]">

<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/JMM%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3.png" class="" title="[JMM数据原子操作详解]">

<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/JMM%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98.png" class="" title="[JMM缓存不一致问题]">

<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/volatile%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" class="" title="[volatile可见性底层实现原理]">

<img src="/2020/06/07/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(%E5%9B%BE%E7%81%B5%E5%AD%A6%E9%99%A2)/volatile%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7.png" class="" title="[volatile可见性、原子性、有序性]">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/%E5%89%91%E6%8C%87Offer%20--%20%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yudesong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/06/%E5%89%91%E6%8C%87Offer%20--%20%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">剑指Offer -- 刷题笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-06 17:05:08" itemprop="dateCreated datePublished" datetime="2020-06-06T17:05:08+08:00">2020-06-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1. 二维数组中的查找</strong></p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>思路： 首先获取二维数组的行数以及列数, 从第一行的最后一列开始比较，如果array[i][j] &gt; target, 那就在数组的前面一列里面寻找，否则在下面一行寻找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 获取数组行数</span><br><span class="line">        int row &#x3D; array.length;</span><br><span class="line">        &#x2F;&#x2F; 获取数组列数</span><br><span class="line">        int col &#x3D; array[0].length;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int j &#x3D; col - 1;</span><br><span class="line">        while (i &lt; row &amp;&amp; j &gt;&#x3D; 0) &#123;</span><br><span class="line">            if (target &#x3D;&#x3D; array[i][j]) return true;</span><br><span class="line">            if (target &gt; array[i][j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (target &lt; array[i][j]) j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 替换空格</strong></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">	String string &#x3D; str.toString();</span><br><span class="line">	string &#x3D; string.replaceAll(&quot; &quot;, &quot;%20&quot;);</span><br><span class="line">	return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 从尾到头打印链表</strong></p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    if (listNode !&#x3D; null) &#123;</span><br><span class="line">        printListFromTailToHead(listNode.next);</span><br><span class="line">        arrayList.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非递归</span><br><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    while (listNode !&#x3D; null) &#123;</span><br><span class="line">        arrayList.add(0, listNode.val);</span><br><span class="line">        listNode &#x3D; listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 反转链表(重点)</strong></p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 非递归</span><br><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">    ListNode pre &#x3D; null;</span><br><span class="line">    ListNode cur &#x3D; head;</span><br><span class="line">    while (cur !&#x3D; null) &#123;</span><br><span class="line">        ListNode next &#x3D; cur.next;</span><br><span class="line">        cur.next &#x3D; pre;</span><br><span class="line">        pre &#x3D; cur;</span><br><span class="line">        cur &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) return head;</span><br><span class="line">    ListNode node &#x3D; ReverseList(head.next);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 合并两个排序的链表</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">    ListNode head &#x3D; new ListNode(0);</span><br><span class="line">    ListNode root &#x3D; head;</span><br><span class="line">    while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123;</span><br><span class="line">        if (list1.val &lt; list2.val) &#123;</span><br><span class="line">            head.next &#x3D; list1;</span><br><span class="line">            list1 &#x3D; list1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head.next &#x3D; list2;</span><br><span class="line">            list2 &#x3D; list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (list1 !&#x3D; null) head.next &#x3D; list1;</span><br><span class="line">    if (list2 !&#x3D; null) head.next &#x3D; list2;</span><br><span class="line">    return root.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 二叉树的深度</strong></p>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return 0;</span><br><span class="line">    int left &#x3D; TreeDepth(root.left);</span><br><span class="line">    int right &#x3D; TreeDepth(root.right);</span><br><span class="line">    return left &gt; right ? left + 1 : right + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>7. 平衡二叉树</strong></p>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return true;</span><br><span class="line">    int left &#x3D; getTreeDepth(root.left);</span><br><span class="line">    int right &#x3D; getTreeDepth(root.right);</span><br><span class="line">    if ((left - right) &#x3D;&#x3D; -1 || (left - right) &#x3D;&#x3D; 1 || (left - right) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private int getTreeDepth(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return 0;</span><br><span class="line">    return 1 + Math.max(getTreeDepth(root.left), getTreeDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8. 对称的二叉树</strong></p>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">      8</span><br><span class="line">  6       6</span><br><span class="line">5   7  7    5</span><br><span class="line"></span><br><span class="line">boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">    if (pRoot &#x3D;&#x3D; null) return true;</span><br><span class="line">    return compare(pRoot.left, pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">boolean compare(TreeNode left, TreeNode right) &#123;</span><br><span class="line">    if (left &#x3D;&#x3D; null) return right &#x3D;&#x3D; null;</span><br><span class="line">    if (right &#x3D;&#x3D; null) return false;</span><br><span class="line">    if (left.val &#x3D;&#x3D; right.val) &#123;</span><br><span class="line">        return compare(left.left, right.right) &amp;&amp; compare(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9. 斐波那契数列</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。<br>n&lt;=39</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int Fibonacci(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    return Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10. 跳台阶</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1) + f(n-2);</span><br><span class="line">public int JumpFloor(int target) &#123;</span><br><span class="line">    if (target &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (target &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (target &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    return JumpFloor(target - 1) + JumpFloor(target - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>11. 变态跳台阶</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f(n)   &#x3D; f(n-1) + f(n-2) + f(n-3) + ... + f(2) + f(1)</span><br><span class="line">f(n-1) &#x3D; f(n-2) + f(n-3) + ... + f(2) + f(1);</span><br><span class="line"></span><br><span class="line">2式相减： f(n) &#x3D; 2 * f(n-1)</span><br><span class="line"></span><br><span class="line">public int JumpFloorII(int target) &#123;</span><br><span class="line">  	if (target &#x3D;&#x3D; 0) return 0;</span><br><span class="line">   	if (target &#x3D;&#x3D; 1) return 1;</span><br><span class="line">   	return 2 * JumpFloorII(target - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>12. 矩形覆盖</strong></p>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int RectCover(int target) &#123;</span><br><span class="line">    if (target &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    if (target &#x3D;&#x3D; 1) return 1;</span><br><span class="line">    if (target &#x3D;&#x3D; 2) return 2;</span><br><span class="line">    return RectCover(target - 1) + RectCover(target - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>13. 二进制中1的个数</strong></p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p>
<p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int NumberOf1(int n) &#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    while (n !&#x3D; 0) &#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        n &#x3D; n &amp; (n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14. 链表中倒数第k个结点</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点。 (快慢指针)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">    ListNode p &#x3D; null;</span><br><span class="line">    ListNode q &#x3D; head;</span><br><span class="line">    while (q !&#x3D; null &amp;&amp; k &gt; 0) &#123;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (k &gt; 0) return p;</span><br><span class="line">    p &#x3D; head;</span><br><span class="line">    while (q !&#x3D; null) &#123;</span><br><span class="line">        q &#x3D; q.next;</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>15. 调整数组顺序使奇数位于偶数前面</strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void reOrderArray(int [] array) &#123;</span><br><span class="line">    int size &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (array[i] % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            int j &#x3D; i;</span><br><span class="line">            int temp &#x3D; array[i];</span><br><span class="line">            while (j &gt; size) &#123;</span><br><span class="line">                array[j] &#x3D; array[j - 1];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[size++] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>16. 数值的整数次方</strong></p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p>
<p><strong>注意exponent为负数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public double Power(double base, int exponent) &#123;</span><br><span class="line">    if (exponent &#x3D;&#x3D; 0) return 1;</span><br><span class="line">    </span><br><span class="line">    double ans &#x3D; base;</span><br><span class="line">    </span><br><span class="line">    if (exponent &lt; 0) &#123;</span><br><span class="line">        ans &#x3D; 1 &#x2F; base;</span><br><span class="line">        base &#x3D; 1 &#x2F; base;</span><br><span class="line">        exponent &#x3D; -exponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 2; i &lt;&#x3D; exponent; i++) &#123;</span><br><span class="line">        ans &#x3D; ans * base;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>17. 二叉树的镜像(重点)</strong></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) return;</span><br><span class="line">    TreeNode temp &#x3D; root.right;</span><br><span class="line">    root.right &#x3D; root.left;</span><br><span class="line">    root.left &#x3D; temp;</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非递归</span><br><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">    if(root &#x3D;&#x3D; null) return;</span><br><span class="line">    Queue&lt;TreeNode&gt; nodes &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode curr, temp;</span><br><span class="line">    nodes.offer(root);</span><br><span class="line">    while (!nodes.isEmpty()) &#123;</span><br><span class="line">        int len &#x3D; nodes.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++)&#123;</span><br><span class="line">            curr &#x3D; nodes.poll();</span><br><span class="line">            temp &#x3D; curr.left;</span><br><span class="line">            curr.left &#x3D; curr.right;</span><br><span class="line">            curr.right &#x3D; temp;</span><br><span class="line">            if (curr.left !&#x3D; null) nodes.offer(curr.left);</span><br><span class="line">            if (curr.right !&#x3D; null) nodes.offer(curr.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>18. 从上往下打印二叉树</strong></p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从上往下打印二叉树 (二叉树层次遍历 + 队列)</span><br><span class="line">public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    if (root &#x3D;&#x3D; null) return arrayList;</span><br><span class="line">    ArrayList&lt;TreeNode&gt; temp &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    temp.add(root);</span><br><span class="line">    while (!temp.isEmpty()) &#123;</span><br><span class="line">        TreeNode node &#x3D; temp.remove(0);</span><br><span class="line">        if (node.left !&#x3D; null) &#123;</span><br><span class="line">            temp.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.right !&#x3D; null) &#123;</span><br><span class="line">            temp.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        arrayList.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>19. 二叉树中和为某一值的路径</strong></p>
<p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yudesong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yudesong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
